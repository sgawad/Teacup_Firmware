
GccApplication1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000032  00800200  00005560  00005614  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005560  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000371  00800232  00800232  00005646  2**0
                  ALLOC
  3 .eeprom       00000020  00810000  00810000  00005646  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000a80  00000000  00000000  00005668  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000358  00000000  00000000  000060e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      0000002f  00000000  00000000  00006440  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000004e0  00000000  00000000  0000646f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00004c5f  00000000  00000000  0000694f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00001a8a  00000000  00000000  0000b5ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00003a0f  00000000  00000000  0000d038  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000010d8  00000000  00000000  00010a48  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0000108d  00000000  00000000  00011b20  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    000040ee  00000000  00000000  00012bad  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000390  00000000  00000000  00016c9b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	da c4       	rjmp	.+2484   	; 0x9b6 <__ctors_end>
       2:	00 00       	nop
       4:	f9 c4       	rjmp	.+2546   	; 0x9f8 <__bad_interrupt>
       6:	00 00       	nop
       8:	f7 c4       	rjmp	.+2542   	; 0x9f8 <__bad_interrupt>
       a:	00 00       	nop
       c:	0c 94 94 11 	jmp	0x2328	; 0x2328 <__vector_3>
      10:	0c 94 d2 11 	jmp	0x23a4	; 0x23a4 <__vector_4>
      14:	f1 c4       	rjmp	.+2530   	; 0x9f8 <__bad_interrupt>
      16:	00 00       	nop
      18:	ef c4       	rjmp	.+2526   	; 0x9f8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ed c4       	rjmp	.+2522   	; 0x9f8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	eb c4       	rjmp	.+2518   	; 0x9f8 <__bad_interrupt>
      22:	00 00       	nop
      24:	e9 c4       	rjmp	.+2514   	; 0x9f8 <__bad_interrupt>
      26:	00 00       	nop
      28:	e7 c4       	rjmp	.+2510   	; 0x9f8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e5 c4       	rjmp	.+2506   	; 0x9f8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	e3 c4       	rjmp	.+2502   	; 0x9f8 <__bad_interrupt>
      32:	00 00       	nop
      34:	e1 c4       	rjmp	.+2498   	; 0x9f8 <__bad_interrupt>
      36:	00 00       	nop
      38:	df c4       	rjmp	.+2494   	; 0x9f8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	dd c4       	rjmp	.+2490   	; 0x9f8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	db c4       	rjmp	.+2486   	; 0x9f8 <__bad_interrupt>
      42:	00 00       	nop
      44:	d9 c4       	rjmp	.+2482   	; 0x9f8 <__bad_interrupt>
      46:	00 00       	nop
      48:	d7 c4       	rjmp	.+2478   	; 0x9f8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d5 c4       	rjmp	.+2474   	; 0x9f8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	d3 c4       	rjmp	.+2470   	; 0x9f8 <__bad_interrupt>
      52:	00 00       	nop
      54:	d1 c4       	rjmp	.+2466   	; 0x9f8 <__bad_interrupt>
      56:	00 00       	nop
      58:	cf c4       	rjmp	.+2462   	; 0x9f8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	cd c4       	rjmp	.+2458   	; 0x9f8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	cb c4       	rjmp	.+2454   	; 0x9f8 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 3b 24 	jmp	0x4876	; 0x4876 <__vector_25>
      68:	0c 94 74 24 	jmp	0x48e8	; 0x48e8 <__vector_26>
      6c:	c5 c4       	rjmp	.+2442   	; 0x9f8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	c3 c4       	rjmp	.+2438   	; 0x9f8 <__bad_interrupt>
      72:	00 00       	nop
      74:	e2 c4       	rjmp	.+2500   	; 0xa3a <__vector_29>
      76:	00 00       	nop
      78:	bf c4       	rjmp	.+2430   	; 0x9f8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	bd c4       	rjmp	.+2426   	; 0x9f8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	bb c4       	rjmp	.+2422   	; 0x9f8 <__bad_interrupt>
      82:	00 00       	nop
      84:	b9 c4       	rjmp	.+2418   	; 0x9f8 <__bad_interrupt>
      86:	00 00       	nop
      88:	b7 c4       	rjmp	.+2414   	; 0x9f8 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b5 c4       	rjmp	.+2410   	; 0x9f8 <__bad_interrupt>
      8e:	00 00       	nop
      90:	b3 c4       	rjmp	.+2406   	; 0x9f8 <__bad_interrupt>
      92:	00 00       	nop
      94:	b1 c4       	rjmp	.+2402   	; 0x9f8 <__bad_interrupt>
      96:	00 00       	nop
      98:	af c4       	rjmp	.+2398   	; 0x9f8 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ad c4       	rjmp	.+2394   	; 0x9f8 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ab c4       	rjmp	.+2390   	; 0x9f8 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	a9 c4       	rjmp	.+2386   	; 0x9f8 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 2c 29 	jmp	0x5258	; 0x5258 <__vector_42>
      ac:	0c 94 e2 28 	jmp	0x51c4	; 0x51c4 <__vector_43>
      b0:	a3 c4       	rjmp	.+2374   	; 0x9f8 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a1 c4       	rjmp	.+2370   	; 0x9f8 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	9f c4       	rjmp	.+2366   	; 0x9f8 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	9d c4       	rjmp	.+2362   	; 0x9f8 <__bad_interrupt>
      be:	00 00       	nop
      c0:	9b c4       	rjmp	.+2358   	; 0x9f8 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	99 c4       	rjmp	.+2354   	; 0x9f8 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	97 c4       	rjmp	.+2350   	; 0x9f8 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	95 c4       	rjmp	.+2346   	; 0x9f8 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	93 c4       	rjmp	.+2342   	; 0x9f8 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	91 c4       	rjmp	.+2338   	; 0x9f8 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	8f c4       	rjmp	.+2334   	; 0x9f8 <__bad_interrupt>
      da:	00 00       	nop
      dc:	8d c4       	rjmp	.+2330   	; 0x9f8 <__bad_interrupt>
      de:	00 00       	nop
      e0:	8b c4       	rjmp	.+2326   	; 0x9f8 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	80 19       	sub	r24, r0
      e6:	80 19       	sub	r24, r0
      e8:	6d 19       	sub	r22, r13
      ea:	6d 19       	sub	r22, r13
      ec:	80 19       	sub	r24, r0
      ee:	6d 19       	sub	r22, r13
      f0:	6d 19       	sub	r22, r13
      f2:	6d 19       	sub	r22, r13
      f4:	6d 19       	sub	r22, r13
      f6:	6d 19       	sub	r22, r13
      f8:	6d 19       	sub	r22, r13
      fa:	6d 19       	sub	r22, r13
      fc:	6d 19       	sub	r22, r13
      fe:	6d 19       	sub	r22, r13
     100:	6d 19       	sub	r22, r13
     102:	6d 19       	sub	r22, r13
     104:	6d 19       	sub	r22, r13
     106:	6d 19       	sub	r22, r13
     108:	6d 19       	sub	r22, r13
     10a:	6d 19       	sub	r22, r13
     10c:	6d 19       	sub	r22, r13
     10e:	6d 19       	sub	r22, r13
     110:	6d 19       	sub	r22, r13
     112:	80 19       	sub	r24, r0
     114:	6d 19       	sub	r22, r13
     116:	6d 19       	sub	r22, r13
     118:	6d 19       	sub	r22, r13
     11a:	6d 19       	sub	r22, r13
     11c:	6d 19       	sub	r22, r13
     11e:	6d 19       	sub	r22, r13
     120:	6d 19       	sub	r22, r13
     122:	50 19       	sub	r21, r0
     124:	6d 19       	sub	r22, r13
     126:	44 19       	sub	r20, r4
     128:	6d 19       	sub	r22, r13
     12a:	6d 19       	sub	r22, r13
     12c:	56 19       	sub	r21, r6
     12e:	62 19       	sub	r22, r2
     130:	6d 19       	sub	r22, r13
     132:	6d 19       	sub	r22, r13
     134:	6d 19       	sub	r22, r13
     136:	6d 19       	sub	r22, r13
     138:	6d 19       	sub	r22, r13
     13a:	6d 19       	sub	r22, r13
     13c:	6d 19       	sub	r22, r13
     13e:	6d 19       	sub	r22, r13
     140:	6d 19       	sub	r22, r13
     142:	6d 19       	sub	r22, r13
     144:	6d 19       	sub	r22, r13
     146:	6d 19       	sub	r22, r13
     148:	4a 19       	sub	r20, r10
     14a:	6d 19       	sub	r22, r13
     14c:	6d 19       	sub	r22, r13
     14e:	6d 19       	sub	r22, r13
     150:	6d 19       	sub	r22, r13
     152:	6d 19       	sub	r22, r13
     154:	6d 19       	sub	r22, r13
     156:	6d 19       	sub	r22, r13
     158:	6d 19       	sub	r22, r13
     15a:	6d 19       	sub	r22, r13
     15c:	20 19       	sub	r18, r0
     15e:	26 19       	sub	r18, r6
     160:	fc 18       	sub	r15, r12
     162:	6d 19       	sub	r22, r13
     164:	6d 19       	sub	r22, r13
     166:	6d 19       	sub	r22, r13
     168:	6d 19       	sub	r22, r13
     16a:	6d 19       	sub	r22, r13
     16c:	05 19       	sub	r16, r5
     16e:	3e 19       	sub	r19, r14
     170:	6d 19       	sub	r22, r13
     172:	32 19       	sub	r19, r2
     174:	6d 19       	sub	r22, r13
     176:	6d 19       	sub	r22, r13
     178:	2c 19       	sub	r18, r12
     17a:	38 19       	sub	r19, r8
     17c:	6d 19       	sub	r22, r13
     17e:	6d 19       	sub	r22, r13
     180:	6d 19       	sub	r22, r13
     182:	0e 19       	sub	r16, r14
     184:	14 19       	sub	r17, r4
     186:	1a 19       	sub	r17, r10
     188:	e7 1b       	sub	r30, r23
     18a:	e3 1d       	adc	r30, r3
     18c:	e7 1b       	sub	r30, r23
     18e:	0d 1c       	adc	r0, r13
     190:	e3 1d       	adc	r30, r3
     192:	ef 1d       	adc	r30, r15
     194:	fc 1b       	sub	r31, r28
     196:	36 1c       	adc	r3, r6
     198:	e3 1d       	adc	r30, r3
     19a:	e3 1d       	adc	r30, r3
     19c:	e3 1d       	adc	r30, r3
     19e:	e3 1d       	adc	r30, r3
     1a0:	e3 1d       	adc	r30, r3
     1a2:	e3 1d       	adc	r30, r3
     1a4:	e3 1d       	adc	r30, r3
     1a6:	e3 1d       	adc	r30, r3
     1a8:	e3 1d       	adc	r30, r3
     1aa:	e3 1d       	adc	r30, r3
     1ac:	e3 1d       	adc	r30, r3
     1ae:	e3 1d       	adc	r30, r3
     1b0:	e3 1d       	adc	r30, r3
     1b2:	e3 1d       	adc	r30, r3
     1b4:	e3 1d       	adc	r30, r3
     1b6:	e3 1d       	adc	r30, r3
     1b8:	e3 1d       	adc	r30, r3
     1ba:	e3 1d       	adc	r30, r3
     1bc:	e3 1d       	adc	r30, r3
     1be:	e3 1d       	adc	r30, r3
     1c0:	e3 1d       	adc	r30, r3
     1c2:	e3 1d       	adc	r30, r3
     1c4:	e3 1d       	adc	r30, r3
     1c6:	e3 1d       	adc	r30, r3
     1c8:	e3 1d       	adc	r30, r3
     1ca:	e3 1d       	adc	r30, r3
     1cc:	e3 1d       	adc	r30, r3
     1ce:	e3 1d       	adc	r30, r3
     1d0:	e3 1d       	adc	r30, r3
     1d2:	e3 1d       	adc	r30, r3
     1d4:	e3 1d       	adc	r30, r3
     1d6:	e3 1d       	adc	r30, r3
     1d8:	e3 1d       	adc	r30, r3
     1da:	e3 1d       	adc	r30, r3
     1dc:	e3 1d       	adc	r30, r3
     1de:	e3 1d       	adc	r30, r3
     1e0:	e3 1d       	adc	r30, r3
     1e2:	e3 1d       	adc	r30, r3
     1e4:	e3 1d       	adc	r30, r3
     1e6:	e3 1d       	adc	r30, r3
     1e8:	e3 1d       	adc	r30, r3
     1ea:	e3 1d       	adc	r30, r3
     1ec:	e3 1d       	adc	r30, r3
     1ee:	e3 1d       	adc	r30, r3
     1f0:	e3 1d       	adc	r30, r3
     1f2:	e3 1d       	adc	r30, r3
     1f4:	e3 1d       	adc	r30, r3
     1f6:	e3 1d       	adc	r30, r3
     1f8:	e3 1d       	adc	r30, r3
     1fa:	e3 1d       	adc	r30, r3
     1fc:	e3 1d       	adc	r30, r3
     1fe:	e3 1d       	adc	r30, r3
     200:	e3 1d       	adc	r30, r3
     202:	e3 1d       	adc	r30, r3
     204:	e3 1d       	adc	r30, r3
     206:	e3 1d       	adc	r30, r3
     208:	e3 1d       	adc	r30, r3
     20a:	e3 1d       	adc	r30, r3
     20c:	e3 1d       	adc	r30, r3
     20e:	e3 1d       	adc	r30, r3
     210:	e3 1d       	adc	r30, r3
     212:	e3 1d       	adc	r30, r3
     214:	e3 1d       	adc	r30, r3
     216:	e3 1d       	adc	r30, r3
     218:	e3 1d       	adc	r30, r3
     21a:	e3 1d       	adc	r30, r3
     21c:	e3 1d       	adc	r30, r3
     21e:	e3 1d       	adc	r30, r3
     220:	e3 1d       	adc	r30, r3
     222:	e3 1d       	adc	r30, r3
     224:	e3 1d       	adc	r30, r3
     226:	e3 1d       	adc	r30, r3
     228:	e3 1d       	adc	r30, r3
     22a:	e3 1d       	adc	r30, r3
     22c:	01 1c       	adc	r0, r1
     22e:	07 1c       	adc	r0, r7
     230:	e7 1b       	sub	r30, r23
     232:	e3 1d       	adc	r30, r3
     234:	e3 1d       	adc	r30, r3
     236:	e3 1d       	adc	r30, r3
     238:	e3 1d       	adc	r30, r3
     23a:	e3 1d       	adc	r30, r3
     23c:	e3 1d       	adc	r30, r3
     23e:	e3 1d       	adc	r30, r3
     240:	e3 1d       	adc	r30, r3
     242:	e3 1d       	adc	r30, r3
     244:	e3 1d       	adc	r30, r3
     246:	e3 1d       	adc	r30, r3
     248:	e3 1d       	adc	r30, r3
     24a:	e3 1d       	adc	r30, r3
     24c:	e3 1d       	adc	r30, r3
     24e:	e3 1d       	adc	r30, r3
     250:	e3 1d       	adc	r30, r3
     252:	0d 1c       	adc	r0, r13
     254:	e3 1d       	adc	r30, r3
     256:	ef 1d       	adc	r30, r15
     258:	17 1c       	adc	r1, r7
     25a:	29 1c       	adc	r2, r9
     25c:	36 1c       	adc	r3, r6
     25e:	e3 1d       	adc	r30, r3
     260:	e3 1d       	adc	r30, r3
     262:	e3 1d       	adc	r30, r3
     264:	ef 1d       	adc	r30, r15
     266:	3f 1c       	adc	r3, r15
     268:	f5 1b       	sub	r31, r21
     26a:	e3 1d       	adc	r30, r3
     26c:	47 1c       	adc	r4, r7
     26e:	fd 1c       	adc	r15, r13
     270:	15 1d       	adc	r17, r5
     272:	e3 1d       	adc	r30, r3
     274:	e3 1d       	adc	r30, r3
     276:	1c 1d       	adc	r17, r12
     278:	e3 1d       	adc	r30, r3
     27a:	e3 1d       	adc	r30, r3
     27c:	e3 1d       	adc	r30, r3
     27e:	e3 1d       	adc	r30, r3
     280:	e3 1d       	adc	r30, r3
     282:	e3 1d       	adc	r30, r3
     284:	e3 1d       	adc	r30, r3
     286:	e3 1d       	adc	r30, r3
     288:	e3 1d       	adc	r30, r3
     28a:	e3 1d       	adc	r30, r3
     28c:	65 1d       	adc	r22, r5
     28e:	7a 1d       	adc	r23, r10
     290:	8f 1d       	adc	r24, r15
     292:	a4 1d       	adc	r26, r4
     294:	b9 1d       	adc	r27, r9
     296:	e3 1d       	adc	r30, r3
     298:	bb 1d       	adc	r27, r11
     29a:	e3 1d       	adc	r30, r3
     29c:	e3 1d       	adc	r30, r3
     29e:	e3 1d       	adc	r30, r3
     2a0:	c7 1d       	adc	r28, r7
     2a2:	e3 1d       	adc	r30, r3
     2a4:	e3 1d       	adc	r30, r3
     2a6:	e3 1d       	adc	r30, r3
     2a8:	e3 1d       	adc	r30, r3
     2aa:	e3 1d       	adc	r30, r3
     2ac:	e3 1d       	adc	r30, r3
     2ae:	e3 1d       	adc	r30, r3
     2b0:	e3 1d       	adc	r30, r3
     2b2:	e3 1d       	adc	r30, r3
     2b4:	e3 1d       	adc	r30, r3
     2b6:	e3 1d       	adc	r30, r3
     2b8:	e3 1d       	adc	r30, r3
     2ba:	e3 1d       	adc	r30, r3
     2bc:	e3 1d       	adc	r30, r3
     2be:	e3 1d       	adc	r30, r3
     2c0:	e3 1d       	adc	r30, r3
     2c2:	e3 1d       	adc	r30, r3
     2c4:	e3 1d       	adc	r30, r3
     2c6:	e3 1d       	adc	r30, r3
     2c8:	e3 1d       	adc	r30, r3
     2ca:	e3 1d       	adc	r30, r3
     2cc:	e3 1d       	adc	r30, r3
     2ce:	e3 1d       	adc	r30, r3
     2d0:	e3 1d       	adc	r30, r3
     2d2:	e3 1d       	adc	r30, r3
     2d4:	e3 1d       	adc	r30, r3
     2d6:	e3 1d       	adc	r30, r3
     2d8:	e3 1d       	adc	r30, r3
     2da:	e3 1d       	adc	r30, r3
     2dc:	e3 1d       	adc	r30, r3
     2de:	e3 1d       	adc	r30, r3
     2e0:	e3 1d       	adc	r30, r3
     2e2:	e3 1d       	adc	r30, r3
     2e4:	e3 1d       	adc	r30, r3
     2e6:	e3 1d       	adc	r30, r3
     2e8:	e3 1d       	adc	r30, r3
     2ea:	e3 1d       	adc	r30, r3
     2ec:	e3 1d       	adc	r30, r3
     2ee:	e3 1d       	adc	r30, r3
     2f0:	e3 1d       	adc	r30, r3
     2f2:	e3 1d       	adc	r30, r3
     2f4:	e3 1d       	adc	r30, r3
     2f6:	e3 1d       	adc	r30, r3
     2f8:	e3 1d       	adc	r30, r3
     2fa:	e3 1d       	adc	r30, r3
     2fc:	e3 1d       	adc	r30, r3
     2fe:	e3 1d       	adc	r30, r3
     300:	e3 1d       	adc	r30, r3
     302:	e3 1d       	adc	r30, r3
     304:	e3 1d       	adc	r30, r3
     306:	e3 1d       	adc	r30, r3
     308:	e3 1d       	adc	r30, r3
     30a:	e3 1d       	adc	r30, r3
     30c:	e3 1d       	adc	r30, r3
     30e:	e3 1d       	adc	r30, r3
     310:	e3 1d       	adc	r30, r3
     312:	e3 1d       	adc	r30, r3
     314:	e3 1d       	adc	r30, r3
     316:	e3 1d       	adc	r30, r3
     318:	e3 1d       	adc	r30, r3
     31a:	e3 1d       	adc	r30, r3
     31c:	e3 1d       	adc	r30, r3
     31e:	e3 1d       	adc	r30, r3
     320:	e3 1d       	adc	r30, r3
     322:	e3 1d       	adc	r30, r3
     324:	e3 1d       	adc	r30, r3
     326:	e3 1d       	adc	r30, r3
     328:	e3 1d       	adc	r30, r3
     32a:	e3 1d       	adc	r30, r3
     32c:	e3 1d       	adc	r30, r3
     32e:	e3 1d       	adc	r30, r3
     330:	e3 1d       	adc	r30, r3
     332:	e3 1d       	adc	r30, r3
     334:	e3 1d       	adc	r30, r3
     336:	e3 1d       	adc	r30, r3
     338:	e3 1d       	adc	r30, r3
     33a:	e3 1d       	adc	r30, r3
     33c:	e3 1d       	adc	r30, r3
     33e:	e3 1d       	adc	r30, r3
     340:	e3 1d       	adc	r30, r3
     342:	e3 1d       	adc	r30, r3
     344:	e3 1d       	adc	r30, r3
     346:	e3 1d       	adc	r30, r3
     348:	e3 1d       	adc	r30, r3
     34a:	e3 1d       	adc	r30, r3
     34c:	e3 1d       	adc	r30, r3
     34e:	e3 1d       	adc	r30, r3
     350:	e3 1d       	adc	r30, r3
     352:	e3 1d       	adc	r30, r3
     354:	e3 1d       	adc	r30, r3
     356:	e3 1d       	adc	r30, r3
     358:	e3 1d       	adc	r30, r3
     35a:	e3 1d       	adc	r30, r3
     35c:	e3 1d       	adc	r30, r3
     35e:	e3 1d       	adc	r30, r3
     360:	e3 1d       	adc	r30, r3
     362:	e3 1d       	adc	r30, r3
     364:	e3 1d       	adc	r30, r3
     366:	e3 1d       	adc	r30, r3
     368:	d1 1d       	adc	r29, r1
     36a:	da 1d       	adc	r29, r10

0000036c <__c.1751>:
     36c:	50 6f 73 3a 20 25 6c 71 2c 25 6c 71 2c 25 6c 71     Pos: %lq,%lq,%lq
     37c:	2c 25 6c 71 2c 25 6c 75 0a 00                       ,%lq,%lu..

00000386 <__c.1753>:
     386:	44 73 74 3a 20 25 6c 71 2c 25 6c 71 2c 25 6c 71     Dst: %lq,%lq,%lq
     396:	2c 25 6c 71 2c 25 6c 75 0a 00                       ,%lq,%lu..

000003a0 <__c.2132>:
     3a0:	0a 7b 44 44 41 5f 43 52 45 41 54 45 3a 20 5b 00     .{DDA_CREATE: [.

000003b0 <__c.2134>:
     3b0:	25 6c 64 2c 25 6c 64 2c 25 6c 64 2c 25 6c 64 5d     %ld,%ld,%ld,%ld]
     3c0:	20 5b 00                                             [.

000003c3 <__c.2136>:
     3c3:	74 73 3a 25 6c 75 00                                ts:%lu.

000003ca <__c.2138>:
     3ca:	2c 64 73 3a 25 6c 75 00                             ,ds:%lu.

000003d2 <__c.2141>:
     3d2:	5d 20 7d 0a 00                                      ] }..

000003d7 <__c.1852>:
     3d7:	54 65 6d 70 20 61 63 68 69 65 76 65 64 0a 00        Temp achieved..

000003e6 <__c.1871>:
     3e6:	57 61 69 74 69 6e 67 20 66 6f 72 20 74 61 72 67     Waiting for targ
     3f6:	65 74 20 74 65 6d 70 0a 00                          et temp..

000003ff <__c.1878>:
     3ff:	51 25 64 2f 25 64 25 63 00                          Q%d/%d%c.

00000408 <__c.1960>:
     408:	6f 6b 20 00                                         ok .

0000040c <__c.1962>:
     40c:	72 73 20 4e 25 6c 64 20 45 78 70 65 63 74 65 64     rs N%ld Expected
     41c:	20 63 68 65 63 6b 73 75 6d 20 25 64 0a 00            checksum %d..

0000042a <__c.1963>:
     42a:	45 3a 20 42 61 64 20 47 2d 63 6f 64 65 20 25 64     E: Bad G-code %d
	...

0000043b <__c.1989>:
     43b:	58 3a 25 6c 71 2c 59 3a 25 6c 71 2c 5a 3a 25 6c     X:%lq,Y:%lq,Z:%l
     44b:	71 2c 45 3a 25 6c 71 2c 46 3a 25 6c 75 00           q,E:%lq,F:%lu.

00000459 <__c.1991>:
     459:	2c 63 3a 25 6c 75 7d 0a 45 6e 64 70 6f 69 6e 74     ,c:%lu}.Endpoint
     469:	3a 20 58 3a 25 6c 64 2c 59 3a 25 6c 64 2c 5a 3a     : X:%ld,Y:%ld,Z:
     479:	25 6c 64 2c 45 3a 25 6c 64 2c 46 3a 25 6c 75 2c     %ld,E:%ld,F:%lu,
     489:	63 3a 25 6c 75 7d 00                                c:%lu}.

00000490 <__c.1994>:
     490:	46 49 52 4d 57 41 52 45 5f 4e 41 4d 45 3a 54 65     FIRMWARE_NAME:Te
     4a0:	61 63 75 70 20 46 49 52 4d 57 41 52 45 5f 55 52     acup FIRMWARE_UR
     4b0:	4c 3a 68 74 74 70 3a 2f 2f 67 69 74 68 75 62 2e     L:http://github.
     4c0:	63 6f 6d 2f 74 72 69 66 66 69 64 2f 54 65 61 63     com/triffid/Teac
     4d0:	75 70 5f 46 69 72 6d 77 61 72 65 2f 20 50 52 4f     up_Firmware/ PRO
     4e0:	54 4f 43 4f 4c 5f 56 45 52 53 49 4f 4e 3a 31 2e     TOCOL_VERSION:1.
     4f0:	30 20 4d 41 43 48 49 4e 45 5f 54 59 50 45 3a 4d     0 MACHINE_TYPE:M
     500:	65 6e 64 65 6c 20 45 58 54 52 55 44 45 52 5f 43     endel EXTRUDER_C
     510:	4f 55 4e 54 3a 25 64 20 54 45 4d 50 5f 53 45 4e     OUNT:%d TEMP_SEN
     520:	53 4f 52 5f 43 4f 55 4e 54 3a 25 64 20 48 45 41     SOR_COUNT:%d HEA
     530:	54 45 52 5f 43 4f 55 4e 54 3a 25 64 00              TER_COUNT:%d.

0000053d <__c.1998>:
     53d:	78 5f 6d 69 6e 3a 25 64 20 00                       x_min:%d .

00000547 <__c.2000>:
     547:	78 5f 6d 61 78 3a 25 64 20 00                       x_max:%d .

00000551 <__c.2002>:
     551:	79 5f 6d 69 6e 3a 25 64 20 00                       y_min:%d .

0000055b <__c.2004>:
     55b:	79 5f 6d 61 78 3a 25 64 20 00                       y_max:%d .

00000565 <__c.2006>:
     565:	7a 5f 6d 69 6e 3a 25 64 20 00                       z_min:%d .

0000056f <__c.2016>:
     56f:	45 63 68 6f 20 6f 66 66 00                          Echo off.

00000578 <__c.2019>:
     578:	45 63 68 6f 20 6f 6e 00                             Echo on.

00000580 <__c.2022>:
     580:	45 3a 20 42 61 64 20 4d 2d 63 6f 64 65 20 25 64     E: Bad M-code %d
	...

00000591 <__c.1803>:
     591:	54 7b 45 3a 25 64 2c 20 50 3a 25 64 20 2a 20 25     T{E:%d, P:%d * %
     5a1:	6c 64 20 3d 20 25 6c 64 20 2f 20 49 3a 25 64 20     ld = %ld / I:%d 
     5b1:	2a 20 25 6c 64 20 3d 20 25 6c 64 20 2f 20 44 3a     * %ld = %ld / D:
     5c1:	25 64 20 2a 20 25 6c 64 20 3d 20 25 6c 64 20 23     %d * %ld = %ld #
     5d1:	20 4f 3a 20 25 6c 64 20 3d 20 25 75 7d 0a 00         O: %ld = %u}..

000005e0 <__c.1809>:
     5e0:	50 57 4d 7b 25 75 20 3d 20 25 75 7d 0a 00           PWM{%u = %u}..

000005ee <__c.1848>:
     5ee:	50 3a 25 6c 64 20 49 3a 25 6c 64 20 44 3a 25 6c     P:%ld I:%ld D:%l
     5fe:	64 20 49 6c 69 6d 3a 25 75 20 63 72 63 3a 25 75     d Ilim:%u crc:%u
     60e:	20 00                                                .

00000610 <__c.1848>:
     610:	73 74 61 72 74 0a 6f 6b 0a 00                       start.ok..

0000061a <__c.1571>:
     61a:	30 78 00                                            0x.

0000061d <temptable>:
     61d:	01 00 fc 0c 0b 00 31 06 15 00 2d 05 1f 00 a6 04     ......1...-.....
     62d:	29 00 4d 04 33 00 0c 04 3d 00 d9 03 47 00 af 03     ).M.3...=...G...
     63d:	51 00 8c 03 5b 00 6d 03 65 00 52 03 6f 00 3a 03     Q...[.m.e.R.o.:.
     64d:	79 00 24 03 83 00 11 03 8d 00 ff 02 97 00 ee 02     y.$.............
     65d:	a1 00 de 02 ab 00 d0 02 b5 00 c2 02 bf 00 b5 02     ................
     66d:	c9 00 a9 02 d3 00 9d 02 dd 00 92 02 e7 00 88 02     ................
     67d:	f1 00 7e 02 fb 00 74 02 05 01 6b 02 0f 01 61 02     ..~...t...k...a.
     68d:	19 01 59 02 23 01 50 02 2d 01 48 02 37 01 40 02     ..Y.#.P.-.H.7.@.
     69d:	41 01 38 02 4b 01 31 02 55 01 29 02 5f 01 22 02     A.8.K.1.U.)._.".
     6ad:	69 01 1b 02 73 01 14 02 7d 01 0e 02 87 01 07 02     i...s...}.......
     6bd:	91 01 00 02 9b 01 fa 01 a5 01 f4 01 af 01 ed 01     ................
     6cd:	b9 01 e7 01 c3 01 e1 01 cd 01 db 01 d7 01 d5 01     ................
     6dd:	e1 01 d0 01 eb 01 ca 01 f5 01 c4 01 ff 01 be 01     ................
     6ed:	09 02 b9 01 13 02 b3 01 1d 02 ae 01 27 02 a8 01     ............'...
     6fd:	31 02 a3 01 3b 02 9d 01 45 02 98 01 4f 02 92 01     1...;...E...O...
     70d:	59 02 8d 01 63 02 87 01 6d 02 82 01 77 02 7c 01     Y...c...m...w.|.
     71d:	81 02 77 01 8b 02 71 01 95 02 6c 01 9f 02 66 01     ..w...q...l...f.
     72d:	a9 02 61 01 b3 02 5b 01 bd 02 55 01 c7 02 50 01     ..a...[...U...P.
     73d:	d1 02 4a 01 db 02 44 01 e5 02 3e 01 ef 02 38 01     ..J...D...>...8.
     74d:	f9 02 32 01 03 03 2c 01 0d 03 26 01 17 03 1f 01     ..2...,...&.....
     75d:	21 03 19 01 2b 03 12 01 35 03 0b 01 3f 03 04 01     !...+...5...?...
     76d:	49 03 fd 00 53 03 f5 00 5d 03 ee 00 67 03 e6 00     I...S...]...g...
     77d:	71 03 dd 00 7b 03 d4 00 85 03 cb 00 8f 03 c1 00     q...{...........
     78d:	99 03 b7 00 a3 03 ac 00 ad 03 a0 00 b7 03 93 00     ................
     79d:	c1 03 84 00 cb 03 73 00 d5 03 60 00 df 03 49 00     ......s...`...I.
     7ad:	e9 03 2b 00 f3 03 00 00 01 00 f6 0c 0b 00 2e 06     ..+.............
     7bd:	15 00 2b 05 1f 00 a4 04 29 00 4c 04 33 00 0b 04     ..+.....).L.3...
     7cd:	3d 00 d8 03 47 00 ae 03 51 00 8a 03 5b 00 6c 03     =...G...Q...[.l.
     7dd:	65 00 51 03 6f 00 39 03 79 00 23 03 83 00 10 03     e.Q.o.9.y.#.....
     7ed:	8d 00 fe 02 97 00 ed 02 a1 00 dd 02 ab 00 cf 02     ................
     7fd:	b5 00 c1 02 bf 00 b4 02 c9 00 a8 02 d3 00 9c 02     ................
     80d:	dd 00 91 02 e7 00 87 02 f1 00 7d 02 fb 00 73 02     ..........}...s.
     81d:	05 01 6a 02 0f 01 60 02 19 01 58 02 23 01 4f 02     ..j...`...X.#.O.
     82d:	2d 01 47 02 37 01 3f 02 41 01 37 02 4b 01 30 02     -.G.7.?.A.7.K.0.
     83d:	55 01 28 02 5f 01 21 02 69 01 1a 02 73 01 13 02     U.(._.!.i...s...
     84d:	7d 01 0d 02 87 01 06 02 91 01 00 02 9b 01 f9 01     }...............
     85d:	a5 01 f3 01 af 01 ed 01 b9 01 e7 01 c3 01 e0 01     ................
     86d:	cd 01 db 01 d7 01 d5 01 e1 01 cf 01 eb 01 c9 01     ................
     87d:	f5 01 c3 01 ff 01 be 01 09 02 b8 01 13 02 b2 01     ................
     88d:	1d 02 ad 01 27 02 a7 01 31 02 a2 01 3b 02 9c 01     ....'...1...;...
     89d:	45 02 97 01 4f 02 91 01 59 02 8c 01 63 02 86 01     E...O...Y...c...
     8ad:	6d 02 81 01 77 02 7c 01 81 02 76 01 8b 02 71 01     m...w.|...v...q.
     8bd:	95 02 6b 01 9f 02 66 01 a9 02 60 01 b3 02 5a 01     ..k...f...`...Z.
     8cd:	bd 02 55 01 c7 02 4f 01 d1 02 49 01 db 02 43 01     ..U...O...I...C.
     8dd:	e5 02 3d 01 ef 02 38 01 f9 02 31 01 03 03 2b 01     ..=...8...1...+.
     8ed:	0d 03 25 01 17 03 1f 01 21 03 18 01 2b 03 11 01     ..%.....!...+...
     8fd:	35 03 0b 01 3f 03 04 01 49 03 fc 00 53 03 f5 00     5...?...I...S...
     90d:	5d 03 ed 00 67 03 e5 00 71 03 dd 00 7b 03 d4 00     ]...g...q...{...
     91d:	85 03 cb 00 8f 03 c1 00 99 03 b6 00 a3 03 ab 00     ................
     92d:	ad 03 9f 00 b7 03 92 00 c1 03 83 00 cb 03 73 00     ..............s.
     93d:	d5 03 60 00 df 03 48 00 e9 03 2a 00 f2 03 04 00     ..`...H...*.....

0000094d <__c.1772>:
     94d:	70 69 6e 3a 25 64 20 52 61 77 20 41 44 43 3a 25     pin:%d Raw ADC:%
     95d:	64 20 74 61 62 6c 65 20 65 6e 74 72 79 3a 20 25     d table entry: %
     96d:	64 00                                               d.

0000096f <__c.1792>:
     96f:	20 74 65 6d 70 3a 25 64 2e 25 64 00                  temp:%d.%d.

0000097b <__c.1797>:
     97b:	20 53 65 6e 73 6f 72 3a 25 64 0a 00                  Sensor:%d..

00000987 <__c.1801>:
     987:	44 55 20 74 65 6d 70 3a 20 7b 25 64 20 25 64 20     DU temp: {%d %d 
     997:	25 64 2e 25 64 7d 00                                %d.%d}.

0000099e <__c.1806>:
     99e:	0a 00                                               ..

000009a0 <__c.1831>:
     9a0:	54 3a 00                                            T:.

000009a3 <__c.1833>:
     9a3:	20 42 3a 00                                          B:.

000009a7 <__c.1835>:
     9a7:	54 5b 25 73 75 5d 3a 00                             T[%su]:.

000009af <__c.1826>:
     9af:	25 75 2e 25 75 00 00                                %u.%u..

000009b6 <__ctors_end>:
     9b6:	11 24       	eor	r1, r1
     9b8:	1f be       	out	0x3f, r1	; 63
     9ba:	cf ef       	ldi	r28, 0xFF	; 255
     9bc:	d1 e2       	ldi	r29, 0x21	; 33
     9be:	de bf       	out	0x3e, r29	; 62
     9c0:	cd bf       	out	0x3d, r28	; 61
     9c2:	00 e0       	ldi	r16, 0x00	; 0
     9c4:	0c bf       	out	0x3c, r16	; 60

000009c6 <__do_copy_data>:
     9c6:	12 e0       	ldi	r17, 0x02	; 2
     9c8:	a0 e0       	ldi	r26, 0x00	; 0
     9ca:	b2 e0       	ldi	r27, 0x02	; 2
     9cc:	e0 e6       	ldi	r30, 0x60	; 96
     9ce:	f5 e5       	ldi	r31, 0x55	; 85
     9d0:	00 e0       	ldi	r16, 0x00	; 0
     9d2:	0b bf       	out	0x3b, r16	; 59
     9d4:	02 c0       	rjmp	.+4      	; 0x9da <__do_copy_data+0x14>
     9d6:	07 90       	elpm	r0, Z+
     9d8:	0d 92       	st	X+, r0
     9da:	a2 33       	cpi	r26, 0x32	; 50
     9dc:	b1 07       	cpc	r27, r17
     9de:	d9 f7       	brne	.-10     	; 0x9d6 <__do_copy_data+0x10>

000009e0 <__do_clear_bss>:
     9e0:	25 e0       	ldi	r18, 0x05	; 5
     9e2:	a2 e3       	ldi	r26, 0x32	; 50
     9e4:	b2 e0       	ldi	r27, 0x02	; 2
     9e6:	01 c0       	rjmp	.+2      	; 0x9ea <.do_clear_bss_start>

000009e8 <.do_clear_bss_loop>:
     9e8:	1d 92       	st	X+, r1

000009ea <.do_clear_bss_start>:
     9ea:	a3 3a       	cpi	r26, 0xA3	; 163
     9ec:	b2 07       	cpc	r27, r18
     9ee:	e1 f7       	brne	.-8      	; 0x9e8 <.do_clear_bss_loop>
     9f0:	0e 94 0c 24 	call	0x4818	; 0x4818 <main>
     9f4:	0c 94 ae 2a 	jmp	0x555c	; 0x555c <_exit>

000009f8 <__bad_interrupt>:
     9f8:	03 cb       	rjmp	.-2554   	; 0x0 <__vectors>

000009fa <analog_init>:
	if (analog_mask > 0) {
		// clear ADC bit in power reduction register because of ADC use.
		#ifdef	PRR
			PRR &= ~MASK(PRADC);
		#elif defined PRR0
			PRR0 &= ~MASK(PRADC);
     9fa:	e4 e6       	ldi	r30, 0x64	; 100
     9fc:	f0 e0       	ldi	r31, 0x00	; 0
     9fe:	80 81       	ld	r24, Z
     a00:	8e 7f       	andi	r24, 0xFE	; 254
     a02:	80 83       	st	Z, r24
		#endif

		// select reference signal to use, set right adjusted results and select ADC input 0
		ADMUX = REFERENCE;
     a04:	80 e4       	ldi	r24, 0x40	; 64
     a06:	80 93 7c 00 	sts	0x007C, r24

		// ADC frequency must be less than 200khz or we lose precision. At 16MHz system clock, we must use the full prescale value of 128 to get an ADC clock of 125khz.
		ADCSRA = MASK(ADEN) | MASK(ADPS2) | MASK(ADPS1) | MASK(ADPS0);
     a0a:	ea e7       	ldi	r30, 0x7A	; 122
     a0c:	f0 e0       	ldi	r31, 0x00	; 0
     a0e:	87 e8       	ldi	r24, 0x87	; 135
     a10:	80 83       	st	Z, r24
		#ifdef	ADCSRB
			ADCSRB = 0;
     a12:	10 92 7b 00 	sts	0x007B, r1
		#endif

		adc_counter = 0;
     a16:	10 92 b3 04 	sts	0x04B3, r1

		// clear analog inputs in the data direction register(s)
		AIO0_DDR &= ~analog_mask;
     a1a:	80 b3       	in	r24, 0x10	; 16
     a1c:	80 bb       	out	0x10, r24	; 16
		#ifdef	AIO8_DDR
			AIO8_DDR &= ~(analog_mask >> 8);
     a1e:	a7 e0       	ldi	r26, 0x07	; 7
     a20:	b1 e0       	ldi	r27, 0x01	; 1
     a22:	8c 91       	ld	r24, X
     a24:	8f 7d       	andi	r24, 0xDF	; 223
     a26:	8c 93       	st	X, r24
		#endif

		// disable the analog inputs for digital use.
		DIDR0 = analog_mask & 0xFF;
     a28:	10 92 7e 00 	sts	0x007E, r1
		#ifdef	DIDR2
			DIDR2 = (analog_mask >> 8) & 0xFF;
     a2c:	80 e2       	ldi	r24, 0x20	; 32
     a2e:	80 93 7d 00 	sts	0x007D, r24
		#endif

		// now we start the first conversion and leave the rest to the interrupt
		ADCSRA |= MASK(ADIE) | MASK(ADSC);
     a32:	80 81       	ld	r24, Z
     a34:	88 64       	ori	r24, 0x48	; 72
     a36:	80 83       	st	Z, r24
     a38:	08 95       	ret

00000a3a <__vector_29>:

/*! Analog Interrupt

	This is where we read our analog value and store it in an array for later retrieval
*/
ISR(ADC_vect, ISR_NOBLOCK) {
     a3a:	78 94       	sei
     a3c:	1f 92       	push	r1
     a3e:	0f 92       	push	r0
     a40:	0f b6       	in	r0, 0x3f	; 63
     a42:	0f 92       	push	r0
     a44:	11 24       	eor	r1, r1
     a46:	0b b6       	in	r0, 0x3b	; 59
     a48:	0f 92       	push	r0
     a4a:	2f 93       	push	r18
     a4c:	8f 93       	push	r24
     a4e:	9f 93       	push	r25
     a50:	ef 93       	push	r30
     a52:	ff 93       	push	r31
	// save status register
	uint8_t sreg_save = SREG;
     a54:	2f b7       	in	r18, 0x3f	; 63

	// emulate free-running mode but be more deterministic about exactly which result we have, since this project has long-running interrupts
	if (analog_mask > 0) { // at least one temp sensor uses an analog channel
		// store next result
		adc_result[adc_counter] = ADC;
     a56:	e0 91 b3 04 	lds	r30, 0x04B3
     a5a:	f0 e0       	ldi	r31, 0x00	; 0
     a5c:	80 91 78 00 	lds	r24, 0x0078
     a60:	90 91 79 00 	lds	r25, 0x0079
     a64:	ee 0f       	add	r30, r30
     a66:	ff 1f       	adc	r31, r31
     a68:	ee 5c       	subi	r30, 0xCE	; 206
     a6a:	fd 4f       	sbci	r31, 0xFD	; 253
     a6c:	91 83       	std	Z+1, r25	; 0x01
     a6e:	80 83       	st	Z, r24

		// next channel
		do {
			adc_counter++;
			if (adc_counter >= sizeof(adc_channel))
				adc_counter = 0;
     a70:	10 92 b3 04 	sts	0x04B3, r1
		} while (adc_channel[adc_counter] == 255);

		// start next conversion
		ADMUX = (adc_channel[adc_counter] & 0x07) | REFERENCE;
     a74:	85 e4       	ldi	r24, 0x45	; 69
     a76:	80 93 7c 00 	sts	0x007C, r24
		#ifdef	MUX5
			if (adc_channel[adc_counter] & 0x08)
				ADCSRB |= MASK(MUX5);
     a7a:	eb e7       	ldi	r30, 0x7B	; 123
     a7c:	f0 e0       	ldi	r31, 0x00	; 0
     a7e:	80 81       	ld	r24, Z
     a80:	88 60       	ori	r24, 0x08	; 8
     a82:	80 83       	st	Z, r24
			else
				ADCSRB &= ~MASK(MUX5);
		#endif

		// After the mux has been set, start a new conversion 
		ADCSRA |= MASK(ADSC);
     a84:	ea e7       	ldi	r30, 0x7A	; 122
     a86:	f0 e0       	ldi	r31, 0x00	; 0
     a88:	80 81       	ld	r24, Z
     a8a:	80 64       	ori	r24, 0x40	; 64
     a8c:	80 83       	st	Z, r24
	}

	// restore status register
	MEMORY_BARRIER();
	SREG = sreg_save;
     a8e:	2f bf       	out	0x3f, r18	; 63
}
     a90:	ff 91       	pop	r31
     a92:	ef 91       	pop	r30
     a94:	9f 91       	pop	r25
     a96:	8f 91       	pop	r24
     a98:	2f 91       	pop	r18
     a9a:	0f 90       	pop	r0
     a9c:	0b be       	out	0x3b, r0	; 59
     a9e:	0f 90       	pop	r0
     aa0:	0f be       	out	0x3f, r0	; 63
     aa2:	0f 90       	pop	r0
     aa4:	1f 90       	pop	r1
     aa6:	18 95       	reti

00000aa8 <analog_read>:
	if (analog_mask > 0) {
		uint16_t r;

		uint8_t sreg;
		// save interrupt flag
		sreg = SREG;
     aa8:	9f b7       	in	r25, 0x3f	; 63
		// disable interrupts
		cli();
     aaa:	f8 94       	cli

		// atomic 16-bit copy
		r = adc_result[index];
     aac:	e8 2f       	mov	r30, r24
     aae:	f0 e0       	ldi	r31, 0x00	; 0
     ab0:	ee 0f       	add	r30, r30
     ab2:	ff 1f       	adc	r31, r31
     ab4:	ee 5c       	subi	r30, 0xCE	; 206
     ab6:	fd 4f       	sbci	r31, 0xFD	; 253
     ab8:	20 81       	ld	r18, Z
     aba:	31 81       	ldd	r19, Z+1	; 0x01

		// restore interrupt flag
		SREG = sreg;
     abc:	9f bf       	out	0x3f, r25	; 63

		return r;
	} else {
		return 0;
	}
}
     abe:	82 2f       	mov	r24, r18
     ac0:	93 2f       	mov	r25, r19
     ac2:	08 95       	ret

00000ac4 <clock>:

/*! do reoccuring stuff

	call it occasionally in busy loops
*/
void clock() {
     ac4:	5f 92       	push	r5
     ac6:	6f 92       	push	r6
     ac8:	7f 92       	push	r7
     aca:	8f 92       	push	r8
     acc:	9f 92       	push	r9
     ace:	af 92       	push	r10
     ad0:	bf 92       	push	r11
     ad2:	cf 92       	push	r12
     ad4:	df 92       	push	r13
     ad6:	ef 92       	push	r14
     ad8:	ff 92       	push	r15
     ada:	0f 93       	push	r16
     adc:	1f 93       	push	r17
     ade:	cf 93       	push	r28
     ae0:	df 93       	push	r29
	ifclock(clock_flag_10ms) {
     ae2:	80 91 c7 04 	lds	r24, 0x04C7
     ae6:	88 23       	and	r24, r24
     ae8:	09 f4       	brne	.+2      	; 0xaec <clock+0x28>
     aea:	e9 c0       	rjmp	.+466    	; 0xcbe <clock+0x1fa>

	ifclock(clock_flag_1s) {
		if (DEBUG_POSITION && (debug_flags & DEBUG_POSITION)) {
			// current position
			update_current_position();
			sersendf_P(PSTR("Pos: %lq,%lq,%lq,%lq,%lu\n"), current_position.X, current_position.Y, current_position.Z, current_position.E, current_position.F);
     aec:	0f 2e       	mov	r0, r31
     aee:	f6 e7       	ldi	r31, 0x76	; 118
     af0:	af 2e       	mov	r10, r31
     af2:	f2 e0       	ldi	r31, 0x02	; 2
     af4:	bf 2e       	mov	r11, r31
     af6:	f0 2d       	mov	r31, r0
     af8:	0f 2e       	mov	r0, r31
     afa:	f2 e7       	ldi	r31, 0x72	; 114
     afc:	cf 2e       	mov	r12, r31
     afe:	f2 e0       	ldi	r31, 0x02	; 2
     b00:	df 2e       	mov	r13, r31
     b02:	f0 2d       	mov	r31, r0
     b04:	0f 2e       	mov	r0, r31
     b06:	fe e6       	ldi	r31, 0x6E	; 110
     b08:	ef 2e       	mov	r14, r31
     b0a:	f2 e0       	ldi	r31, 0x02	; 2
     b0c:	ff 2e       	mov	r15, r31
     b0e:	f0 2d       	mov	r31, r0
     b10:	0a e6       	ldi	r16, 0x6A	; 106
     b12:	12 e0       	ldi	r17, 0x02	; 2
     b14:	c6 e6       	ldi	r28, 0x66	; 102
     b16:	d2 e0       	ldi	r29, 0x02	; 2
*/
static void clock_10ms(void) {
	// reset watchdog
	wd_reset();

	temp_tick();
     b18:	0e 94 2d 27 	call	0x4e5a	; 0x4e5a <temp_sensor_tick>

	ifclock(clock_flag_250ms) {
     b1c:	80 91 c6 04 	lds	r24, 0x04C6
     b20:	88 23       	and	r24, r24
     b22:	09 f4       	brne	.+2      	; 0xb26 <clock+0x62>
     b24:	c6 c0       	rjmp	.+396    	; 0xcb2 <clock+0x1ee>

	ifclock(clock_flag_1s) {
		if (DEBUG_POSITION && (debug_flags & DEBUG_POSITION)) {
			// current position
			update_current_position();
			sersendf_P(PSTR("Pos: %lq,%lq,%lq,%lq,%lu\n"), current_position.X, current_position.Y, current_position.Z, current_position.E, current_position.F);
     b26:	0f 2e       	mov	r0, r31
     b28:	fc e6       	ldi	r31, 0x6C	; 108
     b2a:	6f 2e       	mov	r6, r31
     b2c:	f3 e0       	ldi	r31, 0x03	; 3
     b2e:	7f 2e       	mov	r7, r31
     b30:	f0 2d       	mov	r31, r0

			// target position
			sersendf_P(PSTR("Dst: %lq,%lq,%lq,%lq,%lu\n"), movebuffer[mb_tail].endpoint.X, movebuffer[mb_tail].endpoint.Y, movebuffer[mb_tail].endpoint.Z, movebuffer[mb_tail].endpoint.E, movebuffer[mb_tail].endpoint.F);
     b32:	0f 2e       	mov	r0, r31
     b34:	fc e3       	ldi	r31, 0x3C	; 60
     b36:	5f 2e       	mov	r5, r31
     b38:	f0 2d       	mov	r31, r0
/*!	do stuff every 1/4 second

	called from clock_10ms(), do not call directly
*/
static void clock_250ms(void) {
  if (heaters_all_zero()) {
     b3a:	0e 94 5d 21 	call	0x42ba	; 0x42ba <heaters_all_zero>
     b3e:	88 23       	and	r24, r24
     b40:	79 f0       	breq	.+30     	; 0xb60 <clock+0x9c>
		if (psu_timeout > (30 * 4)) {
     b42:	80 91 bf 04 	lds	r24, 0x04BF
     b46:	89 37       	cpi	r24, 0x79	; 121
     b48:	18 f0       	brcs	.+6      	; 0xb50 <clock+0x8c>
			power_off();
     b4a:	0e 94 24 24 	call	0x4848	; 0x4848 <power_off>
     b4e:	08 c0       	rjmp	.+16     	; 0xb60 <clock+0x9c>
		}
		else {
      ATOMIC_START
     b50:	8f b7       	in	r24, 0x3f	; 63
     b52:	f8 94       	cli
        psu_timeout++;
     b54:	90 91 bf 04 	lds	r25, 0x04BF
     b58:	9f 5f       	subi	r25, 0xFF	; 255
     b5a:	90 93 bf 04 	sts	0x04BF, r25
      ATOMIC_END
     b5e:	8f bf       	out	0x3f, r24	; 63
		}
	}

	ifclock(clock_flag_1s) {
     b60:	80 91 c5 04 	lds	r24, 0x04C5
     b64:	88 23       	and	r24, r24
     b66:	09 f4       	brne	.+2      	; 0xb6a <clock+0xa6>
     b68:	9e c0       	rjmp	.+316    	; 0xca6 <clock+0x1e2>
			// current position
			update_current_position();
			sersendf_P(PSTR("Pos: %lq,%lq,%lq,%lq,%lu\n"), current_position.X, current_position.Y, current_position.Z, current_position.E, current_position.F);

			// target position
			sersendf_P(PSTR("Dst: %lq,%lq,%lq,%lq,%lu\n"), movebuffer[mb_tail].endpoint.X, movebuffer[mb_tail].endpoint.Y, movebuffer[mb_tail].endpoint.Z, movebuffer[mb_tail].endpoint.E, movebuffer[mb_tail].endpoint.F);
     b6a:	0f 2e       	mov	r0, r31
     b6c:	f6 e8       	ldi	r31, 0x86	; 134
     b6e:	8f 2e       	mov	r8, r31
     b70:	f3 e0       	ldi	r31, 0x03	; 3
     b72:	9f 2e       	mov	r9, r31
     b74:	f0 2d       	mov	r31, r0
      ATOMIC_END
		}
	}

	ifclock(clock_flag_1s) {
		if (DEBUG_POSITION && (debug_flags & DEBUG_POSITION)) {
     b76:	80 91 cf 04 	lds	r24, 0x04CF
     b7a:	82 ff       	sbrs	r24, 2
     b7c:	8e c0       	rjmp	.+284    	; 0xc9a <clock+0x1d6>
			// current position
			update_current_position();
     b7e:	0e 94 03 10 	call	0x2006	; 0x2006 <update_current_position>
			sersendf_P(PSTR("Pos: %lq,%lq,%lq,%lq,%lu\n"), current_position.X, current_position.Y, current_position.Z, current_position.E, current_position.F);
     b82:	f5 01       	movw	r30, r10
     b84:	83 81       	ldd	r24, Z+3	; 0x03
     b86:	8f 93       	push	r24
     b88:	82 81       	ldd	r24, Z+2	; 0x02
     b8a:	8f 93       	push	r24
     b8c:	81 81       	ldd	r24, Z+1	; 0x01
     b8e:	8f 93       	push	r24
     b90:	80 81       	ld	r24, Z
     b92:	8f 93       	push	r24
     b94:	f6 01       	movw	r30, r12
     b96:	83 81       	ldd	r24, Z+3	; 0x03
     b98:	8f 93       	push	r24
     b9a:	82 81       	ldd	r24, Z+2	; 0x02
     b9c:	8f 93       	push	r24
     b9e:	81 81       	ldd	r24, Z+1	; 0x01
     ba0:	8f 93       	push	r24
     ba2:	80 81       	ld	r24, Z
     ba4:	8f 93       	push	r24
     ba6:	f7 01       	movw	r30, r14
     ba8:	83 81       	ldd	r24, Z+3	; 0x03
     baa:	8f 93       	push	r24
     bac:	82 81       	ldd	r24, Z+2	; 0x02
     bae:	8f 93       	push	r24
     bb0:	81 81       	ldd	r24, Z+1	; 0x01
     bb2:	8f 93       	push	r24
     bb4:	80 81       	ld	r24, Z
     bb6:	8f 93       	push	r24
     bb8:	f8 01       	movw	r30, r16
     bba:	83 81       	ldd	r24, Z+3	; 0x03
     bbc:	8f 93       	push	r24
     bbe:	82 81       	ldd	r24, Z+2	; 0x02
     bc0:	8f 93       	push	r24
     bc2:	81 81       	ldd	r24, Z+1	; 0x01
     bc4:	8f 93       	push	r24
     bc6:	80 81       	ld	r24, Z
     bc8:	8f 93       	push	r24
     bca:	8b 81       	ldd	r24, Y+3	; 0x03
     bcc:	8f 93       	push	r24
     bce:	8a 81       	ldd	r24, Y+2	; 0x02
     bd0:	8f 93       	push	r24
     bd2:	89 81       	ldd	r24, Y+1	; 0x01
     bd4:	8f 93       	push	r24
     bd6:	88 81       	ld	r24, Y
     bd8:	8f 93       	push	r24
     bda:	7f 92       	push	r7
     bdc:	6f 92       	push	r6
     bde:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>

			// target position
			sersendf_P(PSTR("Dst: %lq,%lq,%lq,%lq,%lu\n"), movebuffer[mb_tail].endpoint.X, movebuffer[mb_tail].endpoint.Y, movebuffer[mb_tail].endpoint.Z, movebuffer[mb_tail].endpoint.E, movebuffer[mb_tail].endpoint.F);
     be2:	e0 91 bc 04 	lds	r30, 0x04BC
     be6:	5e 9e       	mul	r5, r30
     be8:	f0 01       	movw	r30, r0
     bea:	11 24       	eor	r1, r1
     bec:	eb 55       	subi	r30, 0x5B	; 91
     bee:	fd 4f       	sbci	r31, 0xFD	; 253
     bf0:	df 01       	movw	r26, r30
     bf2:	50 96       	adiw	r26, 0x10	; 16
     bf4:	13 96       	adiw	r26, 0x03	; 3
     bf6:	8c 91       	ld	r24, X
     bf8:	13 97       	sbiw	r26, 0x03	; 3
     bfa:	8f 93       	push	r24
     bfc:	12 96       	adiw	r26, 0x02	; 2
     bfe:	8c 91       	ld	r24, X
     c00:	12 97       	sbiw	r26, 0x02	; 2
     c02:	8f 93       	push	r24
     c04:	11 96       	adiw	r26, 0x01	; 1
     c06:	8c 91       	ld	r24, X
     c08:	8f 93       	push	r24
     c0a:	80 89       	ldd	r24, Z+16	; 0x10
     c0c:	8f 93       	push	r24
     c0e:	df 01       	movw	r26, r30
     c10:	1c 96       	adiw	r26, 0x0c	; 12
     c12:	13 96       	adiw	r26, 0x03	; 3
     c14:	8c 91       	ld	r24, X
     c16:	13 97       	sbiw	r26, 0x03	; 3
     c18:	8f 93       	push	r24
     c1a:	12 96       	adiw	r26, 0x02	; 2
     c1c:	8c 91       	ld	r24, X
     c1e:	12 97       	sbiw	r26, 0x02	; 2
     c20:	8f 93       	push	r24
     c22:	11 96       	adiw	r26, 0x01	; 1
     c24:	8c 91       	ld	r24, X
     c26:	8f 93       	push	r24
     c28:	84 85       	ldd	r24, Z+12	; 0x0c
     c2a:	8f 93       	push	r24
     c2c:	df 01       	movw	r26, r30
     c2e:	18 96       	adiw	r26, 0x08	; 8
     c30:	13 96       	adiw	r26, 0x03	; 3
     c32:	8c 91       	ld	r24, X
     c34:	13 97       	sbiw	r26, 0x03	; 3
     c36:	8f 93       	push	r24
     c38:	12 96       	adiw	r26, 0x02	; 2
     c3a:	8c 91       	ld	r24, X
     c3c:	12 97       	sbiw	r26, 0x02	; 2
     c3e:	8f 93       	push	r24
     c40:	11 96       	adiw	r26, 0x01	; 1
     c42:	8c 91       	ld	r24, X
     c44:	8f 93       	push	r24
     c46:	80 85       	ldd	r24, Z+8	; 0x08
     c48:	8f 93       	push	r24
     c4a:	df 01       	movw	r26, r30
     c4c:	14 96       	adiw	r26, 0x04	; 4
     c4e:	13 96       	adiw	r26, 0x03	; 3
     c50:	8c 91       	ld	r24, X
     c52:	13 97       	sbiw	r26, 0x03	; 3
     c54:	8f 93       	push	r24
     c56:	12 96       	adiw	r26, 0x02	; 2
     c58:	8c 91       	ld	r24, X
     c5a:	12 97       	sbiw	r26, 0x02	; 2
     c5c:	8f 93       	push	r24
     c5e:	11 96       	adiw	r26, 0x01	; 1
     c60:	8c 91       	ld	r24, X
     c62:	8f 93       	push	r24
     c64:	84 81       	ldd	r24, Z+4	; 0x04
     c66:	8f 93       	push	r24
     c68:	83 81       	ldd	r24, Z+3	; 0x03
     c6a:	8f 93       	push	r24
     c6c:	82 81       	ldd	r24, Z+2	; 0x02
     c6e:	8f 93       	push	r24
     c70:	81 81       	ldd	r24, Z+1	; 0x01
     c72:	8f 93       	push	r24
     c74:	80 81       	ld	r24, Z
     c76:	8f 93       	push	r24
     c78:	9f 92       	push	r9
     c7a:	8f 92       	push	r8
     c7c:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>

			// Queue
			print_queue();
     c80:	8d b7       	in	r24, 0x3d	; 61
     c82:	9e b7       	in	r25, 0x3e	; 62
     c84:	8c 96       	adiw	r24, 0x2c	; 44
     c86:	0f b6       	in	r0, 0x3f	; 63
     c88:	f8 94       	cli
     c8a:	9e bf       	out	0x3e, r25	; 62
     c8c:	0f be       	out	0x3f, r0	; 63
     c8e:	8d bf       	out	0x3d, r24	; 61
     c90:	0e 94 4f 15 	call	0x2a9e	; 0x2a9e <print_queue>

			// newline
			serial_writechar('\n');
     c94:	8a e0       	ldi	r24, 0x0A	; 10
     c96:	0e 94 d0 24 	call	0x49a0	; 0x49a0 <serial_writechar>
        psu_timeout++;
      ATOMIC_END
		}
	}

	ifclock(clock_flag_1s) {
     c9a:	10 92 c5 04 	sts	0x04C5, r1
     c9e:	80 91 c5 04 	lds	r24, 0x04C5
     ca2:	81 11       	cpse	r24, r1
     ca4:	68 cf       	rjmp	.-304    	; 0xb76 <clock+0xb2>
	// reset watchdog
	wd_reset();

	temp_tick();

	ifclock(clock_flag_250ms) {
     ca6:	10 92 c6 04 	sts	0x04C6, r1
     caa:	80 91 c6 04 	lds	r24, 0x04C6
     cae:	81 11       	cpse	r24, r1
     cb0:	44 cf       	rjmp	.-376    	; 0xb3a <clock+0x76>
/*! do reoccuring stuff

	call it occasionally in busy loops
*/
void clock() {
	ifclock(clock_flag_10ms) {
     cb2:	10 92 c7 04 	sts	0x04C7, r1
     cb6:	80 91 c7 04 	lds	r24, 0x04C7
     cba:	81 11       	cpse	r24, r1
     cbc:	2d cf       	rjmp	.-422    	; 0xb18 <clock+0x54>
		clock_10ms();
	}
}
     cbe:	df 91       	pop	r29
     cc0:	cf 91       	pop	r28
     cc2:	1f 91       	pop	r17
     cc4:	0f 91       	pop	r16
     cc6:	ff 90       	pop	r15
     cc8:	ef 90       	pop	r14
     cca:	df 90       	pop	r13
     ccc:	cf 90       	pop	r12
     cce:	bf 90       	pop	r11
     cd0:	af 90       	pop	r10
     cd2:	9f 90       	pop	r9
     cd4:	8f 90       	pop	r8
     cd6:	7f 90       	pop	r7
     cd8:	6f 90       	pop	r6
     cda:	5f 90       	pop	r5
     cdc:	08 95       	ret

00000cde <crc_block>:
	\param len length of data
	\return uint16 crc16 of passed data

	uses avr-libc's optimised crc16 routine
*/
uint16_t	crc_block(void *data, uint16_t len) {
     cde:	fc 01       	movw	r30, r24
	uint16_t	crc = 0xfeed;
	for (; len; data++, len--) {
     ce0:	61 15       	cp	r22, r1
     ce2:	71 05       	cpc	r23, r1
     ce4:	01 f1       	breq	.+64     	; 0xd26 <crc_block+0x48>
	\param len length of data
	\return uint16 crc16 of passed data

	uses avr-libc's optimised crc16 routine
*/
uint16_t	crc_block(void *data, uint16_t len) {
     ce6:	68 0f       	add	r22, r24
     ce8:	79 1f       	adc	r23, r25
	uint16_t	crc = 0xfeed;
     cea:	2d ee       	ldi	r18, 0xED	; 237
     cec:	3e ef       	ldi	r19, 0xFE	; 254
_crc16_update(uint16_t __crc, uint8_t __data)
{
	uint8_t __tmp;
	uint16_t __ret;

	__asm__ __volatile__ (
     cee:	81 91       	ld	r24, Z+
     cf0:	28 27       	eor	r18, r24
     cf2:	82 2f       	mov	r24, r18
     cf4:	82 95       	swap	r24
     cf6:	82 27       	eor	r24, r18
     cf8:	08 2e       	mov	r0, r24
     cfa:	86 95       	lsr	r24
     cfc:	86 95       	lsr	r24
     cfe:	80 25       	eor	r24, r0
     d00:	08 2e       	mov	r0, r24
     d02:	86 95       	lsr	r24
     d04:	80 25       	eor	r24, r0
     d06:	87 70       	andi	r24, 0x07	; 7
     d08:	02 2e       	mov	r0, r18
     d0a:	23 2f       	mov	r18, r19
     d0c:	86 95       	lsr	r24
     d0e:	07 94       	ror	r0
     d10:	87 95       	ror	r24
     d12:	30 2d       	mov	r19, r0
     d14:	28 27       	eor	r18, r24
     d16:	06 94       	lsr	r0
     d18:	87 95       	ror	r24
     d1a:	30 25       	eor	r19, r0
     d1c:	28 27       	eor	r18, r24
	for (; len; data++, len--) {
     d1e:	e6 17       	cp	r30, r22
     d20:	f7 07       	cpc	r31, r23
     d22:	29 f7       	brne	.-54     	; 0xcee <crc_block+0x10>
     d24:	02 c0       	rjmp	.+4      	; 0xd2a <crc_block+0x4c>
	\return uint16 crc16 of passed data

	uses avr-libc's optimised crc16 routine
*/
uint16_t	crc_block(void *data, uint16_t len) {
	uint16_t	crc = 0xfeed;
     d26:	2d ee       	ldi	r18, 0xED	; 237
     d28:	3e ef       	ldi	r19, 0xFE	; 254
	for (; len; data++, len--) {
		crc = _crc16_update(crc, *((uint8_t *) data));
	}
	return crc;
}
     d2a:	82 2f       	mov	r24, r18
     d2c:	93 2f       	mov	r25, r19
     d2e:	08 95       	ret

00000d30 <dda_init>:

/*! Inititalise DDA movement structures
*/
void dda_init(void) {
	// set up default feedrate
	if (startpoint.F == 0)
     d30:	80 91 a0 02 	lds	r24, 0x02A0
     d34:	90 91 a1 02 	lds	r25, 0x02A1
     d38:	a0 91 a2 02 	lds	r26, 0x02A2
     d3c:	b0 91 a3 02 	lds	r27, 0x02A3
     d40:	89 2b       	or	r24, r25
     d42:	8a 2b       	or	r24, r26
     d44:	8b 2b       	or	r24, r27
     d46:	a1 f4       	brne	.+40     	; 0xd70 <dda_init+0x40>
		startpoint.F = next_target.target.F = SEARCH_FEEDRATE_Z;
     d48:	81 e0       	ldi	r24, 0x01	; 1
     d4a:	90 e0       	ldi	r25, 0x00	; 0
     d4c:	a0 e0       	ldi	r26, 0x00	; 0
     d4e:	b0 e0       	ldi	r27, 0x00	; 0
     d50:	80 93 9a 04 	sts	0x049A, r24
     d54:	90 93 9b 04 	sts	0x049B, r25
     d58:	a0 93 9c 04 	sts	0x049C, r26
     d5c:	b0 93 9d 04 	sts	0x049D, r27
     d60:	80 93 a0 02 	sts	0x02A0, r24
     d64:	90 93 a1 02 	sts	0x02A1, r25
     d68:	a0 93 a2 02 	sts	0x02A2, r26
     d6c:	b0 93 a3 02 	sts	0x02A3, r27

	#ifdef ACCELERATION_RAMPING
		move_state.n = 1;
     d70:	81 e0       	ldi	r24, 0x01	; 1
     d72:	90 e0       	ldi	r25, 0x00	; 0
     d74:	a0 e0       	ldi	r26, 0x00	; 0
     d76:	b0 e0       	ldi	r27, 0x00	; 0
     d78:	80 93 5c 02 	sts	0x025C, r24
     d7c:	90 93 5d 02 	sts	0x025D, r25
     d80:	a0 93 5e 02 	sts	0x025E, r26
     d84:	b0 93 5f 02 	sts	0x025F, r27
		move_state.c = ((uint32_t)((double)F_CPU / sqrt((double)(STEPS_PER_M_X * ACCELERATION / 1000.)))) << 8;
     d88:	80 e0       	ldi	r24, 0x00	; 0
     d8a:	96 e7       	ldi	r25, 0x76	; 118
     d8c:	ac ed       	ldi	r26, 0xDC	; 220
     d8e:	b0 e0       	ldi	r27, 0x00	; 0
     d90:	80 93 58 02 	sts	0x0258, r24
     d94:	90 93 59 02 	sts	0x0259, r25
     d98:	a0 93 5a 02 	sts	0x025A, r26
     d9c:	b0 93 5b 02 	sts	0x025B, r27
	
		// timer 1 is used for DCXYmotor
		#ifdef DCXYMOT
		// setup PWM timers: fast PWM
		// Warning 2012-01-11: these are not consistent across all AVRs
		TCCR1A = MASK(WGM11) | MASK(WGM10);
     da0:	e0 e8       	ldi	r30, 0x80	; 128
     da2:	f0 e0       	ldi	r31, 0x00	; 0
     da4:	93 e0       	ldi	r25, 0x03	; 3
     da6:	90 83       	st	Z, r25
		// PWM frequencies in TCCR0B, see page 108 of the ATmega644 reference.
		TCCR1B = MASK(CS10); // F_CPU / 256 (about 78(62.5) kHz on a 20(16) MHz chip)
     da8:	81 e0       	ldi	r24, 0x01	; 1
     daa:	80 93 81 00 	sts	0x0081, r24
		//TCCR0B = MASK(CS10) | MASK(CS12); // F_CPU / 256 / 1024  (about 76(61) Hz)
		TIMSK1 = 0;
     dae:	10 92 6f 00 	sts	0x006F, r1
		OCR1A = 0;
     db2:	10 92 89 00 	sts	0x0089, r1
     db6:	10 92 88 00 	sts	0x0088, r1
		OCR1B = 0;
     dba:	10 92 8b 00 	sts	0x008B, r1
     dbe:	10 92 8a 00 	sts	0x008A, r1
		OCR1C = 0;
     dc2:	10 92 8d 00 	sts	0x008D, r1
     dc6:	10 92 8c 00 	sts	0x008C, r1
		TCCR1A |= MASK(COM1A1);
     dca:	20 81       	ld	r18, Z
     dcc:	20 68       	ori	r18, 0x80	; 128
     dce:	20 83       	st	Z, r18
		//TCCR3A = MASK(WGM30);
		TCCR3A = MASK(WGM31) | MASK(WGM30);
     dd0:	e0 e9       	ldi	r30, 0x90	; 144
     dd2:	f0 e0       	ldi	r31, 0x00	; 0
     dd4:	90 83       	st	Z, r25
		//TCCR3B = MASK(WGM32) | MASK(CS30);
		TCCR3B = MASK(CS30);
     dd6:	80 93 91 00 	sts	0x0091, r24
		TIMSK3 = 0;
     dda:	10 92 71 00 	sts	0x0071, r1
		OCR3A = 0;
     dde:	10 92 99 00 	sts	0x0099, r1
     de2:	10 92 98 00 	sts	0x0098, r1
		OCR3B = 0;
     de6:	10 92 9b 00 	sts	0x009B, r1
     dea:	10 92 9a 00 	sts	0x009A, r1
		OCR3C = 0;
     dee:	10 92 9d 00 	sts	0x009D, r1
     df2:	10 92 9c 00 	sts	0x009C, r1
		TCCR3A |= MASK(COM3A1);
     df6:	80 81       	ld	r24, Z
     df8:	80 68       	ori	r24, 0x80	; 128
     dfa:	80 83       	st	Z, r24
		SET_OUTPUT(PE5);
     dfc:	6d 9a       	sbi	0x0d, 5	; 13
		SET_OUTPUT(PB5);
     dfe:	25 9a       	sbi	0x04, 5	; 4
		SET_OUTPUT(PB6);
     e00:	26 9a       	sbi	0x04, 6	; 4
		SET_OUTPUT(PB7);
     e02:	27 9a       	sbi	0x04, 7	; 4
		WRITE(PB6,1);
     e04:	2e 9a       	sbi	0x05, 6	; 5
		WRITE(PB7,1);
     e06:	2f 9a       	sbi	0x05, 7	; 5
     e08:	08 95       	ret

00000e0a <dda_new_startpoint>:

/*! Distribute a new startpoint to DDA's internal structures without any movement.

	This is needed for example after homing or a G92. The new location must be in startpoint already.
*/
void dda_new_startpoint(void) {
     e0a:	af 92       	push	r10
     e0c:	bf 92       	push	r11
     e0e:	cf 92       	push	r12
     e10:	df 92       	push	r13
     e12:	ef 92       	push	r14
     e14:	ff 92       	push	r15
     e16:	0f 93       	push	r16
     e18:	1f 93       	push	r17
// it might be worth pre-calculating muldivQR()'s qn and rn in dda_init()
// as soon as STEPS_PER_M_{XYZE} is no longer a compile-time variable.

static int32_t um_to_steps_x(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_x(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_X / 1000000UL,
     e1a:	60 91 90 02 	lds	r22, 0x0290
     e1e:	70 91 91 02 	lds	r23, 0x0291
     e22:	80 91 92 02 	lds	r24, 0x0292
     e26:	90 91 93 02 	lds	r25, 0x0293
     e2a:	0f 2e       	mov	r0, r31
     e2c:	f0 e4       	ldi	r31, 0x40	; 64
     e2e:	af 2e       	mov	r10, r31
     e30:	f2 e4       	ldi	r31, 0x42	; 66
     e32:	bf 2e       	mov	r11, r31
     e34:	ff e0       	ldi	r31, 0x0F	; 15
     e36:	cf 2e       	mov	r12, r31
     e38:	d1 2c       	mov	r13, r1
     e3a:	f0 2d       	mov	r31, r0
     e3c:	10 ef       	ldi	r17, 0xF0	; 240
     e3e:	e1 2e       	mov	r14, r17
     e40:	19 e3       	ldi	r17, 0x39	; 57
     e42:	f1 2e       	mov	r15, r17
     e44:	01 e0       	ldi	r16, 0x01	; 1
     e46:	10 e0       	ldi	r17, 0x00	; 0
     e48:	20 e0       	ldi	r18, 0x00	; 0
     e4a:	30 e0       	ldi	r19, 0x00	; 0
     e4c:	a9 01       	movw	r20, r18
     e4e:	0e 94 10 12 	call	0x2420	; 0x2420 <muldivQR>
	startpoint_steps.X = um_to_steps_x(startpoint.X);
     e52:	60 93 7b 02 	sts	0x027B, r22
     e56:	70 93 7c 02 	sts	0x027C, r23
     e5a:	80 93 7d 02 	sts	0x027D, r24
     e5e:	90 93 7e 02 	sts	0x027E, r25
                    STEPS_PER_M_X % 1000000UL, 1000000UL);
}

static int32_t um_to_steps_y(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_y(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_Y / 1000000UL,
     e62:	60 91 94 02 	lds	r22, 0x0294
     e66:	70 91 95 02 	lds	r23, 0x0295
     e6a:	80 91 96 02 	lds	r24, 0x0296
     e6e:	90 91 97 02 	lds	r25, 0x0297
     e72:	20 e0       	ldi	r18, 0x00	; 0
     e74:	30 e0       	ldi	r19, 0x00	; 0
     e76:	a9 01       	movw	r20, r18
     e78:	0e 94 10 12 	call	0x2420	; 0x2420 <muldivQR>
	startpoint_steps.Y = um_to_steps_y(startpoint.Y);
     e7c:	60 93 7f 02 	sts	0x027F, r22
     e80:	70 93 80 02 	sts	0x0280, r23
     e84:	80 93 81 02 	sts	0x0281, r24
     e88:	90 93 82 02 	sts	0x0282, r25
                    STEPS_PER_M_Y % 1000000UL, 1000000UL);
}

static int32_t um_to_steps_z(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_z(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_Z / 1000000UL,
     e8c:	60 91 98 02 	lds	r22, 0x0298
     e90:	70 91 99 02 	lds	r23, 0x0299
     e94:	80 91 9a 02 	lds	r24, 0x029A
     e98:	90 91 9b 02 	lds	r25, 0x029B
     e9c:	18 e1       	ldi	r17, 0x18	; 24
     e9e:	e1 2e       	mov	r14, r17
     ea0:	17 e1       	ldi	r17, 0x17	; 23
     ea2:	f1 2e       	mov	r15, r17
     ea4:	05 e0       	ldi	r16, 0x05	; 5
     ea6:	10 e0       	ldi	r17, 0x00	; 0
     ea8:	23 e0       	ldi	r18, 0x03	; 3
     eaa:	30 e0       	ldi	r19, 0x00	; 0
     eac:	40 e0       	ldi	r20, 0x00	; 0
     eae:	50 e0       	ldi	r21, 0x00	; 0
     eb0:	0e 94 10 12 	call	0x2420	; 0x2420 <muldivQR>
	startpoint_steps.Z = um_to_steps_z(startpoint.Z);
     eb4:	60 93 83 02 	sts	0x0283, r22
     eb8:	70 93 84 02 	sts	0x0284, r23
     ebc:	80 93 85 02 	sts	0x0285, r24
     ec0:	90 93 86 02 	sts	0x0286, r25
                    STEPS_PER_M_Z % 1000000UL, 1000000UL);
}

static int32_t um_to_steps_e(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_e(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_E / 1000000UL,
     ec4:	60 91 9c 02 	lds	r22, 0x029C
     ec8:	70 91 9d 02 	lds	r23, 0x029D
     ecc:	80 91 9e 02 	lds	r24, 0x029E
     ed0:	90 91 9f 02 	lds	r25, 0x029F
     ed4:	1c e1       	ldi	r17, 0x1C	; 28
     ed6:	e1 2e       	mov	r14, r17
     ed8:	1b e2       	ldi	r17, 0x2B	; 43
     eda:	f1 2e       	mov	r15, r17
     edc:	00 e0       	ldi	r16, 0x00	; 0
     ede:	10 e0       	ldi	r17, 0x00	; 0
     ee0:	20 e0       	ldi	r18, 0x00	; 0
     ee2:	30 e0       	ldi	r19, 0x00	; 0
     ee4:	a9 01       	movw	r20, r18
     ee6:	0e 94 10 12 	call	0x2420	; 0x2420 <muldivQR>
	startpoint_steps.E = um_to_steps_e(startpoint.E);
     eea:	60 93 87 02 	sts	0x0287, r22
     eee:	70 93 88 02 	sts	0x0288, r23
     ef2:	80 93 89 02 	sts	0x0289, r24
     ef6:	90 93 8a 02 	sts	0x028A, r25
}
     efa:	1f 91       	pop	r17
     efc:	0f 91       	pop	r16
     efe:	ff 90       	pop	r15
     f00:	ef 90       	pop	r14
     f02:	df 90       	pop	r13
     f04:	cf 90       	pop	r12
     f06:	bf 90       	pop	r11
     f08:	af 90       	pop	r10
     f0a:	08 95       	ret

00000f0c <dda_create>:

	It also pre-fills any data that the selected acceleration algorithm needs, and can be pre-computed for the whole move.

	This algorithm is probably the main limiting factor to print speed in terms of firmware limitations
*/
void dda_create(DDA *dda, TARGET *target, DDA *prev_dda) {
     f0c:	2f 92       	push	r2
     f0e:	3f 92       	push	r3
     f10:	4f 92       	push	r4
     f12:	5f 92       	push	r5
     f14:	6f 92       	push	r6
     f16:	7f 92       	push	r7
     f18:	8f 92       	push	r8
     f1a:	9f 92       	push	r9
     f1c:	af 92       	push	r10
     f1e:	bf 92       	push	r11
     f20:	cf 92       	push	r12
     f22:	df 92       	push	r13
     f24:	ef 92       	push	r14
     f26:	ff 92       	push	r15
     f28:	0f 93       	push	r16
     f2a:	1f 93       	push	r17
     f2c:	cf 93       	push	r28
     f2e:	df 93       	push	r29
     f30:	cd b7       	in	r28, 0x3d	; 61
     f32:	de b7       	in	r29, 0x3e	; 62
     f34:	6e 97       	sbiw	r28, 0x1e	; 30
     f36:	0f b6       	in	r0, 0x3f	; 63
     f38:	f8 94       	cli
     f3a:	de bf       	out	0x3e, r29	; 62
     f3c:	0f be       	out	0x3f, r0	; 63
     f3e:	cd bf       	out	0x3d, r28	; 61
     f40:	9e 8f       	std	Y+30, r25	; 0x1e
     f42:	8d 8f       	std	Y+29, r24	; 0x1d
     f44:	1b 01       	movw	r2, r22
  // Number the moves to identify them; allowed to overflow.
  static uint8_t idcnt = 0;
  #endif

	// initialise DDA to a known state
	dda->allflags = 0;
     f46:	dc 01       	movw	r26, r24
     f48:	55 96       	adiw	r26, 0x15	; 21
     f4a:	1c 92       	st	X, r1

	if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
     f4c:	80 91 cf 04 	lds	r24, 0x04CF
     f50:	81 ff       	sbrs	r24, 1
     f52:	04 c0       	rjmp	.+8      	; 0xf5c <dda_create+0x50>
		serial_writestr_P(PSTR("\n{DDA_CREATE: ["));
     f54:	80 ea       	ldi	r24, 0xA0	; 160
     f56:	93 e0       	ldi	r25, 0x03	; 3
     f58:	0e 94 0c 25 	call	0x4a18	; 0x4a18 <serial_writestr_P>

	// we end at the passed target
	memcpy(&(dda->endpoint), target, sizeof(TARGET));
     f5c:	85 e1       	ldi	r24, 0x15	; 21
     f5e:	f1 01       	movw	r30, r2
     f60:	ad 8d       	ldd	r26, Y+29	; 0x1d
     f62:	be 8d       	ldd	r27, Y+30	; 0x1e
     f64:	01 90       	ld	r0, Z+
     f66:	0d 92       	st	X+, r0
     f68:	8a 95       	dec	r24
     f6a:	e1 f7       	brne	.-8      	; 0xf64 <dda_create+0x58>
  #endif

// TODO TODO: We should really make up a loop for all axes.
//            Think of what happens when a sixth axis (multi colour extruder)
//            appears?
	x_delta_um = (uint32_t)labs(target->X - startpoint.X);
     f6c:	f1 01       	movw	r30, r2
     f6e:	40 80       	ld	r4, Z
     f70:	51 80       	ldd	r5, Z+1	; 0x01
     f72:	62 80       	ldd	r6, Z+2	; 0x02
     f74:	73 80       	ldd	r7, Z+3	; 0x03
     f76:	20 91 90 02 	lds	r18, 0x0290
     f7a:	30 91 91 02 	lds	r19, 0x0291
     f7e:	40 91 92 02 	lds	r20, 0x0292
     f82:	50 91 93 02 	lds	r21, 0x0293
     f86:	29 83       	std	Y+1, r18	; 0x01
     f88:	3a 83       	std	Y+2, r19	; 0x02
     f8a:	4b 83       	std	Y+3, r20	; 0x03
     f8c:	5c 83       	std	Y+4, r21	; 0x04
	y_delta_um = (uint32_t)labs(target->Y - startpoint.Y);
     f8e:	84 81       	ldd	r24, Z+4	; 0x04
     f90:	95 81       	ldd	r25, Z+5	; 0x05
     f92:	a6 81       	ldd	r26, Z+6	; 0x06
     f94:	b7 81       	ldd	r27, Z+7	; 0x07
     f96:	8d 83       	std	Y+5, r24	; 0x05
     f98:	9e 83       	std	Y+6, r25	; 0x06
     f9a:	af 83       	std	Y+7, r26	; 0x07
     f9c:	b8 87       	std	Y+8, r27	; 0x08
     f9e:	20 91 94 02 	lds	r18, 0x0294
     fa2:	30 91 95 02 	lds	r19, 0x0295
     fa6:	40 91 96 02 	lds	r20, 0x0296
     faa:	50 91 97 02 	lds	r21, 0x0297
     fae:	29 87       	std	Y+9, r18	; 0x09
     fb0:	3a 87       	std	Y+10, r19	; 0x0a
     fb2:	4b 87       	std	Y+11, r20	; 0x0b
     fb4:	5c 87       	std	Y+12, r21	; 0x0c
	z_delta_um = (uint32_t)labs(target->Z - startpoint.Z);
     fb6:	80 85       	ldd	r24, Z+8	; 0x08
     fb8:	91 85       	ldd	r25, Z+9	; 0x09
     fba:	a2 85       	ldd	r26, Z+10	; 0x0a
     fbc:	b3 85       	ldd	r27, Z+11	; 0x0b
     fbe:	8d 8b       	std	Y+21, r24	; 0x15
     fc0:	9e 8b       	std	Y+22, r25	; 0x16
     fc2:	af 8b       	std	Y+23, r26	; 0x17
     fc4:	b8 8f       	std	Y+24, r27	; 0x18
     fc6:	20 91 98 02 	lds	r18, 0x0298
     fca:	30 91 99 02 	lds	r19, 0x0299
     fce:	40 91 9a 02 	lds	r20, 0x029A
     fd2:	50 91 9b 02 	lds	r21, 0x029B
     fd6:	29 8f       	std	Y+25, r18	; 0x19
     fd8:	3a 8f       	std	Y+26, r19	; 0x1a
     fda:	4b 8f       	std	Y+27, r20	; 0x1b
     fdc:	5c 8f       	std	Y+28, r21	; 0x1c
// it might be worth pre-calculating muldivQR()'s qn and rn in dda_init()
// as soon as STEPS_PER_M_{XYZE} is no longer a compile-time variable.

static int32_t um_to_steps_x(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_x(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_X / 1000000UL,
     fde:	0f 2e       	mov	r0, r31
     fe0:	f0 e4       	ldi	r31, 0x40	; 64
     fe2:	af 2e       	mov	r10, r31
     fe4:	f2 e4       	ldi	r31, 0x42	; 66
     fe6:	bf 2e       	mov	r11, r31
     fe8:	ff e0       	ldi	r31, 0x0F	; 15
     fea:	cf 2e       	mov	r12, r31
     fec:	d1 2c       	mov	r13, r1
     fee:	f0 2d       	mov	r31, r0
     ff0:	10 ef       	ldi	r17, 0xF0	; 240
     ff2:	e1 2e       	mov	r14, r17
     ff4:	19 e3       	ldi	r17, 0x39	; 57
     ff6:	f1 2e       	mov	r15, r17
     ff8:	01 e0       	ldi	r16, 0x01	; 1
     ffa:	10 e0       	ldi	r17, 0x00	; 0
     ffc:	20 e0       	ldi	r18, 0x00	; 0
     ffe:	30 e0       	ldi	r19, 0x00	; 0
    1000:	a9 01       	movw	r20, r18
    1002:	c3 01       	movw	r24, r6
    1004:	b2 01       	movw	r22, r4
    1006:	0e 94 10 12 	call	0x2420	; 0x2420 <muldivQR>

	steps = um_to_steps_x(target->X);
	dda->x_delta = labs(steps - startpoint_steps.X);
    100a:	c0 90 7b 02 	lds	r12, 0x027B
    100e:	d0 90 7c 02 	lds	r13, 0x027C
    1012:	e0 90 7d 02 	lds	r14, 0x027D
    1016:	f0 90 7e 02 	lds	r15, 0x027E
    101a:	9b 01       	movw	r18, r22
    101c:	ac 01       	movw	r20, r24
    101e:	2c 19       	sub	r18, r12
    1020:	3d 09       	sbc	r19, r13
    1022:	4e 09       	sbc	r20, r14
    1024:	5f 09       	sbc	r21, r15
    1026:	69 01       	movw	r12, r18
    1028:	7a 01       	movw	r14, r20
    102a:	42 f4       	brpl	.+16     	; 0x103c <dda_create+0x130>
    102c:	f0 94       	com	r15
    102e:	e0 94       	com	r14
    1030:	d0 94       	com	r13
    1032:	c0 94       	com	r12
    1034:	c1 1c       	adc	r12, r1
    1036:	d1 1c       	adc	r13, r1
    1038:	e1 1c       	adc	r14, r1
    103a:	f1 1c       	adc	r15, r1
    103c:	ad 8d       	ldd	r26, Y+29	; 0x1d
    103e:	be 8d       	ldd	r27, Y+30	; 0x1e
    1040:	56 96       	adiw	r26, 0x16	; 22
    1042:	cd 92       	st	X+, r12
    1044:	dd 92       	st	X+, r13
    1046:	ed 92       	st	X+, r14
    1048:	fc 92       	st	X, r15
    104a:	59 97       	sbiw	r26, 0x19	; 25
	startpoint_steps.X = steps;
    104c:	60 93 7b 02 	sts	0x027B, r22
    1050:	70 93 7c 02 	sts	0x027C, r23
    1054:	80 93 7d 02 	sts	0x027D, r24
    1058:	90 93 7e 02 	sts	0x027E, r25
                    STEPS_PER_M_X % 1000000UL, 1000000UL);
}

static int32_t um_to_steps_y(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_y(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_Y / 1000000UL,
    105c:	f1 01       	movw	r30, r2
    105e:	64 81       	ldd	r22, Z+4	; 0x04
    1060:	75 81       	ldd	r23, Z+5	; 0x05
    1062:	86 81       	ldd	r24, Z+6	; 0x06
    1064:	97 81       	ldd	r25, Z+7	; 0x07
    1066:	0f 2e       	mov	r0, r31
    1068:	f0 e4       	ldi	r31, 0x40	; 64
    106a:	af 2e       	mov	r10, r31
    106c:	f2 e4       	ldi	r31, 0x42	; 66
    106e:	bf 2e       	mov	r11, r31
    1070:	ff e0       	ldi	r31, 0x0F	; 15
    1072:	cf 2e       	mov	r12, r31
    1074:	d1 2c       	mov	r13, r1
    1076:	f0 2d       	mov	r31, r0
    1078:	10 ef       	ldi	r17, 0xF0	; 240
    107a:	e1 2e       	mov	r14, r17
    107c:	19 e3       	ldi	r17, 0x39	; 57
    107e:	f1 2e       	mov	r15, r17
    1080:	01 e0       	ldi	r16, 0x01	; 1
    1082:	10 e0       	ldi	r17, 0x00	; 0
    1084:	20 e0       	ldi	r18, 0x00	; 0
    1086:	30 e0       	ldi	r19, 0x00	; 0
    1088:	a9 01       	movw	r20, r18
    108a:	0e 94 10 12 	call	0x2420	; 0x2420 <muldivQR>
	steps = um_to_steps_y(target->Y);
	dda->y_delta = labs(steps - startpoint_steps.Y);
    108e:	c0 90 7f 02 	lds	r12, 0x027F
    1092:	d0 90 80 02 	lds	r13, 0x0280
    1096:	e0 90 81 02 	lds	r14, 0x0281
    109a:	f0 90 82 02 	lds	r15, 0x0282
    109e:	9b 01       	movw	r18, r22
    10a0:	ac 01       	movw	r20, r24
    10a2:	2c 19       	sub	r18, r12
    10a4:	3d 09       	sbc	r19, r13
    10a6:	4e 09       	sbc	r20, r14
    10a8:	5f 09       	sbc	r21, r15
    10aa:	69 01       	movw	r12, r18
    10ac:	7a 01       	movw	r14, r20
    10ae:	42 f4       	brpl	.+16     	; 0x10c0 <dda_create+0x1b4>
    10b0:	f0 94       	com	r15
    10b2:	e0 94       	com	r14
    10b4:	d0 94       	com	r13
    10b6:	c0 94       	com	r12
    10b8:	c1 1c       	adc	r12, r1
    10ba:	d1 1c       	adc	r13, r1
    10bc:	e1 1c       	adc	r14, r1
    10be:	f1 1c       	adc	r15, r1
    10c0:	ad 8d       	ldd	r26, Y+29	; 0x1d
    10c2:	be 8d       	ldd	r27, Y+30	; 0x1e
    10c4:	5a 96       	adiw	r26, 0x1a	; 26
    10c6:	cd 92       	st	X+, r12
    10c8:	dd 92       	st	X+, r13
    10ca:	ed 92       	st	X+, r14
    10cc:	fc 92       	st	X, r15
    10ce:	5d 97       	sbiw	r26, 0x1d	; 29
	startpoint_steps.Y = steps;
    10d0:	60 93 7f 02 	sts	0x027F, r22
    10d4:	70 93 80 02 	sts	0x0280, r23
    10d8:	80 93 81 02 	sts	0x0281, r24
    10dc:	90 93 82 02 	sts	0x0282, r25
                    STEPS_PER_M_Y % 1000000UL, 1000000UL);
}

static int32_t um_to_steps_z(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_z(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_Z / 1000000UL,
    10e0:	f1 01       	movw	r30, r2
    10e2:	60 85       	ldd	r22, Z+8	; 0x08
    10e4:	71 85       	ldd	r23, Z+9	; 0x09
    10e6:	82 85       	ldd	r24, Z+10	; 0x0a
    10e8:	93 85       	ldd	r25, Z+11	; 0x0b
    10ea:	0f 2e       	mov	r0, r31
    10ec:	f0 e4       	ldi	r31, 0x40	; 64
    10ee:	af 2e       	mov	r10, r31
    10f0:	f2 e4       	ldi	r31, 0x42	; 66
    10f2:	bf 2e       	mov	r11, r31
    10f4:	ff e0       	ldi	r31, 0x0F	; 15
    10f6:	cf 2e       	mov	r12, r31
    10f8:	d1 2c       	mov	r13, r1
    10fa:	f0 2d       	mov	r31, r0
    10fc:	18 e1       	ldi	r17, 0x18	; 24
    10fe:	e1 2e       	mov	r14, r17
    1100:	17 e1       	ldi	r17, 0x17	; 23
    1102:	f1 2e       	mov	r15, r17
    1104:	05 e0       	ldi	r16, 0x05	; 5
    1106:	10 e0       	ldi	r17, 0x00	; 0
    1108:	23 e0       	ldi	r18, 0x03	; 3
    110a:	30 e0       	ldi	r19, 0x00	; 0
    110c:	40 e0       	ldi	r20, 0x00	; 0
    110e:	50 e0       	ldi	r21, 0x00	; 0
    1110:	0e 94 10 12 	call	0x2420	; 0x2420 <muldivQR>
	steps = um_to_steps_z(target->Z);
	dda->z_delta = labs(steps - startpoint_steps.Z);
    1114:	c0 90 83 02 	lds	r12, 0x0283
    1118:	d0 90 84 02 	lds	r13, 0x0284
    111c:	e0 90 85 02 	lds	r14, 0x0285
    1120:	f0 90 86 02 	lds	r15, 0x0286
    1124:	9b 01       	movw	r18, r22
    1126:	ac 01       	movw	r20, r24
    1128:	2c 19       	sub	r18, r12
    112a:	3d 09       	sbc	r19, r13
    112c:	4e 09       	sbc	r20, r14
    112e:	5f 09       	sbc	r21, r15
    1130:	69 01       	movw	r12, r18
    1132:	7a 01       	movw	r14, r20
    1134:	42 f4       	brpl	.+16     	; 0x1146 <dda_create+0x23a>
    1136:	f0 94       	com	r15
    1138:	e0 94       	com	r14
    113a:	d0 94       	com	r13
    113c:	c0 94       	com	r12
    113e:	c1 1c       	adc	r12, r1
    1140:	d1 1c       	adc	r13, r1
    1142:	e1 1c       	adc	r14, r1
    1144:	f1 1c       	adc	r15, r1
    1146:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1148:	be 8d       	ldd	r27, Y+30	; 0x1e
    114a:	5e 96       	adiw	r26, 0x1e	; 30
    114c:	cd 92       	st	X+, r12
    114e:	dd 92       	st	X+, r13
    1150:	ed 92       	st	X+, r14
    1152:	fc 92       	st	X, r15
    1154:	91 97       	sbiw	r26, 0x21	; 33
	startpoint_steps.Z = steps;
    1156:	60 93 83 02 	sts	0x0283, r22
    115a:	70 93 84 02 	sts	0x0284, r23
    115e:	80 93 85 02 	sts	0x0285, r24
    1162:	90 93 86 02 	sts	0x0286, r25

	dda->x_direction = (target->X >= startpoint.X)?1:0;
    1166:	21 e0       	ldi	r18, 0x01	; 1
    1168:	f1 01       	movw	r30, r2
    116a:	40 81       	ld	r20, Z
    116c:	51 81       	ldd	r21, Z+1	; 0x01
    116e:	62 81       	ldd	r22, Z+2	; 0x02
    1170:	73 81       	ldd	r23, Z+3	; 0x03
    1172:	80 91 90 02 	lds	r24, 0x0290
    1176:	90 91 91 02 	lds	r25, 0x0291
    117a:	a0 91 92 02 	lds	r26, 0x0292
    117e:	b0 91 93 02 	lds	r27, 0x0293
    1182:	48 17       	cp	r20, r24
    1184:	59 07       	cpc	r21, r25
    1186:	6a 07       	cpc	r22, r26
    1188:	7b 07       	cpc	r23, r27
    118a:	0c f4       	brge	.+2      	; 0x118e <dda_create+0x282>
    118c:	20 e0       	ldi	r18, 0x00	; 0
    118e:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1190:	be 8d       	ldd	r27, Y+30	; 0x1e
    1192:	55 96       	adiw	r26, 0x15	; 21
    1194:	8c 91       	ld	r24, X
    1196:	55 97       	sbiw	r26, 0x15	; 21
    1198:	20 fb       	bst	r18, 0
    119a:	83 f9       	bld	r24, 3
    119c:	55 96       	adiw	r26, 0x15	; 21
    119e:	8c 93       	st	X, r24
	dda->y_direction = (target->Y >= startpoint.Y)?1:0;
    11a0:	21 e0       	ldi	r18, 0x01	; 1
    11a2:	f1 01       	movw	r30, r2
    11a4:	44 81       	ldd	r20, Z+4	; 0x04
    11a6:	55 81       	ldd	r21, Z+5	; 0x05
    11a8:	66 81       	ldd	r22, Z+6	; 0x06
    11aa:	77 81       	ldd	r23, Z+7	; 0x07
    11ac:	80 91 94 02 	lds	r24, 0x0294
    11b0:	90 91 95 02 	lds	r25, 0x0295
    11b4:	a0 91 96 02 	lds	r26, 0x0296
    11b8:	b0 91 97 02 	lds	r27, 0x0297
    11bc:	48 17       	cp	r20, r24
    11be:	59 07       	cpc	r21, r25
    11c0:	6a 07       	cpc	r22, r26
    11c2:	7b 07       	cpc	r23, r27
    11c4:	0c f4       	brge	.+2      	; 0x11c8 <dda_create+0x2bc>
    11c6:	20 e0       	ldi	r18, 0x00	; 0
    11c8:	ad 8d       	ldd	r26, Y+29	; 0x1d
    11ca:	be 8d       	ldd	r27, Y+30	; 0x1e
    11cc:	55 96       	adiw	r26, 0x15	; 21
    11ce:	8c 91       	ld	r24, X
    11d0:	55 97       	sbiw	r26, 0x15	; 21
    11d2:	20 fb       	bst	r18, 0
    11d4:	84 f9       	bld	r24, 4
    11d6:	55 96       	adiw	r26, 0x15	; 21
    11d8:	8c 93       	st	X, r24
	dda->z_direction = (target->Z >= startpoint.Z)?1:0;
    11da:	21 e0       	ldi	r18, 0x01	; 1
    11dc:	f1 01       	movw	r30, r2
    11de:	40 85       	ldd	r20, Z+8	; 0x08
    11e0:	51 85       	ldd	r21, Z+9	; 0x09
    11e2:	62 85       	ldd	r22, Z+10	; 0x0a
    11e4:	73 85       	ldd	r23, Z+11	; 0x0b
    11e6:	80 91 98 02 	lds	r24, 0x0298
    11ea:	90 91 99 02 	lds	r25, 0x0299
    11ee:	a0 91 9a 02 	lds	r26, 0x029A
    11f2:	b0 91 9b 02 	lds	r27, 0x029B
    11f6:	48 17       	cp	r20, r24
    11f8:	59 07       	cpc	r21, r25
    11fa:	6a 07       	cpc	r22, r26
    11fc:	7b 07       	cpc	r23, r27
    11fe:	0c f4       	brge	.+2      	; 0x1202 <dda_create+0x2f6>
    1200:	20 e0       	ldi	r18, 0x00	; 0
    1202:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1204:	be 8d       	ldd	r27, Y+30	; 0x1e
    1206:	55 96       	adiw	r26, 0x15	; 21
    1208:	8c 91       	ld	r24, X
    120a:	55 97       	sbiw	r26, 0x15	; 21
    120c:	20 fb       	bst	r18, 0
    120e:	85 f9       	bld	r24, 5
    1210:	55 96       	adiw	r26, 0x15	; 21
    1212:	8c 93       	st	X, r24

	if (target->e_relative) {
    1214:	f1 01       	movw	r30, r2
    1216:	84 89       	ldd	r24, Z+20	; 0x14
    1218:	80 ff       	sbrs	r24, 0
    121a:	5a c0       	rjmp	.+180    	; 0x12d0 <dda_create+0x3c4>
		e_delta_um = labs(target->E);
    121c:	f4 85       	ldd	r31, Z+12	; 0x0c
    121e:	d1 01       	movw	r26, r2
    1220:	1d 96       	adiw	r26, 0x0d	; 13
    1222:	ec 91       	ld	r30, X
    1224:	1d 97       	sbiw	r26, 0x0d	; 13
    1226:	1e 96       	adiw	r26, 0x0e	; 14
    1228:	8c 91       	ld	r24, X
    122a:	1e 97       	sbiw	r26, 0x0e	; 14
    122c:	1f 96       	adiw	r26, 0x0f	; 15
    122e:	9c 91       	ld	r25, X
    1230:	4f 2f       	mov	r20, r31
    1232:	5e 2f       	mov	r21, r30
    1234:	68 2f       	mov	r22, r24
    1236:	79 2f       	mov	r23, r25
    1238:	77 23       	and	r23, r23
    123a:	3c f4       	brge	.+14     	; 0x124a <dda_create+0x33e>
    123c:	70 95       	com	r23
    123e:	60 95       	com	r22
    1240:	50 95       	com	r21
    1242:	41 95       	neg	r20
    1244:	5f 4f       	sbci	r21, 0xFF	; 255
    1246:	6f 4f       	sbci	r22, 0xFF	; 255
    1248:	7f 4f       	sbci	r23, 0xFF	; 255
    124a:	4d 87       	std	Y+13, r20	; 0x0d
    124c:	5e 87       	std	Y+14, r21	; 0x0e
    124e:	6f 87       	std	Y+15, r22	; 0x0f
    1250:	78 8b       	std	Y+16, r23	; 0x10
                    STEPS_PER_M_Z % 1000000UL, 1000000UL);
}

static int32_t um_to_steps_e(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_e(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_E / 1000000UL,
    1252:	0f 2e       	mov	r0, r31
    1254:	f0 e4       	ldi	r31, 0x40	; 64
    1256:	af 2e       	mov	r10, r31
    1258:	f2 e4       	ldi	r31, 0x42	; 66
    125a:	bf 2e       	mov	r11, r31
    125c:	ff e0       	ldi	r31, 0x0F	; 15
    125e:	cf 2e       	mov	r12, r31
    1260:	d1 2c       	mov	r13, r1
    1262:	f0 2d       	mov	r31, r0
    1264:	1c e1       	ldi	r17, 0x1C	; 28
    1266:	e1 2e       	mov	r14, r17
    1268:	1b e2       	ldi	r17, 0x2B	; 43
    126a:	f1 2e       	mov	r15, r17
    126c:	00 e0       	ldi	r16, 0x00	; 0
    126e:	10 e0       	ldi	r17, 0x00	; 0
    1270:	20 e0       	ldi	r18, 0x00	; 0
    1272:	30 e0       	ldi	r19, 0x00	; 0
    1274:	a9 01       	movw	r20, r18
    1276:	6f 2f       	mov	r22, r31
    1278:	7e 2f       	mov	r23, r30
    127a:	0e 94 10 12 	call	0x2420	; 0x2420 <muldivQR>
		dda->e_delta = labs(um_to_steps_e(target->E));
    127e:	46 2f       	mov	r20, r22
    1280:	57 2f       	mov	r21, r23
    1282:	68 2f       	mov	r22, r24
    1284:	79 2f       	mov	r23, r25
    1286:	77 23       	and	r23, r23
    1288:	3c f4       	brge	.+14     	; 0x1298 <dda_create+0x38c>
    128a:	70 95       	com	r23
    128c:	60 95       	com	r22
    128e:	50 95       	com	r21
    1290:	41 95       	neg	r20
    1292:	5f 4f       	sbci	r21, 0xFF	; 255
    1294:	6f 4f       	sbci	r22, 0xFF	; 255
    1296:	7f 4f       	sbci	r23, 0xFF	; 255
    1298:	ed 8d       	ldd	r30, Y+29	; 0x1d
    129a:	fe 8d       	ldd	r31, Y+30	; 0x1e
    129c:	42 a3       	std	Z+34, r20	; 0x22
    129e:	53 a3       	std	Z+35, r21	; 0x23
    12a0:	64 a3       	std	Z+36, r22	; 0x24
    12a2:	75 a3       	std	Z+37, r23	; 0x25
		dda->e_direction = (target->E >= 0)?1:0;
    12a4:	f1 01       	movw	r30, r2
    12a6:	84 85       	ldd	r24, Z+12	; 0x0c
    12a8:	95 85       	ldd	r25, Z+13	; 0x0d
    12aa:	a6 85       	ldd	r26, Z+14	; 0x0e
    12ac:	b7 85       	ldd	r27, Z+15	; 0x0f
    12ae:	80 95       	com	r24
    12b0:	90 95       	com	r25
    12b2:	a0 95       	com	r26
    12b4:	b0 95       	com	r27
    12b6:	88 27       	eor	r24, r24
    12b8:	b7 fd       	sbrc	r27, 7
    12ba:	83 95       	inc	r24
    12bc:	99 27       	eor	r25, r25
    12be:	aa 27       	eor	r26, r26
    12c0:	bb 27       	eor	r27, r27
    12c2:	ed 8d       	ldd	r30, Y+29	; 0x1d
    12c4:	fe 8d       	ldd	r31, Y+30	; 0x1e
    12c6:	25 89       	ldd	r18, Z+21	; 0x15
    12c8:	80 fb       	bst	r24, 0
    12ca:	26 f9       	bld	r18, 6
    12cc:	25 8b       	std	Z+21, r18	; 0x15
    12ce:	7b c0       	rjmp	.+246    	; 0x13c6 <dda_create+0x4ba>
	}
	else {
		e_delta_um = (uint32_t)labs(target->E - startpoint.E);
    12d0:	64 85       	ldd	r22, Z+12	; 0x0c
    12d2:	75 85       	ldd	r23, Z+13	; 0x0d
    12d4:	86 85       	ldd	r24, Z+14	; 0x0e
    12d6:	97 85       	ldd	r25, Z+15	; 0x0f
    12d8:	c0 90 9c 02 	lds	r12, 0x029C
    12dc:	d0 90 9d 02 	lds	r13, 0x029D
    12e0:	e0 90 9e 02 	lds	r14, 0x029E
    12e4:	f0 90 9f 02 	lds	r15, 0x029F
    12e8:	9b 01       	movw	r18, r22
    12ea:	ac 01       	movw	r20, r24
    12ec:	2c 19       	sub	r18, r12
    12ee:	3d 09       	sbc	r19, r13
    12f0:	4e 09       	sbc	r20, r14
    12f2:	5f 09       	sbc	r21, r15
    12f4:	69 01       	movw	r12, r18
    12f6:	7a 01       	movw	r14, r20
    12f8:	42 f4       	brpl	.+16     	; 0x130a <dda_create+0x3fe>
    12fa:	f0 94       	com	r15
    12fc:	e0 94       	com	r14
    12fe:	d0 94       	com	r13
    1300:	c0 94       	com	r12
    1302:	c1 1c       	adc	r12, r1
    1304:	d1 1c       	adc	r13, r1
    1306:	e1 1c       	adc	r14, r1
    1308:	f1 1c       	adc	r15, r1
    130a:	cd 86       	std	Y+13, r12	; 0x0d
    130c:	de 86       	std	Y+14, r13	; 0x0e
    130e:	ef 86       	std	Y+15, r14	; 0x0f
    1310:	f8 8a       	std	Y+16, r15	; 0x10
    1312:	0f 2e       	mov	r0, r31
    1314:	f0 e4       	ldi	r31, 0x40	; 64
    1316:	af 2e       	mov	r10, r31
    1318:	f2 e4       	ldi	r31, 0x42	; 66
    131a:	bf 2e       	mov	r11, r31
    131c:	ff e0       	ldi	r31, 0x0F	; 15
    131e:	cf 2e       	mov	r12, r31
    1320:	d1 2c       	mov	r13, r1
    1322:	f0 2d       	mov	r31, r0
    1324:	1c e1       	ldi	r17, 0x1C	; 28
    1326:	e1 2e       	mov	r14, r17
    1328:	1b e2       	ldi	r17, 0x2B	; 43
    132a:	f1 2e       	mov	r15, r17
    132c:	00 e0       	ldi	r16, 0x00	; 0
    132e:	10 e0       	ldi	r17, 0x00	; 0
    1330:	20 e0       	ldi	r18, 0x00	; 0
    1332:	30 e0       	ldi	r19, 0x00	; 0
    1334:	a9 01       	movw	r20, r18
    1336:	0e 94 10 12 	call	0x2420	; 0x2420 <muldivQR>
		steps = um_to_steps_e(target->E);
		dda->e_delta = labs(steps - startpoint_steps.E);
    133a:	c0 90 87 02 	lds	r12, 0x0287
    133e:	d0 90 88 02 	lds	r13, 0x0288
    1342:	e0 90 89 02 	lds	r14, 0x0289
    1346:	f0 90 8a 02 	lds	r15, 0x028A
    134a:	9b 01       	movw	r18, r22
    134c:	ac 01       	movw	r20, r24
    134e:	2c 19       	sub	r18, r12
    1350:	3d 09       	sbc	r19, r13
    1352:	4e 09       	sbc	r20, r14
    1354:	5f 09       	sbc	r21, r15
    1356:	69 01       	movw	r12, r18
    1358:	7a 01       	movw	r14, r20
    135a:	42 f4       	brpl	.+16     	; 0x136c <dda_create+0x460>
    135c:	f0 94       	com	r15
    135e:	e0 94       	com	r14
    1360:	d0 94       	com	r13
    1362:	c0 94       	com	r12
    1364:	c1 1c       	adc	r12, r1
    1366:	d1 1c       	adc	r13, r1
    1368:	e1 1c       	adc	r14, r1
    136a:	f1 1c       	adc	r15, r1
    136c:	ad 8d       	ldd	r26, Y+29	; 0x1d
    136e:	be 8d       	ldd	r27, Y+30	; 0x1e
    1370:	92 96       	adiw	r26, 0x22	; 34
    1372:	cd 92       	st	X+, r12
    1374:	dd 92       	st	X+, r13
    1376:	ed 92       	st	X+, r14
    1378:	fc 92       	st	X, r15
    137a:	95 97       	sbiw	r26, 0x25	; 37
		startpoint_steps.E = steps;
    137c:	60 93 87 02 	sts	0x0287, r22
    1380:	70 93 88 02 	sts	0x0288, r23
    1384:	80 93 89 02 	sts	0x0289, r24
    1388:	90 93 8a 02 	sts	0x028A, r25
		dda->e_direction = (target->E >= startpoint.E)?1:0;
    138c:	21 e0       	ldi	r18, 0x01	; 1
    138e:	f1 01       	movw	r30, r2
    1390:	44 85       	ldd	r20, Z+12	; 0x0c
    1392:	55 85       	ldd	r21, Z+13	; 0x0d
    1394:	66 85       	ldd	r22, Z+14	; 0x0e
    1396:	77 85       	ldd	r23, Z+15	; 0x0f
    1398:	80 91 9c 02 	lds	r24, 0x029C
    139c:	90 91 9d 02 	lds	r25, 0x029D
    13a0:	a0 91 9e 02 	lds	r26, 0x029E
    13a4:	b0 91 9f 02 	lds	r27, 0x029F
    13a8:	48 17       	cp	r20, r24
    13aa:	59 07       	cpc	r21, r25
    13ac:	6a 07       	cpc	r22, r26
    13ae:	7b 07       	cpc	r23, r27
    13b0:	0c f4       	brge	.+2      	; 0x13b4 <dda_create+0x4a8>
    13b2:	20 e0       	ldi	r18, 0x00	; 0
    13b4:	ad 8d       	ldd	r26, Y+29	; 0x1d
    13b6:	be 8d       	ldd	r27, Y+30	; 0x1e
    13b8:	55 96       	adiw	r26, 0x15	; 21
    13ba:	8c 91       	ld	r24, X
    13bc:	55 97       	sbiw	r26, 0x15	; 21
    13be:	20 fb       	bst	r18, 0
    13c0:	86 f9       	bld	r24, 6
    13c2:	55 96       	adiw	r26, 0x15	; 21
    13c4:	8c 93       	st	X, r24
  dda->delta.Y = target->Y - startpoint.Y;
  dda->delta.Z = target->Z - startpoint.Z;
  dda->delta.E = target->e_relative ? target->E : target->E - startpoint.E;
  #endif

	if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
    13c6:	80 91 cf 04 	lds	r24, 0x04CF
    13ca:	81 ff       	sbrs	r24, 1
    13cc:	5c c0       	rjmp	.+184    	; 0x1486 <dda_create+0x57a>
		sersendf_P(PSTR("%ld,%ld,%ld,%ld] ["), target->X - startpoint.X, target->Y - startpoint.Y, target->Z - startpoint.Z, target->E - startpoint.E);
    13ce:	f1 01       	movw	r30, r2
    13d0:	84 85       	ldd	r24, Z+12	; 0x0c
    13d2:	95 85       	ldd	r25, Z+13	; 0x0d
    13d4:	a6 85       	ldd	r26, Z+14	; 0x0e
    13d6:	b7 85       	ldd	r27, Z+15	; 0x0f
    13d8:	40 91 9c 02 	lds	r20, 0x029C
    13dc:	50 91 9d 02 	lds	r21, 0x029D
    13e0:	60 91 9e 02 	lds	r22, 0x029E
    13e4:	70 91 9f 02 	lds	r23, 0x029F
    13e8:	84 1b       	sub	r24, r20
    13ea:	95 0b       	sbc	r25, r21
    13ec:	a6 0b       	sbc	r26, r22
    13ee:	b7 0b       	sbc	r27, r23
    13f0:	bf 93       	push	r27
    13f2:	af 93       	push	r26
    13f4:	9f 93       	push	r25
    13f6:	8f 93       	push	r24
    13f8:	80 85       	ldd	r24, Z+8	; 0x08
    13fa:	91 85       	ldd	r25, Z+9	; 0x09
    13fc:	a2 85       	ldd	r26, Z+10	; 0x0a
    13fe:	b3 85       	ldd	r27, Z+11	; 0x0b
    1400:	40 91 98 02 	lds	r20, 0x0298
    1404:	50 91 99 02 	lds	r21, 0x0299
    1408:	60 91 9a 02 	lds	r22, 0x029A
    140c:	70 91 9b 02 	lds	r23, 0x029B
    1410:	84 1b       	sub	r24, r20
    1412:	95 0b       	sbc	r25, r21
    1414:	a6 0b       	sbc	r26, r22
    1416:	b7 0b       	sbc	r27, r23
    1418:	bf 93       	push	r27
    141a:	af 93       	push	r26
    141c:	9f 93       	push	r25
    141e:	8f 93       	push	r24
    1420:	84 81       	ldd	r24, Z+4	; 0x04
    1422:	95 81       	ldd	r25, Z+5	; 0x05
    1424:	a6 81       	ldd	r26, Z+6	; 0x06
    1426:	b7 81       	ldd	r27, Z+7	; 0x07
    1428:	40 91 94 02 	lds	r20, 0x0294
    142c:	50 91 95 02 	lds	r21, 0x0295
    1430:	60 91 96 02 	lds	r22, 0x0296
    1434:	70 91 97 02 	lds	r23, 0x0297
    1438:	84 1b       	sub	r24, r20
    143a:	95 0b       	sbc	r25, r21
    143c:	a6 0b       	sbc	r26, r22
    143e:	b7 0b       	sbc	r27, r23
    1440:	bf 93       	push	r27
    1442:	af 93       	push	r26
    1444:	9f 93       	push	r25
    1446:	8f 93       	push	r24
    1448:	80 81       	ld	r24, Z
    144a:	91 81       	ldd	r25, Z+1	; 0x01
    144c:	a2 81       	ldd	r26, Z+2	; 0x02
    144e:	b3 81       	ldd	r27, Z+3	; 0x03
    1450:	40 91 90 02 	lds	r20, 0x0290
    1454:	50 91 91 02 	lds	r21, 0x0291
    1458:	60 91 92 02 	lds	r22, 0x0292
    145c:	70 91 93 02 	lds	r23, 0x0293
    1460:	84 1b       	sub	r24, r20
    1462:	95 0b       	sbc	r25, r21
    1464:	a6 0b       	sbc	r26, r22
    1466:	b7 0b       	sbc	r27, r23
    1468:	bf 93       	push	r27
    146a:	af 93       	push	r26
    146c:	9f 93       	push	r25
    146e:	8f 93       	push	r24
    1470:	80 eb       	ldi	r24, 0xB0	; 176
    1472:	93 e0       	ldi	r25, 0x03	; 3
    1474:	9f 93       	push	r25
    1476:	8f 93       	push	r24
    1478:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
    147c:	0f b6       	in	r0, 0x3f	; 63
    147e:	f8 94       	cli
    1480:	de bf       	out	0x3e, r29	; 62
    1482:	0f be       	out	0x3f, r0	; 63
    1484:	cd bf       	out	0x3d, r28	; 61

	dda->total_steps = dda->x_delta;
    1486:	ed 8d       	ldd	r30, Y+29	; 0x1d
    1488:	fe 8d       	ldd	r31, Y+30	; 0x1e
    148a:	86 89       	ldd	r24, Z+22	; 0x16
    148c:	97 89       	ldd	r25, Z+23	; 0x17
    148e:	a0 8d       	ldd	r26, Z+24	; 0x18
    1490:	b1 8d       	ldd	r27, Z+25	; 0x19
    1492:	86 a3       	std	Z+38, r24	; 0x26
    1494:	97 a3       	std	Z+39, r25	; 0x27
    1496:	a0 a7       	std	Z+40, r26	; 0x28
    1498:	b1 a7       	std	Z+41, r27	; 0x29
	if (dda->y_delta > dda->total_steps)
    149a:	42 8d       	ldd	r20, Z+26	; 0x1a
    149c:	53 8d       	ldd	r21, Z+27	; 0x1b
    149e:	64 8d       	ldd	r22, Z+28	; 0x1c
    14a0:	75 8d       	ldd	r23, Z+29	; 0x1d
    14a2:	84 17       	cp	r24, r20
    14a4:	95 07       	cpc	r25, r21
    14a6:	a6 07       	cpc	r26, r22
    14a8:	b7 07       	cpc	r27, r23
    14aa:	20 f4       	brcc	.+8      	; 0x14b4 <dda_create+0x5a8>
		dda->total_steps = dda->y_delta;
    14ac:	46 a3       	std	Z+38, r20	; 0x26
    14ae:	57 a3       	std	Z+39, r21	; 0x27
    14b0:	60 a7       	std	Z+40, r22	; 0x28
    14b2:	71 a7       	std	Z+41, r23	; 0x29
	if (dda->z_delta > dda->total_steps)
    14b4:	ed 8d       	ldd	r30, Y+29	; 0x1d
    14b6:	fe 8d       	ldd	r31, Y+30	; 0x1e
    14b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    14ba:	97 8d       	ldd	r25, Z+31	; 0x1f
    14bc:	a0 a1       	ldd	r26, Z+32	; 0x20
    14be:	b1 a1       	ldd	r27, Z+33	; 0x21
    14c0:	46 a1       	ldd	r20, Z+38	; 0x26
    14c2:	57 a1       	ldd	r21, Z+39	; 0x27
    14c4:	60 a5       	ldd	r22, Z+40	; 0x28
    14c6:	71 a5       	ldd	r23, Z+41	; 0x29
    14c8:	48 17       	cp	r20, r24
    14ca:	59 07       	cpc	r21, r25
    14cc:	6a 07       	cpc	r22, r26
    14ce:	7b 07       	cpc	r23, r27
    14d0:	20 f4       	brcc	.+8      	; 0x14da <dda_create+0x5ce>
		dda->total_steps = dda->z_delta;
    14d2:	86 a3       	std	Z+38, r24	; 0x26
    14d4:	97 a3       	std	Z+39, r25	; 0x27
    14d6:	a0 a7       	std	Z+40, r26	; 0x28
    14d8:	b1 a7       	std	Z+41, r27	; 0x29
	if (dda->e_delta > dda->total_steps)
    14da:	ed 8d       	ldd	r30, Y+29	; 0x1d
    14dc:	fe 8d       	ldd	r31, Y+30	; 0x1e
    14de:	82 a1       	ldd	r24, Z+34	; 0x22
    14e0:	93 a1       	ldd	r25, Z+35	; 0x23
    14e2:	a4 a1       	ldd	r26, Z+36	; 0x24
    14e4:	b5 a1       	ldd	r27, Z+37	; 0x25
    14e6:	46 a1       	ldd	r20, Z+38	; 0x26
    14e8:	57 a1       	ldd	r21, Z+39	; 0x27
    14ea:	60 a5       	ldd	r22, Z+40	; 0x28
    14ec:	71 a5       	ldd	r23, Z+41	; 0x29
    14ee:	48 17       	cp	r20, r24
    14f0:	59 07       	cpc	r21, r25
    14f2:	6a 07       	cpc	r22, r26
    14f4:	7b 07       	cpc	r23, r27
    14f6:	20 f4       	brcc	.+8      	; 0x1500 <dda_create+0x5f4>
		dda->total_steps = dda->e_delta;
    14f8:	86 a3       	std	Z+38, r24	; 0x26
    14fa:	97 a3       	std	Z+39, r25	; 0x27
    14fc:	a0 a7       	std	Z+40, r26	; 0x28
    14fe:	b1 a7       	std	Z+41, r27	; 0x29

	if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
    1500:	80 91 cf 04 	lds	r24, 0x04CF
    1504:	81 ff       	sbrs	r24, 1
    1506:	1d c0       	rjmp	.+58     	; 0x1542 <dda_create+0x636>
		sersendf_P(PSTR("ts:%lu"), dda->total_steps);
    1508:	ad 8d       	ldd	r26, Y+29	; 0x1d
    150a:	be 8d       	ldd	r27, Y+30	; 0x1e
    150c:	99 96       	adiw	r26, 0x29	; 41
    150e:	8c 91       	ld	r24, X
    1510:	99 97       	sbiw	r26, 0x29	; 41
    1512:	8f 93       	push	r24
    1514:	98 96       	adiw	r26, 0x28	; 40
    1516:	8c 91       	ld	r24, X
    1518:	98 97       	sbiw	r26, 0x28	; 40
    151a:	8f 93       	push	r24
    151c:	97 96       	adiw	r26, 0x27	; 39
    151e:	8c 91       	ld	r24, X
    1520:	97 97       	sbiw	r26, 0x27	; 39
    1522:	8f 93       	push	r24
    1524:	96 96       	adiw	r26, 0x26	; 38
    1526:	8c 91       	ld	r24, X
    1528:	8f 93       	push	r24
    152a:	83 ec       	ldi	r24, 0xC3	; 195
    152c:	93 e0       	ldi	r25, 0x03	; 3
    152e:	9f 93       	push	r25
    1530:	8f 93       	push	r24
    1532:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
    1536:	0f 90       	pop	r0
    1538:	0f 90       	pop	r0
    153a:	0f 90       	pop	r0
    153c:	0f 90       	pop	r0
    153e:	0f 90       	pop	r0
    1540:	0f 90       	pop	r0

	if (dda->total_steps == 0) {
    1542:	ed 8d       	ldd	r30, Y+29	; 0x1d
    1544:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1546:	86 a1       	ldd	r24, Z+38	; 0x26
    1548:	97 a1       	ldd	r25, Z+39	; 0x27
    154a:	a0 a5       	ldd	r26, Z+40	; 0x28
    154c:	b1 a5       	ldd	r27, Z+41	; 0x29
    154e:	89 2b       	or	r24, r25
    1550:	8a 2b       	or	r24, r26
    1552:	8b 2b       	or	r24, r27
    1554:	21 f4       	brne	.+8      	; 0x155e <dda_create+0x652>
		dda->nullmove = 1;
    1556:	85 89       	ldd	r24, Z+21	; 0x15
    1558:	81 60       	ori	r24, 0x01	; 1
    155a:	85 8b       	std	Z+21, r24	; 0x15
    155c:	cd c1       	rjmp	.+922    	; 0x18f8 <dda_create+0x9ec>
  #endif

// TODO TODO: We should really make up a loop for all axes.
//            Think of what happens when a sixth axis (multi colour extruder)
//            appears?
	x_delta_um = (uint32_t)labs(target->X - startpoint.X);
    155e:	29 81       	ldd	r18, Y+1	; 0x01
    1560:	3a 81       	ldd	r19, Y+2	; 0x02
    1562:	4b 81       	ldd	r20, Y+3	; 0x03
    1564:	5c 81       	ldd	r21, Y+4	; 0x04
    1566:	42 1a       	sub	r4, r18
    1568:	53 0a       	sbc	r5, r19
    156a:	64 0a       	sbc	r6, r20
    156c:	75 0a       	sbc	r7, r21
    156e:	42 f4       	brpl	.+16     	; 0x1580 <dda_create+0x674>
    1570:	70 94       	com	r7
    1572:	60 94       	com	r6
    1574:	50 94       	com	r5
    1576:	40 94       	com	r4
    1578:	41 1c       	adc	r4, r1
    157a:	51 1c       	adc	r5, r1
    157c:	61 1c       	adc	r6, r1
    157e:	71 1c       	adc	r7, r1
    1580:	49 8a       	std	Y+17, r4	; 0x11
    1582:	5a 8a       	std	Y+18, r5	; 0x12
    1584:	6b 8a       	std	Y+19, r6	; 0x13
    1586:	7c 8a       	std	Y+20, r7	; 0x14
	y_delta_um = (uint32_t)labs(target->Y - startpoint.Y);
    1588:	8d 81       	ldd	r24, Y+5	; 0x05
    158a:	9e 81       	ldd	r25, Y+6	; 0x06
    158c:	af 81       	ldd	r26, Y+7	; 0x07
    158e:	b8 85       	ldd	r27, Y+8	; 0x08
    1590:	29 85       	ldd	r18, Y+9	; 0x09
    1592:	3a 85       	ldd	r19, Y+10	; 0x0a
    1594:	4b 85       	ldd	r20, Y+11	; 0x0b
    1596:	5c 85       	ldd	r21, Y+12	; 0x0c
    1598:	82 1b       	sub	r24, r18
    159a:	93 0b       	sbc	r25, r19
    159c:	a4 0b       	sbc	r26, r20
    159e:	b5 0b       	sbc	r27, r21
    15a0:	3a f4       	brpl	.+14     	; 0x15b0 <dda_create+0x6a4>
    15a2:	b0 95       	com	r27
    15a4:	a0 95       	com	r26
    15a6:	90 95       	com	r25
    15a8:	81 95       	neg	r24
    15aa:	9f 4f       	sbci	r25, 0xFF	; 255
    15ac:	af 4f       	sbci	r26, 0xFF	; 255
    15ae:	bf 4f       	sbci	r27, 0xFF	; 255
    15b0:	8d 83       	std	Y+5, r24	; 0x05
    15b2:	9e 83       	std	Y+6, r25	; 0x06
    15b4:	af 83       	std	Y+7, r26	; 0x07
    15b6:	b8 87       	std	Y+8, r27	; 0x08
	z_delta_um = (uint32_t)labs(target->Z - startpoint.Z);
    15b8:	8d 88       	ldd	r8, Y+21	; 0x15
    15ba:	9e 88       	ldd	r9, Y+22	; 0x16
    15bc:	af 88       	ldd	r10, Y+23	; 0x17
    15be:	b8 8c       	ldd	r11, Y+24	; 0x18
    15c0:	89 8d       	ldd	r24, Y+25	; 0x19
    15c2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    15c4:	ab 8d       	ldd	r26, Y+27	; 0x1b
    15c6:	bc 8d       	ldd	r27, Y+28	; 0x1c
    15c8:	88 1a       	sub	r8, r24
    15ca:	99 0a       	sbc	r9, r25
    15cc:	aa 0a       	sbc	r10, r26
    15ce:	bb 0a       	sbc	r11, r27
    15d0:	42 f4       	brpl	.+16     	; 0x15e2 <dda_create+0x6d6>
    15d2:	b0 94       	com	r11
    15d4:	a0 94       	com	r10
    15d6:	90 94       	com	r9
    15d8:	80 94       	com	r8
    15da:	81 1c       	adc	r8, r1
    15dc:	91 1c       	adc	r9, r1
    15de:	a1 1c       	adc	r10, r1
    15e0:	b1 1c       	adc	r11, r1
	if (dda->total_steps == 0) {
		dda->nullmove = 1;
	}
	else {
		// get steppers ready to go
		power_on();
    15e2:	0e 94 1a 24 	call	0x4834	; 0x4834 <power_on>
		y_enable();
		// Z is enabled in dda_start()
		e_enable();

		// since it's unusual to combine X, Y and Z changes in a single move on reprap, check if we can use simpler approximations before trying the full 3d approximation.
		if (z_delta_um == 0)
    15e6:	81 14       	cp	r8, r1
    15e8:	91 04       	cpc	r9, r1
    15ea:	a1 04       	cpc	r10, r1
    15ec:	b1 04       	cpc	r11, r1
    15ee:	71 f4       	brne	.+28     	; 0x160c <dda_create+0x700>
			distance = approx_distance(x_delta_um, y_delta_um);
    15f0:	2d 81       	ldd	r18, Y+5	; 0x05
    15f2:	3e 81       	ldd	r19, Y+6	; 0x06
    15f4:	4f 81       	ldd	r20, Y+7	; 0x07
    15f6:	58 85       	ldd	r21, Y+8	; 0x08
    15f8:	69 89       	ldd	r22, Y+17	; 0x11
    15fa:	7a 89       	ldd	r23, Y+18	; 0x12
    15fc:	8b 89       	ldd	r24, Y+19	; 0x13
    15fe:	9c 89       	ldd	r25, Y+20	; 0x14
    1600:	e7 d7       	rcall	.+4046   	; 0x25d0 <approx_distance>
    1602:	69 83       	std	Y+1, r22	; 0x01
    1604:	7a 83       	std	Y+2, r23	; 0x02
    1606:	8b 83       	std	Y+3, r24	; 0x03
    1608:	9c 83       	std	Y+4, r25	; 0x04
    160a:	25 c0       	rjmp	.+74     	; 0x1656 <dda_create+0x74a>
		else if (x_delta_um == 0 && y_delta_um == 0)
    160c:	29 89       	ldd	r18, Y+17	; 0x11
    160e:	3a 89       	ldd	r19, Y+18	; 0x12
    1610:	4b 89       	ldd	r20, Y+19	; 0x13
    1612:	5c 89       	ldd	r21, Y+20	; 0x14
    1614:	23 2b       	or	r18, r19
    1616:	24 2b       	or	r18, r20
    1618:	25 2b       	or	r18, r21
    161a:	41 f4       	brne	.+16     	; 0x162c <dda_create+0x720>
    161c:	8d 81       	ldd	r24, Y+5	; 0x05
    161e:	9e 81       	ldd	r25, Y+6	; 0x06
    1620:	af 81       	ldd	r26, Y+7	; 0x07
    1622:	b8 85       	ldd	r27, Y+8	; 0x08
    1624:	89 2b       	or	r24, r25
    1626:	8a 2b       	or	r24, r26
    1628:	8b 2b       	or	r24, r27
    162a:	89 f0       	breq	.+34     	; 0x164e <dda_create+0x742>
			distance = z_delta_um;
		else
			distance = approx_distance_3(x_delta_um, y_delta_um, z_delta_um);
    162c:	85 01       	movw	r16, r10
    162e:	74 01       	movw	r14, r8
    1630:	2d 81       	ldd	r18, Y+5	; 0x05
    1632:	3e 81       	ldd	r19, Y+6	; 0x06
    1634:	4f 81       	ldd	r20, Y+7	; 0x07
    1636:	58 85       	ldd	r21, Y+8	; 0x08
    1638:	69 89       	ldd	r22, Y+17	; 0x11
    163a:	7a 89       	ldd	r23, Y+18	; 0x12
    163c:	8b 89       	ldd	r24, Y+19	; 0x13
    163e:	9c 89       	ldd	r25, Y+20	; 0x14
    1640:	0e 94 62 13 	call	0x26c4	; 0x26c4 <approx_distance_3>
    1644:	69 83       	std	Y+1, r22	; 0x01
    1646:	7a 83       	std	Y+2, r23	; 0x02
    1648:	8b 83       	std	Y+3, r24	; 0x03
    164a:	9c 83       	std	Y+4, r25	; 0x04
    164c:	04 c0       	rjmp	.+8      	; 0x1656 <dda_create+0x74a>

		// since it's unusual to combine X, Y and Z changes in a single move on reprap, check if we can use simpler approximations before trying the full 3d approximation.
		if (z_delta_um == 0)
			distance = approx_distance(x_delta_um, y_delta_um);
		else if (x_delta_um == 0 && y_delta_um == 0)
			distance = z_delta_um;
    164e:	89 82       	std	Y+1, r8	; 0x01
    1650:	9a 82       	std	Y+2, r9	; 0x02
    1652:	ab 82       	std	Y+3, r10	; 0x03
    1654:	bc 82       	std	Y+4, r11	; 0x04
		else
			distance = approx_distance_3(x_delta_um, y_delta_um, z_delta_um);

		if (distance < 2)
    1656:	29 81       	ldd	r18, Y+1	; 0x01
    1658:	3a 81       	ldd	r19, Y+2	; 0x02
    165a:	4b 81       	ldd	r20, Y+3	; 0x03
    165c:	5c 81       	ldd	r21, Y+4	; 0x04
    165e:	22 30       	cpi	r18, 0x02	; 2
    1660:	31 05       	cpc	r19, r1
    1662:	41 05       	cpc	r20, r1
    1664:	51 05       	cpc	r21, r1
    1666:	40 f4       	brcc	.+16     	; 0x1678 <dda_create+0x76c>
			distance = e_delta_um;
    1668:	3d 85       	ldd	r19, Y+13	; 0x0d
    166a:	39 83       	std	Y+1, r19	; 0x01
    166c:	4e 85       	ldd	r20, Y+14	; 0x0e
    166e:	4a 83       	std	Y+2, r20	; 0x02
    1670:	5f 85       	ldd	r21, Y+15	; 0x0f
    1672:	5b 83       	std	Y+3, r21	; 0x03
    1674:	88 89       	ldd	r24, Y+16	; 0x10
    1676:	8c 83       	std	Y+4, r24	; 0x04

		if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
    1678:	80 91 cf 04 	lds	r24, 0x04CF
    167c:	81 ff       	sbrs	r24, 1
    167e:	14 c0       	rjmp	.+40     	; 0x16a8 <dda_create+0x79c>
			sersendf_P(PSTR(",ds:%lu"), distance);
    1680:	9c 81       	ldd	r25, Y+4	; 0x04
    1682:	9f 93       	push	r25
    1684:	ab 81       	ldd	r26, Y+3	; 0x03
    1686:	af 93       	push	r26
    1688:	ba 81       	ldd	r27, Y+2	; 0x02
    168a:	bf 93       	push	r27
    168c:	e9 81       	ldd	r30, Y+1	; 0x01
    168e:	ef 93       	push	r30
    1690:	8a ec       	ldi	r24, 0xCA	; 202
    1692:	93 e0       	ldi	r25, 0x03	; 3
    1694:	9f 93       	push	r25
    1696:	8f 93       	push	r24
    1698:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
    169c:	0f 90       	pop	r0
    169e:	0f 90       	pop	r0
    16a0:	0f 90       	pop	r0
    16a2:	0f 90       	pop	r0
    16a4:	0f 90       	pop	r0
    16a6:	0f 90       	pop	r0
			// changed * 10 to * (F_CPU / 100000) so we can work in cpu_ticks rather than microseconds.
			// timer.c setTimer() routine altered for same reason

			// changed distance * 6000 .. * F_CPU / 100000 to
			//         distance * 2400 .. * F_CPU / 40000 so we can move a distance of up to 1800mm without overflowing
			uint32_t move_duration = ((distance * 2400) / dda->total_steps) * (F_CPU / 40000);
    16a8:	ad 8d       	ldd	r26, Y+29	; 0x1d
    16aa:	be 8d       	ldd	r27, Y+30	; 0x1e
    16ac:	96 96       	adiw	r26, 0x26	; 38
    16ae:	cd 90       	ld	r12, X+
    16b0:	dd 90       	ld	r13, X+
    16b2:	ed 90       	ld	r14, X+
    16b4:	fc 90       	ld	r15, X
    16b6:	99 97       	sbiw	r26, 0x29	; 41
		// check X axis
		c_limit_calc = ((x_delta_um * 2400L) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_X) << 8;
		if (c_limit_calc > c_limit)
			c_limit = c_limit_calc;
		// check Y axis
		c_limit_calc = ((y_delta_um * 2400L) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_Y) << 8;
    16b8:	a0 e6       	ldi	r26, 0x60	; 96
    16ba:	b9 e0       	ldi	r27, 0x09	; 9
    16bc:	2d 81       	ldd	r18, Y+5	; 0x05
    16be:	3e 81       	ldd	r19, Y+6	; 0x06
    16c0:	4f 81       	ldd	r20, Y+7	; 0x07
    16c2:	58 85       	ldd	r21, Y+8	; 0x08
    16c4:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    16c8:	a7 01       	movw	r20, r14
    16ca:	96 01       	movw	r18, r12
    16cc:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    16d0:	a0 e9       	ldi	r26, 0x90	; 144
    16d2:	b1 e0       	ldi	r27, 0x01	; 1
    16d4:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    16d8:	0f 2e       	mov	r0, r31
    16da:	f8 ec       	ldi	r31, 0xC8	; 200
    16dc:	4f 2e       	mov	r4, r31
    16de:	51 2c       	mov	r5, r1
    16e0:	61 2c       	mov	r6, r1
    16e2:	71 2c       	mov	r7, r1
    16e4:	f0 2d       	mov	r31, r0
    16e6:	a3 01       	movw	r20, r6
    16e8:	92 01       	movw	r18, r4
    16ea:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    16ee:	29 87       	std	Y+9, r18	; 0x09
    16f0:	3a 87       	std	Y+10, r19	; 0x0a
    16f2:	4b 87       	std	Y+11, r20	; 0x0b
    16f4:	5c 87       	std	Y+12, r21	; 0x0c

		// similarly, find out how fast we can run our axes.
		// do this for each axis individually, as the combined speed of two or more axes can be higher than the capabilities of a single one.
		c_limit = 0;
		// check X axis
		c_limit_calc = ((x_delta_um * 2400L) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_X) << 8;
    16f6:	a0 e6       	ldi	r26, 0x60	; 96
    16f8:	b9 e0       	ldi	r27, 0x09	; 9
    16fa:	29 89       	ldd	r18, Y+17	; 0x11
    16fc:	3a 89       	ldd	r19, Y+18	; 0x12
    16fe:	4b 89       	ldd	r20, Y+19	; 0x13
    1700:	5c 89       	ldd	r21, Y+20	; 0x14
    1702:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    1706:	a7 01       	movw	r20, r14
    1708:	96 01       	movw	r18, r12
    170a:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    170e:	a0 e9       	ldi	r26, 0x90	; 144
    1710:	b1 e0       	ldi	r27, 0x01	; 1
    1712:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    1716:	a3 01       	movw	r20, r6
    1718:	92 01       	movw	r18, r4
    171a:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    171e:	b4 2f       	mov	r27, r20
    1720:	a3 2f       	mov	r26, r19
    1722:	92 2f       	mov	r25, r18
    1724:	88 27       	eor	r24, r24
    1726:	29 85       	ldd	r18, Y+9	; 0x09
    1728:	3a 85       	ldd	r19, Y+10	; 0x0a
    172a:	4b 85       	ldd	r20, Y+11	; 0x0b
    172c:	5c 85       	ldd	r21, Y+12	; 0x0c
    172e:	44 24       	eor	r4, r4
    1730:	52 2e       	mov	r5, r18
    1732:	63 2e       	mov	r6, r19
    1734:	74 2e       	mov	r7, r20
    1736:	48 16       	cp	r4, r24
    1738:	59 06       	cpc	r5, r25
    173a:	6a 06       	cpc	r6, r26
    173c:	7b 06       	cpc	r7, r27
    173e:	10 f4       	brcc	.+4      	; 0x1744 <dda_create+0x838>
    1740:	2c 01       	movw	r4, r24
    1742:	3d 01       	movw	r6, r26
		// check Y axis
		c_limit_calc = ((y_delta_um * 2400L) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_Y) << 8;
		if (c_limit_calc > c_limit)
			c_limit = c_limit_calc;
		// check Z axis
		c_limit_calc = ((z_delta_um * 2400L) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_Z) << 8;
    1744:	a0 e6       	ldi	r26, 0x60	; 96
    1746:	b9 e0       	ldi	r27, 0x09	; 9
    1748:	a5 01       	movw	r20, r10
    174a:	94 01       	movw	r18, r8
    174c:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    1750:	a7 01       	movw	r20, r14
    1752:	96 01       	movw	r18, r12
    1754:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    1758:	a0 e9       	ldi	r26, 0x90	; 144
    175a:	b1 e0       	ldi	r27, 0x01	; 1
    175c:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    1760:	24 e6       	ldi	r18, 0x64	; 100
    1762:	30 e0       	ldi	r19, 0x00	; 0
    1764:	40 e0       	ldi	r20, 0x00	; 0
    1766:	50 e0       	ldi	r21, 0x00	; 0
    1768:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    176c:	b4 2f       	mov	r27, r20
    176e:	a3 2f       	mov	r26, r19
    1770:	92 2f       	mov	r25, r18
    1772:	88 27       	eor	r24, r24
    1774:	48 16       	cp	r4, r24
    1776:	59 06       	cpc	r5, r25
    1778:	6a 06       	cpc	r6, r26
    177a:	7b 06       	cpc	r7, r27
    177c:	10 f4       	brcc	.+4      	; 0x1782 <dda_create+0x876>
    177e:	2c 01       	movw	r4, r24
    1780:	3d 01       	movw	r6, r26
		if (c_limit_calc > c_limit)
			c_limit = c_limit_calc;
		// check E axis
		c_limit_calc = ((e_delta_um * 2400L) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_E) << 8;
    1782:	a0 e6       	ldi	r26, 0x60	; 96
    1784:	b9 e0       	ldi	r27, 0x09	; 9
    1786:	2d 85       	ldd	r18, Y+13	; 0x0d
    1788:	3e 85       	ldd	r19, Y+14	; 0x0e
    178a:	4f 85       	ldd	r20, Y+15	; 0x0f
    178c:	58 89       	ldd	r21, Y+16	; 0x10
    178e:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    1792:	a7 01       	movw	r20, r14
    1794:	96 01       	movw	r18, r12
    1796:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    179a:	a0 e9       	ldi	r26, 0x90	; 144
    179c:	b1 e0       	ldi	r27, 0x01	; 1
    179e:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    17a2:	28 e5       	ldi	r18, 0x58	; 88
    17a4:	32 e0       	ldi	r19, 0x02	; 2
    17a6:	40 e0       	ldi	r20, 0x00	; 0
    17a8:	50 e0       	ldi	r21, 0x00	; 0
    17aa:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    17ae:	b4 2f       	mov	r27, r20
    17b0:	a3 2f       	mov	r26, r19
    17b2:	92 2f       	mov	r25, r18
    17b4:	88 27       	eor	r24, r24
    17b6:	48 16       	cp	r4, r24
    17b8:	59 06       	cpc	r5, r25
    17ba:	6a 06       	cpc	r6, r26
    17bc:	7b 06       	cpc	r7, r27
    17be:	10 f4       	brcc	.+4      	; 0x17c4 <dda_create+0x8b8>
    17c0:	2c 01       	movw	r4, r24
    17c2:	3d 01       	movw	r6, r26
			// changed * 10 to * (F_CPU / 100000) so we can work in cpu_ticks rather than microseconds.
			// timer.c setTimer() routine altered for same reason

			// changed distance * 6000 .. * F_CPU / 100000 to
			//         distance * 2400 .. * F_CPU / 40000 so we can move a distance of up to 1800mm without overflowing
			uint32_t move_duration = ((distance * 2400) / dda->total_steps) * (F_CPU / 40000);
    17c4:	a0 e6       	ldi	r26, 0x60	; 96
    17c6:	b9 e0       	ldi	r27, 0x09	; 9
    17c8:	29 81       	ldd	r18, Y+1	; 0x01
    17ca:	3a 81       	ldd	r19, Y+2	; 0x02
    17cc:	4b 81       	ldd	r20, Y+3	; 0x03
    17ce:	5c 81       	ldd	r21, Y+4	; 0x04
    17d0:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    17d4:	a7 01       	movw	r20, r14
    17d6:	96 01       	movw	r18, r12
    17d8:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    17dc:	a0 e9       	ldi	r26, 0x90	; 144
    17de:	b1 e0       	ldi	r27, 0x01	; 1
    17e0:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
		}
		else
			dda->accel = 0;
		#elif defined ACCELERATION_RAMPING
			// yes, this assumes always the x axis as the critical one regarding acceleration. If we want to implement per-axis acceleration, things get tricky ...
			dda->c_min = (move_duration / target->F) << 8;
    17e4:	d1 01       	movw	r26, r2
    17e6:	50 96       	adiw	r26, 0x10	; 16
    17e8:	2d 91       	ld	r18, X+
    17ea:	3d 91       	ld	r19, X+
    17ec:	4d 91       	ld	r20, X+
    17ee:	5c 91       	ld	r21, X
    17f0:	53 97       	sbiw	r26, 0x13	; 19
    17f2:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    17f6:	b4 2f       	mov	r27, r20
    17f8:	a3 2f       	mov	r26, r19
    17fa:	92 2f       	mov	r25, r18
    17fc:	88 27       	eor	r24, r24
			if (dda->c_min < c_limit)
    17fe:	84 15       	cp	r24, r4
    1800:	95 05       	cpc	r25, r5
    1802:	a6 05       	cpc	r26, r6
    1804:	b7 05       	cpc	r27, r7
    1806:	38 f0       	brcs	.+14     	; 0x1816 <dda_create+0x90a>
		}
		else
			dda->accel = 0;
		#elif defined ACCELERATION_RAMPING
			// yes, this assumes always the x axis as the critical one regarding acceleration. If we want to implement per-axis acceleration, things get tricky ...
			dda->c_min = (move_duration / target->F) << 8;
    1808:	ed 8d       	ldd	r30, Y+29	; 0x1d
    180a:	fe 8d       	ldd	r31, Y+30	; 0x1e
    180c:	86 ab       	std	Z+54, r24	; 0x36
    180e:	97 ab       	std	Z+55, r25	; 0x37
    1810:	a0 af       	std	Z+56, r26	; 0x38
    1812:	b1 af       	std	Z+57, r27	; 0x39
    1814:	08 c0       	rjmp	.+16     	; 0x1826 <dda_create+0x91a>
			if (dda->c_min < c_limit)
				dda->c_min = c_limit;
    1816:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1818:	be 8d       	ldd	r27, Y+30	; 0x1e
    181a:	d6 96       	adiw	r26, 0x36	; 54
    181c:	4d 92       	st	X+, r4
    181e:	5d 92       	st	X+, r5
    1820:	6d 92       	st	X+, r6
    1822:	7c 92       	st	X, r7
    1824:	d9 97       	sbiw	r26, 0x39	; 57
                   steps = F^2 / (int)((7200000 * ACCELERATION) / STEPS_PER_M_X)
         Note 3: As mentioned, setting F to 65535 or larger will overflow the
                 calculation. Make sure this does not happen.
         Note 4: Anyone trying to run their machine at 65535 mm/min > 1m/s is nuts
       */
      if (target->F > 65534) target->F = 65534;
    1826:	f1 01       	movw	r30, r2
    1828:	80 89       	ldd	r24, Z+16	; 0x10
    182a:	91 89       	ldd	r25, Z+17	; 0x11
    182c:	a2 89       	ldd	r26, Z+18	; 0x12
    182e:	b3 89       	ldd	r27, Z+19	; 0x13
    1830:	8f 3f       	cpi	r24, 0xFF	; 255
    1832:	9f 4f       	sbci	r25, 0xFF	; 255
    1834:	a1 05       	cpc	r26, r1
    1836:	b1 05       	cpc	r27, r1
    1838:	48 f0       	brcs	.+18     	; 0x184c <dda_create+0x940>
    183a:	8e ef       	ldi	r24, 0xFE	; 254
    183c:	9f ef       	ldi	r25, 0xFF	; 255
    183e:	a0 e0       	ldi	r26, 0x00	; 0
    1840:	b0 e0       	ldi	r27, 0x00	; 0
    1842:	f1 01       	movw	r30, r2
    1844:	80 8b       	std	Z+16, r24	; 0x10
    1846:	91 8b       	std	Z+17, r25	; 0x11
    1848:	a2 8b       	std	Z+18, r26	; 0x12
    184a:	b3 8b       	std	Z+19, r27	; 0x13
      dda->rampup_steps = ACCELERATE_RAMP_LEN(target->F);
    184c:	d1 01       	movw	r26, r2
    184e:	50 96       	adiw	r26, 0x10	; 16
    1850:	6d 91       	ld	r22, X+
    1852:	7d 91       	ld	r23, X+
    1854:	8d 91       	ld	r24, X+
    1856:	9c 91       	ld	r25, X
    1858:	53 97       	sbiw	r26, 0x13	; 19
    185a:	9b 01       	movw	r18, r22
    185c:	ac 01       	movw	r20, r24
    185e:	0e 94 10 2a 	call	0x5420	; 0x5420 <__mulsi3>
    1862:	23 ef       	ldi	r18, 0xF3	; 243
    1864:	3d e5       	ldi	r19, 0x5D	; 93
    1866:	41 e0       	ldi	r20, 0x01	; 1
    1868:	50 e0       	ldi	r21, 0x00	; 0
    186a:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    186e:	ed 8d       	ldd	r30, Y+29	; 0x1d
    1870:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1872:	26 a7       	std	Z+46, r18	; 0x2e
    1874:	37 a7       	std	Z+47, r19	; 0x2f
    1876:	40 ab       	std	Z+48, r20	; 0x30
    1878:	51 ab       	std	Z+49, r21	; 0x31
      // Quick hack: we do not do Z move joins as jerk on the Z axis is undesirable;
      // as the ramp length is calculated for XY, its incorrect for Z: apply the original
      // 'fix' to simply specify a large enough ramp for any speed.
      if (x_delta_um == 0 && y_delta_um == 0) {
    187a:	29 89       	ldd	r18, Y+17	; 0x11
    187c:	3a 89       	ldd	r19, Y+18	; 0x12
    187e:	4b 89       	ldd	r20, Y+19	; 0x13
    1880:	5c 89       	ldd	r21, Y+20	; 0x14
    1882:	23 2b       	or	r18, r19
    1884:	24 2b       	or	r18, r20
    1886:	25 2b       	or	r18, r21
    1888:	81 f4       	brne	.+32     	; 0x18aa <dda_create+0x99e>
    188a:	8d 81       	ldd	r24, Y+5	; 0x05
    188c:	9e 81       	ldd	r25, Y+6	; 0x06
    188e:	af 81       	ldd	r26, Y+7	; 0x07
    1890:	b8 85       	ldd	r27, Y+8	; 0x08
    1892:	89 2b       	or	r24, r25
    1894:	8a 2b       	or	r24, r26
    1896:	8b 2b       	or	r24, r27
    1898:	41 f4       	brne	.+16     	; 0x18aa <dda_create+0x99e>
        dda->rampup_steps = 100000; // replace mis-calculation by a safe value
    189a:	80 ea       	ldi	r24, 0xA0	; 160
    189c:	96 e8       	ldi	r25, 0x86	; 134
    189e:	a1 e0       	ldi	r26, 0x01	; 1
    18a0:	b0 e0       	ldi	r27, 0x00	; 0
    18a2:	86 a7       	std	Z+46, r24	; 0x2e
    18a4:	97 a7       	std	Z+47, r25	; 0x2f
    18a6:	a0 ab       	std	Z+48, r26	; 0x30
    18a8:	b1 ab       	std	Z+49, r27	; 0x31
      }

      if (dda->rampup_steps > dda->total_steps / 2)
    18aa:	ed 8d       	ldd	r30, Y+29	; 0x1d
    18ac:	fe 8d       	ldd	r31, Y+30	; 0x1e
    18ae:	86 a1       	ldd	r24, Z+38	; 0x26
    18b0:	97 a1       	ldd	r25, Z+39	; 0x27
    18b2:	a0 a5       	ldd	r26, Z+40	; 0x28
    18b4:	b1 a5       	ldd	r27, Z+41	; 0x29
    18b6:	ac 01       	movw	r20, r24
    18b8:	bd 01       	movw	r22, r26
    18ba:	76 95       	lsr	r23
    18bc:	67 95       	ror	r22
    18be:	57 95       	ror	r21
    18c0:	47 95       	ror	r20
    18c2:	c6 a4       	ldd	r12, Z+46	; 0x2e
    18c4:	d7 a4       	ldd	r13, Z+47	; 0x2f
    18c6:	e0 a8       	ldd	r14, Z+48	; 0x30
    18c8:	f1 a8       	ldd	r15, Z+49	; 0x31
    18ca:	4c 15       	cp	r20, r12
    18cc:	5d 05       	cpc	r21, r13
    18ce:	6e 05       	cpc	r22, r14
    18d0:	7f 05       	cpc	r23, r15
    18d2:	20 f4       	brcc	.+8      	; 0x18dc <dda_create+0x9d0>
        dda->rampup_steps = dda->total_steps / 2;
    18d4:	46 a7       	std	Z+46, r20	; 0x2e
    18d6:	57 a7       	std	Z+47, r21	; 0x2f
    18d8:	60 ab       	std	Z+48, r22	; 0x30
    18da:	71 ab       	std	Z+49, r23	; 0x31
      dda->rampdown_steps = dda->total_steps - dda->rampup_steps;
    18dc:	ed 8d       	ldd	r30, Y+29	; 0x1d
    18de:	fe 8d       	ldd	r31, Y+30	; 0x1e
    18e0:	46 a5       	ldd	r20, Z+46	; 0x2e
    18e2:	57 a5       	ldd	r21, Z+47	; 0x2f
    18e4:	60 a9       	ldd	r22, Z+48	; 0x30
    18e6:	71 a9       	ldd	r23, Z+49	; 0x31
    18e8:	84 1b       	sub	r24, r20
    18ea:	95 0b       	sbc	r25, r21
    18ec:	a6 0b       	sbc	r26, r22
    18ee:	b7 0b       	sbc	r27, r23
    18f0:	82 ab       	std	Z+50, r24	; 0x32
    18f2:	93 ab       	std	Z+51, r25	; 0x33
    18f4:	a4 ab       	std	Z+52, r26	; 0x34
    18f6:	b5 ab       	std	Z+53, r27	; 0x35
			if (dda->c < c_limit)
				dda->c = c_limit;
		#endif
	}

	if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
    18f8:	80 91 cf 04 	lds	r24, 0x04CF
    18fc:	81 ff       	sbrs	r24, 1
    18fe:	04 c0       	rjmp	.+8      	; 0x1908 <dda_create+0x9fc>
		serial_writestr_P(PSTR("] }\n"));
    1900:	82 ed       	ldi	r24, 0xD2	; 210
    1902:	93 e0       	ldi	r25, 0x03	; 3
    1904:	0e 94 0c 25 	call	0x4a18	; 0x4a18 <serial_writestr_P>

	// next dda starts where we finish
	memcpy(&startpoint, target, sizeof(TARGET));
    1908:	85 e1       	ldi	r24, 0x15	; 21
    190a:	f1 01       	movw	r30, r2
    190c:	a0 e9       	ldi	r26, 0x90	; 144
    190e:	b2 e0       	ldi	r27, 0x02	; 2
    1910:	01 90       	ld	r0, Z+
    1912:	0d 92       	st	X+, r0
    1914:	8a 95       	dec	r24
    1916:	e1 f7       	brne	.-8      	; 0x1910 <dda_create+0xa04>
}
    1918:	6e 96       	adiw	r28, 0x1e	; 30
    191a:	0f b6       	in	r0, 0x3f	; 63
    191c:	f8 94       	cli
    191e:	de bf       	out	0x3e, r29	; 62
    1920:	0f be       	out	0x3f, r0	; 63
    1922:	cd bf       	out	0x3d, r28	; 61
    1924:	df 91       	pop	r29
    1926:	cf 91       	pop	r28
    1928:	1f 91       	pop	r17
    192a:	0f 91       	pop	r16
    192c:	ff 90       	pop	r15
    192e:	ef 90       	pop	r14
    1930:	df 90       	pop	r13
    1932:	cf 90       	pop	r12
    1934:	bf 90       	pop	r11
    1936:	af 90       	pop	r10
    1938:	9f 90       	pop	r9
    193a:	8f 90       	pop	r8
    193c:	7f 90       	pop	r7
    193e:	6f 90       	pop	r6
    1940:	5f 90       	pop	r5
    1942:	4f 90       	pop	r4
    1944:	3f 90       	pop	r3
    1946:	2f 90       	pop	r2
    1948:	08 95       	ret

0000194a <dda_start>:

	We also mark this DDA as running, so other parts of the firmware know that something is happening

	Called both inside and outside of interrupts.
*/
void dda_start(DDA *dda) {
    194a:	cf 93       	push	r28
    194c:	df 93       	push	r29
    194e:	ec 01       	movw	r28, r24
	// called from interrupt context: keep it simple!
	if ( ! dda->nullmove) {
    1950:	8d 89       	ldd	r24, Y+21	; 0x15
    1952:	80 fd       	sbrc	r24, 0
    1954:	82 c0       	rjmp	.+260    	; 0x1a5a <dda_start+0x110>
		// get ready to go
		psu_timeout = 0;
    1956:	10 92 bf 04 	sts	0x04BF, r1
			z_enable();
		if (dda->endstop_check)
			endstops_on();

		// set direction outputs
		x_direction(dda->x_direction);
    195a:	83 ff       	sbrs	r24, 3
    195c:	02 c0       	rjmp	.+4      	; 0x1962 <dda_start+0x18>
    195e:	2e 9a       	sbi	0x05, 6	; 5
    1960:	01 c0       	rjmp	.+2      	; 0x1964 <dda_start+0x1a>
    1962:	2e 98       	cbi	0x05, 6	; 5
		y_direction(dda->y_direction);
    1964:	8d 89       	ldd	r24, Y+21	; 0x15
    1966:	84 fd       	sbrc	r24, 4
    1968:	02 c0       	rjmp	.+4      	; 0x196e <dda_start+0x24>
    196a:	2f 9a       	sbi	0x05, 7	; 5
    196c:	01 c0       	rjmp	.+2      	; 0x1970 <dda_start+0x26>
    196e:	2f 98       	cbi	0x05, 7	; 5
		z_direction(dda->z_direction);
    1970:	8d 89       	ldd	r24, Y+21	; 0x15
    1972:	85 fd       	sbrc	r24, 5
    1974:	06 c0       	rjmp	.+12     	; 0x1982 <dda_start+0x38>
    1976:	eb e0       	ldi	r30, 0x0B	; 11
    1978:	f1 e0       	ldi	r31, 0x01	; 1
    197a:	80 81       	ld	r24, Z
    197c:	82 60       	ori	r24, 0x02	; 2
    197e:	80 83       	st	Z, r24
    1980:	05 c0       	rjmp	.+10     	; 0x198c <dda_start+0x42>
    1982:	eb e0       	ldi	r30, 0x0B	; 11
    1984:	f1 e0       	ldi	r31, 0x01	; 1
    1986:	80 81       	ld	r24, Z
    1988:	8d 7f       	andi	r24, 0xFD	; 253
    198a:	80 83       	st	Z, r24
		e_direction(dda->e_direction);
    198c:	8d 89       	ldd	r24, Y+21	; 0x15
    198e:	86 ff       	sbrs	r24, 6
    1990:	02 c0       	rjmp	.+4      	; 0x1996 <dda_start+0x4c>
    1992:	16 9a       	sbi	0x02, 6	; 2
    1994:	01 c0       	rjmp	.+2      	; 0x1998 <dda_start+0x4e>
    1996:	16 98       	cbi	0x02, 6	; 2
			heater_set(DC_EXTRUDER, DC_EXTRUDER_PWM);
		#endif

		// initialise state variable
		move_state.x_counter = move_state.y_counter = move_state.z_counter = \
			move_state.e_counter = -(dda->total_steps >> 1);
    1998:	4e a1       	ldd	r20, Y+38	; 0x26
    199a:	5f a1       	ldd	r21, Y+39	; 0x27
    199c:	68 a5       	ldd	r22, Y+40	; 0x28
    199e:	79 a5       	ldd	r23, Y+41	; 0x29
    19a0:	76 95       	lsr	r23
    19a2:	67 95       	ror	r22
    19a4:	57 95       	ror	r21
    19a6:	47 95       	ror	r20
    19a8:	70 95       	com	r23
    19aa:	60 95       	com	r22
    19ac:	50 95       	com	r21
    19ae:	41 95       	neg	r20
    19b0:	5f 4f       	sbci	r21, 0xFF	; 255
    19b2:	6f 4f       	sbci	r22, 0xFF	; 255
    19b4:	7f 4f       	sbci	r23, 0xFF	; 255
    19b6:	40 93 40 02 	sts	0x0240, r20
    19ba:	50 93 41 02 	sts	0x0241, r21
    19be:	60 93 42 02 	sts	0x0242, r22
    19c2:	70 93 43 02 	sts	0x0243, r23
		if (dda->e_delta)
			heater_set(DC_EXTRUDER, DC_EXTRUDER_PWM);
		#endif

		// initialise state variable
		move_state.x_counter = move_state.y_counter = move_state.z_counter = \
    19c6:	40 93 3c 02 	sts	0x023C, r20
    19ca:	50 93 3d 02 	sts	0x023D, r21
    19ce:	60 93 3e 02 	sts	0x023E, r22
    19d2:	70 93 3f 02 	sts	0x023F, r23
    19d6:	40 93 38 02 	sts	0x0238, r20
    19da:	50 93 39 02 	sts	0x0239, r21
    19de:	60 93 3a 02 	sts	0x023A, r22
    19e2:	70 93 3b 02 	sts	0x023B, r23
    19e6:	40 93 34 02 	sts	0x0234, r20
    19ea:	50 93 35 02 	sts	0x0235, r21
    19ee:	60 93 36 02 	sts	0x0236, r22
    19f2:	70 93 37 02 	sts	0x0237, r23
			move_state.e_counter = -(dda->total_steps >> 1);
		memcpy(&move_state.x_steps, &dda->x_delta, sizeof(uint32_t) * 4);
    19f6:	fe 01       	movw	r30, r28
    19f8:	76 96       	adiw	r30, 0x16	; 22
    19fa:	80 e1       	ldi	r24, 0x10	; 16
    19fc:	a4 e4       	ldi	r26, 0x44	; 68
    19fe:	b2 e0       	ldi	r27, 0x02	; 2
    1a00:	01 90       	ld	r0, Z+
    1a02:	0d 92       	st	X+, r0
    1a04:	8a 95       	dec	r24
    1a06:	e1 f7       	brne	.-8      	; 0x1a00 <dda_start+0xb6>
		#ifdef ACCELERATION_RAMPING
			move_state.step_no = 0;
    1a08:	10 92 54 02 	sts	0x0254, r1
    1a0c:	10 92 55 02 	sts	0x0255, r1
    1a10:	10 92 56 02 	sts	0x0256, r1
    1a14:	10 92 57 02 	sts	0x0257, r1
		move_state.x_time = move_state.y_time = \
			move_state.z_time = move_state.e_time = 0UL;
		#endif

		// ensure this dda starts
		dda->live = 1;
    1a18:	8d 89       	ldd	r24, Y+21	; 0x15
    1a1a:	82 60       	ori	r24, 0x02	; 2
    1a1c:	8d 8b       	std	Y+21, r24	; 0x15

		// set timeout for first step
		#ifdef ACCELERATION_RAMPING
		if (dda->c_min > move_state.c) // can be true when look-ahead removed all deceleration steps
    1a1e:	8e a9       	ldd	r24, Y+54	; 0x36
    1a20:	9f a9       	ldd	r25, Y+55	; 0x37
    1a22:	a8 ad       	ldd	r26, Y+56	; 0x38
    1a24:	b9 ad       	ldd	r27, Y+57	; 0x39
    1a26:	40 91 58 02 	lds	r20, 0x0258
    1a2a:	50 91 59 02 	lds	r21, 0x0259
    1a2e:	60 91 5a 02 	lds	r22, 0x025A
    1a32:	70 91 5b 02 	lds	r23, 0x025B
    1a36:	48 17       	cp	r20, r24
    1a38:	59 07       	cpc	r21, r25
    1a3a:	6a 07       	cpc	r22, r26
    1a3c:	7b 07       	cpc	r23, r27
    1a3e:	38 f4       	brcc	.+14     	; 0x1a4e <dda_start+0x104>
			setTimer(dda->c_min >> 8);
    1a40:	69 2f       	mov	r22, r25
    1a42:	7a 2f       	mov	r23, r26
    1a44:	8b 2f       	mov	r24, r27
    1a46:	99 27       	eor	r25, r25
    1a48:	0e 94 b0 29 	call	0x5360	; 0x5360 <setTimer>
    1a4c:	06 c0       	rjmp	.+12     	; 0x1a5a <dda_start+0x110>
		else
			setTimer(move_state.c >> 8);
    1a4e:	99 27       	eor	r25, r25
    1a50:	87 2f       	mov	r24, r23
    1a52:	76 2f       	mov	r23, r22
    1a54:	65 2f       	mov	r22, r21
    1a56:	0e 94 b0 29 	call	0x5360	; 0x5360 <setTimer>
		setTimer(dda->c >> 8);
		#endif
	}
	// else just a speed change, keep dda->live = 0

	current_position.F = dda->endpoint.F;
    1a5a:	88 89       	ldd	r24, Y+16	; 0x10
    1a5c:	99 89       	ldd	r25, Y+17	; 0x11
    1a5e:	aa 89       	ldd	r26, Y+18	; 0x12
    1a60:	bb 89       	ldd	r27, Y+19	; 0x13
    1a62:	80 93 76 02 	sts	0x0276, r24
    1a66:	90 93 77 02 	sts	0x0277, r25
    1a6a:	a0 93 78 02 	sts	0x0278, r26
    1a6e:	b0 93 79 02 	sts	0x0279, r27
}
    1a72:	df 91       	pop	r29
    1a74:	cf 91       	pop	r28
    1a76:	08 95       	ret

00001a78 <dda_step>:
	Then we re-enable global interrupts so serial data reception and other important things can occur while we do some math.
	Next, we work out how long until our next step using the selected acceleration algorithm and set the timer.
	Then we decide if this was the last step for this move, and if so mark this dda as dead so next timer interrupt we can start a new one.
	Finally we de-assert any asserted step pins.
*/
void dda_step(DDA *dda) {
    1a78:	7f 92       	push	r7
    1a7a:	8f 92       	push	r8
    1a7c:	9f 92       	push	r9
    1a7e:	af 92       	push	r10
    1a80:	bf 92       	push	r11
    1a82:	cf 92       	push	r12
    1a84:	df 92       	push	r13
    1a86:	ef 92       	push	r14
    1a88:	ff 92       	push	r15
    1a8a:	0f 93       	push	r16
    1a8c:	1f 93       	push	r17
    1a8e:	cf 93       	push	r28
    1a90:	df 93       	push	r29
    1a92:	ec 01       	movw	r28, r24
	uint8_t endstop_stop; ///< Stop due to endstop trigger
	uint8_t endstop_not_done = 0; ///< Which axes haven't finished homing

#if defined X_MIN_PIN || defined X_MAX_PIN
	if (dda->endstop_check & 0x1) {
    1a94:	8a ad       	ldd	r24, Y+58	; 0x3a
    1a96:	80 ff       	sbrs	r24, 0
    1a98:	50 c2       	rjmp	.+1184   	; 0x1f3a <dda_step+0x4c2>
#if defined X_MIN_PIN
		if (x_min() == dda->endstop_stop_cond)
    1a9a:	10 91 00 01 	lds	r17, 0x0100
    1a9e:	8b ad       	ldd	r24, Y+59	; 0x3b
    1aa0:	90 e0       	ldi	r25, 0x00	; 0
    1aa2:	11 fb       	bst	r17, 1
    1aa4:	aa 27       	eor	r26, r26
    1aa6:	a0 f9       	bld	r26, 0
    1aa8:	b0 e0       	ldi	r27, 0x00	; 0
    1aaa:	a8 17       	cp	r26, r24
    1aac:	b9 07       	cpc	r27, r25
    1aae:	31 f4       	brne	.+12     	; 0x1abc <dda_step+0x44>
			move_state.debounce_count_xmin++;
    1ab0:	a0 e6       	ldi	r26, 0x60	; 96
    1ab2:	b2 e0       	ldi	r27, 0x02	; 2
    1ab4:	1c 91       	ld	r17, X
    1ab6:	1f 5f       	subi	r17, 0xFF	; 255
    1ab8:	1c 93       	st	X, r17
    1aba:	02 c0       	rjmp	.+4      	; 0x1ac0 <dda_step+0x48>
		else
			move_state.debounce_count_xmin = 0;
    1abc:	10 92 60 02 	sts	0x0260, r1
#endif

#if defined X_MAX_PIN
		if (x_max() == dda->endstop_stop_cond)
    1ac0:	a0 91 00 01 	lds	r26, 0x0100
    1ac4:	ea 2f       	mov	r30, r26
    1ac6:	e1 70       	andi	r30, 0x01	; 1
    1ac8:	f0 e0       	ldi	r31, 0x00	; 0
    1aca:	8e 17       	cp	r24, r30
    1acc:	9f 07       	cpc	r25, r31
    1ace:	31 f4       	brne	.+12     	; 0x1adc <dda_step+0x64>
			move_state.debounce_count_xmax++;
    1ad0:	e3 e6       	ldi	r30, 0x63	; 99
    1ad2:	f2 e0       	ldi	r31, 0x02	; 2
    1ad4:	80 81       	ld	r24, Z
    1ad6:	8f 5f       	subi	r24, 0xFF	; 255
    1ad8:	80 83       	st	Z, r24
    1ada:	02 c0       	rjmp	.+4      	; 0x1ae0 <dda_step+0x68>
		else
			move_state.debounce_count_xmax = 0;
    1adc:	10 92 63 02 	sts	0x0263, r1
#endif

		endstop_stop = move_state.debounce_count_xmin >= ENDSTOP_STEPS ||
    1ae0:	80 91 60 02 	lds	r24, 0x0260
    1ae4:	84 30       	cpi	r24, 0x04	; 4
    1ae6:	08 f0       	brcs	.+2      	; 0x1aea <dda_step+0x72>
    1ae8:	41 c0       	rjmp	.+130    	; 0x1b6c <dda_step+0xf4>
		               move_state.debounce_count_xmax >= ENDSTOP_STEPS;
		if (!endstop_stop)
    1aea:	80 91 63 02 	lds	r24, 0x0263
    1aee:	84 30       	cpi	r24, 0x04	; 4
    1af0:	08 f4       	brcc	.+2      	; 0x1af4 <dda_step+0x7c>
    1af2:	25 c2       	rjmp	.+1098   	; 0x1f3e <dda_step+0x4c6>
    1af4:	71 2c       	mov	r7, r1
    1af6:	3b c0       	rjmp	.+118    	; 0x1b6e <dda_step+0xf6>
#endif
		endstop_stop = 0;

#if ! defined ACCELERATION_TEMPORAL
	if ((move_state.x_steps) && ! endstop_stop) {
		move_state.x_counter -= dda->x_delta;
    1af8:	e4 e3       	ldi	r30, 0x34	; 52
    1afa:	f2 e0       	ldi	r31, 0x02	; 2
    1afc:	80 81       	ld	r24, Z
    1afe:	91 81       	ldd	r25, Z+1	; 0x01
    1b00:	a2 81       	ldd	r26, Z+2	; 0x02
    1b02:	b3 81       	ldd	r27, Z+3	; 0x03
    1b04:	ce 88       	ldd	r12, Y+22	; 0x16
    1b06:	df 88       	ldd	r13, Y+23	; 0x17
    1b08:	e8 8c       	ldd	r14, Y+24	; 0x18
    1b0a:	f9 8c       	ldd	r15, Y+25	; 0x19
    1b0c:	8c 19       	sub	r24, r12
    1b0e:	9d 09       	sbc	r25, r13
    1b10:	ae 09       	sbc	r26, r14
    1b12:	bf 09       	sbc	r27, r15
    1b14:	80 83       	st	Z, r24
    1b16:	91 83       	std	Z+1, r25	; 0x01
    1b18:	a2 83       	std	Z+2, r26	; 0x02
    1b1a:	b3 83       	std	Z+3, r27	; 0x03
		if (move_state.x_counter < 0) {
    1b1c:	bb 23       	and	r27, r27
    1b1e:	3c f5       	brge	.+78     	; 0x1b6e <dda_step+0xf6>
			//x_step();
			OCR1A=70;
    1b20:	86 e4       	ldi	r24, 0x46	; 70
    1b22:	90 e0       	ldi	r25, 0x00	; 0
    1b24:	90 93 89 00 	sts	0x0089, r25
    1b28:	80 93 88 00 	sts	0x0088, r24
			move_state.x_steps--;
    1b2c:	e4 e4       	ldi	r30, 0x44	; 68
    1b2e:	f2 e0       	ldi	r31, 0x02	; 2
    1b30:	80 81       	ld	r24, Z
    1b32:	91 81       	ldd	r25, Z+1	; 0x01
    1b34:	a2 81       	ldd	r26, Z+2	; 0x02
    1b36:	b3 81       	ldd	r27, Z+3	; 0x03
    1b38:	01 97       	sbiw	r24, 0x01	; 1
    1b3a:	a1 09       	sbc	r26, r1
    1b3c:	b1 09       	sbc	r27, r1
    1b3e:	80 83       	st	Z, r24
    1b40:	91 83       	std	Z+1, r25	; 0x01
    1b42:	a2 83       	std	Z+2, r26	; 0x02
    1b44:	b3 83       	std	Z+3, r27	; 0x03
			move_state.x_counter += dda->total_steps;
    1b46:	e4 e3       	ldi	r30, 0x34	; 52
    1b48:	f2 e0       	ldi	r31, 0x02	; 2
    1b4a:	c0 80       	ld	r12, Z
    1b4c:	d1 80       	ldd	r13, Z+1	; 0x01
    1b4e:	e2 80       	ldd	r14, Z+2	; 0x02
    1b50:	f3 80       	ldd	r15, Z+3	; 0x03
    1b52:	8e a1       	ldd	r24, Y+38	; 0x26
    1b54:	9f a1       	ldd	r25, Y+39	; 0x27
    1b56:	a8 a5       	ldd	r26, Y+40	; 0x28
    1b58:	b9 a5       	ldd	r27, Y+41	; 0x29
    1b5a:	8c 0d       	add	r24, r12
    1b5c:	9d 1d       	adc	r25, r13
    1b5e:	ae 1d       	adc	r26, r14
    1b60:	bf 1d       	adc	r27, r15
    1b62:	80 83       	st	Z, r24
    1b64:	91 83       	std	Z+1, r25	; 0x01
    1b66:	a2 83       	std	Z+2, r26	; 0x02
    1b68:	b3 83       	std	Z+3, r27	; 0x03
    1b6a:	01 c0       	rjmp	.+2      	; 0x1b6e <dda_step+0xf6>
			move_state.debounce_count_xmax++;
		else
			move_state.debounce_count_xmax = 0;
#endif

		endstop_stop = move_state.debounce_count_xmin >= ENDSTOP_STEPS ||
    1b6c:	71 2c       	mov	r7, r1
		move_state.all_time = move_state.x_time;
	}
#endif

#if defined Y_MIN_PIN || defined Y_MAX_PIN
	if (dda->endstop_check & 0x2) {
    1b6e:	1a ad       	ldd	r17, Y+58	; 0x3a
    1b70:	11 ff       	sbrs	r17, 1
    1b72:	f5 c1       	rjmp	.+1002   	; 0x1f5e <dda_step+0x4e6>
#if defined Y_MIN_PIN
		if (y_min() == dda->endstop_stop_cond)
    1b74:	e0 91 03 01 	lds	r30, 0x0103
    1b78:	8b ad       	ldd	r24, Y+59	; 0x3b
    1b7a:	90 e0       	ldi	r25, 0x00	; 0
    1b7c:	e1 fb       	bst	r30, 1
    1b7e:	44 27       	eor	r20, r20
    1b80:	40 f9       	bld	r20, 0
    1b82:	50 e0       	ldi	r21, 0x00	; 0
    1b84:	48 17       	cp	r20, r24
    1b86:	59 07       	cpc	r21, r25
    1b88:	31 f4       	brne	.+12     	; 0x1b96 <dda_step+0x11e>
			move_state.debounce_count_ymin++;
    1b8a:	e1 e6       	ldi	r30, 0x61	; 97
    1b8c:	f2 e0       	ldi	r31, 0x02	; 2
    1b8e:	40 81       	ld	r20, Z
    1b90:	4f 5f       	subi	r20, 0xFF	; 255
    1b92:	40 83       	st	Z, r20
    1b94:	02 c0       	rjmp	.+4      	; 0x1b9a <dda_step+0x122>
		else
			move_state.debounce_count_ymin = 0;
    1b96:	10 92 61 02 	sts	0x0261, r1
#endif

#if defined Y_MAX_PIN
		if (y_max() == dda->endstop_stop_cond)
    1b9a:	40 91 03 01 	lds	r20, 0x0103
    1b9e:	64 2f       	mov	r22, r20
    1ba0:	61 70       	andi	r22, 0x01	; 1
    1ba2:	70 e0       	ldi	r23, 0x00	; 0
    1ba4:	86 17       	cp	r24, r22
    1ba6:	97 07       	cpc	r25, r23
    1ba8:	31 f4       	brne	.+12     	; 0x1bb6 <dda_step+0x13e>
			move_state.debounce_count_ymax++;
    1baa:	e4 e6       	ldi	r30, 0x64	; 100
    1bac:	f2 e0       	ldi	r31, 0x02	; 2
    1bae:	80 81       	ld	r24, Z
    1bb0:	8f 5f       	subi	r24, 0xFF	; 255
    1bb2:	80 83       	st	Z, r24
    1bb4:	02 c0       	rjmp	.+4      	; 0x1bba <dda_step+0x142>
		else
			move_state.debounce_count_ymax = 0;
    1bb6:	10 92 64 02 	sts	0x0264, r1
#endif

		endstop_stop = move_state.debounce_count_ymin >= ENDSTOP_STEPS ||
    1bba:	80 91 61 02 	lds	r24, 0x0261
    1bbe:	84 30       	cpi	r24, 0x04	; 4
    1bc0:	c8 f5       	brcc	.+114    	; 0x1c34 <dda_step+0x1bc>
		               move_state.debounce_count_ymax >= ENDSTOP_STEPS;
		if (!endstop_stop)
    1bc2:	80 91 64 02 	lds	r24, 0x0264
    1bc6:	84 30       	cpi	r24, 0x04	; 4
    1bc8:	a8 f5       	brcc	.+106    	; 0x1c34 <dda_step+0x1bc>
			endstop_not_done |= 0x2;
    1bca:	02 e0       	ldi	r16, 0x02	; 2
    1bcc:	70 2a       	or	r7, r16
    1bce:	c7 c1       	rjmp	.+910    	; 0x1f5e <dda_step+0x4e6>
#endif
		endstop_stop = 0;

#if ! defined ACCELERATION_TEMPORAL
	if ((move_state.y_steps) && ! endstop_stop) {
		move_state.y_counter -= dda->y_delta;
    1bd0:	e8 e3       	ldi	r30, 0x38	; 56
    1bd2:	f2 e0       	ldi	r31, 0x02	; 2
    1bd4:	80 81       	ld	r24, Z
    1bd6:	91 81       	ldd	r25, Z+1	; 0x01
    1bd8:	a2 81       	ldd	r26, Z+2	; 0x02
    1bda:	b3 81       	ldd	r27, Z+3	; 0x03
    1bdc:	4a 8d       	ldd	r20, Y+26	; 0x1a
    1bde:	5b 8d       	ldd	r21, Y+27	; 0x1b
    1be0:	6c 8d       	ldd	r22, Y+28	; 0x1c
    1be2:	7d 8d       	ldd	r23, Y+29	; 0x1d
    1be4:	84 1b       	sub	r24, r20
    1be6:	95 0b       	sbc	r25, r21
    1be8:	a6 0b       	sbc	r26, r22
    1bea:	b7 0b       	sbc	r27, r23
    1bec:	80 83       	st	Z, r24
    1bee:	91 83       	std	Z+1, r25	; 0x01
    1bf0:	a2 83       	std	Z+2, r26	; 0x02
    1bf2:	b3 83       	std	Z+3, r27	; 0x03
		if (move_state.y_counter < 0) {
    1bf4:	bb 23       	and	r27, r27
    1bf6:	f4 f4       	brge	.+60     	; 0x1c34 <dda_step+0x1bc>
			//y_step();
			move_state.y_steps--;
    1bf8:	b7 01       	movw	r22, r14
    1bfa:	a6 01       	movw	r20, r12
    1bfc:	41 50       	subi	r20, 0x01	; 1
    1bfe:	51 09       	sbc	r21, r1
    1c00:	61 09       	sbc	r22, r1
    1c02:	71 09       	sbc	r23, r1
    1c04:	40 93 48 02 	sts	0x0248, r20
    1c08:	50 93 49 02 	sts	0x0249, r21
    1c0c:	60 93 4a 02 	sts	0x024A, r22
    1c10:	70 93 4b 02 	sts	0x024B, r23
			move_state.y_counter += dda->total_steps;
    1c14:	4e a1       	ldd	r20, Y+38	; 0x26
    1c16:	5f a1       	ldd	r21, Y+39	; 0x27
    1c18:	68 a5       	ldd	r22, Y+40	; 0x28
    1c1a:	79 a5       	ldd	r23, Y+41	; 0x29
    1c1c:	84 0f       	add	r24, r20
    1c1e:	95 1f       	adc	r25, r21
    1c20:	a6 1f       	adc	r26, r22
    1c22:	b7 1f       	adc	r27, r23
    1c24:	80 93 38 02 	sts	0x0238, r24
    1c28:	90 93 39 02 	sts	0x0239, r25
    1c2c:	a0 93 3a 02 	sts	0x023A, r26
    1c30:	b0 93 3b 02 	sts	0x023B, r27
		move_state.all_time = move_state.y_time;
	}
#endif

#if defined Z_MIN_PIN || defined Z_MAX_PIN
	if (dda->endstop_check & 0x4) {
    1c34:	12 ff       	sbrs	r17, 2
    1c36:	a2 c1       	rjmp	.+836    	; 0x1f7c <dda_step+0x504>
#if defined Z_MIN_PIN
		if (z_min() == dda->endstop_stop_cond)
    1c38:	89 b1       	in	r24, 0x09	; 9
    1c3a:	83 fb       	bst	r24, 3
    1c3c:	22 27       	eor	r18, r18
    1c3e:	20 f9       	bld	r18, 0
    1c40:	30 e0       	ldi	r19, 0x00	; 0
    1c42:	8b ad       	ldd	r24, Y+59	; 0x3b
    1c44:	90 e0       	ldi	r25, 0x00	; 0
    1c46:	28 17       	cp	r18, r24
    1c48:	39 07       	cpc	r19, r25
    1c4a:	49 f4       	brne	.+18     	; 0x1c5e <dda_step+0x1e6>
			move_state.debounce_count_zmin++;
    1c4c:	e2 e6       	ldi	r30, 0x62	; 98
    1c4e:	f2 e0       	ldi	r31, 0x02	; 2
    1c50:	80 81       	ld	r24, Z
    1c52:	8f 5f       	subi	r24, 0xFF	; 255
    1c54:	80 83       	st	Z, r24
			move_state.debounce_count_zmax++;
		else
			move_state.debounce_count_zmax = 0;
#endif

		endstop_stop = move_state.debounce_count_zmin >= ENDSTOP_STEPS ||
    1c56:	84 30       	cpi	r24, 0x04	; 4
    1c58:	08 f0       	brcs	.+2      	; 0x1c5c <dda_step+0x1e4>
    1c5a:	42 c0       	rjmp	.+132    	; 0x1ce0 <dda_step+0x268>
    1c5c:	02 c0       	rjmp	.+4      	; 0x1c62 <dda_step+0x1ea>
	if (dda->endstop_check & 0x4) {
#if defined Z_MIN_PIN
		if (z_min() == dda->endstop_stop_cond)
			move_state.debounce_count_zmin++;
		else
			move_state.debounce_count_zmin = 0;
    1c5e:	10 92 62 02 	sts	0x0262, r1
			move_state.debounce_count_zmax = 0;
#endif

		endstop_stop = move_state.debounce_count_zmin >= ENDSTOP_STEPS ||
		               move_state.debounce_count_zmax >= ENDSTOP_STEPS;
		if (!endstop_stop)
    1c62:	80 91 65 02 	lds	r24, 0x0265
    1c66:	84 30       	cpi	r24, 0x04	; 4
    1c68:	d8 f5       	brcc	.+118    	; 0x1ce0 <dda_step+0x268>
			endstop_not_done |= 0x4;
    1c6a:	14 e0       	ldi	r17, 0x04	; 4
    1c6c:	71 2a       	or	r7, r17
    1c6e:	86 c1       	rjmp	.+780    	; 0x1f7c <dda_step+0x504>
#endif
		endstop_stop = 0;

#if ! defined ACCELERATION_TEMPORAL
	if ((move_state.z_steps) && ! endstop_stop) {
		move_state.z_counter -= dda->z_delta;
    1c70:	ec e3       	ldi	r30, 0x3C	; 60
    1c72:	f2 e0       	ldi	r31, 0x02	; 2
    1c74:	80 81       	ld	r24, Z
    1c76:	91 81       	ldd	r25, Z+1	; 0x01
    1c78:	a2 81       	ldd	r26, Z+2	; 0x02
    1c7a:	b3 81       	ldd	r27, Z+3	; 0x03
    1c7c:	4e 8d       	ldd	r20, Y+30	; 0x1e
    1c7e:	5f 8d       	ldd	r21, Y+31	; 0x1f
    1c80:	68 a1       	ldd	r22, Y+32	; 0x20
    1c82:	79 a1       	ldd	r23, Y+33	; 0x21
    1c84:	84 1b       	sub	r24, r20
    1c86:	95 0b       	sbc	r25, r21
    1c88:	a6 0b       	sbc	r26, r22
    1c8a:	b7 0b       	sbc	r27, r23
    1c8c:	80 83       	st	Z, r24
    1c8e:	91 83       	std	Z+1, r25	; 0x01
    1c90:	a2 83       	std	Z+2, r26	; 0x02
    1c92:	b3 83       	std	Z+3, r27	; 0x03
		if (move_state.z_counter < 0) {
    1c94:	bb 23       	and	r27, r27
    1c96:	24 f5       	brge	.+72     	; 0x1ce0 <dda_step+0x268>
			z_step();
    1c98:	eb e0       	ldi	r30, 0x0B	; 11
    1c9a:	f1 e0       	ldi	r31, 0x01	; 1
    1c9c:	80 81       	ld	r24, Z
    1c9e:	88 60       	ori	r24, 0x08	; 8
    1ca0:	80 83       	st	Z, r24
			move_state.z_steps--;
    1ca2:	ec e4       	ldi	r30, 0x4C	; 76
    1ca4:	f2 e0       	ldi	r31, 0x02	; 2
    1ca6:	80 81       	ld	r24, Z
    1ca8:	91 81       	ldd	r25, Z+1	; 0x01
    1caa:	a2 81       	ldd	r26, Z+2	; 0x02
    1cac:	b3 81       	ldd	r27, Z+3	; 0x03
    1cae:	01 97       	sbiw	r24, 0x01	; 1
    1cb0:	a1 09       	sbc	r26, r1
    1cb2:	b1 09       	sbc	r27, r1
    1cb4:	80 83       	st	Z, r24
    1cb6:	91 83       	std	Z+1, r25	; 0x01
    1cb8:	a2 83       	std	Z+2, r26	; 0x02
    1cba:	b3 83       	std	Z+3, r27	; 0x03
			move_state.z_counter += dda->total_steps;
    1cbc:	ec e3       	ldi	r30, 0x3C	; 60
    1cbe:	f2 e0       	ldi	r31, 0x02	; 2
    1cc0:	40 81       	ld	r20, Z
    1cc2:	51 81       	ldd	r21, Z+1	; 0x01
    1cc4:	62 81       	ldd	r22, Z+2	; 0x02
    1cc6:	73 81       	ldd	r23, Z+3	; 0x03
    1cc8:	8e a1       	ldd	r24, Y+38	; 0x26
    1cca:	9f a1       	ldd	r25, Y+39	; 0x27
    1ccc:	a8 a5       	ldd	r26, Y+40	; 0x28
    1cce:	b9 a5       	ldd	r27, Y+41	; 0x29
    1cd0:	84 0f       	add	r24, r20
    1cd2:	95 1f       	adc	r25, r21
    1cd4:	a6 1f       	adc	r26, r22
    1cd6:	b7 1f       	adc	r27, r23
    1cd8:	80 83       	st	Z, r24
    1cda:	91 83       	std	Z+1, r25	; 0x01
    1cdc:	a2 83       	std	Z+2, r26	; 0x02
    1cde:	b3 83       	std	Z+3, r27	; 0x03
		move_state.all_time = move_state.z_time;
	}
#endif

#if ! defined ACCELERATION_TEMPORAL
	if (move_state.e_steps) {
    1ce0:	80 91 50 02 	lds	r24, 0x0250
    1ce4:	90 91 51 02 	lds	r25, 0x0251
    1ce8:	a0 91 52 02 	lds	r26, 0x0252
    1cec:	b0 91 53 02 	lds	r27, 0x0253
    1cf0:	89 2b       	or	r24, r25
    1cf2:	8a 2b       	or	r24, r26
    1cf4:	8b 2b       	or	r24, r27
    1cf6:	a1 f1       	breq	.+104    	; 0x1d60 <dda_step+0x2e8>
		move_state.e_counter -= dda->e_delta;
    1cf8:	e0 e4       	ldi	r30, 0x40	; 64
    1cfa:	f2 e0       	ldi	r31, 0x02	; 2
    1cfc:	80 81       	ld	r24, Z
    1cfe:	91 81       	ldd	r25, Z+1	; 0x01
    1d00:	a2 81       	ldd	r26, Z+2	; 0x02
    1d02:	b3 81       	ldd	r27, Z+3	; 0x03
    1d04:	4a a1       	ldd	r20, Y+34	; 0x22
    1d06:	5b a1       	ldd	r21, Y+35	; 0x23
    1d08:	6c a1       	ldd	r22, Y+36	; 0x24
    1d0a:	7d a1       	ldd	r23, Y+37	; 0x25
    1d0c:	84 1b       	sub	r24, r20
    1d0e:	95 0b       	sbc	r25, r21
    1d10:	a6 0b       	sbc	r26, r22
    1d12:	b7 0b       	sbc	r27, r23
    1d14:	80 83       	st	Z, r24
    1d16:	91 83       	std	Z+1, r25	; 0x01
    1d18:	a2 83       	std	Z+2, r26	; 0x02
    1d1a:	b3 83       	std	Z+3, r27	; 0x03
		if (move_state.e_counter < 0) {
    1d1c:	bb 23       	and	r27, r27
    1d1e:	04 f5       	brge	.+64     	; 0x1d60 <dda_step+0x2e8>
			e_step();
    1d20:	14 9a       	sbi	0x02, 4	; 2
			move_state.e_steps--;
    1d22:	e0 e5       	ldi	r30, 0x50	; 80
    1d24:	f2 e0       	ldi	r31, 0x02	; 2
    1d26:	80 81       	ld	r24, Z
    1d28:	91 81       	ldd	r25, Z+1	; 0x01
    1d2a:	a2 81       	ldd	r26, Z+2	; 0x02
    1d2c:	b3 81       	ldd	r27, Z+3	; 0x03
    1d2e:	01 97       	sbiw	r24, 0x01	; 1
    1d30:	a1 09       	sbc	r26, r1
    1d32:	b1 09       	sbc	r27, r1
    1d34:	80 83       	st	Z, r24
    1d36:	91 83       	std	Z+1, r25	; 0x01
    1d38:	a2 83       	std	Z+2, r26	; 0x02
    1d3a:	b3 83       	std	Z+3, r27	; 0x03
			move_state.e_counter += dda->total_steps;
    1d3c:	e0 e4       	ldi	r30, 0x40	; 64
    1d3e:	f2 e0       	ldi	r31, 0x02	; 2
    1d40:	40 81       	ld	r20, Z
    1d42:	51 81       	ldd	r21, Z+1	; 0x01
    1d44:	62 81       	ldd	r22, Z+2	; 0x02
    1d46:	73 81       	ldd	r23, Z+3	; 0x03
    1d48:	8e a1       	ldd	r24, Y+38	; 0x26
    1d4a:	9f a1       	ldd	r25, Y+39	; 0x27
    1d4c:	a8 a5       	ldd	r26, Y+40	; 0x28
    1d4e:	b9 a5       	ldd	r27, Y+41	; 0x29
    1d50:	84 0f       	add	r24, r20
    1d52:	95 1f       	adc	r25, r21
    1d54:	a6 1f       	adc	r26, r22
    1d56:	b7 1f       	adc	r27, r23
    1d58:	80 83       	st	Z, r24
    1d5a:	91 83       	std	Z+1, r25	; 0x01
    1d5c:	a2 83       	std	Z+2, r26	; 0x02
    1d5e:	b3 83       	std	Z+3, r27	; 0x03
		// Since we have sent steps to all the motors that will be stepping
		// and the rest of this function isn't so time critical, this interrupt
		// can now be interruptible by other interrupts.
		// The step interrupt is disabled before entering dda_step() to ensure
		// that we don't step again while computing the below.
		sei();
    1d60:	78 94       	sei
		//if (move_state.step_no == 0) {
		//	sersendf_P(PSTR("\r\nc %lu  c_min %lu  n %d"), dda->c, dda->c_min, move_state.n);
		//}

		recalc_speed = 0;
		if (move_state.step_no < dda->rampup_steps) {
    1d62:	c0 90 54 02 	lds	r12, 0x0254
    1d66:	d0 90 55 02 	lds	r13, 0x0255
    1d6a:	e0 90 56 02 	lds	r14, 0x0256
    1d6e:	f0 90 57 02 	lds	r15, 0x0257
    1d72:	8e a5       	ldd	r24, Y+46	; 0x2e
    1d74:	9f a5       	ldd	r25, Y+47	; 0x2f
    1d76:	a8 a9       	ldd	r26, Y+48	; 0x30
    1d78:	b9 a9       	ldd	r27, Y+49	; 0x31
    1d7a:	c8 16       	cp	r12, r24
    1d7c:	d9 06       	cpc	r13, r25
    1d7e:	ea 06       	cpc	r14, r26
    1d80:	fb 06       	cpc	r15, r27
    1d82:	f0 f4       	brcc	.+60     	; 0x1dc0 <dda_step+0x348>
			if (move_state.n < 0) // wrong ramp direction
    1d84:	80 91 5c 02 	lds	r24, 0x025C
    1d88:	90 91 5d 02 	lds	r25, 0x025D
    1d8c:	a0 91 5e 02 	lds	r26, 0x025E
    1d90:	b0 91 5f 02 	lds	r27, 0x025F
    1d94:	bb 23       	and	r27, r27
    1d96:	0c f0       	brlt	.+2      	; 0x1d9a <dda_step+0x322>
    1d98:	ff c0       	rjmp	.+510    	; 0x1f98 <dda_step+0x520>
				move_state.n = -((int32_t)2) - move_state.n;
    1d9a:	4e ef       	ldi	r20, 0xFE	; 254
    1d9c:	5f ef       	ldi	r21, 0xFF	; 255
    1d9e:	6f ef       	ldi	r22, 0xFF	; 255
    1da0:	7f ef       	ldi	r23, 0xFF	; 255
    1da2:	8a 01       	movw	r16, r20
    1da4:	9b 01       	movw	r18, r22
    1da6:	08 1b       	sub	r16, r24
    1da8:	19 0b       	sbc	r17, r25
    1daa:	2a 0b       	sbc	r18, r26
    1dac:	3b 0b       	sbc	r19, r27
    1dae:	00 93 5c 02 	sts	0x025C, r16
    1db2:	10 93 5d 02 	sts	0x025D, r17
    1db6:	20 93 5e 02 	sts	0x025E, r18
    1dba:	30 93 5f 02 	sts	0x025F, r19
    1dbe:	ec c0       	rjmp	.+472    	; 0x1f98 <dda_step+0x520>
			recalc_speed = 1;
		}
		else if (move_state.step_no >= dda->rampdown_steps) {
    1dc0:	8a a9       	ldd	r24, Y+50	; 0x32
    1dc2:	9b a9       	ldd	r25, Y+51	; 0x33
    1dc4:	ac a9       	ldd	r26, Y+52	; 0x34
    1dc6:	bd a9       	ldd	r27, Y+53	; 0x35
    1dc8:	c8 16       	cp	r12, r24
    1dca:	d9 06       	cpc	r13, r25
    1dcc:	ea 06       	cpc	r14, r26
    1dce:	fb 06       	cpc	r15, r27
    1dd0:	08 f1       	brcs	.+66     	; 0x1e14 <dda_step+0x39c>
			if (move_state.n > 0) // wrong ramp direction
    1dd2:	80 91 5c 02 	lds	r24, 0x025C
    1dd6:	90 91 5d 02 	lds	r25, 0x025D
    1dda:	a0 91 5e 02 	lds	r26, 0x025E
    1dde:	b0 91 5f 02 	lds	r27, 0x025F
    1de2:	18 16       	cp	r1, r24
    1de4:	19 06       	cpc	r1, r25
    1de6:	1a 06       	cpc	r1, r26
    1de8:	1b 06       	cpc	r1, r27
    1dea:	0c f0       	brlt	.+2      	; 0x1dee <dda_step+0x376>
    1dec:	d5 c0       	rjmp	.+426    	; 0x1f98 <dda_step+0x520>
				move_state.n = -((int32_t)2) - move_state.n;
    1dee:	4e ef       	ldi	r20, 0xFE	; 254
    1df0:	5f ef       	ldi	r21, 0xFF	; 255
    1df2:	6f ef       	ldi	r22, 0xFF	; 255
    1df4:	7f ef       	ldi	r23, 0xFF	; 255
    1df6:	8a 01       	movw	r16, r20
    1df8:	9b 01       	movw	r18, r22
    1dfa:	08 1b       	sub	r16, r24
    1dfc:	19 0b       	sbc	r17, r25
    1dfe:	2a 0b       	sbc	r18, r26
    1e00:	3b 0b       	sbc	r19, r27
    1e02:	00 93 5c 02 	sts	0x025C, r16
    1e06:	10 93 5d 02 	sts	0x025D, r17
    1e0a:	20 93 5e 02 	sts	0x025E, r18
    1e0e:	30 93 5f 02 	sts	0x025F, r19
    1e12:	c2 c0       	rjmp	.+388    	; 0x1f98 <dda_step+0x520>
			// be careful of signedness!
			move_state.c = (int32_t)move_state.c - ((int32_t)(move_state.c * 2) / (int32_t)move_state.n);
      //sersendf_P(PSTR("n:%ld; c:%ld; steps: %ld / %lu\n"), move_state.n,
      //           move_state.c, move_state.step_no, move_state.y_steps);
		}
		move_state.step_no++;
    1e14:	1f ef       	ldi	r17, 0xFF	; 255
    1e16:	c1 1a       	sub	r12, r17
    1e18:	d1 0a       	sbc	r13, r17
    1e1a:	e1 0a       	sbc	r14, r17
    1e1c:	f1 0a       	sbc	r15, r17
    1e1e:	c0 92 54 02 	sts	0x0254, r12
    1e22:	d0 92 55 02 	sts	0x0255, r13
    1e26:	e0 92 56 02 	sts	0x0256, r14
    1e2a:	f0 92 57 02 	sts	0x0257, r15
		//	sersendf_P(PSTR("\r\nc %lu  c_min %lu  n %ld"),
		//	           move_state.c, dda->c_min, move_state.n);
	#endif

	// TODO: If we stop axes individually, could we home two or more axes at the same time?
	if (dda->endstop_check != 0x0 && endstop_not_done == 0x0) {
    1e2e:	8a ad       	ldd	r24, Y+58	; 0x3a
    1e30:	88 23       	and	r24, r24
    1e32:	21 f1       	breq	.+72     	; 0x1e7c <dda_step+0x404>
    1e34:	71 10       	cpse	r7, r1
    1e36:	22 c0       	rjmp	.+68     	; 0x1e7c <dda_step+0x404>
		move_state.x_steps = move_state.y_steps = move_state.z_steps = move_state.e_steps = 0;
    1e38:	10 92 50 02 	sts	0x0250, r1
    1e3c:	10 92 51 02 	sts	0x0251, r1
    1e40:	10 92 52 02 	sts	0x0252, r1
    1e44:	10 92 53 02 	sts	0x0253, r1
    1e48:	10 92 4c 02 	sts	0x024C, r1
    1e4c:	10 92 4d 02 	sts	0x024D, r1
    1e50:	10 92 4e 02 	sts	0x024E, r1
    1e54:	10 92 4f 02 	sts	0x024F, r1
    1e58:	10 92 48 02 	sts	0x0248, r1
    1e5c:	10 92 49 02 	sts	0x0249, r1
    1e60:	10 92 4a 02 	sts	0x024A, r1
    1e64:	10 92 4b 02 	sts	0x024B, r1
    1e68:	10 92 44 02 	sts	0x0244, r1
    1e6c:	10 92 45 02 	sts	0x0245, r1
    1e70:	10 92 46 02 	sts	0x0246, r1
    1e74:	10 92 47 02 	sts	0x0247, r1
		endstops_off();
		// as we stop without ramping down, we have to re-init our ramping here
		dda_init();
    1e78:	0e 94 98 06 	call	0xd30	; 0xd30 <dda_init>
		}
		dda->c <<= 8;
	#endif

	// If there are no steps left, we have finished.
	if (move_state.x_steps == 0 && move_state.y_steps == 0 &&
    1e7c:	80 91 44 02 	lds	r24, 0x0244
    1e80:	90 91 45 02 	lds	r25, 0x0245
    1e84:	a0 91 46 02 	lds	r26, 0x0246
    1e88:	b0 91 47 02 	lds	r27, 0x0247
    1e8c:	89 2b       	or	r24, r25
    1e8e:	8a 2b       	or	r24, r26
    1e90:	8b 2b       	or	r24, r27
    1e92:	41 f5       	brne	.+80     	; 0x1ee4 <dda_step+0x46c>
    1e94:	80 91 48 02 	lds	r24, 0x0248
    1e98:	90 91 49 02 	lds	r25, 0x0249
    1e9c:	a0 91 4a 02 	lds	r26, 0x024A
    1ea0:	b0 91 4b 02 	lds	r27, 0x024B
    1ea4:	89 2b       	or	r24, r25
    1ea6:	8a 2b       	or	r24, r26
    1ea8:	8b 2b       	or	r24, r27
    1eaa:	e1 f4       	brne	.+56     	; 0x1ee4 <dda_step+0x46c>
    1eac:	80 91 4c 02 	lds	r24, 0x024C
    1eb0:	90 91 4d 02 	lds	r25, 0x024D
    1eb4:	a0 91 4e 02 	lds	r26, 0x024E
    1eb8:	b0 91 4f 02 	lds	r27, 0x024F
    1ebc:	89 2b       	or	r24, r25
    1ebe:	8a 2b       	or	r24, r26
    1ec0:	8b 2b       	or	r24, r27
    1ec2:	81 f4       	brne	.+32     	; 0x1ee4 <dda_step+0x46c>
	    move_state.z_steps == 0 && move_state.e_steps == 0) {
    1ec4:	80 91 50 02 	lds	r24, 0x0250
    1ec8:	90 91 51 02 	lds	r25, 0x0251
    1ecc:	a0 91 52 02 	lds	r26, 0x0252
    1ed0:	b0 91 53 02 	lds	r27, 0x0253
    1ed4:	89 2b       	or	r24, r25
    1ed6:	8a 2b       	or	r24, r26
    1ed8:	8b 2b       	or	r24, r27
    1eda:	21 f4       	brne	.+8      	; 0x1ee4 <dda_step+0x46c>
		dda->live = 0;
    1edc:	8d 89       	ldd	r24, Y+21	; 0x15
    1ede:	8d 7f       	andi	r24, 0xFD	; 253
    1ee0:	8d 8b       	std	Y+21, r24	; 0x15
    1ee2:	02 c0       	rjmp	.+4      	; 0x1ee8 <dda_step+0x470>
		#endif
		// z stepper is only enabled while moving
		z_disable();
	}
	else
		psu_timeout = 0;
    1ee4:	10 92 bf 04 	sts	0x04BF, r1

	#ifdef ACCELERATION_RAMPING
		// we don't hit maximum speed exactly with acceleration calculation, so limit it here
		// the nice thing about _not_ setting dda->c to dda->c_min is, the move stops at the exact same c as it started, so we have to calculate c only once for the time being
		// TODO: set timer only if dda->c has changed
		if (dda->c_min > move_state.c)
    1ee8:	ce a8       	ldd	r12, Y+54	; 0x36
    1eea:	df a8       	ldd	r13, Y+55	; 0x37
    1eec:	e8 ac       	ldd	r14, Y+56	; 0x38
    1eee:	f9 ac       	ldd	r15, Y+57	; 0x39
    1ef0:	80 91 58 02 	lds	r24, 0x0258
    1ef4:	90 91 59 02 	lds	r25, 0x0259
    1ef8:	a0 91 5a 02 	lds	r26, 0x025A
    1efc:	b0 91 5b 02 	lds	r27, 0x025B
    1f00:	8c 15       	cp	r24, r12
    1f02:	9d 05       	cpc	r25, r13
    1f04:	ae 05       	cpc	r26, r14
    1f06:	bf 05       	cpc	r27, r15
    1f08:	38 f4       	brcc	.+14     	; 0x1f18 <dda_step+0x4a0>
			setTimer(dda->c_min >> 8);
    1f0a:	99 27       	eor	r25, r25
    1f0c:	8f 2d       	mov	r24, r15
    1f0e:	7e 2d       	mov	r23, r14
    1f10:	6d 2d       	mov	r22, r13
    1f12:	0e 94 b0 29 	call	0x5360	; 0x5360 <setTimer>
    1f16:	06 c0       	rjmp	.+12     	; 0x1f24 <dda_step+0x4ac>
		else
			setTimer(move_state.c >> 8);
    1f18:	69 2f       	mov	r22, r25
    1f1a:	7a 2f       	mov	r23, r26
    1f1c:	8b 2f       	mov	r24, r27
    1f1e:	99 27       	eor	r25, r25
    1f20:	0e 94 b0 29 	call	0x5360	; 0x5360 <setTimer>
	#endif

	// turn off step outputs, hopefully they've been on long enough by now to register with the drivers
	// if not, too bad. or insert a (very!) small delay here, or fire up a spare timer or something.
	// we also hope that we don't step before the drivers register the low- limit maximum speed if you think this is a problem.
	unstep();
    1f24:	eb e0       	ldi	r30, 0x0B	; 11
    1f26:	f1 e0       	ldi	r31, 0x01	; 1
    1f28:	80 81       	ld	r24, Z
    1f2a:	87 7f       	andi	r24, 0xF7	; 247
    1f2c:	80 83       	st	Z, r24
    1f2e:	14 98       	cbi	0x02, 4	; 2
	OCR1A=0;
    1f30:	10 92 89 00 	sts	0x0089, r1
    1f34:	10 92 88 00 	sts	0x0088, r1
    1f38:	58 c0       	rjmp	.+176    	; 0x1fea <dda_step+0x572>
	Then we decide if this was the last step for this move, and if so mark this dda as dead so next timer interrupt we can start a new one.
	Finally we de-assert any asserted step pins.
*/
void dda_step(DDA *dda) {
	uint8_t endstop_stop; ///< Stop due to endstop trigger
	uint8_t endstop_not_done = 0; ///< Which axes haven't finished homing
    1f3a:	71 2c       	mov	r7, r1
    1f3c:	02 c0       	rjmp	.+4      	; 0x1f42 <dda_step+0x4ca>
#endif

		endstop_stop = move_state.debounce_count_xmin >= ENDSTOP_STEPS ||
		               move_state.debounce_count_xmax >= ENDSTOP_STEPS;
		if (!endstop_stop)
			endstop_not_done |= 0x1;
    1f3e:	77 24       	eor	r7, r7
    1f40:	73 94       	inc	r7
	} else
#endif
		endstop_stop = 0;

#if ! defined ACCELERATION_TEMPORAL
	if ((move_state.x_steps) && ! endstop_stop) {
    1f42:	80 91 44 02 	lds	r24, 0x0244
    1f46:	90 91 45 02 	lds	r25, 0x0245
    1f4a:	a0 91 46 02 	lds	r26, 0x0246
    1f4e:	b0 91 47 02 	lds	r27, 0x0247
    1f52:	89 2b       	or	r24, r25
    1f54:	8a 2b       	or	r24, r26
    1f56:	8b 2b       	or	r24, r27
    1f58:	09 f0       	breq	.+2      	; 0x1f5c <dda_step+0x4e4>
    1f5a:	ce cd       	rjmp	.-1124   	; 0x1af8 <dda_step+0x80>
    1f5c:	08 ce       	rjmp	.-1008   	; 0x1b6e <dda_step+0xf6>
	} else
#endif
		endstop_stop = 0;

#if ! defined ACCELERATION_TEMPORAL
	if ((move_state.y_steps) && ! endstop_stop) {
    1f5e:	c0 90 48 02 	lds	r12, 0x0248
    1f62:	d0 90 49 02 	lds	r13, 0x0249
    1f66:	e0 90 4a 02 	lds	r14, 0x024A
    1f6a:	f0 90 4b 02 	lds	r15, 0x024B
    1f6e:	c1 14       	cp	r12, r1
    1f70:	d1 04       	cpc	r13, r1
    1f72:	e1 04       	cpc	r14, r1
    1f74:	f1 04       	cpc	r15, r1
    1f76:	09 f0       	breq	.+2      	; 0x1f7a <dda_step+0x502>
    1f78:	2b ce       	rjmp	.-938    	; 0x1bd0 <dda_step+0x158>
    1f7a:	5c ce       	rjmp	.-840    	; 0x1c34 <dda_step+0x1bc>
	} else 
#endif
		endstop_stop = 0;

#if ! defined ACCELERATION_TEMPORAL
	if ((move_state.z_steps) && ! endstop_stop) {
    1f7c:	80 91 4c 02 	lds	r24, 0x024C
    1f80:	90 91 4d 02 	lds	r25, 0x024D
    1f84:	a0 91 4e 02 	lds	r26, 0x024E
    1f88:	b0 91 4f 02 	lds	r27, 0x024F
    1f8c:	89 2b       	or	r24, r25
    1f8e:	8a 2b       	or	r24, r26
    1f90:	8b 2b       	or	r24, r27
    1f92:	09 f0       	breq	.+2      	; 0x1f96 <dda_step+0x51e>
    1f94:	6d ce       	rjmp	.-806    	; 0x1c70 <dda_step+0x1f8>
    1f96:	a4 ce       	rjmp	.-696    	; 0x1ce0 <dda_step+0x268>
			if (move_state.n > 0) // wrong ramp direction
				move_state.n = -((int32_t)2) - move_state.n;
			recalc_speed = 1;
		}
		if (recalc_speed) {
			move_state.n += 4;
    1f98:	ec e5       	ldi	r30, 0x5C	; 92
    1f9a:	f2 e0       	ldi	r31, 0x02	; 2
    1f9c:	80 81       	ld	r24, Z
    1f9e:	91 81       	ldd	r25, Z+1	; 0x01
    1fa0:	a2 81       	ldd	r26, Z+2	; 0x02
    1fa2:	b3 81       	ldd	r27, Z+3	; 0x03
    1fa4:	9c 01       	movw	r18, r24
    1fa6:	ad 01       	movw	r20, r26
    1fa8:	2c 5f       	subi	r18, 0xFC	; 252
    1faa:	3f 4f       	sbci	r19, 0xFF	; 255
    1fac:	4f 4f       	sbci	r20, 0xFF	; 255
    1fae:	5f 4f       	sbci	r21, 0xFF	; 255
    1fb0:	20 83       	st	Z, r18
    1fb2:	31 83       	std	Z+1, r19	; 0x01
    1fb4:	42 83       	std	Z+2, r20	; 0x02
    1fb6:	53 83       	std	Z+3, r21	; 0x03
			// be careful of signedness!
			move_state.c = (int32_t)move_state.c - ((int32_t)(move_state.c * 2) / (int32_t)move_state.n);
    1fb8:	08 e5       	ldi	r16, 0x58	; 88
    1fba:	12 e0       	ldi	r17, 0x02	; 2
    1fbc:	f8 01       	movw	r30, r16
    1fbe:	80 80       	ld	r8, Z
    1fc0:	91 80       	ldd	r9, Z+1	; 0x01
    1fc2:	a2 80       	ldd	r10, Z+2	; 0x02
    1fc4:	b3 80       	ldd	r11, Z+3	; 0x03
    1fc6:	c5 01       	movw	r24, r10
    1fc8:	b4 01       	movw	r22, r8
    1fca:	66 0f       	add	r22, r22
    1fcc:	77 1f       	adc	r23, r23
    1fce:	88 1f       	adc	r24, r24
    1fd0:	99 1f       	adc	r25, r25
    1fd2:	0e 94 41 2a 	call	0x5482	; 0x5482 <__divmodsi4>
    1fd6:	82 1a       	sub	r8, r18
    1fd8:	93 0a       	sbc	r9, r19
    1fda:	a4 0a       	sbc	r10, r20
    1fdc:	b5 0a       	sbc	r11, r21
    1fde:	f8 01       	movw	r30, r16
    1fe0:	80 82       	st	Z, r8
    1fe2:	91 82       	std	Z+1, r9	; 0x01
    1fe4:	a2 82       	std	Z+2, r10	; 0x02
    1fe6:	b3 82       	std	Z+3, r11	; 0x03
    1fe8:	15 cf       	rjmp	.-470    	; 0x1e14 <dda_step+0x39c>
	// turn off step outputs, hopefully they've been on long enough by now to register with the drivers
	// if not, too bad. or insert a (very!) small delay here, or fire up a spare timer or something.
	// we also hope that we don't step before the drivers register the low- limit maximum speed if you think this is a problem.
	unstep();
	OCR1A=0;
}
    1fea:	df 91       	pop	r29
    1fec:	cf 91       	pop	r28
    1fee:	1f 91       	pop	r17
    1ff0:	0f 91       	pop	r16
    1ff2:	ff 90       	pop	r15
    1ff4:	ef 90       	pop	r14
    1ff6:	df 90       	pop	r13
    1ff8:	cf 90       	pop	r12
    1ffa:	bf 90       	pop	r11
    1ffc:	af 90       	pop	r10
    1ffe:	9f 90       	pop	r9
    2000:	8f 90       	pop	r8
    2002:	7f 90       	pop	r7
    2004:	08 95       	ret

00002006 <update_current_position>:

/// update global current_position struct
void update_current_position() {
    2006:	1f 93       	push	r17
    2008:	cf 93       	push	r28
    200a:	df 93       	push	r29
	DDA *dda = &movebuffer[mb_tail];
    200c:	c0 91 bc 04 	lds	r28, 0x04BC

	if (queue_empty()) {
    2010:	77 d4       	rcall	.+2286   	; 0x2900 <queue_empty>
    2012:	88 23       	and	r24, r24
    2014:	09 f4       	brne	.+2      	; 0x2018 <update_current_position+0x12>
    2016:	41 c0       	rjmp	.+130    	; 0x209a <update_current_position+0x94>
		current_position.X = startpoint.X;
    2018:	80 91 90 02 	lds	r24, 0x0290
    201c:	90 91 91 02 	lds	r25, 0x0291
    2020:	a0 91 92 02 	lds	r26, 0x0292
    2024:	b0 91 93 02 	lds	r27, 0x0293
    2028:	80 93 66 02 	sts	0x0266, r24
    202c:	90 93 67 02 	sts	0x0267, r25
    2030:	a0 93 68 02 	sts	0x0268, r26
    2034:	b0 93 69 02 	sts	0x0269, r27
		current_position.Y = startpoint.Y;
    2038:	80 91 94 02 	lds	r24, 0x0294
    203c:	90 91 95 02 	lds	r25, 0x0295
    2040:	a0 91 96 02 	lds	r26, 0x0296
    2044:	b0 91 97 02 	lds	r27, 0x0297
    2048:	80 93 6a 02 	sts	0x026A, r24
    204c:	90 93 6b 02 	sts	0x026B, r25
    2050:	a0 93 6c 02 	sts	0x026C, r26
    2054:	b0 93 6d 02 	sts	0x026D, r27
		current_position.Z = startpoint.Z;
    2058:	80 91 98 02 	lds	r24, 0x0298
    205c:	90 91 99 02 	lds	r25, 0x0299
    2060:	a0 91 9a 02 	lds	r26, 0x029A
    2064:	b0 91 9b 02 	lds	r27, 0x029B
    2068:	80 93 6e 02 	sts	0x026E, r24
    206c:	90 93 6f 02 	sts	0x026F, r25
    2070:	a0 93 70 02 	sts	0x0270, r26
    2074:	b0 93 71 02 	sts	0x0271, r27
		current_position.E = startpoint.E;
    2078:	80 91 9c 02 	lds	r24, 0x029C
    207c:	90 91 9d 02 	lds	r25, 0x029D
    2080:	a0 91 9e 02 	lds	r26, 0x029E
    2084:	b0 91 9f 02 	lds	r27, 0x029F
    2088:	80 93 72 02 	sts	0x0272, r24
    208c:	90 93 73 02 	sts	0x0273, r25
    2090:	a0 93 74 02 	sts	0x0274, r26
    2094:	b0 93 75 02 	sts	0x0275, r27
    2098:	43 c1       	rjmp	.+646    	; 0x2320 <__stack+0x121>
	OCR1A=0;
}

/// update global current_position struct
void update_current_position() {
	DDA *dda = &movebuffer[mb_tail];
    209a:	8c e3       	ldi	r24, 0x3C	; 60
    209c:	c8 9f       	mul	r28, r24
    209e:	e0 01       	movw	r28, r0
    20a0:	11 24       	eor	r1, r1
    20a2:	cb 55       	subi	r28, 0x5B	; 91
    20a4:	dd 4f       	sbci	r29, 0xFD	; 253
		current_position.X = startpoint.X;
		current_position.Y = startpoint.Y;
		current_position.Z = startpoint.Z;
		current_position.E = startpoint.E;
	}
	else if (dda->live) {
    20a6:	1d 89       	ldd	r17, Y+21	; 0x15
    20a8:	11 ff       	sbrs	r17, 1
    20aa:	3a c1       	rjmp	.+628    	; 0x2320 <__stack+0x121>
		if (dda->x_direction)
    20ac:	13 ff       	sbrs	r17, 3
    20ae:	23 c0       	rjmp	.+70     	; 0x20f6 <update_current_position+0xf0>
			// (STEPS_PER_M_X / 1000) is a bit inaccurate for low STEPS_PER_M numbers
			current_position.X = dda->endpoint.X -
			                     // should be: move_state.x_steps * 1000000 / STEPS_PER_M_X)
			                     // but x_steps can be like 1000000 already, so we'd overflow
			                     move_state.x_steps * 1000 / ((STEPS_PER_M_X + 500) / 1000);
    20b0:	20 91 44 02 	lds	r18, 0x0244
    20b4:	30 91 45 02 	lds	r19, 0x0245
    20b8:	40 91 46 02 	lds	r20, 0x0246
    20bc:	50 91 47 02 	lds	r21, 0x0247
    20c0:	a8 ee       	ldi	r26, 0xE8	; 232
    20c2:	b3 e0       	ldi	r27, 0x03	; 3
    20c4:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    20c8:	20 e5       	ldi	r18, 0x50	; 80
    20ca:	30 e0       	ldi	r19, 0x00	; 0
    20cc:	40 e0       	ldi	r20, 0x00	; 0
    20ce:	50 e0       	ldi	r21, 0x00	; 0
    20d0:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
		current_position.E = startpoint.E;
	}
	else if (dda->live) {
		if (dda->x_direction)
			// (STEPS_PER_M_X / 1000) is a bit inaccurate for low STEPS_PER_M numbers
			current_position.X = dda->endpoint.X -
    20d4:	88 81       	ld	r24, Y
    20d6:	99 81       	ldd	r25, Y+1	; 0x01
    20d8:	aa 81       	ldd	r26, Y+2	; 0x02
    20da:	bb 81       	ldd	r27, Y+3	; 0x03
    20dc:	82 1b       	sub	r24, r18
    20de:	93 0b       	sbc	r25, r19
    20e0:	a4 0b       	sbc	r26, r20
    20e2:	b5 0b       	sbc	r27, r21
    20e4:	80 93 66 02 	sts	0x0266, r24
    20e8:	90 93 67 02 	sts	0x0267, r25
    20ec:	a0 93 68 02 	sts	0x0268, r26
    20f0:	b0 93 69 02 	sts	0x0269, r27
    20f4:	22 c0       	rjmp	.+68     	; 0x213a <update_current_position+0x134>
			                     // should be: move_state.x_steps * 1000000 / STEPS_PER_M_X)
			                     // but x_steps can be like 1000000 already, so we'd overflow
			                     move_state.x_steps * 1000 / ((STEPS_PER_M_X + 500) / 1000);
		else
			current_position.X = dda->endpoint.X +
			                     move_state.x_steps * 1000 / ((STEPS_PER_M_X + 500) / 1000);
    20f6:	20 91 44 02 	lds	r18, 0x0244
    20fa:	30 91 45 02 	lds	r19, 0x0245
    20fe:	40 91 46 02 	lds	r20, 0x0246
    2102:	50 91 47 02 	lds	r21, 0x0247
    2106:	a8 ee       	ldi	r26, 0xE8	; 232
    2108:	b3 e0       	ldi	r27, 0x03	; 3
    210a:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    210e:	20 e5       	ldi	r18, 0x50	; 80
    2110:	30 e0       	ldi	r19, 0x00	; 0
    2112:	40 e0       	ldi	r20, 0x00	; 0
    2114:	50 e0       	ldi	r21, 0x00	; 0
    2116:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
			current_position.X = dda->endpoint.X -
			                     // should be: move_state.x_steps * 1000000 / STEPS_PER_M_X)
			                     // but x_steps can be like 1000000 already, so we'd overflow
			                     move_state.x_steps * 1000 / ((STEPS_PER_M_X + 500) / 1000);
		else
			current_position.X = dda->endpoint.X +
    211a:	88 81       	ld	r24, Y
    211c:	99 81       	ldd	r25, Y+1	; 0x01
    211e:	aa 81       	ldd	r26, Y+2	; 0x02
    2120:	bb 81       	ldd	r27, Y+3	; 0x03
    2122:	82 0f       	add	r24, r18
    2124:	93 1f       	adc	r25, r19
    2126:	a4 1f       	adc	r26, r20
    2128:	b5 1f       	adc	r27, r21
    212a:	80 93 66 02 	sts	0x0266, r24
    212e:	90 93 67 02 	sts	0x0267, r25
    2132:	a0 93 68 02 	sts	0x0268, r26
    2136:	b0 93 69 02 	sts	0x0269, r27
			                     move_state.x_steps * 1000 / ((STEPS_PER_M_X + 500) / 1000);

		if (dda->y_direction)
    213a:	14 ff       	sbrs	r17, 4
    213c:	23 c0       	rjmp	.+70     	; 0x2184 <update_current_position+0x17e>
			current_position.Y = dda->endpoint.Y -
			                     move_state.y_steps * 1000 / ((STEPS_PER_M_Y + 500) / 1000);
    213e:	20 91 48 02 	lds	r18, 0x0248
    2142:	30 91 49 02 	lds	r19, 0x0249
    2146:	40 91 4a 02 	lds	r20, 0x024A
    214a:	50 91 4b 02 	lds	r21, 0x024B
    214e:	a8 ee       	ldi	r26, 0xE8	; 232
    2150:	b3 e0       	ldi	r27, 0x03	; 3
    2152:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    2156:	20 e5       	ldi	r18, 0x50	; 80
    2158:	30 e0       	ldi	r19, 0x00	; 0
    215a:	40 e0       	ldi	r20, 0x00	; 0
    215c:	50 e0       	ldi	r21, 0x00	; 0
    215e:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
		else
			current_position.X = dda->endpoint.X +
			                     move_state.x_steps * 1000 / ((STEPS_PER_M_X + 500) / 1000);

		if (dda->y_direction)
			current_position.Y = dda->endpoint.Y -
    2162:	8c 81       	ldd	r24, Y+4	; 0x04
    2164:	9d 81       	ldd	r25, Y+5	; 0x05
    2166:	ae 81       	ldd	r26, Y+6	; 0x06
    2168:	bf 81       	ldd	r27, Y+7	; 0x07
    216a:	82 1b       	sub	r24, r18
    216c:	93 0b       	sbc	r25, r19
    216e:	a4 0b       	sbc	r26, r20
    2170:	b5 0b       	sbc	r27, r21
    2172:	80 93 6a 02 	sts	0x026A, r24
    2176:	90 93 6b 02 	sts	0x026B, r25
    217a:	a0 93 6c 02 	sts	0x026C, r26
    217e:	b0 93 6d 02 	sts	0x026D, r27
    2182:	22 c0       	rjmp	.+68     	; 0x21c8 <update_current_position+0x1c2>
			                     move_state.y_steps * 1000 / ((STEPS_PER_M_Y + 500) / 1000);
		else
			current_position.Y = dda->endpoint.Y +
			                     move_state.y_steps * 1000 / ((STEPS_PER_M_Y + 500) / 1000);
    2184:	20 91 48 02 	lds	r18, 0x0248
    2188:	30 91 49 02 	lds	r19, 0x0249
    218c:	40 91 4a 02 	lds	r20, 0x024A
    2190:	50 91 4b 02 	lds	r21, 0x024B
    2194:	a8 ee       	ldi	r26, 0xE8	; 232
    2196:	b3 e0       	ldi	r27, 0x03	; 3
    2198:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    219c:	20 e5       	ldi	r18, 0x50	; 80
    219e:	30 e0       	ldi	r19, 0x00	; 0
    21a0:	40 e0       	ldi	r20, 0x00	; 0
    21a2:	50 e0       	ldi	r21, 0x00	; 0
    21a4:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>

		if (dda->y_direction)
			current_position.Y = dda->endpoint.Y -
			                     move_state.y_steps * 1000 / ((STEPS_PER_M_Y + 500) / 1000);
		else
			current_position.Y = dda->endpoint.Y +
    21a8:	8c 81       	ldd	r24, Y+4	; 0x04
    21aa:	9d 81       	ldd	r25, Y+5	; 0x05
    21ac:	ae 81       	ldd	r26, Y+6	; 0x06
    21ae:	bf 81       	ldd	r27, Y+7	; 0x07
    21b0:	82 0f       	add	r24, r18
    21b2:	93 1f       	adc	r25, r19
    21b4:	a4 1f       	adc	r26, r20
    21b6:	b5 1f       	adc	r27, r21
    21b8:	80 93 6a 02 	sts	0x026A, r24
    21bc:	90 93 6b 02 	sts	0x026B, r25
    21c0:	a0 93 6c 02 	sts	0x026C, r26
    21c4:	b0 93 6d 02 	sts	0x026D, r27
			                     move_state.y_steps * 1000 / ((STEPS_PER_M_Y + 500) / 1000);

		if (dda->z_direction)
    21c8:	15 ff       	sbrs	r17, 5
    21ca:	23 c0       	rjmp	.+70     	; 0x2212 <__stack+0x13>
			current_position.Z = dda->endpoint.Z -
			                     move_state.z_steps * 1000 / ((STEPS_PER_M_Z + 500) / 1000);
    21cc:	20 91 4c 02 	lds	r18, 0x024C
    21d0:	30 91 4d 02 	lds	r19, 0x024D
    21d4:	40 91 4e 02 	lds	r20, 0x024E
    21d8:	50 91 4f 02 	lds	r21, 0x024F
    21dc:	a8 ee       	ldi	r26, 0xE8	; 232
    21de:	b3 e0       	ldi	r27, 0x03	; 3
    21e0:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    21e4:	26 e0       	ldi	r18, 0x06	; 6
    21e6:	3d e0       	ldi	r19, 0x0D	; 13
    21e8:	40 e0       	ldi	r20, 0x00	; 0
    21ea:	50 e0       	ldi	r21, 0x00	; 0
    21ec:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
		else
			current_position.Y = dda->endpoint.Y +
			                     move_state.y_steps * 1000 / ((STEPS_PER_M_Y + 500) / 1000);

		if (dda->z_direction)
			current_position.Z = dda->endpoint.Z -
    21f0:	88 85       	ldd	r24, Y+8	; 0x08
    21f2:	99 85       	ldd	r25, Y+9	; 0x09
    21f4:	aa 85       	ldd	r26, Y+10	; 0x0a
    21f6:	bb 85       	ldd	r27, Y+11	; 0x0b
    21f8:	82 1b       	sub	r24, r18
    21fa:	93 0b       	sbc	r25, r19
    21fc:	a4 0b       	sbc	r26, r20
    21fe:	b5 0b       	sbc	r27, r21
    2200:	80 93 6e 02 	sts	0x026E, r24
    2204:	90 93 6f 02 	sts	0x026F, r25
    2208:	a0 93 70 02 	sts	0x0270, r26
    220c:	b0 93 71 02 	sts	0x0271, r27
    2210:	22 c0       	rjmp	.+68     	; 0x2256 <__stack+0x57>
			                     move_state.z_steps * 1000 / ((STEPS_PER_M_Z + 500) / 1000);
		else
			current_position.Z = dda->endpoint.Z +
			                     move_state.z_steps * 1000 / ((STEPS_PER_M_Z + 500) / 1000);
    2212:	20 91 4c 02 	lds	r18, 0x024C
    2216:	30 91 4d 02 	lds	r19, 0x024D
    221a:	40 91 4e 02 	lds	r20, 0x024E
    221e:	50 91 4f 02 	lds	r21, 0x024F
    2222:	a8 ee       	ldi	r26, 0xE8	; 232
    2224:	b3 e0       	ldi	r27, 0x03	; 3
    2226:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    222a:	26 e0       	ldi	r18, 0x06	; 6
    222c:	3d e0       	ldi	r19, 0x0D	; 13
    222e:	40 e0       	ldi	r20, 0x00	; 0
    2230:	50 e0       	ldi	r21, 0x00	; 0
    2232:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>

		if (dda->z_direction)
			current_position.Z = dda->endpoint.Z -
			                     move_state.z_steps * 1000 / ((STEPS_PER_M_Z + 500) / 1000);
		else
			current_position.Z = dda->endpoint.Z +
    2236:	88 85       	ldd	r24, Y+8	; 0x08
    2238:	99 85       	ldd	r25, Y+9	; 0x09
    223a:	aa 85       	ldd	r26, Y+10	; 0x0a
    223c:	bb 85       	ldd	r27, Y+11	; 0x0b
    223e:	82 0f       	add	r24, r18
    2240:	93 1f       	adc	r25, r19
    2242:	a4 1f       	adc	r26, r20
    2244:	b5 1f       	adc	r27, r21
    2246:	80 93 6e 02 	sts	0x026E, r24
    224a:	90 93 6f 02 	sts	0x026F, r25
    224e:	a0 93 70 02 	sts	0x0270, r26
    2252:	b0 93 71 02 	sts	0x0271, r27
			                     move_state.z_steps * 1000 / ((STEPS_PER_M_Z + 500) / 1000);

		if (dda->endpoint.e_relative) {
    2256:	8c 89       	ldd	r24, Y+20	; 0x14
    2258:	80 ff       	sbrs	r24, 0
    225a:	1b c0       	rjmp	.+54     	; 0x2292 <__stack+0x93>
			current_position.E = move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
    225c:	20 91 50 02 	lds	r18, 0x0250
    2260:	30 91 51 02 	lds	r19, 0x0251
    2264:	40 91 52 02 	lds	r20, 0x0252
    2268:	50 91 53 02 	lds	r21, 0x0253
    226c:	a8 ee       	ldi	r26, 0xE8	; 232
    226e:	b3 e0       	ldi	r27, 0x03	; 3
    2270:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    2274:	2b e0       	ldi	r18, 0x0B	; 11
    2276:	30 e0       	ldi	r19, 0x00	; 0
    2278:	40 e0       	ldi	r20, 0x00	; 0
    227a:	50 e0       	ldi	r21, 0x00	; 0
    227c:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    2280:	20 93 72 02 	sts	0x0272, r18
    2284:	30 93 73 02 	sts	0x0273, r19
    2288:	40 93 74 02 	sts	0x0274, r20
    228c:	50 93 75 02 	sts	0x0275, r21
    2290:	47 c0       	rjmp	.+142    	; 0x2320 <__stack+0x121>
		}
		else {
			if (dda->e_direction)
    2292:	16 ff       	sbrs	r17, 6
    2294:	23 c0       	rjmp	.+70     	; 0x22dc <__stack+0xdd>
				current_position.E = dda->endpoint.E -
				                     move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
    2296:	20 91 50 02 	lds	r18, 0x0250
    229a:	30 91 51 02 	lds	r19, 0x0251
    229e:	40 91 52 02 	lds	r20, 0x0252
    22a2:	50 91 53 02 	lds	r21, 0x0253
    22a6:	a8 ee       	ldi	r26, 0xE8	; 232
    22a8:	b3 e0       	ldi	r27, 0x03	; 3
    22aa:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    22ae:	2b e0       	ldi	r18, 0x0B	; 11
    22b0:	30 e0       	ldi	r19, 0x00	; 0
    22b2:	40 e0       	ldi	r20, 0x00	; 0
    22b4:	50 e0       	ldi	r21, 0x00	; 0
    22b6:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
		if (dda->endpoint.e_relative) {
			current_position.E = move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
		}
		else {
			if (dda->e_direction)
				current_position.E = dda->endpoint.E -
    22ba:	8c 85       	ldd	r24, Y+12	; 0x0c
    22bc:	9d 85       	ldd	r25, Y+13	; 0x0d
    22be:	ae 85       	ldd	r26, Y+14	; 0x0e
    22c0:	bf 85       	ldd	r27, Y+15	; 0x0f
    22c2:	82 1b       	sub	r24, r18
    22c4:	93 0b       	sbc	r25, r19
    22c6:	a4 0b       	sbc	r26, r20
    22c8:	b5 0b       	sbc	r27, r21
    22ca:	80 93 72 02 	sts	0x0272, r24
    22ce:	90 93 73 02 	sts	0x0273, r25
    22d2:	a0 93 74 02 	sts	0x0274, r26
    22d6:	b0 93 75 02 	sts	0x0275, r27
    22da:	22 c0       	rjmp	.+68     	; 0x2320 <__stack+0x121>
				                     move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
			else
				current_position.E = dda->endpoint.E +
				                     move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
    22dc:	20 91 50 02 	lds	r18, 0x0250
    22e0:	30 91 51 02 	lds	r19, 0x0251
    22e4:	40 91 52 02 	lds	r20, 0x0252
    22e8:	50 91 53 02 	lds	r21, 0x0253
    22ec:	a8 ee       	ldi	r26, 0xE8	; 232
    22ee:	b3 e0       	ldi	r27, 0x03	; 3
    22f0:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    22f4:	2b e0       	ldi	r18, 0x0B	; 11
    22f6:	30 e0       	ldi	r19, 0x00	; 0
    22f8:	40 e0       	ldi	r20, 0x00	; 0
    22fa:	50 e0       	ldi	r21, 0x00	; 0
    22fc:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
		else {
			if (dda->e_direction)
				current_position.E = dda->endpoint.E -
				                     move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
			else
				current_position.E = dda->endpoint.E +
    2300:	8c 85       	ldd	r24, Y+12	; 0x0c
    2302:	9d 85       	ldd	r25, Y+13	; 0x0d
    2304:	ae 85       	ldd	r26, Y+14	; 0x0e
    2306:	bf 85       	ldd	r27, Y+15	; 0x0f
    2308:	82 0f       	add	r24, r18
    230a:	93 1f       	adc	r25, r19
    230c:	a4 1f       	adc	r26, r20
    230e:	b5 1f       	adc	r27, r21
    2310:	80 93 72 02 	sts	0x0272, r24
    2314:	90 93 73 02 	sts	0x0273, r25
    2318:	a0 93 74 02 	sts	0x0274, r26
    231c:	b0 93 75 02 	sts	0x0275, r27
				                     move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
		}

		// current_position.F is updated in dda_start()
	}
}
    2320:	df 91       	pop	r29
    2322:	cf 91       	pop	r28
    2324:	1f 91       	pop	r17
    2326:	08 95       	ret

00002328 <__vector_3>:

ISR(INT2_vect) 
{
    2328:	1f 92       	push	r1
    232a:	0f 92       	push	r0
    232c:	0f b6       	in	r0, 0x3f	; 63
    232e:	0f 92       	push	r0
    2330:	11 24       	eor	r1, r1
    2332:	4f 93       	push	r20
    2334:	5f 93       	push	r21
    2336:	6f 93       	push	r22
    2338:	7f 93       	push	r23
    233a:	8f 93       	push	r24
    233c:	9f 93       	push	r25
    233e:	af 93       	push	r26
    2340:	bf 93       	push	r27
	// Test transition; since the interrupt will only fire on 'rising' we don't need to read pin A
	//_XCsens=analogRead(A0);
	_XEncoderBSet = x_EncB();   // read the input pin 
    2342:	10 92 cb 04 	sts	0x04CB, r1
	_XEncoderISet = x_EncI();
    2346:	10 92 ce 04 	sts	0x04CE, r1
	#ifdef LeftEncoderIsReversed
	_XEncoderTicks -= _XEncoderBSet ? -1 : +1;
	if (_XEncoderISet == 0)
	_XEncoderIndex -= _XEncoderBSet ? -1 : +1;
	#else
	_XEncoderTicks += _XEncoderBSet ? -1 : +1;
    234a:	80 91 cb 04 	lds	r24, 0x04CB
    234e:	88 23       	and	r24, r24
    2350:	21 f0       	breq	.+8      	; 0x235a <__vector_3+0x32>
    2352:	4f ef       	ldi	r20, 0xFF	; 255
    2354:	5f ef       	ldi	r21, 0xFF	; 255
    2356:	ba 01       	movw	r22, r20
    2358:	04 c0       	rjmp	.+8      	; 0x2362 <__vector_3+0x3a>
    235a:	41 e0       	ldi	r20, 0x01	; 1
    235c:	50 e0       	ldi	r21, 0x00	; 0
    235e:	60 e0       	ldi	r22, 0x00	; 0
    2360:	70 e0       	ldi	r23, 0x00	; 0
    2362:	80 91 b8 04 	lds	r24, 0x04B8
    2366:	90 91 b9 04 	lds	r25, 0x04B9
    236a:	a0 91 ba 04 	lds	r26, 0x04BA
    236e:	b0 91 bb 04 	lds	r27, 0x04BB
    2372:	84 0f       	add	r24, r20
    2374:	95 1f       	adc	r25, r21
    2376:	a6 1f       	adc	r26, r22
    2378:	b7 1f       	adc	r27, r23
    237a:	80 93 b8 04 	sts	0x04B8, r24
    237e:	90 93 b9 04 	sts	0x04B9, r25
    2382:	a0 93 ba 04 	sts	0x04BA, r26
    2386:	b0 93 bb 04 	sts	0x04BB, r27
	#endif
}
    238a:	bf 91       	pop	r27
    238c:	af 91       	pop	r26
    238e:	9f 91       	pop	r25
    2390:	8f 91       	pop	r24
    2392:	7f 91       	pop	r23
    2394:	6f 91       	pop	r22
    2396:	5f 91       	pop	r21
    2398:	4f 91       	pop	r20
    239a:	0f 90       	pop	r0
    239c:	0f be       	out	0x3f, r0	; 63
    239e:	0f 90       	pop	r0
    23a0:	1f 90       	pop	r1
    23a2:	18 95       	reti

000023a4 <__vector_4>:

// Interrupt service routines for the right motor's quadrature encoder
ISR(INT3_vect) 
{
    23a4:	1f 92       	push	r1
    23a6:	0f 92       	push	r0
    23a8:	0f b6       	in	r0, 0x3f	; 63
    23aa:	0f 92       	push	r0
    23ac:	11 24       	eor	r1, r1
    23ae:	4f 93       	push	r20
    23b0:	5f 93       	push	r21
    23b2:	6f 93       	push	r22
    23b4:	7f 93       	push	r23
    23b6:	8f 93       	push	r24
    23b8:	9f 93       	push	r25
    23ba:	af 93       	push	r26
    23bc:	bf 93       	push	r27
	// Test transition; since the interrupt will only fire on 'rising' we don't need to read pin A
	_YEncoderBSet = y_EncB();    // read the input pin
    23be:	10 92 cc 04 	sts	0x04CC, r1
	_YEncoderISet = y_EncI();
    23c2:	10 92 cd 04 	sts	0x04CD, r1
	#ifdef RightEncoderIsReversed
	_YEncoderTicks -= _YEncoderBSet ? -1 : +1;
	if (_YEncoderISet == 0)
	_YEncoderIndex -= _YEncoderBSet ? -1 : +1;
	#else
	_YEncoderTicks += _YEncoderBSet ? -1 : +1;
    23c6:	80 91 cc 04 	lds	r24, 0x04CC
    23ca:	88 23       	and	r24, r24
    23cc:	21 f0       	breq	.+8      	; 0x23d6 <__vector_4+0x32>
    23ce:	4f ef       	ldi	r20, 0xFF	; 255
    23d0:	5f ef       	ldi	r21, 0xFF	; 255
    23d2:	ba 01       	movw	r22, r20
    23d4:	04 c0       	rjmp	.+8      	; 0x23de <__vector_4+0x3a>
    23d6:	41 e0       	ldi	r20, 0x01	; 1
    23d8:	50 e0       	ldi	r21, 0x00	; 0
    23da:	60 e0       	ldi	r22, 0x00	; 0
    23dc:	70 e0       	ldi	r23, 0x00	; 0
    23de:	80 91 b4 04 	lds	r24, 0x04B4
    23e2:	90 91 b5 04 	lds	r25, 0x04B5
    23e6:	a0 91 b6 04 	lds	r26, 0x04B6
    23ea:	b0 91 b7 04 	lds	r27, 0x04B7
    23ee:	84 0f       	add	r24, r20
    23f0:	95 1f       	adc	r25, r21
    23f2:	a6 1f       	adc	r26, r22
    23f4:	b7 1f       	adc	r27, r23
    23f6:	80 93 b4 04 	sts	0x04B4, r24
    23fa:	90 93 b5 04 	sts	0x04B5, r25
    23fe:	a0 93 b6 04 	sts	0x04B6, r26
    2402:	b0 93 b7 04 	sts	0x04B7, r27
	#endif
    2406:	bf 91       	pop	r27
    2408:	af 91       	pop	r26
    240a:	9f 91       	pop	r25
    240c:	8f 91       	pop	r24
    240e:	7f 91       	pop	r23
    2410:	6f 91       	pop	r22
    2412:	5f 91       	pop	r21
    2414:	4f 91       	pop	r20
    2416:	0f 90       	pop	r0
    2418:	0f be       	out	0x3f, r0	; 63
    241a:	0f 90       	pop	r0
    241c:	1f 90       	pop	r1
    241e:	18 95       	reti

00002420 <muldivQR>:

  Found on  http://stackoverflow.com/questions/4144232/
  how-to-calculate-a-times-b-divided-by-c-only-using-32-bit-integer-types-even-i
*/
const int32_t muldivQR(int32_t multiplicand, uint32_t qn, uint32_t rn,
                       uint32_t divisor) {
    2420:	2f 92       	push	r2
    2422:	3f 92       	push	r3
    2424:	4f 92       	push	r4
    2426:	5f 92       	push	r5
    2428:	6f 92       	push	r6
    242a:	7f 92       	push	r7
    242c:	8f 92       	push	r8
    242e:	9f 92       	push	r9
    2430:	af 92       	push	r10
    2432:	bf 92       	push	r11
    2434:	cf 92       	push	r12
    2436:	df 92       	push	r13
    2438:	ef 92       	push	r14
    243a:	ff 92       	push	r15
    243c:	0f 93       	push	r16
    243e:	1f 93       	push	r17
    2440:	cf 93       	push	r28
    2442:	df 93       	push	r29
    2444:	cd b7       	in	r28, 0x3d	; 61
    2446:	de b7       	in	r29, 0x3e	; 62
    2448:	28 97       	sbiw	r28, 0x08	; 8
    244a:	0f b6       	in	r0, 0x3f	; 63
    244c:	f8 94       	cli
    244e:	de bf       	out	0x3e, r29	; 62
    2450:	0f be       	out	0x3f, r0	; 63
    2452:	cd bf       	out	0x3d, r28	; 61
    2454:	1b 01       	movw	r2, r22
    2456:	2c 01       	movw	r4, r24
  uint32_t quotient = 0;
  uint32_t remainder = 0;
  uint8_t negative_flag = 0;

  if (multiplicand < 0) {
    2458:	99 23       	and	r25, r25
    245a:	54 f4       	brge	.+20     	; 0x2470 <muldivQR+0x50>
    negative_flag = 1;
    multiplicand = -multiplicand;
    245c:	50 94       	com	r5
    245e:	40 94       	com	r4
    2460:	30 94       	com	r3
    2462:	20 94       	com	r2
    2464:	21 1c       	adc	r2, r1
    2466:	31 1c       	adc	r3, r1
    2468:	41 1c       	adc	r4, r1
    246a:	51 1c       	adc	r5, r1
  uint32_t quotient = 0;
  uint32_t remainder = 0;
  uint8_t negative_flag = 0;

  if (multiplicand < 0) {
    negative_flag = 1;
    246c:	61 e0       	ldi	r22, 0x01	; 1
    246e:	01 c0       	rjmp	.+2      	; 0x2472 <muldivQR+0x52>
*/
const int32_t muldivQR(int32_t multiplicand, uint32_t qn, uint32_t rn,
                       uint32_t divisor) {
  uint32_t quotient = 0;
  uint32_t remainder = 0;
  uint8_t negative_flag = 0;
    2470:	60 e0       	ldi	r22, 0x00	; 0
  if (multiplicand < 0) {
    negative_flag = 1;
    multiplicand = -multiplicand;
  }

  while(multiplicand) {
    2472:	21 14       	cp	r2, r1
    2474:	31 04       	cpc	r3, r1
    2476:	41 04       	cpc	r4, r1
    2478:	51 04       	cpc	r5, r1
    247a:	09 f4       	brne	.+2      	; 0x247e <muldivQR+0x5e>
    247c:	76 c0       	rjmp	.+236    	; 0x256a <muldivQR+0x14a>
    247e:	1d 82       	std	Y+5, r1	; 0x05
    2480:	1e 82       	std	Y+6, r1	; 0x06
    2482:	1f 82       	std	Y+7, r1	; 0x07
    2484:	18 86       	std	Y+8, r1	; 0x08
    2486:	19 82       	std	Y+1, r1	; 0x01
    2488:	1a 82       	std	Y+2, r1	; 0x02
    248a:	1b 82       	std	Y+3, r1	; 0x03
    248c:	1c 82       	std	Y+4, r1	; 0x04
    if (multiplicand & 1) {
    248e:	20 fe       	sbrs	r2, 0
    2490:	32 c0       	rjmp	.+100    	; 0x24f6 <muldivQR+0xd6>
      quotient += qn;
    2492:	69 80       	ldd	r6, Y+1	; 0x01
    2494:	7a 80       	ldd	r7, Y+2	; 0x02
    2496:	8b 80       	ldd	r8, Y+3	; 0x03
    2498:	9c 80       	ldd	r9, Y+4	; 0x04
    249a:	62 0e       	add	r6, r18
    249c:	73 1e       	adc	r7, r19
    249e:	84 1e       	adc	r8, r20
    24a0:	95 1e       	adc	r9, r21
    24a2:	69 82       	std	Y+1, r6	; 0x01
    24a4:	7a 82       	std	Y+2, r7	; 0x02
    24a6:	8b 82       	std	Y+3, r8	; 0x03
    24a8:	9c 82       	std	Y+4, r9	; 0x04
      remainder += rn;
    24aa:	8d 81       	ldd	r24, Y+5	; 0x05
    24ac:	9e 81       	ldd	r25, Y+6	; 0x06
    24ae:	af 81       	ldd	r26, Y+7	; 0x07
    24b0:	b8 85       	ldd	r27, Y+8	; 0x08
    24b2:	8e 0d       	add	r24, r14
    24b4:	9f 1d       	adc	r25, r15
    24b6:	a0 1f       	adc	r26, r16
    24b8:	b1 1f       	adc	r27, r17
    24ba:	8d 83       	std	Y+5, r24	; 0x05
    24bc:	9e 83       	std	Y+6, r25	; 0x06
    24be:	af 83       	std	Y+7, r26	; 0x07
    24c0:	b8 87       	std	Y+8, r27	; 0x08
      if (remainder >= divisor) {
    24c2:	8a 15       	cp	r24, r10
    24c4:	9b 05       	cpc	r25, r11
    24c6:	ac 05       	cpc	r26, r12
    24c8:	bd 05       	cpc	r27, r13
    24ca:	a8 f0       	brcs	.+42     	; 0x24f6 <muldivQR+0xd6>
        quotient++;
    24cc:	d4 01       	movw	r26, r8
    24ce:	c3 01       	movw	r24, r6
    24d0:	01 96       	adiw	r24, 0x01	; 1
    24d2:	a1 1d       	adc	r26, r1
    24d4:	b1 1d       	adc	r27, r1
    24d6:	89 83       	std	Y+1, r24	; 0x01
    24d8:	9a 83       	std	Y+2, r25	; 0x02
    24da:	ab 83       	std	Y+3, r26	; 0x03
    24dc:	bc 83       	std	Y+4, r27	; 0x04
        remainder -= divisor;
    24de:	6d 80       	ldd	r6, Y+5	; 0x05
    24e0:	7e 80       	ldd	r7, Y+6	; 0x06
    24e2:	8f 80       	ldd	r8, Y+7	; 0x07
    24e4:	98 84       	ldd	r9, Y+8	; 0x08
    24e6:	6a 18       	sub	r6, r10
    24e8:	7b 08       	sbc	r7, r11
    24ea:	8c 08       	sbc	r8, r12
    24ec:	9d 08       	sbc	r9, r13
    24ee:	6d 82       	std	Y+5, r6	; 0x05
    24f0:	7e 82       	std	Y+6, r7	; 0x06
    24f2:	8f 82       	std	Y+7, r8	; 0x07
    24f4:	98 86       	std	Y+8, r9	; 0x08
      }
    }
    multiplicand  >>= 1;
    24f6:	55 94       	asr	r5
    24f8:	47 94       	ror	r4
    24fa:	37 94       	ror	r3
    24fc:	27 94       	ror	r2
    qn <<= 1;
    24fe:	22 0f       	add	r18, r18
    2500:	33 1f       	adc	r19, r19
    2502:	44 1f       	adc	r20, r20
    2504:	55 1f       	adc	r21, r21
    rn <<= 1;
    2506:	ee 0c       	add	r14, r14
    2508:	ff 1c       	adc	r15, r15
    250a:	00 1f       	adc	r16, r16
    250c:	11 1f       	adc	r17, r17
    if (rn >= divisor) {
    250e:	ea 14       	cp	r14, r10
    2510:	fb 04       	cpc	r15, r11
    2512:	0c 05       	cpc	r16, r12
    2514:	1d 05       	cpc	r17, r13
    2516:	40 f0       	brcs	.+16     	; 0x2528 <muldivQR+0x108>
      qn++; 
    2518:	2f 5f       	subi	r18, 0xFF	; 255
    251a:	3f 4f       	sbci	r19, 0xFF	; 255
    251c:	4f 4f       	sbci	r20, 0xFF	; 255
    251e:	5f 4f       	sbci	r21, 0xFF	; 255
      rn -= divisor;
    2520:	ea 18       	sub	r14, r10
    2522:	fb 08       	sbc	r15, r11
    2524:	0c 09       	sbc	r16, r12
    2526:	1d 09       	sbc	r17, r13
  if (multiplicand < 0) {
    negative_flag = 1;
    multiplicand = -multiplicand;
  }

  while(multiplicand) {
    2528:	21 14       	cp	r2, r1
    252a:	31 04       	cpc	r3, r1
    252c:	41 04       	cpc	r4, r1
    252e:	51 04       	cpc	r5, r1
    2530:	09 f0       	breq	.+2      	; 0x2534 <muldivQR+0x114>
    2532:	ad cf       	rjmp	.-166    	; 0x248e <muldivQR+0x6e>
      rn -= divisor;
    }
  }

  // rounding
  if (remainder > divisor / 2)
    2534:	d6 01       	movw	r26, r12
    2536:	c5 01       	movw	r24, r10
    2538:	b6 95       	lsr	r27
    253a:	a7 95       	ror	r26
    253c:	97 95       	ror	r25
    253e:	87 95       	ror	r24
    2540:	2d 81       	ldd	r18, Y+5	; 0x05
    2542:	3e 81       	ldd	r19, Y+6	; 0x06
    2544:	4f 81       	ldd	r20, Y+7	; 0x07
    2546:	58 85       	ldd	r21, Y+8	; 0x08
    2548:	82 17       	cp	r24, r18
    254a:	93 07       	cpc	r25, r19
    254c:	a4 07       	cpc	r26, r20
    254e:	b5 07       	cpc	r27, r21
    2550:	80 f4       	brcc	.+32     	; 0x2572 <muldivQR+0x152>
    quotient++;
    2552:	89 81       	ldd	r24, Y+1	; 0x01
    2554:	9a 81       	ldd	r25, Y+2	; 0x02
    2556:	ab 81       	ldd	r26, Y+3	; 0x03
    2558:	bc 81       	ldd	r27, Y+4	; 0x04
    255a:	01 96       	adiw	r24, 0x01	; 1
    255c:	a1 1d       	adc	r26, r1
    255e:	b1 1d       	adc	r27, r1
    2560:	89 83       	std	Y+1, r24	; 0x01
    2562:	9a 83       	std	Y+2, r25	; 0x02
    2564:	ab 83       	std	Y+3, r26	; 0x03
    2566:	bc 83       	std	Y+4, r27	; 0x04
    2568:	04 c0       	rjmp	.+8      	; 0x2572 <muldivQR+0x152>
  if (multiplicand < 0) {
    negative_flag = 1;
    multiplicand = -multiplicand;
  }

  while(multiplicand) {
    256a:	19 82       	std	Y+1, r1	; 0x01
    256c:	1a 82       	std	Y+2, r1	; 0x02
    256e:	1b 82       	std	Y+3, r1	; 0x03
    2570:	1c 82       	std	Y+4, r1	; 0x04
  // rounding
  if (remainder > divisor / 2)
    quotient++;

  // remainder is valid here, but not returned
  return negative_flag ? -((int32_t)quotient) : (int32_t)quotient;
    2572:	66 23       	and	r22, r22
    2574:	61 f0       	breq	.+24     	; 0x258e <muldivQR+0x16e>
    2576:	09 81       	ldd	r16, Y+1	; 0x01
    2578:	1a 81       	ldd	r17, Y+2	; 0x02
    257a:	2b 81       	ldd	r18, Y+3	; 0x03
    257c:	3c 81       	ldd	r19, Y+4	; 0x04
    257e:	30 95       	com	r19
    2580:	20 95       	com	r18
    2582:	10 95       	com	r17
    2584:	01 95       	neg	r16
    2586:	1f 4f       	sbci	r17, 0xFF	; 255
    2588:	2f 4f       	sbci	r18, 0xFF	; 255
    258a:	3f 4f       	sbci	r19, 0xFF	; 255
    258c:	04 c0       	rjmp	.+8      	; 0x2596 <muldivQR+0x176>
    258e:	09 81       	ldd	r16, Y+1	; 0x01
    2590:	1a 81       	ldd	r17, Y+2	; 0x02
    2592:	2b 81       	ldd	r18, Y+3	; 0x03
    2594:	3c 81       	ldd	r19, Y+4	; 0x04
}
    2596:	60 2f       	mov	r22, r16
    2598:	71 2f       	mov	r23, r17
    259a:	82 2f       	mov	r24, r18
    259c:	93 2f       	mov	r25, r19
    259e:	28 96       	adiw	r28, 0x08	; 8
    25a0:	0f b6       	in	r0, 0x3f	; 63
    25a2:	f8 94       	cli
    25a4:	de bf       	out	0x3e, r29	; 62
    25a6:	0f be       	out	0x3f, r0	; 63
    25a8:	cd bf       	out	0x3d, r28	; 61
    25aa:	df 91       	pop	r29
    25ac:	cf 91       	pop	r28
    25ae:	1f 91       	pop	r17
    25b0:	0f 91       	pop	r16
    25b2:	ff 90       	pop	r15
    25b4:	ef 90       	pop	r14
    25b6:	df 90       	pop	r13
    25b8:	cf 90       	pop	r12
    25ba:	bf 90       	pop	r11
    25bc:	af 90       	pop	r10
    25be:	9f 90       	pop	r9
    25c0:	8f 90       	pop	r8
    25c2:	7f 90       	pop	r7
    25c4:	6f 90       	pop	r6
    25c6:	5f 90       	pop	r5
    25c8:	4f 90       	pop	r4
    25ca:	3f 90       	pop	r3
    25cc:	2f 90       	pop	r2
    25ce:	08 95       	ret

000025d0 <approx_distance>:
  \param dy distance in Y plane
  \return 3-part linear approximation of \f$\sqrt{\Delta x^2 + \Delta y^2}\f$

  see http://www.flipcode.com/archives/Fast_Approximate_Distance_Functions.shtml
*/
uint32_t approx_distance(uint32_t dx, uint32_t dy) {
    25d0:	4f 92       	push	r4
    25d2:	5f 92       	push	r5
    25d4:	6f 92       	push	r6
    25d6:	7f 92       	push	r7
    25d8:	8f 92       	push	r8
    25da:	9f 92       	push	r9
    25dc:	af 92       	push	r10
    25de:	bf 92       	push	r11
    25e0:	cf 92       	push	r12
    25e2:	df 92       	push	r13
    25e4:	ef 92       	push	r14
    25e6:	ff 92       	push	r15
    25e8:	0f 93       	push	r16
    25ea:	1f 93       	push	r17
  uint32_t min, max, approx;

  if ( dx < dy ) {
    25ec:	62 17       	cp	r22, r18
    25ee:	73 07       	cpc	r23, r19
    25f0:	84 07       	cpc	r24, r20
    25f2:	95 07       	cpc	r25, r21
    25f4:	28 f4       	brcc	.+10     	; 0x2600 <approx_distance+0x30>
    min = dx;
    max = dy;
    25f6:	69 01       	movw	r12, r18
    25f8:	7a 01       	movw	r14, r20
*/
uint32_t approx_distance(uint32_t dx, uint32_t dy) {
  uint32_t min, max, approx;

  if ( dx < dy ) {
    min = dx;
    25fa:	4b 01       	movw	r8, r22
    25fc:	5c 01       	movw	r10, r24
    25fe:	04 c0       	rjmp	.+8      	; 0x2608 <approx_distance+0x38>
    max = dy;
  } else {
    min = dy;
    max = dx;
    2600:	6b 01       	movw	r12, r22
    2602:	7c 01       	movw	r14, r24

  if ( dx < dy ) {
    min = dx;
    max = dy;
  } else {
    min = dy;
    2604:	49 01       	movw	r8, r18
    2606:	5a 01       	movw	r10, r20
    max = dx;
  }

  approx = ( max * 1007 ) + ( min * 441 );
    2608:	a9 eb       	ldi	r26, 0xB9	; 185
    260a:	b1 e0       	ldi	r27, 0x01	; 1
    260c:	a5 01       	movw	r20, r10
    260e:	94 01       	movw	r18, r8
    2610:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    2614:	2b 01       	movw	r4, r22
    2616:	3c 01       	movw	r6, r24
    2618:	af ee       	ldi	r26, 0xEF	; 239
    261a:	b3 e0       	ldi	r27, 0x03	; 3
    261c:	a7 01       	movw	r20, r14
    261e:	96 01       	movw	r18, r12
    2620:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    2624:	93 01       	movw	r18, r6
    2626:	82 01       	movw	r16, r4
    2628:	06 0f       	add	r16, r22
    262a:	17 1f       	adc	r17, r23
    262c:	28 1f       	adc	r18, r24
    262e:	39 1f       	adc	r19, r25
  if ( max < ( min << 4 ))
    2630:	68 94       	set
    2632:	13 f8       	bld	r1, 3
    2634:	88 0c       	add	r8, r8
    2636:	99 1c       	adc	r9, r9
    2638:	aa 1c       	adc	r10, r10
    263a:	bb 1c       	adc	r11, r11
    263c:	16 94       	lsr	r1
    263e:	d1 f7       	brne	.-12     	; 0x2634 <approx_distance+0x64>
    2640:	c8 14       	cp	r12, r8
    2642:	d9 04       	cpc	r13, r9
    2644:	ea 04       	cpc	r14, r10
    2646:	fb 04       	cpc	r15, r11
    2648:	f0 f4       	brcc	.+60     	; 0x2686 <approx_distance+0xb6>
    approx -= ( max * 40 );
    264a:	cc 0c       	add	r12, r12
    264c:	dd 1c       	adc	r13, r13
    264e:	ee 1c       	adc	r14, r14
    2650:	ff 1c       	adc	r15, r15
    2652:	cc 0c       	add	r12, r12
    2654:	dd 1c       	adc	r13, r13
    2656:	ee 1c       	adc	r14, r14
    2658:	ff 1c       	adc	r15, r15
    265a:	cc 0c       	add	r12, r12
    265c:	dd 1c       	adc	r13, r13
    265e:	ee 1c       	adc	r14, r14
    2660:	ff 1c       	adc	r15, r15
    2662:	d7 01       	movw	r26, r14
    2664:	c6 01       	movw	r24, r12
    2666:	88 0f       	add	r24, r24
    2668:	99 1f       	adc	r25, r25
    266a:	aa 1f       	adc	r26, r26
    266c:	bb 1f       	adc	r27, r27
    266e:	88 0f       	add	r24, r24
    2670:	99 1f       	adc	r25, r25
    2672:	aa 1f       	adc	r26, r26
    2674:	bb 1f       	adc	r27, r27
    2676:	c8 0e       	add	r12, r24
    2678:	d9 1e       	adc	r13, r25
    267a:	ea 1e       	adc	r14, r26
    267c:	fb 1e       	adc	r15, r27
    267e:	0c 19       	sub	r16, r12
    2680:	1d 09       	sbc	r17, r13
    2682:	2e 09       	sbc	r18, r14
    2684:	3f 09       	sbc	r19, r15

  // add 512 for proper rounding
  return (( approx + 512 ) >> 10 );
    2686:	1e 5f       	subi	r17, 0xFE	; 254
    2688:	2f 4f       	sbci	r18, 0xFF	; 255
    268a:	3f 4f       	sbci	r19, 0xFF	; 255
    268c:	0f 2e       	mov	r0, r31
    268e:	fa e0       	ldi	r31, 0x0A	; 10
    2690:	36 95       	lsr	r19
    2692:	27 95       	ror	r18
    2694:	17 95       	ror	r17
    2696:	07 95       	ror	r16
    2698:	fa 95       	dec	r31
    269a:	d1 f7       	brne	.-12     	; 0x2690 <approx_distance+0xc0>
    269c:	f0 2d       	mov	r31, r0
}
    269e:	60 2f       	mov	r22, r16
    26a0:	71 2f       	mov	r23, r17
    26a2:	82 2f       	mov	r24, r18
    26a4:	93 2f       	mov	r25, r19
    26a6:	1f 91       	pop	r17
    26a8:	0f 91       	pop	r16
    26aa:	ff 90       	pop	r15
    26ac:	ef 90       	pop	r14
    26ae:	df 90       	pop	r13
    26b0:	cf 90       	pop	r12
    26b2:	bf 90       	pop	r11
    26b4:	af 90       	pop	r10
    26b6:	9f 90       	pop	r9
    26b8:	8f 90       	pop	r8
    26ba:	7f 90       	pop	r7
    26bc:	6f 90       	pop	r6
    26be:	5f 90       	pop	r5
    26c0:	4f 90       	pop	r4
    26c2:	08 95       	ret

000026c4 <approx_distance_3>:
  \param dz distance in Z plane
  \return 3-part linear approximation of \f$\sqrt{\Delta x^2 + \Delta y^2 + \Delta z^2}\f$

  see http://www.oroboro.com/rafael/docserv.php/index/programming/article/distance
*/
uint32_t approx_distance_3(uint32_t dx, uint32_t dy, uint32_t dz) {
    26c4:	4f 92       	push	r4
    26c6:	5f 92       	push	r5
    26c8:	6f 92       	push	r6
    26ca:	7f 92       	push	r7
    26cc:	8f 92       	push	r8
    26ce:	9f 92       	push	r9
    26d0:	af 92       	push	r10
    26d2:	bf 92       	push	r11
    26d4:	cf 92       	push	r12
    26d6:	df 92       	push	r13
    26d8:	ef 92       	push	r14
    26da:	ff 92       	push	r15
    26dc:	0f 93       	push	r16
    26de:	1f 93       	push	r17
    26e0:	cf 93       	push	r28
    26e2:	df 93       	push	r29
    26e4:	cd b7       	in	r28, 0x3d	; 61
    26e6:	de b7       	in	r29, 0x3e	; 62
    26e8:	28 97       	sbiw	r28, 0x08	; 8
    26ea:	0f b6       	in	r0, 0x3f	; 63
    26ec:	f8 94       	cli
    26ee:	de bf       	out	0x3e, r29	; 62
    26f0:	0f be       	out	0x3f, r0	; 63
    26f2:	cd bf       	out	0x3d, r28	; 61
  uint32_t min, med, max, approx;

  if ( dx < dy ) {
    26f4:	62 17       	cp	r22, r18
    26f6:	73 07       	cpc	r23, r19
    26f8:	84 07       	cpc	r24, r20
    26fa:	95 07       	cpc	r25, r21
    26fc:	48 f4       	brcc	.+18     	; 0x2710 <approx_distance_3+0x4c>
    min = dy;
    med = dx;
    26fe:	6d 83       	std	Y+5, r22	; 0x05
    2700:	7e 83       	std	Y+6, r23	; 0x06
    2702:	8f 83       	std	Y+7, r24	; 0x07
    2704:	98 87       	std	Y+8, r25	; 0x08
*/
uint32_t approx_distance_3(uint32_t dx, uint32_t dy, uint32_t dz) {
  uint32_t min, med, max, approx;

  if ( dx < dy ) {
    min = dy;
    2706:	29 83       	std	Y+1, r18	; 0x01
    2708:	3a 83       	std	Y+2, r19	; 0x02
    270a:	4b 83       	std	Y+3, r20	; 0x03
    270c:	5c 83       	std	Y+4, r21	; 0x04
    270e:	08 c0       	rjmp	.+16     	; 0x2720 <approx_distance_3+0x5c>
    med = dx;
  } else {
    min = dx;
    med = dy;
    2710:	2d 83       	std	Y+5, r18	; 0x05
    2712:	3e 83       	std	Y+6, r19	; 0x06
    2714:	4f 83       	std	Y+7, r20	; 0x07
    2716:	58 87       	std	Y+8, r21	; 0x08

  if ( dx < dy ) {
    min = dy;
    med = dx;
  } else {
    min = dx;
    2718:	69 83       	std	Y+1, r22	; 0x01
    271a:	7a 83       	std	Y+2, r23	; 0x02
    271c:	8b 83       	std	Y+3, r24	; 0x03
    271e:	9c 83       	std	Y+4, r25	; 0x04
    med = dy;
  }

  if ( dz < min ) {
    2720:	29 81       	ldd	r18, Y+1	; 0x01
    2722:	3a 81       	ldd	r19, Y+2	; 0x02
    2724:	4b 81       	ldd	r20, Y+3	; 0x03
    2726:	5c 81       	ldd	r21, Y+4	; 0x04
    2728:	e2 16       	cp	r14, r18
    272a:	f3 06       	cpc	r15, r19
    272c:	04 07       	cpc	r16, r20
    272e:	15 07       	cpc	r17, r21
    2730:	80 f0       	brcs	.+32     	; 0x2752 <approx_distance_3+0x8e>
    max = med;
    med = min;
    min = dz;
  } else if ( dz < med ) {
    2732:	8d 81       	ldd	r24, Y+5	; 0x05
    2734:	9e 81       	ldd	r25, Y+6	; 0x06
    2736:	af 81       	ldd	r26, Y+7	; 0x07
    2738:	b8 85       	ldd	r27, Y+8	; 0x08
    273a:	e8 16       	cp	r14, r24
    273c:	f9 06       	cpc	r15, r25
    273e:	0a 07       	cpc	r16, r26
    2740:	1b 07       	cpc	r17, r27
    2742:	c0 f4       	brcc	.+48     	; 0x2774 <approx_distance_3+0xb0>
    max = med;
    2744:	2c 01       	movw	r4, r24
    2746:	3d 01       	movw	r6, r26
    med = dz;
    2748:	ed 82       	std	Y+5, r14	; 0x05
    274a:	fe 82       	std	Y+6, r15	; 0x06
    274c:	0f 83       	std	Y+7, r16	; 0x07
    274e:	18 87       	std	Y+8, r17	; 0x08
    2750:	13 c0       	rjmp	.+38     	; 0x2778 <approx_distance_3+0xb4>
    min = dx;
    med = dy;
  }

  if ( dz < min ) {
    max = med;
    2752:	4d 80       	ldd	r4, Y+5	; 0x05
    2754:	5e 80       	ldd	r5, Y+6	; 0x06
    2756:	6f 80       	ldd	r6, Y+7	; 0x07
    2758:	78 84       	ldd	r7, Y+8	; 0x08
    med = min;
    275a:	29 81       	ldd	r18, Y+1	; 0x01
    275c:	3a 81       	ldd	r19, Y+2	; 0x02
    275e:	4b 81       	ldd	r20, Y+3	; 0x03
    2760:	5c 81       	ldd	r21, Y+4	; 0x04
    2762:	2d 83       	std	Y+5, r18	; 0x05
    2764:	3e 83       	std	Y+6, r19	; 0x06
    2766:	4f 83       	std	Y+7, r20	; 0x07
    2768:	58 87       	std	Y+8, r21	; 0x08
    min = dz;
    276a:	e9 82       	std	Y+1, r14	; 0x01
    276c:	fa 82       	std	Y+2, r15	; 0x02
    276e:	0b 83       	std	Y+3, r16	; 0x03
    2770:	1c 83       	std	Y+4, r17	; 0x04
    2772:	02 c0       	rjmp	.+4      	; 0x2778 <approx_distance_3+0xb4>
  } else if ( dz < med ) {
    max = med;
    med = dz;
  } else {
    max = dz;
    2774:	27 01       	movw	r4, r14
    2776:	38 01       	movw	r6, r16
  }

  approx = ( max * 860 ) + ( med * 851 ) + ( min * 520 );
    2778:	a3 e5       	ldi	r26, 0x53	; 83
    277a:	b3 e0       	ldi	r27, 0x03	; 3
    277c:	2d 81       	ldd	r18, Y+5	; 0x05
    277e:	3e 81       	ldd	r19, Y+6	; 0x06
    2780:	4f 81       	ldd	r20, Y+7	; 0x07
    2782:	58 85       	ldd	r21, Y+8	; 0x08
    2784:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    2788:	4b 01       	movw	r8, r22
    278a:	5c 01       	movw	r10, r24
    278c:	ac e5       	ldi	r26, 0x5C	; 92
    278e:	b3 e0       	ldi	r27, 0x03	; 3
    2790:	a3 01       	movw	r20, r6
    2792:	92 01       	movw	r18, r4
    2794:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    2798:	86 0e       	add	r8, r22
    279a:	97 1e       	adc	r9, r23
    279c:	a8 1e       	adc	r10, r24
    279e:	b9 1e       	adc	r11, r25
    27a0:	a8 e0       	ldi	r26, 0x08	; 8
    27a2:	b2 e0       	ldi	r27, 0x02	; 2
    27a4:	29 81       	ldd	r18, Y+1	; 0x01
    27a6:	3a 81       	ldd	r19, Y+2	; 0x02
    27a8:	4b 81       	ldd	r20, Y+3	; 0x03
    27aa:	5c 81       	ldd	r21, Y+4	; 0x04
    27ac:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    27b0:	86 0e       	add	r8, r22
    27b2:	97 1e       	adc	r9, r23
    27b4:	a8 1e       	adc	r10, r24
    27b6:	b9 1e       	adc	r11, r25
  if ( max < ( med << 1 )) approx -= ( max * 294 );
    27b8:	8d 81       	ldd	r24, Y+5	; 0x05
    27ba:	9e 81       	ldd	r25, Y+6	; 0x06
    27bc:	af 81       	ldd	r26, Y+7	; 0x07
    27be:	b8 85       	ldd	r27, Y+8	; 0x08
    27c0:	88 0f       	add	r24, r24
    27c2:	99 1f       	adc	r25, r25
    27c4:	aa 1f       	adc	r26, r26
    27c6:	bb 1f       	adc	r27, r27
    27c8:	48 16       	cp	r4, r24
    27ca:	59 06       	cpc	r5, r25
    27cc:	6a 06       	cpc	r6, r26
    27ce:	7b 06       	cpc	r7, r27
    27d0:	50 f4       	brcc	.+20     	; 0x27e6 <approx_distance_3+0x122>
    27d2:	a6 e2       	ldi	r26, 0x26	; 38
    27d4:	b1 e0       	ldi	r27, 0x01	; 1
    27d6:	a3 01       	movw	r20, r6
    27d8:	92 01       	movw	r18, r4
    27da:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    27de:	86 1a       	sub	r8, r22
    27e0:	97 0a       	sbc	r9, r23
    27e2:	a8 0a       	sbc	r10, r24
    27e4:	b9 0a       	sbc	r11, r25
  if ( max < ( min << 2 )) approx -= ( max * 113 );
    27e6:	89 81       	ldd	r24, Y+1	; 0x01
    27e8:	9a 81       	ldd	r25, Y+2	; 0x02
    27ea:	ab 81       	ldd	r26, Y+3	; 0x03
    27ec:	bc 81       	ldd	r27, Y+4	; 0x04
    27ee:	88 0f       	add	r24, r24
    27f0:	99 1f       	adc	r25, r25
    27f2:	aa 1f       	adc	r26, r26
    27f4:	bb 1f       	adc	r27, r27
    27f6:	88 0f       	add	r24, r24
    27f8:	99 1f       	adc	r25, r25
    27fa:	aa 1f       	adc	r26, r26
    27fc:	bb 1f       	adc	r27, r27
    27fe:	89 83       	std	Y+1, r24	; 0x01
    2800:	9a 83       	std	Y+2, r25	; 0x02
    2802:	ab 83       	std	Y+3, r26	; 0x03
    2804:	bc 83       	std	Y+4, r27	; 0x04
    2806:	48 16       	cp	r4, r24
    2808:	59 06       	cpc	r5, r25
    280a:	6a 06       	cpc	r6, r26
    280c:	7b 06       	cpc	r7, r27
    280e:	50 f4       	brcc	.+20     	; 0x2824 <approx_distance_3+0x160>
    2810:	a1 e7       	ldi	r26, 0x71	; 113
    2812:	b0 e0       	ldi	r27, 0x00	; 0
    2814:	a3 01       	movw	r20, r6
    2816:	92 01       	movw	r18, r4
    2818:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    281c:	86 1a       	sub	r8, r22
    281e:	97 0a       	sbc	r9, r23
    2820:	a8 0a       	sbc	r10, r24
    2822:	b9 0a       	sbc	r11, r25
  if ( med < ( min << 2 )) approx -= ( med *  40 );
    2824:	2d 81       	ldd	r18, Y+5	; 0x05
    2826:	3e 81       	ldd	r19, Y+6	; 0x06
    2828:	4f 81       	ldd	r20, Y+7	; 0x07
    282a:	58 85       	ldd	r21, Y+8	; 0x08
    282c:	89 81       	ldd	r24, Y+1	; 0x01
    282e:	9a 81       	ldd	r25, Y+2	; 0x02
    2830:	ab 81       	ldd	r26, Y+3	; 0x03
    2832:	bc 81       	ldd	r27, Y+4	; 0x04
    2834:	28 17       	cp	r18, r24
    2836:	39 07       	cpc	r19, r25
    2838:	4a 07       	cpc	r20, r26
    283a:	5b 07       	cpc	r21, r27
    283c:	00 f5       	brcc	.+64     	; 0x287e <approx_distance_3+0x1ba>
    283e:	69 01       	movw	r12, r18
    2840:	7a 01       	movw	r14, r20
    2842:	cc 0c       	add	r12, r12
    2844:	dd 1c       	adc	r13, r13
    2846:	ee 1c       	adc	r14, r14
    2848:	ff 1c       	adc	r15, r15
    284a:	cc 0c       	add	r12, r12
    284c:	dd 1c       	adc	r13, r13
    284e:	ee 1c       	adc	r14, r14
    2850:	ff 1c       	adc	r15, r15
    2852:	cc 0c       	add	r12, r12
    2854:	dd 1c       	adc	r13, r13
    2856:	ee 1c       	adc	r14, r14
    2858:	ff 1c       	adc	r15, r15
    285a:	d7 01       	movw	r26, r14
    285c:	c6 01       	movw	r24, r12
    285e:	88 0f       	add	r24, r24
    2860:	99 1f       	adc	r25, r25
    2862:	aa 1f       	adc	r26, r26
    2864:	bb 1f       	adc	r27, r27
    2866:	88 0f       	add	r24, r24
    2868:	99 1f       	adc	r25, r25
    286a:	aa 1f       	adc	r26, r26
    286c:	bb 1f       	adc	r27, r27
    286e:	c8 0e       	add	r12, r24
    2870:	d9 1e       	adc	r13, r25
    2872:	ea 1e       	adc	r14, r26
    2874:	fb 1e       	adc	r15, r27
    2876:	8c 18       	sub	r8, r12
    2878:	9d 08       	sbc	r9, r13
    287a:	ae 08       	sbc	r10, r14
    287c:	bf 08       	sbc	r11, r15

  // add 512 for proper rounding
  return (( approx + 512 ) >> 10 );
    287e:	92 e0       	ldi	r25, 0x02	; 2
    2880:	99 0e       	add	r9, r25
    2882:	a1 1c       	adc	r10, r1
    2884:	b1 1c       	adc	r11, r1
    2886:	07 2e       	mov	r0, r23
    2888:	7a e0       	ldi	r23, 0x0A	; 10
    288a:	b6 94       	lsr	r11
    288c:	a7 94       	ror	r10
    288e:	97 94       	ror	r9
    2890:	87 94       	ror	r8
    2892:	7a 95       	dec	r23
    2894:	d1 f7       	brne	.-12     	; 0x288a <approx_distance_3+0x1c6>
    2896:	70 2d       	mov	r23, r0
}
    2898:	68 2d       	mov	r22, r8
    289a:	79 2d       	mov	r23, r9
    289c:	8a 2d       	mov	r24, r10
    289e:	9b 2d       	mov	r25, r11
    28a0:	28 96       	adiw	r28, 0x08	; 8
    28a2:	0f b6       	in	r0, 0x3f	; 63
    28a4:	f8 94       	cli
    28a6:	de bf       	out	0x3e, r29	; 62
    28a8:	0f be       	out	0x3f, r0	; 63
    28aa:	cd bf       	out	0x3d, r28	; 61
    28ac:	df 91       	pop	r29
    28ae:	cf 91       	pop	r28
    28b0:	1f 91       	pop	r17
    28b2:	0f 91       	pop	r16
    28b4:	ff 90       	pop	r15
    28b6:	ef 90       	pop	r14
    28b8:	df 90       	pop	r13
    28ba:	cf 90       	pop	r12
    28bc:	bf 90       	pop	r11
    28be:	af 90       	pop	r10
    28c0:	9f 90       	pop	r9
    28c2:	8f 90       	pop	r8
    28c4:	7f 90       	pop	r7
    28c6:	6f 90       	pop	r6
    28c8:	5f 90       	pop	r5
    28ca:	4f 90       	pop	r4
    28cc:	08 95       	ret

000028ce <queue_full>:
DDA movebuffer[MOVEBUFFER_SIZE] __attribute__ ((__section__ (".bss")));

/// check if the queue is completely full
uint8_t queue_full() {
	MEMORY_BARRIER();
	if (mb_tail > mb_head) {
    28ce:	80 91 bc 04 	lds	r24, 0x04BC
    28d2:	20 91 bd 04 	lds	r18, 0x04BD
    28d6:	28 17       	cp	r18, r24
    28d8:	38 f4       	brcc	.+14     	; 0x28e8 <queue_full+0x1a>
		return ((mb_tail - mb_head - 1) == 0) ? 255 : 0;
    28da:	90 e0       	ldi	r25, 0x00	; 0
    28dc:	82 1b       	sub	r24, r18
    28de:	91 09       	sbc	r25, r1
    28e0:	01 97       	sbiw	r24, 0x01	; 1
    28e2:	51 f4       	brne	.+20     	; 0x28f8 <queue_full+0x2a>
    28e4:	8f ef       	ldi	r24, 0xFF	; 255
    28e6:	08 95       	ret
	} else {
		return ((mb_tail + MOVEBUFFER_SIZE - mb_head - 1) == 0) ? 255 : 0;
    28e8:	90 e0       	ldi	r25, 0x00	; 0
    28ea:	08 96       	adiw	r24, 0x08	; 8
    28ec:	82 1b       	sub	r24, r18
    28ee:	91 09       	sbc	r25, r1
    28f0:	01 97       	sbiw	r24, 0x01	; 1
    28f2:	21 f4       	brne	.+8      	; 0x28fc <queue_full+0x2e>
    28f4:	8f ef       	ldi	r24, 0xFF	; 255
    28f6:	08 95       	ret

/// check if the queue is completely full
uint8_t queue_full() {
	MEMORY_BARRIER();
	if (mb_tail > mb_head) {
		return ((mb_tail - mb_head - 1) == 0) ? 255 : 0;
    28f8:	80 e0       	ldi	r24, 0x00	; 0
    28fa:	08 95       	ret
	} else {
		return ((mb_tail + MOVEBUFFER_SIZE - mb_head - 1) == 0) ? 255 : 0;
    28fc:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    28fe:	08 95       	ret

00002900 <queue_empty>:

/// check if the queue is completely empty
uint8_t queue_empty() {
  uint8_t result;

  ATOMIC_START
    2900:	9f b7       	in	r25, 0x3f	; 63
    2902:	f8 94       	cli
    result = ((mb_tail == mb_head) && (movebuffer[mb_tail].live == 0))?255:0;
    2904:	e0 91 bc 04 	lds	r30, 0x04BC
    2908:	80 91 bd 04 	lds	r24, 0x04BD
    290c:	e8 13       	cpse	r30, r24
    290e:	0b c0       	rjmp	.+22     	; 0x2926 <queue_empty+0x26>
    2910:	8c e3       	ldi	r24, 0x3C	; 60
    2912:	e8 9f       	mul	r30, r24
    2914:	f0 01       	movw	r30, r0
    2916:	11 24       	eor	r1, r1
    2918:	e6 54       	subi	r30, 0x46	; 70
    291a:	fd 4f       	sbci	r31, 0xFD	; 253
    291c:	80 81       	ld	r24, Z
    291e:	81 ff       	sbrs	r24, 1
    2920:	04 c0       	rjmp	.+8      	; 0x292a <queue_empty+0x2a>
    2922:	80 e0       	ldi	r24, 0x00	; 0
    2924:	03 c0       	rjmp	.+6      	; 0x292c <queue_empty+0x2c>
    2926:	80 e0       	ldi	r24, 0x00	; 0
    2928:	01 c0       	rjmp	.+2      	; 0x292c <queue_empty+0x2c>
    292a:	8f ef       	ldi	r24, 0xFF	; 255
  ATOMIC_END
    292c:	9f bf       	out	0x3f, r25	; 63

	return result;
}
    292e:	08 95       	ret

00002930 <next_move>:
/// be interrupted such that it can be re-entered from within an interrupt.
/// The timer interrupt MUST be disabled on entry. This is ensured because
/// the timer was disabled at the start of the ISR or else because the current
/// move buffer was dead in the non-interrupt case (which indicates that the 
/// timer interrupt is disabled).
void next_move() {
    2930:	1f 93       	push	r17
    2932:	cf 93       	push	r28
    2934:	df 93       	push	r29
	while ((queue_empty() == 0) && (movebuffer[mb_tail].live == 0)) {
    2936:	1c e3       	ldi	r17, 0x3C	; 60
    2938:	1d c0       	rjmp	.+58     	; 0x2974 <next_move+0x44>
		// next item
		uint8_t t = mb_tail + 1;
    293a:	8f 5f       	subi	r24, 0xFF	; 255
		t &= (MOVEBUFFER_SIZE - 1);
    293c:	87 70       	andi	r24, 0x07	; 7
		DDA* current_movebuffer = &movebuffer[t];
    293e:	18 9f       	mul	r17, r24
    2940:	e0 01       	movw	r28, r0
    2942:	11 24       	eor	r1, r1
    2944:	cb 55       	subi	r28, 0x5B	; 91
    2946:	dd 4f       	sbci	r29, 0xFD	; 253
		// tail must be set before setTimer call as setTimer
		// reenables the timer interrupt, potentially exposing
		// mb_tail to the timer interrupt routine. 
		mb_tail = t;
    2948:	80 93 bc 04 	sts	0x04BC, r24
		if (current_movebuffer->waitfor_temp) {
    294c:	8d 89       	ldd	r24, Y+21	; 0x15
    294e:	82 ff       	sbrs	r24, 2
    2950:	0e c0       	rjmp	.+28     	; 0x296e <next_move+0x3e>
			serial_writestr_P(PSTR("Waiting for target temp\n"));
    2952:	86 ee       	ldi	r24, 0xE6	; 230
    2954:	93 e0       	ldi	r25, 0x03	; 3
    2956:	0e 94 0c 25 	call	0x4a18	; 0x4a18 <serial_writestr_P>
			current_movebuffer->live = 1;
    295a:	8d 89       	ldd	r24, Y+21	; 0x15
    295c:	82 60       	ori	r24, 0x02	; 2
    295e:	8d 8b       	std	Y+21, r24	; 0x15
			setTimer(HEATER_WAIT_TIMEOUT);
    2960:	60 e0       	ldi	r22, 0x00	; 0
    2962:	74 e2       	ldi	r23, 0x24	; 36
    2964:	84 ef       	ldi	r24, 0xF4	; 244
    2966:	90 e0       	ldi	r25, 0x00	; 0
    2968:	0e 94 b0 29 	call	0x5360	; 0x5360 <setTimer>
    296c:	03 c0       	rjmp	.+6      	; 0x2974 <next_move+0x44>
		}
		else {
			dda_start(current_movebuffer);
    296e:	ce 01       	movw	r24, r28
    2970:	0e 94 a5 0c 	call	0x194a	; 0x194a <dda_start>
/// The timer interrupt MUST be disabled on entry. This is ensured because
/// the timer was disabled at the start of the ISR or else because the current
/// move buffer was dead in the non-interrupt case (which indicates that the 
/// timer interrupt is disabled).
void next_move() {
	while ((queue_empty() == 0) && (movebuffer[mb_tail].live == 0)) {
    2974:	c5 df       	rcall	.-118    	; 0x2900 <queue_empty>
    2976:	81 11       	cpse	r24, r1
    2978:	0a c0       	rjmp	.+20     	; 0x298e <next_move+0x5e>
    297a:	80 91 bc 04 	lds	r24, 0x04BC
    297e:	18 9f       	mul	r17, r24
    2980:	f0 01       	movw	r30, r0
    2982:	11 24       	eor	r1, r1
    2984:	e6 54       	subi	r30, 0x46	; 70
    2986:	fd 4f       	sbci	r31, 0xFD	; 253
    2988:	90 81       	ld	r25, Z
    298a:	91 ff       	sbrs	r25, 1
    298c:	d6 cf       	rjmp	.-84     	; 0x293a <next_move+0xa>
		}
		else {
			dda_start(current_movebuffer);
		}
	} 
}
    298e:	df 91       	pop	r29
    2990:	cf 91       	pop	r28
    2992:	1f 91       	pop	r17
    2994:	08 95       	ret

00002996 <enqueue_home>:
}

/// add a move to the movebuffer
/// \note this function waits for space to be available if necessary, check queue_full() first if waiting is a problem
/// This is the only function that modifies mb_head and it always called from outside an interrupt.
void enqueue_home(TARGET *t, uint8_t endstop_check, uint8_t endstop_stop_cond) {
    2996:	df 92       	push	r13
    2998:	ef 92       	push	r14
    299a:	ff 92       	push	r15
    299c:	0f 93       	push	r16
    299e:	1f 93       	push	r17
    29a0:	cf 93       	push	r28
    29a2:	df 93       	push	r29
    29a4:	8c 01       	movw	r16, r24
    29a6:	d6 2e       	mov	r13, r22
    29a8:	e4 2e       	mov	r14, r20
	// don't call this function when the queue is full, but just in case, wait for a move to complete and free up the space for the passed target
	while (queue_full())
    29aa:	03 c0       	rjmp	.+6      	; 0x29b2 <enqueue_home+0x1c>
		delay_us(100);
    29ac:	84 e6       	ldi	r24, 0x64	; 100
    29ae:	90 e0       	ldi	r25, 0x00	; 0
    29b0:	b2 d0       	rcall	.+356    	; 0x2b16 <delay_us>
/// add a move to the movebuffer
/// \note this function waits for space to be available if necessary, check queue_full() first if waiting is a problem
/// This is the only function that modifies mb_head and it always called from outside an interrupt.
void enqueue_home(TARGET *t, uint8_t endstop_check, uint8_t endstop_stop_cond) {
	// don't call this function when the queue is full, but just in case, wait for a move to complete and free up the space for the passed target
	while (queue_full())
    29b2:	8d df       	rcall	.-230    	; 0x28ce <queue_full>
    29b4:	81 11       	cpse	r24, r1
    29b6:	fa cf       	rjmp	.-12     	; 0x29ac <enqueue_home+0x16>
		delay_us(100);

	uint8_t h = mb_head + 1;
    29b8:	f0 90 bd 04 	lds	r15, 0x04BD
    29bc:	8f 2d       	mov	r24, r15
    29be:	8f 5f       	subi	r24, 0xFF	; 255
	h &= (MOVEBUFFER_SIZE - 1);
    29c0:	0f 2e       	mov	r0, r31
    29c2:	f7 e0       	ldi	r31, 0x07	; 7
    29c4:	ff 2e       	mov	r15, r31
    29c6:	f0 2d       	mov	r31, r0
    29c8:	f8 22       	and	r15, r24

	DDA* new_movebuffer = &(movebuffer[h]);
    29ca:	2c e3       	ldi	r18, 0x3C	; 60
    29cc:	f2 9e       	mul	r15, r18
    29ce:	e0 01       	movw	r28, r0
    29d0:	11 24       	eor	r1, r1
    29d2:	cb 55       	subi	r28, 0x5B	; 91
    29d4:	dd 4f       	sbci	r29, 0xFD	; 253
  DDA* prev_movebuffer = (queue_empty() != 0) ? NULL : &movebuffer[mb_head];
    29d6:	94 df       	rcall	.-216    	; 0x2900 <queue_empty>
    29d8:	81 11       	cpse	r24, r1
    29da:	0a c0       	rjmp	.+20     	; 0x29f0 <enqueue_home+0x5a>
    29dc:	80 91 bd 04 	lds	r24, 0x04BD
    29e0:	2c e3       	ldi	r18, 0x3C	; 60
    29e2:	82 9f       	mul	r24, r18
    29e4:	c0 01       	movw	r24, r0
    29e6:	11 24       	eor	r1, r1
    29e8:	ac 01       	movw	r20, r24
    29ea:	4b 55       	subi	r20, 0x5B	; 91
    29ec:	5d 4f       	sbci	r21, 0xFD	; 253
    29ee:	02 c0       	rjmp	.+4      	; 0x29f4 <enqueue_home+0x5e>
    29f0:	40 e0       	ldi	r20, 0x00	; 0
    29f2:	50 e0       	ldi	r21, 0x00	; 0

  if (t != NULL) {
    29f4:	01 15       	cp	r16, r1
    29f6:	11 05       	cpc	r17, r1
    29f8:	39 f0       	breq	.+14     	; 0x2a08 <enqueue_home+0x72>
    dda_create(new_movebuffer, t, prev_movebuffer);
    29fa:	b8 01       	movw	r22, r16
    29fc:	ce 01       	movw	r24, r28
    29fe:	0e 94 86 07 	call	0xf0c	; 0xf0c <dda_create>
		new_movebuffer->endstop_check = endstop_check;
    2a02:	da ae       	std	Y+58, r13	; 0x3a
		new_movebuffer->endstop_stop_cond = endstop_stop_cond;
    2a04:	eb ae       	std	Y+59, r14	; 0x3b
    2a06:	04 c0       	rjmp	.+8      	; 0x2a10 <enqueue_home+0x7a>
	}
	else {
		// it's a wait for temp
		new_movebuffer->waitfor_temp = 1;
    2a08:	8d 89       	ldd	r24, Y+21	; 0x15
		new_movebuffer->nullmove = 0;
    2a0a:	84 60       	ori	r24, 0x04	; 4
    2a0c:	8e 7f       	andi	r24, 0xFE	; 254
    2a0e:	8d 8b       	std	Y+21, r24	; 0x15

	// make certain all writes to global memory
	// are flushed before modifying mb_head.
	MEMORY_BARRIER();

	mb_head = h;
    2a10:	f0 92 bd 04 	sts	0x04BD, r15

  uint8_t isdead;

  ATOMIC_START
    2a14:	9f b7       	in	r25, 0x3f	; 63
    2a16:	f8 94       	cli
    isdead = (movebuffer[mb_tail].live == 0);
    2a18:	e0 91 bc 04 	lds	r30, 0x04BC
    2a1c:	8c e3       	ldi	r24, 0x3C	; 60
    2a1e:	e8 9f       	mul	r30, r24
    2a20:	f0 01       	movw	r30, r0
    2a22:	11 24       	eor	r1, r1
    2a24:	e6 54       	subi	r30, 0x46	; 70
    2a26:	fd 4f       	sbci	r31, 0xFD	; 253
    2a28:	80 81       	ld	r24, Z
    2a2a:	86 95       	lsr	r24
    2a2c:	81 70       	andi	r24, 0x01	; 1
  ATOMIC_END
    2a2e:	9f bf       	out	0x3f, r25	; 63

	if (isdead) {
    2a30:	81 11       	cpse	r24, r1
    2a32:	02 c0       	rjmp	.+4      	; 0x2a38 <enqueue_home+0xa2>
		next_move();
    2a34:	7d df       	rcall	.-262    	; 0x2930 <next_move>
		// Compensate for the cli() in setTimer().
		sei();
    2a36:	78 94       	sei
	}
}
    2a38:	df 91       	pop	r29
    2a3a:	cf 91       	pop	r28
    2a3c:	1f 91       	pop	r17
    2a3e:	0f 91       	pop	r16
    2a40:	ff 90       	pop	r15
    2a42:	ef 90       	pop	r14
    2a44:	df 90       	pop	r13
    2a46:	08 95       	ret

00002a48 <queue_step>:
// -------------------------------------------------------
// This is the one function called by the timer interrupt.
// It calls a few other functions, though.
// -------------------------------------------------------
/// Take a step or go to the next move.
void queue_step() {
    2a48:	cf 93       	push	r28
    2a4a:	df 93       	push	r29
	// do our next step
	DDA* current_movebuffer = &movebuffer[mb_tail];
    2a4c:	c0 91 bc 04 	lds	r28, 0x04BC
    2a50:	8c e3       	ldi	r24, 0x3C	; 60
    2a52:	c8 9f       	mul	r28, r24
    2a54:	e0 01       	movw	r28, r0
    2a56:	11 24       	eor	r1, r1
    2a58:	cb 55       	subi	r28, 0x5B	; 91
    2a5a:	dd 4f       	sbci	r29, 0xFD	; 253
	if (current_movebuffer->live) {
    2a5c:	8d 89       	ldd	r24, Y+21	; 0x15
    2a5e:	81 ff       	sbrs	r24, 1
    2a60:	1a c0       	rjmp	.+52     	; 0x2a96 <queue_step+0x4e>
		if (current_movebuffer->waitfor_temp) {
    2a62:	82 ff       	sbrs	r24, 2
    2a64:	13 c0       	rjmp	.+38     	; 0x2a8c <queue_step+0x44>
			setTimer(HEATER_WAIT_TIMEOUT);
    2a66:	60 e0       	ldi	r22, 0x00	; 0
    2a68:	74 e2       	ldi	r23, 0x24	; 36
    2a6a:	84 ef       	ldi	r24, 0xF4	; 244
    2a6c:	90 e0       	ldi	r25, 0x00	; 0
    2a6e:	0e 94 b0 29 	call	0x5360	; 0x5360 <setTimer>
			if (temp_achieved()) {
    2a72:	0e 94 a0 28 	call	0x5140	; 0x5140 <temp_achieved>
    2a76:	88 23       	and	r24, r24
    2a78:	61 f0       	breq	.+24     	; 0x2a92 <queue_step+0x4a>
				current_movebuffer->live = current_movebuffer->waitfor_temp = 0;
    2a7a:	8d 89       	ldd	r24, Y+21	; 0x15
    2a7c:	8b 7f       	andi	r24, 0xFB	; 251
    2a7e:	8d 7f       	andi	r24, 0xFD	; 253
    2a80:	8d 8b       	std	Y+21, r24	; 0x15
				serial_writestr_P(PSTR("Temp achieved\n"));
    2a82:	87 ed       	ldi	r24, 0xD7	; 215
    2a84:	93 e0       	ldi	r25, 0x03	; 3
    2a86:	0e 94 0c 25 	call	0x4a18	; 0x4a18 <serial_writestr_P>
    2a8a:	03 c0       	rjmp	.+6      	; 0x2a92 <queue_step+0x4a>
			}
		}
		else {
			// NOTE: dda_step makes this interrupt interruptible for some time,
			//       see STEP_INTERRUPT_INTERRUPTIBLE.
			dda_step(current_movebuffer);
    2a8c:	ce 01       	movw	r24, r28
    2a8e:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <dda_step>
		}
	}

	// fall directly into dda_start instead of waiting for another step
	// the dda dies not directly after its last step, but when the timer fires and there's no steps to do
	if (current_movebuffer->live == 0)
    2a92:	8d 89       	ldd	r24, Y+21	; 0x15
    2a94:	81 ff       	sbrs	r24, 1
		next_move();
    2a96:	4c df       	rcall	.-360    	; 0x2930 <next_move>
}
    2a98:	df 91       	pop	r29
    2a9a:	cf 91       	pop	r28
    2a9c:	08 95       	ret

00002a9e <print_queue>:
}

/// DEBUG - print queue.
/// Qt/hs format, t is tail, h is head, s is F/full, E/empty or neither
void print_queue() {
	sersendf_P(PSTR("Q%d/%d%c"), mb_tail, mb_head, (queue_full()?'F':(queue_empty()?'E':' ')));
    2a9e:	17 df       	rcall	.-466    	; 0x28ce <queue_full>
    2aa0:	81 11       	cpse	r24, r1
    2aa2:	06 c0       	rjmp	.+12     	; 0x2ab0 <print_queue+0x12>
    2aa4:	2d df       	rcall	.-422    	; 0x2900 <queue_empty>
    2aa6:	88 23       	and	r24, r24
    2aa8:	31 f0       	breq	.+12     	; 0x2ab6 <print_queue+0x18>
    2aaa:	85 e4       	ldi	r24, 0x45	; 69
    2aac:	90 e0       	ldi	r25, 0x00	; 0
    2aae:	05 c0       	rjmp	.+10     	; 0x2aba <print_queue+0x1c>
    2ab0:	86 e4       	ldi	r24, 0x46	; 70
    2ab2:	90 e0       	ldi	r25, 0x00	; 0
    2ab4:	02 c0       	rjmp	.+4      	; 0x2aba <print_queue+0x1c>
    2ab6:	80 e2       	ldi	r24, 0x20	; 32
    2ab8:	90 e0       	ldi	r25, 0x00	; 0
    2aba:	9f 93       	push	r25
    2abc:	8f 93       	push	r24
    2abe:	80 91 bd 04 	lds	r24, 0x04BD
    2ac2:	1f 92       	push	r1
    2ac4:	8f 93       	push	r24
    2ac6:	80 91 bc 04 	lds	r24, 0x04BC
    2aca:	1f 92       	push	r1
    2acc:	8f 93       	push	r24
    2ace:	8f ef       	ldi	r24, 0xFF	; 255
    2ad0:	93 e0       	ldi	r25, 0x03	; 3
    2ad2:	9f 93       	push	r25
    2ad4:	8f 93       	push	r24
    2ad6:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
    2ada:	8d b7       	in	r24, 0x3d	; 61
    2adc:	9e b7       	in	r25, 0x3e	; 62
    2ade:	08 96       	adiw	r24, 0x08	; 8
    2ae0:	0f b6       	in	r0, 0x3f	; 63
    2ae2:	f8 94       	cli
    2ae4:	9e bf       	out	0x3e, r25	; 62
    2ae6:	0f be       	out	0x3f, r0	; 63
    2ae8:	8d bf       	out	0x3d, r24	; 61
    2aea:	08 95       	ret

00002aec <queue_flush>:
/// \todo effect on startpoint is undefined!
void queue_flush() {

  // if the timer were running, this would require
  // wrapping in ATOMIC_START ... ATOMIC_END.
  mb_tail = mb_head;
    2aec:	e0 91 bd 04 	lds	r30, 0x04BD
    2af0:	e0 93 bc 04 	sts	0x04BC, r30
  movebuffer[mb_head].live = 0;
    2af4:	8c e3       	ldi	r24, 0x3C	; 60
    2af6:	e8 9f       	mul	r30, r24
    2af8:	f0 01       	movw	r30, r0
    2afa:	11 24       	eor	r1, r1
    2afc:	e6 54       	subi	r30, 0x46	; 70
    2afe:	fd 4f       	sbci	r31, 0xFD	; 253
    2b00:	80 81       	ld	r24, Z
    2b02:	8d 7f       	andi	r24, 0xFD	; 253
    2b04:	80 83       	st	Z, r24
    2b06:	08 95       	ret

00002b08 <queue_wait>:
}

/// wait for queue to empty
void queue_wait() {
	while (queue_empty() == 0)
    2b08:	02 c0       	rjmp	.+4      	; 0x2b0e <queue_wait+0x6>
		clock();
    2b0a:	0e 94 62 05 	call	0xac4	; 0xac4 <clock>
  movebuffer[mb_head].live = 0;
}

/// wait for queue to empty
void queue_wait() {
	while (queue_empty() == 0)
    2b0e:	f8 de       	rcall	.-528    	; 0x2900 <queue_empty>
    2b10:	88 23       	and	r24, r24
    2b12:	d9 f3       	breq	.-10     	; 0x2b0a <queue_wait+0x2>
		clock();
}
    2b14:	08 95       	ret

00002b16 <delay_us>:

/// delay microseconds
/// \param delay time to wait in microseconds
void delay_us(uint16_t delay) {
	wd_reset();
	while (delay > (65536L / (F_CPU / 4000000L))) {
    2b16:	81 30       	cpi	r24, 0x01	; 1
    2b18:	20 e4       	ldi	r18, 0x40	; 64
    2b1a:	92 07       	cpc	r25, r18
    2b1c:	f8 f0       	brcs	.+62     	; 0x2b5c <delay_us+0x46>
    2b1e:	9c 01       	movw	r18, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2b20:	4e ef       	ldi	r20, 0xFE	; 254
    2b22:	5f ef       	ldi	r21, 0xFF	; 255
    2b24:	fa 01       	movw	r30, r20
    2b26:	31 97       	sbiw	r30, 0x01	; 1
    2b28:	f1 f7       	brne	.-4      	; 0x2b26 <delay_us+0x10>
		_delay_loop_2(65534); // we use 65534 here to compensate for the time that the surrounding loop takes. TODO: exact figure needs tuning
		delay -= (65536L / (F_CPU / 4000000L));
    2b2a:	30 54       	subi	r19, 0x40	; 64

/// delay microseconds
/// \param delay time to wait in microseconds
void delay_us(uint16_t delay) {
	wd_reset();
	while (delay > (65536L / (F_CPU / 4000000L))) {
    2b2c:	21 30       	cpi	r18, 0x01	; 1
    2b2e:	60 e4       	ldi	r22, 0x40	; 64
    2b30:	36 07       	cpc	r19, r22
    2b32:	c0 f7       	brcc	.-16     	; 0x2b24 <delay_us+0xe>
#error Delay functions only work with F_CPU >= 4000000UL 
#endif

/// delay microseconds
/// \param delay time to wait in microseconds
void delay_us(uint16_t delay) {
    2b34:	bc 01       	movw	r22, r24
    2b36:	61 50       	subi	r22, 0x01	; 1
    2b38:	70 44       	sbci	r23, 0x40	; 64
    2b3a:	64 e0       	ldi	r22, 0x04	; 4
    2b3c:	76 9f       	mul	r23, r22
    2b3e:	61 2d       	mov	r22, r1
    2b40:	77 27       	eor	r23, r23
    2b42:	11 24       	eor	r1, r1
    2b44:	40 e0       	ldi	r20, 0x00	; 0
    2b46:	50 ec       	ldi	r21, 0xC0	; 192
    2b48:	64 9f       	mul	r22, r20
    2b4a:	90 01       	movw	r18, r0
    2b4c:	65 9f       	mul	r22, r21
    2b4e:	30 0d       	add	r19, r0
    2b50:	74 9f       	mul	r23, r20
    2b52:	30 0d       	add	r19, r0
    2b54:	11 24       	eor	r1, r1
    2b56:	90 54       	subi	r25, 0x40	; 64
    2b58:	82 0f       	add	r24, r18
    2b5a:	93 1f       	adc	r25, r19
	while (delay > (65536L / (F_CPU / 4000000L))) {
		_delay_loop_2(65534); // we use 65534 here to compensate for the time that the surrounding loop takes. TODO: exact figure needs tuning
		delay -= (65536L / (F_CPU / 4000000L));
		wd_reset();
	}
	_delay_loop_2(delay * (F_CPU / 4000000L));
    2b5c:	88 0f       	add	r24, r24
    2b5e:	99 1f       	adc	r25, r25
    2b60:	88 0f       	add	r24, r24
    2b62:	99 1f       	adc	r25, r25
    2b64:	01 97       	sbiw	r24, 0x01	; 1
    2b66:	f1 f7       	brne	.-4      	; 0x2b64 <delay_us+0x4e>
    2b68:	08 95       	ret

00002b6a <delay_ms>:
	wd_reset();
}

/// delay milliseconds
/// \param delay time to wait in milliseconds
void delay_ms(uint32_t delay) {
    2b6a:	cf 92       	push	r12
    2b6c:	df 92       	push	r13
    2b6e:	ef 92       	push	r14
    2b70:	ff 92       	push	r15
    2b72:	6b 01       	movw	r12, r22
    2b74:	7c 01       	movw	r14, r24
	wd_reset();
	while (delay > 65) {
    2b76:	82 e4       	ldi	r24, 0x42	; 66
    2b78:	c8 16       	cp	r12, r24
    2b7a:	d1 04       	cpc	r13, r1
    2b7c:	e1 04       	cpc	r14, r1
    2b7e:	f1 04       	cpc	r15, r1
    2b80:	70 f0       	brcs	.+28     	; 0x2b9e <delay_ms+0x34>
		delay_us(64999);
    2b82:	87 ee       	ldi	r24, 0xE7	; 231
    2b84:	9d ef       	ldi	r25, 0xFD	; 253
    2b86:	c7 df       	rcall	.-114    	; 0x2b16 <delay_us>
		delay -= 65;
    2b88:	81 e4       	ldi	r24, 0x41	; 65
    2b8a:	c8 1a       	sub	r12, r24
    2b8c:	d1 08       	sbc	r13, r1
    2b8e:	e1 08       	sbc	r14, r1
    2b90:	f1 08       	sbc	r15, r1

/// delay milliseconds
/// \param delay time to wait in milliseconds
void delay_ms(uint32_t delay) {
	wd_reset();
	while (delay > 65) {
    2b92:	82 e4       	ldi	r24, 0x42	; 66
    2b94:	c8 16       	cp	r12, r24
    2b96:	d1 04       	cpc	r13, r1
    2b98:	e1 04       	cpc	r14, r1
    2b9a:	f1 04       	cpc	r15, r1
    2b9c:	90 f7       	brcc	.-28     	; 0x2b82 <delay_ms+0x18>
		delay_us(64999);
		delay -= 65;
		wd_reset();
	}
	delay_us(delay * 1000);
    2b9e:	28 ee       	ldi	r18, 0xE8	; 232
    2ba0:	33 e0       	ldi	r19, 0x03	; 3
    2ba2:	c2 9e       	mul	r12, r18
    2ba4:	c0 01       	movw	r24, r0
    2ba6:	c3 9e       	mul	r12, r19
    2ba8:	90 0d       	add	r25, r0
    2baa:	d2 9e       	mul	r13, r18
    2bac:	90 0d       	add	r25, r0
    2bae:	11 24       	eor	r1, r1
    2bb0:	b2 df       	rcall	.-156    	; 0x2b16 <delay_us>
	wd_reset();
}
    2bb2:	ff 90       	pop	r15
    2bb4:	ef 90       	pop	r14
    2bb6:	df 90       	pop	r13
    2bb8:	cf 90       	pop	r12
    2bba:	08 95       	ret

00002bbc <decfloat_to_int>:
/// \param *df pointer to floating point structure that holds fp value to convert
/// \param multiplicand multiply by this amount during conversion to integer
///
/// Tested for up to 42'000 mm (accurate), 420'000 mm (precision 10 um) and
/// 4'200'000 mm (precision 100 um).
static int32_t decfloat_to_int(decfloat *df, uint16_t multiplicand) {
    2bbc:	4f 92       	push	r4
    2bbe:	5f 92       	push	r5
    2bc0:	6f 92       	push	r6
    2bc2:	7f 92       	push	r7
    2bc4:	8f 92       	push	r8
    2bc6:	9f 92       	push	r9
    2bc8:	af 92       	push	r10
    2bca:	bf 92       	push	r11
    2bcc:	cf 92       	push	r12
    2bce:	df 92       	push	r13
    2bd0:	ef 92       	push	r14
    2bd2:	ff 92       	push	r15
    2bd4:	cf 93       	push	r28
    2bd6:	df 93       	push	r29
    2bd8:	ec 01       	movw	r28, r24
    2bda:	ab 01       	movw	r20, r22
	uint32_t	r = df->mantissa;
    2bdc:	c8 80       	ld	r12, Y
    2bde:	d9 80       	ldd	r13, Y+1	; 0x01
    2be0:	ea 80       	ldd	r14, Y+2	; 0x02
    2be2:	fb 80       	ldd	r15, Y+3	; 0x03
	uint8_t	e = df->exponent;
    2be4:	ec 81       	ldd	r30, Y+4	; 0x04
    2be6:	ef 77       	andi	r30, 0x7F	; 127

	// e=1 means we've seen a decimal point but no digits after it, and e=2 means we've seen a decimal point with one digit so it's too high by one if not zero
	if (e)
    2be8:	09 f4       	brne	.+2      	; 0x2bec <decfloat_to_int+0x30>
    2bea:	70 c0       	rjmp	.+224    	; 0x2ccc <decfloat_to_int+0x110>
		e--;
    2bec:	e1 50       	subi	r30, 0x01	; 1

	// This raises range for mm by factor 1000 and for inches by factor 100.
	// It's a bit expensive, but we should have the time while parsing.
	while (e && multiplicand % 10 == 0) {
    2bee:	09 f4       	brne	.+2      	; 0x2bf2 <decfloat_to_int+0x36>
    2bf0:	6d c0       	rjmp	.+218    	; 0x2ccc <decfloat_to_int+0x110>
    2bf2:	9b 01       	movw	r18, r22
    2bf4:	ad ec       	ldi	r26, 0xCD	; 205
    2bf6:	bc ec       	ldi	r27, 0xCC	; 204
    2bf8:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <__umulhisi3>
    2bfc:	96 95       	lsr	r25
    2bfe:	87 95       	ror	r24
    2c00:	96 95       	lsr	r25
    2c02:	87 95       	ror	r24
    2c04:	96 95       	lsr	r25
    2c06:	87 95       	ror	r24
    2c08:	9c 01       	movw	r18, r24
    2c0a:	22 0f       	add	r18, r18
    2c0c:	33 1f       	adc	r19, r19
    2c0e:	88 0f       	add	r24, r24
    2c10:	99 1f       	adc	r25, r25
    2c12:	88 0f       	add	r24, r24
    2c14:	99 1f       	adc	r25, r25
    2c16:	88 0f       	add	r24, r24
    2c18:	99 1f       	adc	r25, r25
    2c1a:	82 0f       	add	r24, r18
    2c1c:	93 1f       	adc	r25, r19
    2c1e:	48 17       	cp	r20, r24
    2c20:	59 07       	cpc	r21, r25
    2c22:	a9 f5       	brne	.+106    	; 0x2c8e <decfloat_to_int+0xd2>
		multiplicand /= 10;
    2c24:	9a 01       	movw	r18, r20
    2c26:	ad ec       	ldi	r26, 0xCD	; 205
    2c28:	bc ec       	ldi	r27, 0xCC	; 204
    2c2a:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <__umulhisi3>
    2c2e:	ac 01       	movw	r20, r24
    2c30:	56 95       	lsr	r21
    2c32:	47 95       	ror	r20
    2c34:	56 95       	lsr	r21
    2c36:	47 95       	ror	r20
    2c38:	56 95       	lsr	r21
    2c3a:	47 95       	ror	r20
		e--;
    2c3c:	e1 50       	subi	r30, 0x01	; 1
	if (e)
		e--;

	// This raises range for mm by factor 1000 and for inches by factor 100.
	// It's a bit expensive, but we should have the time while parsing.
	while (e && multiplicand % 10 == 0) {
    2c3e:	09 f4       	brne	.+2      	; 0x2c42 <decfloat_to_int+0x86>
    2c40:	45 c0       	rjmp	.+138    	; 0x2ccc <decfloat_to_int+0x110>
    2c42:	9a 01       	movw	r18, r20
    2c44:	0e 94 62 2a 	call	0x54c4	; 0x54c4 <__umulhisi3>
    2c48:	96 95       	lsr	r25
    2c4a:	87 95       	ror	r24
    2c4c:	96 95       	lsr	r25
    2c4e:	87 95       	ror	r24
    2c50:	96 95       	lsr	r25
    2c52:	87 95       	ror	r24
    2c54:	9c 01       	movw	r18, r24
    2c56:	22 0f       	add	r18, r18
    2c58:	33 1f       	adc	r19, r19
    2c5a:	88 0f       	add	r24, r24
    2c5c:	99 1f       	adc	r25, r25
    2c5e:	88 0f       	add	r24, r24
    2c60:	99 1f       	adc	r25, r25
    2c62:	88 0f       	add	r24, r24
    2c64:	99 1f       	adc	r25, r25
    2c66:	82 0f       	add	r24, r18
    2c68:	93 1f       	adc	r25, r19
    2c6a:	48 17       	cp	r20, r24
    2c6c:	59 07       	cpc	r21, r25
    2c6e:	d1 f2       	breq	.-76     	; 0x2c24 <decfloat_to_int+0x68>
    2c70:	0e c0       	rjmp	.+28     	; 0x2c8e <decfloat_to_int+0xd2>

	r *= multiplicand;
	if (e)
		r = (r + powers[e] / 2) / powers[e];

	return df->sign ? -(int32_t)r : (int32_t)r;
    2c72:	8c 81       	ldd	r24, Y+4	; 0x04
    2c74:	88 23       	and	r24, r24
    2c76:	44 f4       	brge	.+16     	; 0x2c88 <decfloat_to_int+0xcc>
    2c78:	88 27       	eor	r24, r24
    2c7a:	99 27       	eor	r25, r25
    2c7c:	dc 01       	movw	r26, r24
    2c7e:	82 1b       	sub	r24, r18
    2c80:	93 0b       	sbc	r25, r19
    2c82:	a4 0b       	sbc	r26, r20
    2c84:	b5 0b       	sbc	r27, r21
    2c86:	2a c0       	rjmp	.+84     	; 0x2cdc <decfloat_to_int+0x120>
    2c88:	da 01       	movw	r26, r20
    2c8a:	c9 01       	movw	r24, r18
    2c8c:	27 c0       	rjmp	.+78     	; 0x2cdc <decfloat_to_int+0x120>
		e--;
	}

	r *= multiplicand;
	if (e)
		r = (r + powers[e] / 2) / powers[e];
    2c8e:	f0 e0       	ldi	r31, 0x00	; 0
    2c90:	ee 0f       	add	r30, r30
    2c92:	ff 1f       	adc	r31, r31
    2c94:	ee 0f       	add	r30, r30
    2c96:	ff 1f       	adc	r31, r31
    2c98:	e6 5f       	subi	r30, 0xF6	; 246
    2c9a:	fd 4f       	sbci	r31, 0xFD	; 253
    2c9c:	80 80       	ld	r8, Z
    2c9e:	91 80       	ldd	r9, Z+1	; 0x01
    2ca0:	a2 80       	ldd	r10, Z+2	; 0x02
    2ca2:	b3 80       	ldd	r11, Z+3	; 0x03
    2ca4:	24 01       	movw	r4, r8
    2ca6:	35 01       	movw	r6, r10
    2ca8:	76 94       	lsr	r7
    2caa:	67 94       	ror	r6
    2cac:	57 94       	ror	r5
    2cae:	47 94       	ror	r4
	while (e && multiplicand % 10 == 0) {
		multiplicand /= 10;
		e--;
	}

	r *= multiplicand;
    2cb0:	da 01       	movw	r26, r20
    2cb2:	a7 01       	movw	r20, r14
    2cb4:	96 01       	movw	r18, r12
    2cb6:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
	if (e)
		r = (r + powers[e] / 2) / powers[e];
    2cba:	64 0d       	add	r22, r4
    2cbc:	75 1d       	adc	r23, r5
    2cbe:	86 1d       	adc	r24, r6
    2cc0:	97 1d       	adc	r25, r7
    2cc2:	a5 01       	movw	r20, r10
    2cc4:	94 01       	movw	r18, r8
    2cc6:	0e 94 1f 2a 	call	0x543e	; 0x543e <__udivmodsi4>
    2cca:	d3 cf       	rjmp	.-90     	; 0x2c72 <decfloat_to_int+0xb6>
	while (e && multiplicand % 10 == 0) {
		multiplicand /= 10;
		e--;
	}

	r *= multiplicand;
    2ccc:	da 01       	movw	r26, r20
    2cce:	a7 01       	movw	r20, r14
    2cd0:	96 01       	movw	r18, r12
    2cd2:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <__muluhisi3>
    2cd6:	9b 01       	movw	r18, r22
    2cd8:	ac 01       	movw	r20, r24
    2cda:	cb cf       	rjmp	.-106    	; 0x2c72 <decfloat_to_int+0xb6>
	if (e)
		r = (r + powers[e] / 2) / powers[e];

	return df->sign ? -(int32_t)r : (int32_t)r;
    2cdc:	39 2f       	mov	r19, r25
    2cde:	9b 2f       	mov	r25, r27
}
    2ce0:	68 2f       	mov	r22, r24
    2ce2:	73 2f       	mov	r23, r19
    2ce4:	8a 2f       	mov	r24, r26
    2ce6:	df 91       	pop	r29
    2ce8:	cf 91       	pop	r28
    2cea:	ff 90       	pop	r15
    2cec:	ef 90       	pop	r14
    2cee:	df 90       	pop	r13
    2cf0:	cf 90       	pop	r12
    2cf2:	bf 90       	pop	r11
    2cf4:	af 90       	pop	r10
    2cf6:	9f 90       	pop	r9
    2cf8:	8f 90       	pop	r8
    2cfa:	7f 90       	pop	r7
    2cfc:	6f 90       	pop	r6
    2cfe:	5f 90       	pop	r5
    2d00:	4f 90       	pop	r4
    2d02:	08 95       	ret

00002d04 <gcode_init>:

void gcode_init(void) {
	// gcc guarantees us all variables are initialised to 0.

	// assume a G1 by default
	next_target.seen_G = 1;
    2d04:	e5 e8       	ldi	r30, 0x85	; 133
    2d06:	f4 e0       	ldi	r31, 0x04	; 4
    2d08:	80 81       	ld	r24, Z
    2d0a:	81 60       	ori	r24, 0x01	; 1
    2d0c:	80 83       	st	Z, r24
	next_target.G = 1;
    2d0e:	81 e0       	ldi	r24, 0x01	; 1
    2d10:	80 93 88 04 	sts	0x0488, r24

	#ifndef E_ABSOLUTE
		next_target.option_e_relative = 1;
    2d14:	e6 e8       	ldi	r30, 0x86	; 134
    2d16:	f4 e0       	ldi	r31, 0x04	; 4
    2d18:	80 81       	ld	r24, Z
    2d1a:	80 68       	ori	r24, 0x80	; 128
    2d1c:	80 83       	st	Z, r24
    2d1e:	08 95       	ret

00002d20 <gcode_parse_char>:
	#endif
}

/// Character Received - add it to our command
/// \param c the next character to process
void gcode_parse_char(uint8_t c) {
    2d20:	cf 93       	push	r28
    2d22:	df 93       	push	r29
    2d24:	d8 2f       	mov	r29, r24
	uint8_t checksum_char = c;

	// uppercase
	if (c >= 'a' && c <= 'z')
    2d26:	81 56       	subi	r24, 0x61	; 97
    2d28:	8a 31       	cpi	r24, 0x1A	; 26
    2d2a:	18 f4       	brcc	.+6      	; 0x2d32 <gcode_parse_char+0x12>
		c &= ~32;
    2d2c:	cd 2f       	mov	r28, r29
    2d2e:	cf 7d       	andi	r28, 0xDF	; 223
    2d30:	01 c0       	rjmp	.+2      	; 0x2d34 <gcode_parse_char+0x14>
/// \param c the next character to process
void gcode_parse_char(uint8_t c) {
	uint8_t checksum_char = c;

	// uppercase
	if (c >= 'a' && c <= 'z')
    2d32:	cd 2f       	mov	r28, r29
		c &= ~32;

	// process previous field
	if (last_field) {
    2d34:	80 91 be 04 	lds	r24, 0x04BE
    2d38:	88 23       	and	r24, r24
    2d3a:	09 f4       	brne	.+2      	; 0x2d3e <gcode_parse_char+0x1e>
    2d3c:	da c1       	rjmp	.+948    	; 0x30f2 <gcode_parse_char+0x3d2>
		// check if we're seeing a new field or end of line
		// any character will start a new field, even invalid/unknown ones
		if ((c >= 'A' && c <= 'Z') || c == '*' || (c == 10) || (c == 13)) {
    2d3e:	9c 2f       	mov	r25, r28
    2d40:	91 54       	subi	r25, 0x41	; 65
    2d42:	9a 31       	cpi	r25, 0x1A	; 26
    2d44:	38 f0       	brcs	.+14     	; 0x2d54 <gcode_parse_char+0x34>
    2d46:	ca 32       	cpi	r28, 0x2A	; 42
    2d48:	29 f0       	breq	.+10     	; 0x2d54 <gcode_parse_char+0x34>
    2d4a:	ca 30       	cpi	r28, 0x0A	; 10
    2d4c:	19 f0       	breq	.+6      	; 0x2d54 <gcode_parse_char+0x34>
    2d4e:	cd 30       	cpi	r28, 0x0D	; 13
    2d50:	09 f0       	breq	.+2      	; 0x2d54 <gcode_parse_char+0x34>
    2d52:	cf c1       	rjmp	.+926    	; 0x30f2 <gcode_parse_char+0x3d2>
			switch (last_field) {
    2d54:	80 35       	cpi	r24, 0x50	; 80
    2d56:	09 f4       	brne	.+2      	; 0x2d5a <gcode_parse_char+0x3a>
    2d58:	75 c1       	rjmp	.+746    	; 0x3044 <gcode_parse_char+0x324>
    2d5a:	90 f4       	brcc	.+36     	; 0x2d80 <gcode_parse_char+0x60>
    2d5c:	87 34       	cpi	r24, 0x47	; 71
    2d5e:	09 f1       	breq	.+66     	; 0x2da2 <gcode_parse_char+0x82>
    2d60:	48 f4       	brcc	.+18     	; 0x2d74 <gcode_parse_char+0x54>
    2d62:	85 34       	cpi	r24, 0x45	; 69
    2d64:	09 f4       	brne	.+2      	; 0x2d68 <gcode_parse_char+0x48>
    2d66:	d8 c0       	rjmp	.+432    	; 0x2f18 <gcode_parse_char+0x1f8>
    2d68:	08 f0       	brcs	.+2      	; 0x2d6c <gcode_parse_char+0x4c>
    2d6a:	05 c1       	rjmp	.+522    	; 0x2f76 <gcode_parse_char+0x256>
    2d6c:	8a 32       	cpi	r24, 0x2A	; 42
    2d6e:	09 f0       	breq	.+2      	; 0x2d72 <gcode_parse_char+0x52>
    2d70:	b4 c1       	rjmp	.+872    	; 0x30da <gcode_parse_char+0x3ba>
    2d72:	a3 c1       	rjmp	.+838    	; 0x30ba <gcode_parse_char+0x39a>
    2d74:	8d 34       	cpi	r24, 0x4D	; 77
    2d76:	61 f1       	breq	.+88     	; 0x2dd0 <gcode_parse_char+0xb0>
    2d78:	8e 34       	cpi	r24, 0x4E	; 78
    2d7a:	09 f0       	breq	.+2      	; 0x2d7e <gcode_parse_char+0x5e>
    2d7c:	ae c1       	rjmp	.+860    	; 0x30da <gcode_parse_char+0x3ba>
    2d7e:	8b c1       	rjmp	.+790    	; 0x3096 <gcode_parse_char+0x376>
    2d80:	88 35       	cpi	r24, 0x58	; 88
    2d82:	e9 f1       	breq	.+122    	; 0x2dfe <gcode_parse_char+0xde>
    2d84:	38 f4       	brcc	.+14     	; 0x2d94 <gcode_parse_char+0x74>
    2d86:	83 35       	cpi	r24, 0x53	; 83
    2d88:	09 f4       	brne	.+2      	; 0x2d8c <gcode_parse_char+0x6c>
    2d8a:	24 c1       	rjmp	.+584    	; 0x2fd4 <gcode_parse_char+0x2b4>
    2d8c:	84 35       	cpi	r24, 0x54	; 84
    2d8e:	09 f0       	breq	.+2      	; 0x2d92 <gcode_parse_char+0x72>
    2d90:	a4 c1       	rjmp	.+840    	; 0x30da <gcode_parse_char+0x3ba>
    2d92:	6b c1       	rjmp	.+726    	; 0x306a <gcode_parse_char+0x34a>
    2d94:	89 35       	cpi	r24, 0x59	; 89
    2d96:	09 f4       	brne	.+2      	; 0x2d9a <gcode_parse_char+0x7a>
    2d98:	61 c0       	rjmp	.+194    	; 0x2e5c <gcode_parse_char+0x13c>
    2d9a:	8a 35       	cpi	r24, 0x5A	; 90
    2d9c:	09 f0       	breq	.+2      	; 0x2da0 <gcode_parse_char+0x80>
    2d9e:	9d c1       	rjmp	.+826    	; 0x30da <gcode_parse_char+0x3ba>
    2da0:	8c c0       	rjmp	.+280    	; 0x2eba <gcode_parse_char+0x19a>
				case 'G':
					next_target.G = read_digit.mantissa;
    2da2:	80 91 ae 04 	lds	r24, 0x04AE
    2da6:	90 91 af 04 	lds	r25, 0x04AF
    2daa:	a0 91 b0 04 	lds	r26, 0x04B0
    2dae:	b0 91 b1 04 	lds	r27, 0x04B1
    2db2:	80 93 88 04 	sts	0x0488, r24
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2db6:	20 91 cf 04 	lds	r18, 0x04CF
    2dba:	22 23       	and	r18, r18
    2dbc:	0c f0       	brlt	.+2      	; 0x2dc0 <gcode_parse_char+0xa0>
    2dbe:	8d c1       	rjmp	.+794    	; 0x30da <gcode_parse_char+0x3ba>
						serwrite_uint8(next_target.G);
    2dc0:	bc 01       	movw	r22, r24
    2dc2:	cd 01       	movw	r24, r26
    2dc4:	77 27       	eor	r23, r23
    2dc6:	88 27       	eor	r24, r24
    2dc8:	99 27       	eor	r25, r25
    2dca:	0e 94 49 25 	call	0x4a92	; 0x4a92 <serwrite_uint32>
    2dce:	85 c1       	rjmp	.+778    	; 0x30da <gcode_parse_char+0x3ba>
					break;
				case 'M':
					next_target.M = read_digit.mantissa;
    2dd0:	80 91 ae 04 	lds	r24, 0x04AE
    2dd4:	90 91 af 04 	lds	r25, 0x04AF
    2dd8:	a0 91 b0 04 	lds	r26, 0x04B0
    2ddc:	b0 91 b1 04 	lds	r27, 0x04B1
    2de0:	80 93 89 04 	sts	0x0489, r24
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2de4:	20 91 cf 04 	lds	r18, 0x04CF
    2de8:	22 23       	and	r18, r18
    2dea:	0c f0       	brlt	.+2      	; 0x2dee <gcode_parse_char+0xce>
    2dec:	76 c1       	rjmp	.+748    	; 0x30da <gcode_parse_char+0x3ba>
						serwrite_uint8(next_target.M);
    2dee:	bc 01       	movw	r22, r24
    2df0:	cd 01       	movw	r24, r26
    2df2:	77 27       	eor	r23, r23
    2df4:	88 27       	eor	r24, r24
    2df6:	99 27       	eor	r25, r25
    2df8:	0e 94 49 25 	call	0x4a92	; 0x4a92 <serwrite_uint32>
    2dfc:	6e c1       	rjmp	.+732    	; 0x30da <gcode_parse_char+0x3ba>
					break;
				case 'X':
					if (next_target.option_inches)
    2dfe:	80 91 87 04 	lds	r24, 0x0487
    2e02:	80 ff       	sbrs	r24, 0
    2e04:	0e c0       	rjmp	.+28     	; 0x2e22 <gcode_parse_char+0x102>
						next_target.target.X = decfloat_to_int(&read_digit, 25400);
    2e06:	68 e3       	ldi	r22, 0x38	; 56
    2e08:	73 e6       	ldi	r23, 0x63	; 99
    2e0a:	8e ea       	ldi	r24, 0xAE	; 174
    2e0c:	94 e0       	ldi	r25, 0x04	; 4
    2e0e:	d6 de       	rcall	.-596    	; 0x2bbc <decfloat_to_int>
    2e10:	60 93 8a 04 	sts	0x048A, r22
    2e14:	70 93 8b 04 	sts	0x048B, r23
    2e18:	80 93 8c 04 	sts	0x048C, r24
    2e1c:	90 93 8d 04 	sts	0x048D, r25
    2e20:	0d c0       	rjmp	.+26     	; 0x2e3c <gcode_parse_char+0x11c>
					else
						next_target.target.X = decfloat_to_int(&read_digit, 1000);
    2e22:	68 ee       	ldi	r22, 0xE8	; 232
    2e24:	73 e0       	ldi	r23, 0x03	; 3
    2e26:	8e ea       	ldi	r24, 0xAE	; 174
    2e28:	94 e0       	ldi	r25, 0x04	; 4
    2e2a:	c8 de       	rcall	.-624    	; 0x2bbc <decfloat_to_int>
    2e2c:	60 93 8a 04 	sts	0x048A, r22
    2e30:	70 93 8b 04 	sts	0x048B, r23
    2e34:	80 93 8c 04 	sts	0x048C, r24
    2e38:	90 93 8d 04 	sts	0x048D, r25
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2e3c:	80 91 cf 04 	lds	r24, 0x04CF
    2e40:	88 23       	and	r24, r24
    2e42:	0c f0       	brlt	.+2      	; 0x2e46 <gcode_parse_char+0x126>
    2e44:	4a c1       	rjmp	.+660    	; 0x30da <gcode_parse_char+0x3ba>
						serwrite_int32(next_target.target.X);
    2e46:	60 91 8a 04 	lds	r22, 0x048A
    2e4a:	70 91 8b 04 	lds	r23, 0x048B
    2e4e:	80 91 8c 04 	lds	r24, 0x048C
    2e52:	90 91 8d 04 	lds	r25, 0x048D
    2e56:	0e 94 98 25 	call	0x4b30	; 0x4b30 <serwrite_int32>
    2e5a:	3f c1       	rjmp	.+638    	; 0x30da <gcode_parse_char+0x3ba>
					break;
				case 'Y':
					if (next_target.option_inches)
    2e5c:	80 91 87 04 	lds	r24, 0x0487
    2e60:	80 ff       	sbrs	r24, 0
    2e62:	0e c0       	rjmp	.+28     	; 0x2e80 <gcode_parse_char+0x160>
						next_target.target.Y = decfloat_to_int(&read_digit, 25400);
    2e64:	68 e3       	ldi	r22, 0x38	; 56
    2e66:	73 e6       	ldi	r23, 0x63	; 99
    2e68:	8e ea       	ldi	r24, 0xAE	; 174
    2e6a:	94 e0       	ldi	r25, 0x04	; 4
    2e6c:	a7 de       	rcall	.-690    	; 0x2bbc <decfloat_to_int>
    2e6e:	60 93 8e 04 	sts	0x048E, r22
    2e72:	70 93 8f 04 	sts	0x048F, r23
    2e76:	80 93 90 04 	sts	0x0490, r24
    2e7a:	90 93 91 04 	sts	0x0491, r25
    2e7e:	0d c0       	rjmp	.+26     	; 0x2e9a <gcode_parse_char+0x17a>
					else
						next_target.target.Y = decfloat_to_int(&read_digit, 1000);
    2e80:	68 ee       	ldi	r22, 0xE8	; 232
    2e82:	73 e0       	ldi	r23, 0x03	; 3
    2e84:	8e ea       	ldi	r24, 0xAE	; 174
    2e86:	94 e0       	ldi	r25, 0x04	; 4
    2e88:	99 de       	rcall	.-718    	; 0x2bbc <decfloat_to_int>
    2e8a:	60 93 8e 04 	sts	0x048E, r22
    2e8e:	70 93 8f 04 	sts	0x048F, r23
    2e92:	80 93 90 04 	sts	0x0490, r24
    2e96:	90 93 91 04 	sts	0x0491, r25
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2e9a:	80 91 cf 04 	lds	r24, 0x04CF
    2e9e:	88 23       	and	r24, r24
    2ea0:	0c f0       	brlt	.+2      	; 0x2ea4 <gcode_parse_char+0x184>
    2ea2:	1b c1       	rjmp	.+566    	; 0x30da <gcode_parse_char+0x3ba>
						serwrite_int32(next_target.target.Y);
    2ea4:	60 91 8e 04 	lds	r22, 0x048E
    2ea8:	70 91 8f 04 	lds	r23, 0x048F
    2eac:	80 91 90 04 	lds	r24, 0x0490
    2eb0:	90 91 91 04 	lds	r25, 0x0491
    2eb4:	0e 94 98 25 	call	0x4b30	; 0x4b30 <serwrite_int32>
    2eb8:	10 c1       	rjmp	.+544    	; 0x30da <gcode_parse_char+0x3ba>
					break;
				case 'Z':
					if (next_target.option_inches)
    2eba:	80 91 87 04 	lds	r24, 0x0487
    2ebe:	80 ff       	sbrs	r24, 0
    2ec0:	0e c0       	rjmp	.+28     	; 0x2ede <gcode_parse_char+0x1be>
						next_target.target.Z = decfloat_to_int(&read_digit, 25400);
    2ec2:	68 e3       	ldi	r22, 0x38	; 56
    2ec4:	73 e6       	ldi	r23, 0x63	; 99
    2ec6:	8e ea       	ldi	r24, 0xAE	; 174
    2ec8:	94 e0       	ldi	r25, 0x04	; 4
    2eca:	78 de       	rcall	.-784    	; 0x2bbc <decfloat_to_int>
    2ecc:	60 93 92 04 	sts	0x0492, r22
    2ed0:	70 93 93 04 	sts	0x0493, r23
    2ed4:	80 93 94 04 	sts	0x0494, r24
    2ed8:	90 93 95 04 	sts	0x0495, r25
    2edc:	0d c0       	rjmp	.+26     	; 0x2ef8 <gcode_parse_char+0x1d8>
					else
						next_target.target.Z = decfloat_to_int(&read_digit, 1000);
    2ede:	68 ee       	ldi	r22, 0xE8	; 232
    2ee0:	73 e0       	ldi	r23, 0x03	; 3
    2ee2:	8e ea       	ldi	r24, 0xAE	; 174
    2ee4:	94 e0       	ldi	r25, 0x04	; 4
    2ee6:	6a de       	rcall	.-812    	; 0x2bbc <decfloat_to_int>
    2ee8:	60 93 92 04 	sts	0x0492, r22
    2eec:	70 93 93 04 	sts	0x0493, r23
    2ef0:	80 93 94 04 	sts	0x0494, r24
    2ef4:	90 93 95 04 	sts	0x0495, r25
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2ef8:	80 91 cf 04 	lds	r24, 0x04CF
    2efc:	88 23       	and	r24, r24
    2efe:	0c f0       	brlt	.+2      	; 0x2f02 <gcode_parse_char+0x1e2>
    2f00:	ec c0       	rjmp	.+472    	; 0x30da <gcode_parse_char+0x3ba>
						serwrite_int32(next_target.target.Z);
    2f02:	60 91 92 04 	lds	r22, 0x0492
    2f06:	70 91 93 04 	lds	r23, 0x0493
    2f0a:	80 91 94 04 	lds	r24, 0x0494
    2f0e:	90 91 95 04 	lds	r25, 0x0495
    2f12:	0e 94 98 25 	call	0x4b30	; 0x4b30 <serwrite_int32>
    2f16:	e1 c0       	rjmp	.+450    	; 0x30da <gcode_parse_char+0x3ba>
					break;
				case 'E':
					if (next_target.option_inches)
    2f18:	80 91 87 04 	lds	r24, 0x0487
    2f1c:	80 ff       	sbrs	r24, 0
    2f1e:	0e c0       	rjmp	.+28     	; 0x2f3c <gcode_parse_char+0x21c>
						next_target.target.E = decfloat_to_int(&read_digit, 25400);
    2f20:	68 e3       	ldi	r22, 0x38	; 56
    2f22:	73 e6       	ldi	r23, 0x63	; 99
    2f24:	8e ea       	ldi	r24, 0xAE	; 174
    2f26:	94 e0       	ldi	r25, 0x04	; 4
    2f28:	49 de       	rcall	.-878    	; 0x2bbc <decfloat_to_int>
    2f2a:	60 93 96 04 	sts	0x0496, r22
    2f2e:	70 93 97 04 	sts	0x0497, r23
    2f32:	80 93 98 04 	sts	0x0498, r24
    2f36:	90 93 99 04 	sts	0x0499, r25
    2f3a:	0d c0       	rjmp	.+26     	; 0x2f56 <gcode_parse_char+0x236>
					else
						next_target.target.E = decfloat_to_int(&read_digit, 1000);
    2f3c:	68 ee       	ldi	r22, 0xE8	; 232
    2f3e:	73 e0       	ldi	r23, 0x03	; 3
    2f40:	8e ea       	ldi	r24, 0xAE	; 174
    2f42:	94 e0       	ldi	r25, 0x04	; 4
    2f44:	3b de       	rcall	.-906    	; 0x2bbc <decfloat_to_int>
    2f46:	60 93 96 04 	sts	0x0496, r22
    2f4a:	70 93 97 04 	sts	0x0497, r23
    2f4e:	80 93 98 04 	sts	0x0498, r24
    2f52:	90 93 99 04 	sts	0x0499, r25
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2f56:	80 91 cf 04 	lds	r24, 0x04CF
    2f5a:	88 23       	and	r24, r24
    2f5c:	0c f0       	brlt	.+2      	; 0x2f60 <gcode_parse_char+0x240>
    2f5e:	bd c0       	rjmp	.+378    	; 0x30da <gcode_parse_char+0x3ba>
						serwrite_uint32(next_target.target.E);
    2f60:	60 91 96 04 	lds	r22, 0x0496
    2f64:	70 91 97 04 	lds	r23, 0x0497
    2f68:	80 91 98 04 	lds	r24, 0x0498
    2f6c:	90 91 99 04 	lds	r25, 0x0499
    2f70:	0e 94 49 25 	call	0x4a92	; 0x4a92 <serwrite_uint32>
    2f74:	b2 c0       	rjmp	.+356    	; 0x30da <gcode_parse_char+0x3ba>
					break;
				case 'F':
					// just use raw integer, we need move distance and n_steps to convert it to a useful value, so wait until we have those to convert it
					if (next_target.option_inches)
    2f76:	80 91 87 04 	lds	r24, 0x0487
    2f7a:	80 ff       	sbrs	r24, 0
    2f7c:	0e c0       	rjmp	.+28     	; 0x2f9a <gcode_parse_char+0x27a>
						next_target.target.F = decfloat_to_int(&read_digit, 25400);
    2f7e:	68 e3       	ldi	r22, 0x38	; 56
    2f80:	73 e6       	ldi	r23, 0x63	; 99
    2f82:	8e ea       	ldi	r24, 0xAE	; 174
    2f84:	94 e0       	ldi	r25, 0x04	; 4
    2f86:	1a de       	rcall	.-972    	; 0x2bbc <decfloat_to_int>
    2f88:	60 93 9a 04 	sts	0x049A, r22
    2f8c:	70 93 9b 04 	sts	0x049B, r23
    2f90:	80 93 9c 04 	sts	0x049C, r24
    2f94:	90 93 9d 04 	sts	0x049D, r25
    2f98:	0d c0       	rjmp	.+26     	; 0x2fb4 <gcode_parse_char+0x294>
					else
						next_target.target.F = decfloat_to_int(&read_digit, 1);
    2f9a:	61 e0       	ldi	r22, 0x01	; 1
    2f9c:	70 e0       	ldi	r23, 0x00	; 0
    2f9e:	8e ea       	ldi	r24, 0xAE	; 174
    2fa0:	94 e0       	ldi	r25, 0x04	; 4
    2fa2:	0c de       	rcall	.-1000   	; 0x2bbc <decfloat_to_int>
    2fa4:	60 93 9a 04 	sts	0x049A, r22
    2fa8:	70 93 9b 04 	sts	0x049B, r23
    2fac:	80 93 9c 04 	sts	0x049C, r24
    2fb0:	90 93 9d 04 	sts	0x049D, r25
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2fb4:	80 91 cf 04 	lds	r24, 0x04CF
    2fb8:	88 23       	and	r24, r24
    2fba:	0c f0       	brlt	.+2      	; 0x2fbe <gcode_parse_char+0x29e>
    2fbc:	8e c0       	rjmp	.+284    	; 0x30da <gcode_parse_char+0x3ba>
						serwrite_uint32(next_target.target.F);
    2fbe:	60 91 9a 04 	lds	r22, 0x049A
    2fc2:	70 91 9b 04 	lds	r23, 0x049B
    2fc6:	80 91 9c 04 	lds	r24, 0x049C
    2fca:	90 91 9d 04 	lds	r25, 0x049D
    2fce:	0e 94 49 25 	call	0x4a92	; 0x4a92 <serwrite_uint32>
    2fd2:	83 c0       	rjmp	.+262    	; 0x30da <gcode_parse_char+0x3ba>
					break;
				case 'S':
					// if this is temperature, multiply by 4 to convert to quarter-degree units
					// cosmetically this should be done in the temperature section,
					// but it takes less code, less memory and loses no precision if we do it here instead
					if ((next_target.M == 104) || (next_target.M == 109) || (next_target.M == 140))
    2fd4:	80 91 89 04 	lds	r24, 0x0489
    2fd8:	88 36       	cpi	r24, 0x68	; 104
    2fda:	21 f0       	breq	.+8      	; 0x2fe4 <gcode_parse_char+0x2c4>
    2fdc:	8d 36       	cpi	r24, 0x6D	; 109
    2fde:	11 f0       	breq	.+4      	; 0x2fe4 <gcode_parse_char+0x2c4>
    2fe0:	8c 38       	cpi	r24, 0x8C	; 140
    2fe2:	51 f4       	brne	.+20     	; 0x2ff8 <gcode_parse_char+0x2d8>
						next_target.S = decfloat_to_int(&read_digit, 4);
    2fe4:	64 e0       	ldi	r22, 0x04	; 4
    2fe6:	70 e0       	ldi	r23, 0x00	; 0
    2fe8:	8e ea       	ldi	r24, 0xAE	; 174
    2fea:	94 e0       	ldi	r25, 0x04	; 4
    2fec:	e7 dd       	rcall	.-1074   	; 0x2bbc <decfloat_to_int>
    2fee:	70 93 a0 04 	sts	0x04A0, r23
    2ff2:	60 93 9f 04 	sts	0x049F, r22
    2ff6:	16 c0       	rjmp	.+44     	; 0x3024 <gcode_parse_char+0x304>
					// if this is heater PID stuff, multiply by PID_SCALE because we divide by PID_SCALE later on
					else if ((next_target.M >= 130) && (next_target.M <= 132))
    2ff8:	82 58       	subi	r24, 0x82	; 130
    2ffa:	83 30       	cpi	r24, 0x03	; 3
    2ffc:	50 f4       	brcc	.+20     	; 0x3012 <gcode_parse_char+0x2f2>
						next_target.S = decfloat_to_int(&read_digit, PID_SCALE);
    2ffe:	60 e0       	ldi	r22, 0x00	; 0
    3000:	74 e0       	ldi	r23, 0x04	; 4
    3002:	8e ea       	ldi	r24, 0xAE	; 174
    3004:	94 e0       	ldi	r25, 0x04	; 4
    3006:	da dd       	rcall	.-1100   	; 0x2bbc <decfloat_to_int>
    3008:	70 93 a0 04 	sts	0x04A0, r23
    300c:	60 93 9f 04 	sts	0x049F, r22
    3010:	09 c0       	rjmp	.+18     	; 0x3024 <gcode_parse_char+0x304>
					else
						next_target.S = decfloat_to_int(&read_digit, 1);
    3012:	61 e0       	ldi	r22, 0x01	; 1
    3014:	70 e0       	ldi	r23, 0x00	; 0
    3016:	8e ea       	ldi	r24, 0xAE	; 174
    3018:	94 e0       	ldi	r25, 0x04	; 4
    301a:	d0 dd       	rcall	.-1120   	; 0x2bbc <decfloat_to_int>
    301c:	70 93 a0 04 	sts	0x04A0, r23
    3020:	60 93 9f 04 	sts	0x049F, r22
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    3024:	80 91 cf 04 	lds	r24, 0x04CF
    3028:	88 23       	and	r24, r24
    302a:	0c f0       	brlt	.+2      	; 0x302e <gcode_parse_char+0x30e>
    302c:	56 c0       	rjmp	.+172    	; 0x30da <gcode_parse_char+0x3ba>
						serwrite_uint16(next_target.S);
    302e:	60 91 9f 04 	lds	r22, 0x049F
    3032:	70 91 a0 04 	lds	r23, 0x04A0
    3036:	88 27       	eor	r24, r24
    3038:	77 fd       	sbrc	r23, 7
    303a:	80 95       	com	r24
    303c:	98 2f       	mov	r25, r24
    303e:	0e 94 49 25 	call	0x4a92	; 0x4a92 <serwrite_uint32>
    3042:	4b c0       	rjmp	.+150    	; 0x30da <gcode_parse_char+0x3ba>
					break;
				case 'P':
					next_target.P = decfloat_to_int(&read_digit, 1);
    3044:	61 e0       	ldi	r22, 0x01	; 1
    3046:	70 e0       	ldi	r23, 0x00	; 0
    3048:	8e ea       	ldi	r24, 0xAE	; 174
    304a:	94 e0       	ldi	r25, 0x04	; 4
    304c:	b7 dd       	rcall	.-1170   	; 0x2bbc <decfloat_to_int>
    304e:	70 93 a2 04 	sts	0x04A2, r23
    3052:	60 93 a1 04 	sts	0x04A1, r22
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    3056:	20 91 cf 04 	lds	r18, 0x04CF
    305a:	22 23       	and	r18, r18
    305c:	0c f0       	brlt	.+2      	; 0x3060 <gcode_parse_char+0x340>
    305e:	3d c0       	rjmp	.+122    	; 0x30da <gcode_parse_char+0x3ba>
	#endif
}

/// Character Received - add it to our command
/// \param c the next character to process
void gcode_parse_char(uint8_t c) {
    3060:	88 27       	eor	r24, r24
    3062:	99 27       	eor	r25, r25
						serwrite_uint16(next_target.S);
					break;
				case 'P':
					next_target.P = decfloat_to_int(&read_digit, 1);
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
						serwrite_uint16(next_target.P);
    3064:	0e 94 49 25 	call	0x4a92	; 0x4a92 <serwrite_uint32>
    3068:	38 c0       	rjmp	.+112    	; 0x30da <gcode_parse_char+0x3ba>
					break;
				case 'T':
					next_target.T = read_digit.mantissa;
    306a:	80 91 ae 04 	lds	r24, 0x04AE
    306e:	90 91 af 04 	lds	r25, 0x04AF
    3072:	a0 91 b0 04 	lds	r26, 0x04B0
    3076:	b0 91 b1 04 	lds	r27, 0x04B1
    307a:	80 93 a3 04 	sts	0x04A3, r24
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    307e:	20 91 cf 04 	lds	r18, 0x04CF
    3082:	22 23       	and	r18, r18
    3084:	54 f5       	brge	.+84     	; 0x30da <gcode_parse_char+0x3ba>
						serwrite_uint8(next_target.T);
    3086:	bc 01       	movw	r22, r24
    3088:	cd 01       	movw	r24, r26
    308a:	77 27       	eor	r23, r23
    308c:	88 27       	eor	r24, r24
    308e:	99 27       	eor	r25, r25
    3090:	0e 94 49 25 	call	0x4a92	; 0x4a92 <serwrite_uint32>
    3094:	22 c0       	rjmp	.+68     	; 0x30da <gcode_parse_char+0x3ba>
					break;
				case 'N':
					next_target.N = decfloat_to_int(&read_digit, 1);
    3096:	61 e0       	ldi	r22, 0x01	; 1
    3098:	70 e0       	ldi	r23, 0x00	; 0
    309a:	8e ea       	ldi	r24, 0xAE	; 174
    309c:	94 e0       	ldi	r25, 0x04	; 4
    309e:	8e dd       	rcall	.-1252   	; 0x2bbc <decfloat_to_int>
    30a0:	e4 ea       	ldi	r30, 0xA4	; 164
    30a2:	f4 e0       	ldi	r31, 0x04	; 4
    30a4:	60 83       	st	Z, r22
    30a6:	71 83       	std	Z+1, r23	; 0x01
    30a8:	82 83       	std	Z+2, r24	; 0x02
    30aa:	93 83       	std	Z+3, r25	; 0x03
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    30ac:	20 91 cf 04 	lds	r18, 0x04CF
    30b0:	22 23       	and	r18, r18
    30b2:	9c f4       	brge	.+38     	; 0x30da <gcode_parse_char+0x3ba>
						serwrite_uint32(next_target.N);
    30b4:	0e 94 49 25 	call	0x4a92	; 0x4a92 <serwrite_uint32>
    30b8:	10 c0       	rjmp	.+32     	; 0x30da <gcode_parse_char+0x3ba>
					break;
				case '*':
					next_target.checksum_read = decfloat_to_int(&read_digit, 1);
    30ba:	61 e0       	ldi	r22, 0x01	; 1
    30bc:	70 e0       	ldi	r23, 0x00	; 0
    30be:	8e ea       	ldi	r24, 0xAE	; 174
    30c0:	94 e0       	ldi	r25, 0x04	; 4
    30c2:	7c dd       	rcall	.-1288   	; 0x2bbc <decfloat_to_int>
    30c4:	60 93 ac 04 	sts	0x04AC, r22
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    30c8:	20 91 cf 04 	lds	r18, 0x04CF
    30cc:	22 23       	and	r18, r18
    30ce:	2c f4       	brge	.+10     	; 0x30da <gcode_parse_char+0x3ba>
	#endif
}

/// Character Received - add it to our command
/// \param c the next character to process
void gcode_parse_char(uint8_t c) {
    30d0:	77 27       	eor	r23, r23
    30d2:	88 27       	eor	r24, r24
    30d4:	99 27       	eor	r25, r25
						serwrite_uint32(next_target.N);
					break;
				case '*':
					next_target.checksum_read = decfloat_to_int(&read_digit, 1);
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
						serwrite_uint8(next_target.checksum_read);
    30d6:	0e 94 49 25 	call	0x4a92	; 0x4a92 <serwrite_uint32>
					break;
			}
			// reset for next field
			last_field = 0;
    30da:	10 92 be 04 	sts	0x04BE, r1
			read_digit.sign = read_digit.mantissa = read_digit.exponent = 0;
    30de:	10 92 ae 04 	sts	0x04AE, r1
    30e2:	10 92 af 04 	sts	0x04AF, r1
    30e6:	10 92 b0 04 	sts	0x04B0, r1
    30ea:	10 92 b1 04 	sts	0x04B1, r1
    30ee:	10 92 b2 04 	sts	0x04B2, r1
		}
	}

	// skip comments
	if (next_target.seen_semi_comment == 0 && next_target.seen_parens_comment == 0) {
    30f2:	80 91 86 04 	lds	r24, 0x0486
    30f6:	98 2f       	mov	r25, r24
    30f8:	90 73       	andi	r25, 0x30	; 48
    30fa:	09 f0       	breq	.+2      	; 0x30fe <gcode_parse_char+0x3de>
    30fc:	f8 c0       	rjmp	.+496    	; 0x32ee <gcode_parse_char+0x5ce>
		// new field?
		if ((c >= 'A' && c <= 'Z') || c == '*') {
    30fe:	8c 2f       	mov	r24, r28
    3100:	81 54       	subi	r24, 0x41	; 65
    3102:	8a 31       	cpi	r24, 0x1A	; 26
    3104:	10 f0       	brcs	.+4      	; 0x310a <gcode_parse_char+0x3ea>
    3106:	ca 32       	cpi	r28, 0x2A	; 42
    3108:	49 f4       	brne	.+18     	; 0x311c <gcode_parse_char+0x3fc>
			last_field = c;
    310a:	c0 93 be 04 	sts	0x04BE, r28
			if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    310e:	80 91 cf 04 	lds	r24, 0x04CF
    3112:	88 23       	and	r24, r24
    3114:	1c f4       	brge	.+6      	; 0x311c <gcode_parse_char+0x3fc>
				serial_writechar(c);
    3116:	8c 2f       	mov	r24, r28
    3118:	0e 94 d0 24 	call	0x49a0	; 0x49a0 <serial_writechar>
		}

		// process character
    // Can't do ranges in switch..case, so process actual digits here.
    // Do it early, as there are many more digits than characters expected.
    if (c >= '0' && c <= '9') {
    311c:	8c 2f       	mov	r24, r28
    311e:	80 53       	subi	r24, 0x30	; 48
    3120:	8a 30       	cpi	r24, 0x0A	; 10
    3122:	08 f0       	brcs	.+2      	; 0x3126 <gcode_parse_char+0x406>
    3124:	5d c0       	rjmp	.+186    	; 0x31e0 <gcode_parse_char+0x4c0>
      if (read_digit.exponent < DECFLOAT_EXP_MAX + 1 &&
    3126:	20 91 b2 04 	lds	r18, 0x04B2
    312a:	2f 77       	andi	r18, 0x7F	; 127
    312c:	82 2f       	mov	r24, r18
    312e:	90 e0       	ldi	r25, 0x00	; 0
    3130:	04 97       	sbiw	r24, 0x04	; 4
    3132:	0c f0       	brlt	.+2      	; 0x3136 <gcode_parse_char+0x416>
    3134:	e5 c0       	rjmp	.+458    	; 0x3300 <gcode_parse_char+0x5e0>
          ((next_target.option_inches == 0 &&
    3136:	80 91 87 04 	lds	r24, 0x0487

		// process character
    // Can't do ranges in switch..case, so process actual digits here.
    // Do it early, as there are many more digits than characters expected.
    if (c >= '0' && c <= '9') {
      if (read_digit.exponent < DECFLOAT_EXP_MAX + 1 &&
    313a:	80 fd       	sbrc	r24, 0
    313c:	0e c0       	rjmp	.+28     	; 0x315a <gcode_parse_char+0x43a>
          ((next_target.option_inches == 0 &&
    313e:	40 91 ae 04 	lds	r20, 0x04AE
    3142:	50 91 af 04 	lds	r21, 0x04AF
    3146:	60 91 b0 04 	lds	r22, 0x04B0
    314a:	70 91 b1 04 	lds	r23, 0x04B1
    314e:	4f 3a       	cpi	r20, 0xAF	; 175
    3150:	55 47       	sbci	r21, 0x75	; 117
    3152:	61 44       	sbci	r22, 0x41	; 65
    3154:	71 05       	cpc	r23, r1
    3156:	78 f0       	brcs	.+30     	; 0x3176 <gcode_parse_char+0x456>
    3158:	d3 c0       	rjmp	.+422    	; 0x3300 <gcode_parse_char+0x5e0>
          read_digit.mantissa < DECFLOAT_MANT_MM_MAX) ||
          (next_target.option_inches &&
    315a:	80 91 ae 04 	lds	r24, 0x04AE
    315e:	90 91 af 04 	lds	r25, 0x04AF
    3162:	a0 91 b0 04 	lds	r26, 0x04B0
    3166:	b0 91 b1 04 	lds	r27, 0x04B1
    316a:	8d 3f       	cpi	r24, 0xFD	; 253
    316c:	90 48       	sbci	r25, 0x80	; 128
    316e:	a2 40       	sbci	r26, 0x02	; 2
    3170:	b1 05       	cpc	r27, r1
    3172:	08 f0       	brcs	.+2      	; 0x3176 <gcode_parse_char+0x456>
    3174:	c5 c0       	rjmp	.+394    	; 0x3300 <gcode_parse_char+0x5e0>
          read_digit.mantissa < DECFLOAT_MANT_IN_MAX))) {
        // this is simply mantissa = (mantissa * 10) + atoi(c) in different clothes
        read_digit.mantissa = (read_digit.mantissa << 3) +
    3176:	ee ea       	ldi	r30, 0xAE	; 174
    3178:	f4 e0       	ldi	r31, 0x04	; 4
    317a:	40 81       	ld	r20, Z
    317c:	51 81       	ldd	r21, Z+1	; 0x01
    317e:	62 81       	ldd	r22, Z+2	; 0x02
    3180:	73 81       	ldd	r23, Z+3	; 0x03
                              (read_digit.mantissa << 1) + (c - '0');
    3182:	44 0f       	add	r20, r20
    3184:	55 1f       	adc	r21, r21
    3186:	66 1f       	adc	r22, r22
    3188:	77 1f       	adc	r23, r23
          ((next_target.option_inches == 0 &&
          read_digit.mantissa < DECFLOAT_MANT_MM_MAX) ||
          (next_target.option_inches &&
          read_digit.mantissa < DECFLOAT_MANT_IN_MAX))) {
        // this is simply mantissa = (mantissa * 10) + atoi(c) in different clothes
        read_digit.mantissa = (read_digit.mantissa << 3) +
    318a:	db 01       	movw	r26, r22
    318c:	ca 01       	movw	r24, r20
    318e:	88 0f       	add	r24, r24
    3190:	99 1f       	adc	r25, r25
    3192:	aa 1f       	adc	r26, r26
    3194:	bb 1f       	adc	r27, r27
    3196:	88 0f       	add	r24, r24
    3198:	99 1f       	adc	r25, r25
    319a:	aa 1f       	adc	r26, r26
    319c:	bb 1f       	adc	r27, r27
    319e:	48 0f       	add	r20, r24
    31a0:	59 1f       	adc	r21, r25
    31a2:	6a 1f       	adc	r22, r26
    31a4:	7b 1f       	adc	r23, r27
                              (read_digit.mantissa << 1) + (c - '0');
    31a6:	8c 2f       	mov	r24, r28
    31a8:	90 e0       	ldi	r25, 0x00	; 0
    31aa:	c0 97       	sbiw	r24, 0x30	; 48
    31ac:	aa 27       	eor	r26, r26
    31ae:	97 fd       	sbrc	r25, 7
    31b0:	a0 95       	com	r26
    31b2:	ba 2f       	mov	r27, r26
    31b4:	48 0f       	add	r20, r24
    31b6:	59 1f       	adc	r21, r25
    31b8:	6a 1f       	adc	r22, r26
    31ba:	7b 1f       	adc	r23, r27
          ((next_target.option_inches == 0 &&
          read_digit.mantissa < DECFLOAT_MANT_MM_MAX) ||
          (next_target.option_inches &&
          read_digit.mantissa < DECFLOAT_MANT_IN_MAX))) {
        // this is simply mantissa = (mantissa * 10) + atoi(c) in different clothes
        read_digit.mantissa = (read_digit.mantissa << 3) +
    31bc:	40 83       	st	Z, r20
    31be:	51 83       	std	Z+1, r21	; 0x01
    31c0:	62 83       	std	Z+2, r22	; 0x02
    31c2:	73 83       	std	Z+3, r23	; 0x03
                              (read_digit.mantissa << 1) + (c - '0');
        if (read_digit.exponent)
    31c4:	80 91 b2 04 	lds	r24, 0x04B2
    31c8:	8f 77       	andi	r24, 0x7F	; 127
    31ca:	09 f4       	brne	.+2      	; 0x31ce <gcode_parse_char+0x4ae>
    31cc:	99 c0       	rjmp	.+306    	; 0x3300 <gcode_parse_char+0x5e0>
          read_digit.exponent++;
    31ce:	2f 5f       	subi	r18, 0xFF	; 255
    31d0:	2f 77       	andi	r18, 0x7F	; 127
    31d2:	e2 eb       	ldi	r30, 0xB2	; 178
    31d4:	f4 e0       	ldi	r31, 0x04	; 4
    31d6:	80 81       	ld	r24, Z
    31d8:	80 78       	andi	r24, 0x80	; 128
    31da:	28 2b       	or	r18, r24
    31dc:	20 83       	st	Z, r18
    31de:	90 c0       	rjmp	.+288    	; 0x3300 <gcode_parse_char+0x5e0>
      }
    }
    else {
      switch (c) {
    31e0:	4c 2f       	mov	r20, r28
    31e2:	50 e0       	ldi	r21, 0x00	; 0
    31e4:	fa 01       	movw	r30, r20
    31e6:	39 97       	sbiw	r30, 0x09	; 9
    31e8:	e2 35       	cpi	r30, 0x52	; 82
    31ea:	f1 05       	cpc	r31, r1
    31ec:	08 f0       	brcs	.+2      	; 0x31f0 <gcode_parse_char+0x4d0>
    31ee:	75 c0       	rjmp	.+234    	; 0x32da <gcode_parse_char+0x5ba>
    31f0:	ee 58       	subi	r30, 0x8E	; 142
    31f2:	ff 4f       	sbci	r31, 0xFF	; 255
    31f4:	0c 94 5c 2a 	jmp	0x54b8	; 0x54b8 <__tablejump2__>
        // Each currently known command is either G or M, so preserve
        // previous G/M unless a new one has appeared.
        // FIXME: same for T command
        case 'G':
          next_target.seen_G = 1;
    31f8:	e5 e8       	ldi	r30, 0x85	; 133
    31fa:	f4 e0       	ldi	r31, 0x04	; 4
    31fc:	80 81       	ld	r24, Z
          next_target.seen_M = 0;
    31fe:	81 60       	ori	r24, 0x01	; 1
    3200:	8d 7f       	andi	r24, 0xFD	; 253
    3202:	80 83       	st	Z, r24
          next_target.M = 0;
    3204:	10 92 89 04 	sts	0x0489, r1
          break;
    3208:	7b c0       	rjmp	.+246    	; 0x3300 <gcode_parse_char+0x5e0>
        case 'M':
          next_target.seen_M = 1;
    320a:	e5 e8       	ldi	r30, 0x85	; 133
    320c:	f4 e0       	ldi	r31, 0x04	; 4
    320e:	80 81       	ld	r24, Z
          next_target.seen_G = 0;
    3210:	82 60       	ori	r24, 0x02	; 2
    3212:	8e 7f       	andi	r24, 0xFE	; 254
    3214:	80 83       	st	Z, r24
          next_target.G = 0;
    3216:	10 92 88 04 	sts	0x0488, r1
          break;
    321a:	72 c0       	rjmp	.+228    	; 0x3300 <gcode_parse_char+0x5e0>
        case 'X':
          next_target.seen_X = 1;
    321c:	e5 e8       	ldi	r30, 0x85	; 133
    321e:	f4 e0       	ldi	r31, 0x04	; 4
    3220:	80 81       	ld	r24, Z
    3222:	84 60       	ori	r24, 0x04	; 4
    3224:	80 83       	st	Z, r24
          break;
    3226:	6c c0       	rjmp	.+216    	; 0x3300 <gcode_parse_char+0x5e0>
        case 'Y':
          next_target.seen_Y = 1;
    3228:	e5 e8       	ldi	r30, 0x85	; 133
    322a:	f4 e0       	ldi	r31, 0x04	; 4
    322c:	80 81       	ld	r24, Z
    322e:	88 60       	ori	r24, 0x08	; 8
    3230:	80 83       	st	Z, r24
          break;
    3232:	66 c0       	rjmp	.+204    	; 0x3300 <gcode_parse_char+0x5e0>
        case 'Z':
          next_target.seen_Z = 1;
    3234:	e5 e8       	ldi	r30, 0x85	; 133
    3236:	f4 e0       	ldi	r31, 0x04	; 4
    3238:	80 81       	ld	r24, Z
    323a:	80 61       	ori	r24, 0x10	; 16
    323c:	80 83       	st	Z, r24
          break;
    323e:	60 c0       	rjmp	.+192    	; 0x3300 <gcode_parse_char+0x5e0>
        case 'E':
          next_target.seen_E = 1;
    3240:	e5 e8       	ldi	r30, 0x85	; 133
    3242:	f4 e0       	ldi	r31, 0x04	; 4
    3244:	80 81       	ld	r24, Z
    3246:	80 62       	ori	r24, 0x20	; 32
    3248:	80 83       	st	Z, r24
          break;
    324a:	5a c0       	rjmp	.+180    	; 0x3300 <gcode_parse_char+0x5e0>
        case 'F':
          next_target.seen_F = 1;
    324c:	e5 e8       	ldi	r30, 0x85	; 133
    324e:	f4 e0       	ldi	r31, 0x04	; 4
    3250:	80 81       	ld	r24, Z
    3252:	80 64       	ori	r24, 0x40	; 64
    3254:	80 83       	st	Z, r24
          break;
    3256:	54 c0       	rjmp	.+168    	; 0x3300 <gcode_parse_char+0x5e0>
        case 'S':
          next_target.seen_S = 1;
    3258:	e5 e8       	ldi	r30, 0x85	; 133
    325a:	f4 e0       	ldi	r31, 0x04	; 4
    325c:	80 81       	ld	r24, Z
    325e:	80 68       	ori	r24, 0x80	; 128
    3260:	80 83       	st	Z, r24
          break;
    3262:	4e c0       	rjmp	.+156    	; 0x3300 <gcode_parse_char+0x5e0>
        case 'P':
          next_target.seen_P = 1;
    3264:	e6 e8       	ldi	r30, 0x86	; 134
    3266:	f4 e0       	ldi	r31, 0x04	; 4
    3268:	80 81       	ld	r24, Z
    326a:	81 60       	ori	r24, 0x01	; 1
    326c:	80 83       	st	Z, r24
          break;
    326e:	48 c0       	rjmp	.+144    	; 0x3300 <gcode_parse_char+0x5e0>
        case 'T':
          next_target.seen_T = 1;
    3270:	e6 e8       	ldi	r30, 0x86	; 134
    3272:	f4 e0       	ldi	r31, 0x04	; 4
    3274:	80 81       	ld	r24, Z
    3276:	82 60       	ori	r24, 0x02	; 2
    3278:	80 83       	st	Z, r24
          break;
    327a:	42 c0       	rjmp	.+132    	; 0x3300 <gcode_parse_char+0x5e0>
        case 'N':
          next_target.seen_N = 1;
    327c:	e6 e8       	ldi	r30, 0x86	; 134
    327e:	f4 e0       	ldi	r31, 0x04	; 4
    3280:	80 81       	ld	r24, Z
    3282:	84 60       	ori	r24, 0x04	; 4
    3284:	80 83       	st	Z, r24
          break;
    3286:	3c c0       	rjmp	.+120    	; 0x3300 <gcode_parse_char+0x5e0>
        case '*':
          next_target.seen_checksum = 1;
    3288:	e6 e8       	ldi	r30, 0x86	; 134
    328a:	f4 e0       	ldi	r31, 0x04	; 4
    328c:	80 81       	ld	r24, Z
    328e:	88 60       	ori	r24, 0x08	; 8
    3290:	80 83       	st	Z, r24
          break;
    3292:	36 c0       	rjmp	.+108    	; 0x3300 <gcode_parse_char+0x5e0>

        // comments
        case ';':
          next_target.seen_semi_comment = 1;
    3294:	e6 e8       	ldi	r30, 0x86	; 134
    3296:	f4 e0       	ldi	r31, 0x04	; 4
    3298:	80 81       	ld	r24, Z
    329a:	80 61       	ori	r24, 0x10	; 16
    329c:	80 83       	st	Z, r24
          break;
    329e:	30 c0       	rjmp	.+96     	; 0x3300 <gcode_parse_char+0x5e0>
        case '(':
          next_target.seen_parens_comment = 1;
    32a0:	e6 e8       	ldi	r30, 0x86	; 134
    32a2:	f4 e0       	ldi	r31, 0x04	; 4
    32a4:	80 81       	ld	r24, Z
    32a6:	80 62       	ori	r24, 0x20	; 32
    32a8:	80 83       	st	Z, r24
          break;
    32aa:	2a c0       	rjmp	.+84     	; 0x3300 <gcode_parse_char+0x5e0>

        // now for some numeracy
        case '-':
          read_digit.sign = 1;
          // force sign to be at start of number, so 1-2 = -2 instead of -12
          read_digit.exponent = 0;
    32ac:	80 e8       	ldi	r24, 0x80	; 128
    32ae:	80 93 b2 04 	sts	0x04B2, r24
          read_digit.mantissa = 0;
    32b2:	10 92 ae 04 	sts	0x04AE, r1
    32b6:	10 92 af 04 	sts	0x04AF, r1
    32ba:	10 92 b0 04 	sts	0x04B0, r1
    32be:	10 92 b1 04 	sts	0x04B1, r1
          break;
    32c2:	1e c0       	rjmp	.+60     	; 0x3300 <gcode_parse_char+0x5e0>
        case '.':
          if (read_digit.exponent == 0)
    32c4:	80 91 b2 04 	lds	r24, 0x04B2
    32c8:	8f 77       	andi	r24, 0x7F	; 127
    32ca:	d1 f4       	brne	.+52     	; 0x3300 <gcode_parse_char+0x5e0>
            read_digit.exponent = 1;
    32cc:	e2 eb       	ldi	r30, 0xB2	; 178
    32ce:	f4 e0       	ldi	r31, 0x04	; 4
    32d0:	80 81       	ld	r24, Z
    32d2:	80 78       	andi	r24, 0x80	; 128
    32d4:	81 60       	ori	r24, 0x01	; 1
    32d6:	80 83       	st	Z, r24
    32d8:	13 c0       	rjmp	.+38     	; 0x3300 <gcode_parse_char+0x5e0>
        #endif

        default:
          #ifdef	DEBUG
            // invalid
            serial_writechar('?');
    32da:	8f e3       	ldi	r24, 0x3F	; 63
    32dc:	0e 94 d0 24 	call	0x49a0	; 0x49a0 <serial_writechar>
            serial_writechar(c);
    32e0:	8c 2f       	mov	r24, r28
    32e2:	0e 94 d0 24 	call	0x49a0	; 0x49a0 <serial_writechar>
            serial_writechar('?');
    32e6:	8f e3       	ldi	r24, 0x3F	; 63
    32e8:	0e 94 d0 24 	call	0x49a0	; 0x49a0 <serial_writechar>
          #endif
          break;
    32ec:	09 c0       	rjmp	.+18     	; 0x3300 <gcode_parse_char+0x5e0>
      }
		}
	} else if ( next_target.seen_parens_comment == 1 && c == ')')
    32ee:	85 ff       	sbrs	r24, 5
    32f0:	07 c0       	rjmp	.+14     	; 0x3300 <gcode_parse_char+0x5e0>
    32f2:	c9 32       	cpi	r28, 0x29	; 41
    32f4:	29 f4       	brne	.+10     	; 0x3300 <gcode_parse_char+0x5e0>
		next_target.seen_parens_comment = 0; // recognize stuff after a (comment)
    32f6:	e6 e8       	ldi	r30, 0x86	; 134
    32f8:	f4 e0       	ldi	r31, 0x04	; 4
    32fa:	80 81       	ld	r24, Z
    32fc:	8f 7d       	andi	r24, 0xDF	; 223
    32fe:	80 83       	st	Z, r24

	if (next_target.seen_checksum == 0)
    3300:	80 91 86 04 	lds	r24, 0x0486
    3304:	83 fd       	sbrc	r24, 3
    3306:	05 c0       	rjmp	.+10     	; 0x3312 <gcode_parse_char+0x5f2>
		next_target.checksum_calculated =
    3308:	ed ea       	ldi	r30, 0xAD	; 173
    330a:	f4 e0       	ldi	r31, 0x04	; 4
    330c:	80 81       	ld	r24, Z
    330e:	d8 27       	eor	r29, r24
    3310:	d0 83       	st	Z, r29
			crc(next_target.checksum_calculated, checksum_char);

	// end of line
	if ((c == 10) || (c == 13)) {
    3312:	ca 30       	cpi	r28, 0x0A	; 10
    3314:	19 f0       	breq	.+6      	; 0x331c <gcode_parse_char+0x5fc>
    3316:	cd 30       	cpi	r28, 0x0D	; 13
    3318:	09 f0       	breq	.+2      	; 0x331c <gcode_parse_char+0x5fc>
    331a:	84 c0       	rjmp	.+264    	; 0x3424 <gcode_parse_char+0x704>
		if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    331c:	80 91 cf 04 	lds	r24, 0x04CF
    3320:	88 23       	and	r24, r24
    3322:	1c f4       	brge	.+6      	; 0x332a <gcode_parse_char+0x60a>
			serial_writechar(c);
    3324:	8c 2f       	mov	r24, r28
    3326:	0e 94 d0 24 	call	0x49a0	; 0x49a0 <serial_writechar>
			) {
			if (
				#ifdef	REQUIRE_CHECKSUM
				((next_target.checksum_calculated == next_target.checksum_read) && (next_target.seen_checksum == 1))
				#else
				((next_target.checksum_calculated == next_target.checksum_read) || (next_target.seen_checksum == 0))
    332a:	80 91 ad 04 	lds	r24, 0x04AD
			(next_target.seen_M && (next_target.M == 110))
		#else
			1
		#endif
			) {
			if (
    332e:	90 91 ac 04 	lds	r25, 0x04AC
    3332:	89 17       	cp	r24, r25
    3334:	21 f0       	breq	.+8      	; 0x333e <gcode_parse_char+0x61e>
				#ifdef	REQUIRE_CHECKSUM
				((next_target.checksum_calculated == next_target.checksum_read) && (next_target.seen_checksum == 1))
				#else
				((next_target.checksum_calculated == next_target.checksum_read) || (next_target.seen_checksum == 0))
    3336:	90 91 86 04 	lds	r25, 0x0486
    333a:	93 fd       	sbrc	r25, 3
    333c:	20 c0       	rjmp	.+64     	; 0x337e <gcode_parse_char+0x65e>
				#endif
				) {
				// process
				serial_writestr_P(PSTR("ok "));
    333e:	88 e0       	ldi	r24, 0x08	; 8
    3340:	94 e0       	ldi	r25, 0x04	; 4
    3342:	0e 94 0c 25 	call	0x4a18	; 0x4a18 <serial_writestr_P>
				process_gcode_command();
    3346:	71 d0       	rcall	.+226    	; 0x342a <process_gcode_command>
				serial_writechar('\n');
    3348:	8a e0       	ldi	r24, 0x0A	; 10
    334a:	0e 94 d0 24 	call	0x49a0	; 0x49a0 <serial_writechar>

				// expect next line number
				if (next_target.seen_N == 1)
    334e:	80 91 86 04 	lds	r24, 0x0486
    3352:	82 ff       	sbrs	r24, 2
    3354:	2e c0       	rjmp	.+92     	; 0x33b2 <gcode_parse_char+0x692>
					next_target.N_expected = next_target.N + 1;
    3356:	80 91 a4 04 	lds	r24, 0x04A4
    335a:	90 91 a5 04 	lds	r25, 0x04A5
    335e:	a0 91 a6 04 	lds	r26, 0x04A6
    3362:	b0 91 a7 04 	lds	r27, 0x04A7
    3366:	01 96       	adiw	r24, 0x01	; 1
    3368:	a1 1d       	adc	r26, r1
    336a:	b1 1d       	adc	r27, r1
    336c:	80 93 a8 04 	sts	0x04A8, r24
    3370:	90 93 a9 04 	sts	0x04A9, r25
    3374:	a0 93 aa 04 	sts	0x04AA, r26
    3378:	b0 93 ab 04 	sts	0x04AB, r27
    337c:	1a c0       	rjmp	.+52     	; 0x33b2 <gcode_parse_char+0x692>
			}
			else {
				sersendf_P(PSTR("rs N%ld Expected checksum %d\n"), next_target.N_expected, next_target.checksum_calculated);
    337e:	1f 92       	push	r1
    3380:	8f 93       	push	r24
    3382:	e8 ea       	ldi	r30, 0xA8	; 168
    3384:	f4 e0       	ldi	r31, 0x04	; 4
    3386:	83 81       	ldd	r24, Z+3	; 0x03
    3388:	8f 93       	push	r24
    338a:	82 81       	ldd	r24, Z+2	; 0x02
    338c:	8f 93       	push	r24
    338e:	81 81       	ldd	r24, Z+1	; 0x01
    3390:	8f 93       	push	r24
    3392:	80 81       	ld	r24, Z
    3394:	8f 93       	push	r24
    3396:	8c e0       	ldi	r24, 0x0C	; 12
    3398:	94 e0       	ldi	r25, 0x04	; 4
    339a:	9f 93       	push	r25
    339c:	8f 93       	push	r24
    339e:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
    33a2:	8d b7       	in	r24, 0x3d	; 61
    33a4:	9e b7       	in	r25, 0x3e	; 62
    33a6:	08 96       	adiw	r24, 0x08	; 8
    33a8:	0f b6       	in	r0, 0x3f	; 63
    33aa:	f8 94       	cli
    33ac:	9e bf       	out	0x3e, r25	; 62
    33ae:	0f be       	out	0x3f, r0	; 63
    33b0:	8d bf       	out	0x3d, r24	; 61
		next_target.seen_X = next_target.seen_Y = next_target.seen_Z = \
			next_target.seen_E = next_target.seen_F = next_target.seen_S = \
			next_target.seen_P = next_target.seen_T = next_target.seen_N = \
			next_target.seen_M = next_target.seen_checksum = next_target.seen_semi_comment = \
			next_target.seen_parens_comment = next_target.checksum_read = \
			next_target.checksum_calculated = 0;
    33b2:	10 92 ad 04 	sts	0x04AD, r1
		// reset variables
		next_target.seen_X = next_target.seen_Y = next_target.seen_Z = \
			next_target.seen_E = next_target.seen_F = next_target.seen_S = \
			next_target.seen_P = next_target.seen_T = next_target.seen_N = \
			next_target.seen_M = next_target.seen_checksum = next_target.seen_semi_comment = \
			next_target.seen_parens_comment = next_target.checksum_read = \
    33b6:	10 92 ac 04 	sts	0x04AC, r1
    33ba:	a6 e8       	ldi	r26, 0x86	; 134
    33bc:	b4 e0       	ldi	r27, 0x04	; 4
    33be:	8c 91       	ld	r24, X

		// reset variables
		next_target.seen_X = next_target.seen_Y = next_target.seen_Z = \
			next_target.seen_E = next_target.seen_F = next_target.seen_S = \
			next_target.seen_P = next_target.seen_T = next_target.seen_N = \
			next_target.seen_M = next_target.seen_checksum = next_target.seen_semi_comment = \
    33c0:	e5 e8       	ldi	r30, 0x85	; 133
    33c2:	f4 e0       	ldi	r31, 0x04	; 4
    33c4:	90 81       	ld	r25, Z
		}

		// reset variables
		next_target.seen_X = next_target.seen_Y = next_target.seen_Z = \
			next_target.seen_E = next_target.seen_F = next_target.seen_S = \
			next_target.seen_P = next_target.seen_T = next_target.seen_N = \
    33c6:	81 7c       	andi	r24, 0xC1	; 193
    33c8:	8e 7f       	andi	r24, 0xFE	; 254
    33ca:	8c 93       	st	X, r24
			next_target.seen_parens_comment = next_target.checksum_read = \
			next_target.checksum_calculated = 0;
		// last_field and read_digit are reset above already

		// assume a G1 by default
		next_target.seen_G = 1;
    33cc:	91 70       	andi	r25, 0x01	; 1
    33ce:	91 60       	ori	r25, 0x01	; 1
    33d0:	90 83       	st	Z, r25
		next_target.G = 1;
    33d2:	91 e0       	ldi	r25, 0x01	; 1
    33d4:	90 93 88 04 	sts	0x0488, r25

		if (next_target.option_all_relative) {
    33d8:	98 2f       	mov	r25, r24
    33da:	86 ff       	sbrs	r24, 6
    33dc:	18 c0       	rjmp	.+48     	; 0x340e <gcode_parse_char+0x6ee>
			next_target.target.X = next_target.target.Y = next_target.target.Z = 0;
    33de:	10 92 92 04 	sts	0x0492, r1
    33e2:	10 92 93 04 	sts	0x0493, r1
    33e6:	10 92 94 04 	sts	0x0494, r1
    33ea:	10 92 95 04 	sts	0x0495, r1
    33ee:	10 92 8e 04 	sts	0x048E, r1
    33f2:	10 92 8f 04 	sts	0x048F, r1
    33f6:	10 92 90 04 	sts	0x0490, r1
    33fa:	10 92 91 04 	sts	0x0491, r1
    33fe:	10 92 8a 04 	sts	0x048A, r1
    3402:	10 92 8b 04 	sts	0x048B, r1
    3406:	10 92 8c 04 	sts	0x048C, r1
    340a:	10 92 8d 04 	sts	0x048D, r1
		}
		if (next_target.option_all_relative || next_target.option_e_relative) {
    340e:	89 2f       	mov	r24, r25
    3410:	80 7c       	andi	r24, 0xC0	; 192
    3412:	41 f0       	breq	.+16     	; 0x3424 <gcode_parse_char+0x704>
			next_target.target.E = 0;
    3414:	10 92 96 04 	sts	0x0496, r1
    3418:	10 92 97 04 	sts	0x0497, r1
    341c:	10 92 98 04 	sts	0x0498, r1
    3420:	10 92 99 04 	sts	0x0499, r1
		}
	}
}
    3424:	df 91       	pop	r29
    3426:	cf 91       	pop	r28
    3428:	08 95       	ret

0000342a <process_gcode_command>:
    If you want to add support for a new G or M code, this is the place.


*//*************************************************************************/

void process_gcode_command() {
    342a:	cf 92       	push	r12
    342c:	df 92       	push	r13
    342e:	ef 92       	push	r14
    3430:	ff 92       	push	r15
    3432:	cf 93       	push	r28
    3434:	df 93       	push	r29
	uint32_t	backup_f;

	// convert relative to absolute
	if (next_target.option_all_relative) {
    3436:	20 91 86 04 	lds	r18, 0x0486
    343a:	26 ff       	sbrs	r18, 6
    343c:	42 c0       	rjmp	.+132    	; 0x34c2 <process_gcode_command+0x98>
		next_target.target.X += startpoint.X;
    343e:	ea e8       	ldi	r30, 0x8A	; 138
    3440:	f4 e0       	ldi	r31, 0x04	; 4
    3442:	40 81       	ld	r20, Z
    3444:	51 81       	ldd	r21, Z+1	; 0x01
    3446:	62 81       	ldd	r22, Z+2	; 0x02
    3448:	73 81       	ldd	r23, Z+3	; 0x03
    344a:	80 91 90 02 	lds	r24, 0x0290
    344e:	90 91 91 02 	lds	r25, 0x0291
    3452:	a0 91 92 02 	lds	r26, 0x0292
    3456:	b0 91 93 02 	lds	r27, 0x0293
    345a:	84 0f       	add	r24, r20
    345c:	95 1f       	adc	r25, r21
    345e:	a6 1f       	adc	r26, r22
    3460:	b7 1f       	adc	r27, r23
    3462:	80 83       	st	Z, r24
    3464:	91 83       	std	Z+1, r25	; 0x01
    3466:	a2 83       	std	Z+2, r26	; 0x02
    3468:	b3 83       	std	Z+3, r27	; 0x03
		next_target.target.Y += startpoint.Y;
    346a:	ee e8       	ldi	r30, 0x8E	; 142
    346c:	f4 e0       	ldi	r31, 0x04	; 4
    346e:	40 81       	ld	r20, Z
    3470:	51 81       	ldd	r21, Z+1	; 0x01
    3472:	62 81       	ldd	r22, Z+2	; 0x02
    3474:	73 81       	ldd	r23, Z+3	; 0x03
    3476:	80 91 94 02 	lds	r24, 0x0294
    347a:	90 91 95 02 	lds	r25, 0x0295
    347e:	a0 91 96 02 	lds	r26, 0x0296
    3482:	b0 91 97 02 	lds	r27, 0x0297
    3486:	84 0f       	add	r24, r20
    3488:	95 1f       	adc	r25, r21
    348a:	a6 1f       	adc	r26, r22
    348c:	b7 1f       	adc	r27, r23
    348e:	80 83       	st	Z, r24
    3490:	91 83       	std	Z+1, r25	; 0x01
    3492:	a2 83       	std	Z+2, r26	; 0x02
    3494:	b3 83       	std	Z+3, r27	; 0x03
		next_target.target.Z += startpoint.Z;
    3496:	e2 e9       	ldi	r30, 0x92	; 146
    3498:	f4 e0       	ldi	r31, 0x04	; 4
    349a:	40 81       	ld	r20, Z
    349c:	51 81       	ldd	r21, Z+1	; 0x01
    349e:	62 81       	ldd	r22, Z+2	; 0x02
    34a0:	73 81       	ldd	r23, Z+3	; 0x03
    34a2:	80 91 98 02 	lds	r24, 0x0298
    34a6:	90 91 99 02 	lds	r25, 0x0299
    34aa:	a0 91 9a 02 	lds	r26, 0x029A
    34ae:	b0 91 9b 02 	lds	r27, 0x029B
    34b2:	84 0f       	add	r24, r20
    34b4:	95 1f       	adc	r25, r21
    34b6:	a6 1f       	adc	r26, r22
    34b8:	b7 1f       	adc	r27, r23
    34ba:	80 83       	st	Z, r24
    34bc:	91 83       	std	Z+1, r25	; 0x01
    34be:	a2 83       	std	Z+2, r26	; 0x02
    34c0:	b3 83       	std	Z+3, r27	; 0x03
	}

	// E relative movement.
	// Matches Sprinter's behaviour as of March 2012.
	if (next_target.option_all_relative || next_target.option_e_relative)
    34c2:	82 2f       	mov	r24, r18
    34c4:	80 7c       	andi	r24, 0xC0	; 192
    34c6:	31 f0       	breq	.+12     	; 0x34d4 <process_gcode_command+0xaa>
		next_target.target.e_relative = 1;
    34c8:	ee e9       	ldi	r30, 0x9E	; 158
    34ca:	f4 e0       	ldi	r31, 0x04	; 4
    34cc:	80 81       	ld	r24, Z
    34ce:	81 60       	ori	r24, 0x01	; 1
    34d0:	80 83       	st	Z, r24
    34d2:	05 c0       	rjmp	.+10     	; 0x34de <process_gcode_command+0xb4>
	else
		next_target.target.e_relative = 0;
    34d4:	ee e9       	ldi	r30, 0x9E	; 158
    34d6:	f4 e0       	ldi	r31, 0x04	; 4
    34d8:	80 81       	ld	r24, Z
    34da:	8e 7f       	andi	r24, 0xFE	; 254
    34dc:	80 83       	st	Z, r24
	#endif


	// The GCode documentation was taken from http://reprap.org/wiki/Gcode .

	if (next_target.seen_T) {
    34de:	21 ff       	sbrs	r18, 1
    34e0:	04 c0       	rjmp	.+8      	; 0x34ea <process_gcode_command+0xc0>
	    //?
	    //? Example: T1
	    //?
	    //? Select extruder number 1 to build with.  Extruder numbering starts at 0.

	    next_tool = next_target.T;
    34e2:	80 91 a3 04 	lds	r24, 0x04A3
    34e6:	80 93 d0 04 	sts	0x04D0, r24
	}

	if (next_target.seen_G) {
    34ea:	80 91 85 04 	lds	r24, 0x0485
    34ee:	80 ff       	sbrs	r24, 0
    34f0:	60 c1       	rjmp	.+704    	; 0x37b2 <process_gcode_command+0x388>
		uint8_t axisSelected = 0;
		switch (next_target.G) {
    34f2:	90 91 88 04 	lds	r25, 0x0488
    34f6:	9c 31       	cpi	r25, 0x1C	; 28
    34f8:	09 f4       	brne	.+2      	; 0x34fc <process_gcode_command+0xd2>
    34fa:	73 c0       	rjmp	.+230    	; 0x35e2 <process_gcode_command+0x1b8>
    34fc:	88 f4       	brcc	.+34     	; 0x3520 <process_gcode_command+0xf6>
    34fe:	94 30       	cpi	r25, 0x04	; 4
    3500:	09 f4       	brne	.+2      	; 0x3504 <process_gcode_command+0xda>
    3502:	41 c0       	rjmp	.+130    	; 0x3586 <process_gcode_command+0x15c>
    3504:	30 f4       	brcc	.+12     	; 0x3512 <process_gcode_command+0xe8>
    3506:	99 23       	and	r25, r25
    3508:	01 f1       	breq	.+64     	; 0x354a <process_gcode_command+0x120>
    350a:	91 30       	cpi	r25, 0x01	; 1
    350c:	09 f0       	breq	.+2      	; 0x3510 <process_gcode_command+0xe6>
    350e:	44 c1       	rjmp	.+648    	; 0x3798 <process_gcode_command+0x36e>
    3510:	34 c0       	rjmp	.+104    	; 0x357a <process_gcode_command+0x150>
    3512:	94 31       	cpi	r25, 0x14	; 20
    3514:	09 f4       	brne	.+2      	; 0x3518 <process_gcode_command+0xee>
    3516:	54 c0       	rjmp	.+168    	; 0x35c0 <process_gcode_command+0x196>
    3518:	95 31       	cpi	r25, 0x15	; 21
    351a:	09 f0       	breq	.+2      	; 0x351e <process_gcode_command+0xf4>
    351c:	3d c1       	rjmp	.+634    	; 0x3798 <process_gcode_command+0x36e>
    351e:	56 c0       	rjmp	.+172    	; 0x35cc <process_gcode_command+0x1a2>
    3520:	9b 35       	cpi	r25, 0x5B	; 91
    3522:	09 f4       	brne	.+2      	; 0x3526 <process_gcode_command+0xfc>
    3524:	83 c0       	rjmp	.+262    	; 0x362c <process_gcode_command+0x202>
    3526:	38 f4       	brcc	.+14     	; 0x3536 <process_gcode_command+0x10c>
    3528:	9e 31       	cpi	r25, 0x1E	; 30
    352a:	09 f4       	brne	.+2      	; 0x352e <process_gcode_command+0x104>
    352c:	55 c0       	rjmp	.+170    	; 0x35d8 <process_gcode_command+0x1ae>
    352e:	9a 35       	cpi	r25, 0x5A	; 90
    3530:	09 f0       	breq	.+2      	; 0x3534 <process_gcode_command+0x10a>
    3532:	32 c1       	rjmp	.+612    	; 0x3798 <process_gcode_command+0x36e>
    3534:	75 c0       	rjmp	.+234    	; 0x3620 <process_gcode_command+0x1f6>
    3536:	91 3a       	cpi	r25, 0xA1	; 161
    3538:	09 f4       	brne	.+2      	; 0x353c <process_gcode_command+0x112>
    353a:	16 c1       	rjmp	.+556    	; 0x3768 <process_gcode_command+0x33e>
    353c:	92 3a       	cpi	r25, 0xA2	; 162
    353e:	09 f4       	brne	.+2      	; 0x3542 <process_gcode_command+0x118>
    3540:	1f c1       	rjmp	.+574    	; 0x3780 <process_gcode_command+0x356>
    3542:	9c 35       	cpi	r25, 0x5C	; 92
    3544:	09 f0       	breq	.+2      	; 0x3548 <process_gcode_command+0x11e>
    3546:	28 c1       	rjmp	.+592    	; 0x3798 <process_gcode_command+0x36e>
    3548:	77 c0       	rjmp	.+238    	; 0x3638 <process_gcode_command+0x20e>
				//?
				//? Example: G0 X12
				//?
				//? In this case move rapidly to X = 12 mm.  In fact, the RepRap firmware uses exactly the same code for rapid as it uses for controlled moves (see G1 below), as - for the RepRap machine - this is just as efficient as not doing so.  (The distinction comes from some old machine tools that used to move faster if the axes were not driven in a straight line.  For them G0 allowed any movement in space to get to the destination as fast as possible.)
				//?
				backup_f = next_target.target.F;
    354a:	ca e9       	ldi	r28, 0x9A	; 154
    354c:	d4 e0       	ldi	r29, 0x04	; 4
    354e:	c8 80       	ld	r12, Y
    3550:	d9 80       	ldd	r13, Y+1	; 0x01
    3552:	ea 80       	ldd	r14, Y+2	; 0x02
    3554:	fb 80       	ldd	r15, Y+3	; 0x03
				next_target.target.F = MAXIMUM_FEEDRATE_X * 2L;
    3556:	80 e9       	ldi	r24, 0x90	; 144
    3558:	91 e0       	ldi	r25, 0x01	; 1
    355a:	a0 e0       	ldi	r26, 0x00	; 0
    355c:	b0 e0       	ldi	r27, 0x00	; 0
    355e:	88 83       	st	Y, r24
    3560:	99 83       	std	Y+1, r25	; 0x01
    3562:	aa 83       	std	Y+2, r26	; 0x02
    3564:	bb 83       	std	Y+3, r27	; 0x03
// t == NULL means add a wait for target temp to the queue
void enqueue_home(TARGET *t, uint8_t endstop_check, uint8_t endstop_stop_cond);

static void enqueue(TARGET *) __attribute__ ((always_inline));
inline void enqueue(TARGET *t) {
  enqueue_home(t, 0, 0);
    3566:	40 e0       	ldi	r20, 0x00	; 0
    3568:	60 e0       	ldi	r22, 0x00	; 0
    356a:	8a e8       	ldi	r24, 0x8A	; 138
    356c:	94 e0       	ldi	r25, 0x04	; 4
    356e:	13 da       	rcall	.-3034   	; 0x2996 <enqueue_home>
				enqueue(&next_target.target);
				next_target.target.F = backup_f;
    3570:	c8 82       	st	Y, r12
    3572:	d9 82       	std	Y+1, r13	; 0x01
    3574:	ea 82       	std	Y+2, r14	; 0x02
    3576:	fb 82       	std	Y+3, r15	; 0x03
				break;
    3578:	32 c3       	rjmp	.+1636   	; 0x3bde <process_gcode_command+0x7b4>
    357a:	40 e0       	ldi	r20, 0x00	; 0
    357c:	60 e0       	ldi	r22, 0x00	; 0
    357e:	8a e8       	ldi	r24, 0x8A	; 138
    3580:	94 e0       	ldi	r25, 0x04	; 4
    3582:	09 da       	rcall	.-3054   	; 0x2996 <enqueue_home>
    3584:	2c c3       	rjmp	.+1624   	; 0x3bde <process_gcode_command+0x7b4>
				//?
				//? Example: G4 P200
				//?
				//? In this case sit still doing nothing for 200 milliseconds.  During delays the state of the machine (for example the temperatures of its extruders) will still be preserved and controlled.
				//?
				queue_wait();
    3586:	c0 da       	rcall	.-2688   	; 0x2b08 <queue_wait>
				// delay
				if (next_target.seen_P) {
    3588:	80 91 86 04 	lds	r24, 0x0486
    358c:	80 ff       	sbrs	r24, 0
    358e:	27 c3       	rjmp	.+1614   	; 0x3bde <process_gcode_command+0x7b4>
					for (;next_target.P > 0;next_target.P--) {
    3590:	80 91 a1 04 	lds	r24, 0x04A1
    3594:	90 91 a2 04 	lds	r25, 0x04A2
    3598:	89 2b       	or	r24, r25
    359a:	09 f4       	brne	.+2      	; 0x359e <process_gcode_command+0x174>
    359c:	20 c3       	rjmp	.+1600   	; 0x3bde <process_gcode_command+0x7b4>
    359e:	c1 ea       	ldi	r28, 0xA1	; 161
    35a0:	d4 e0       	ldi	r29, 0x04	; 4
						clock();
    35a2:	0e 94 62 05 	call	0xac4	; 0xac4 <clock>
						delay_ms(1);
    35a6:	61 e0       	ldi	r22, 0x01	; 1
    35a8:	70 e0       	ldi	r23, 0x00	; 0
    35aa:	80 e0       	ldi	r24, 0x00	; 0
    35ac:	90 e0       	ldi	r25, 0x00	; 0
    35ae:	dd da       	rcall	.-2630   	; 0x2b6a <delay_ms>
				//? In this case sit still doing nothing for 200 milliseconds.  During delays the state of the machine (for example the temperatures of its extruders) will still be preserved and controlled.
				//?
				queue_wait();
				// delay
				if (next_target.seen_P) {
					for (;next_target.P > 0;next_target.P--) {
    35b0:	88 81       	ld	r24, Y
    35b2:	99 81       	ldd	r25, Y+1	; 0x01
    35b4:	01 97       	sbiw	r24, 0x01	; 1
    35b6:	99 83       	std	Y+1, r25	; 0x01
    35b8:	88 83       	st	Y, r24
    35ba:	89 2b       	or	r24, r25
    35bc:	91 f7       	brne	.-28     	; 0x35a2 <process_gcode_command+0x178>
    35be:	0f c3       	rjmp	.+1566   	; 0x3bde <process_gcode_command+0x7b4>
				//?
				//? Example: G20
				//?
				//? Units from now on are in inches.
				//?
				next_target.option_inches = 1;
    35c0:	e7 e8       	ldi	r30, 0x87	; 135
    35c2:	f4 e0       	ldi	r31, 0x04	; 4
    35c4:	80 81       	ld	r24, Z
    35c6:	81 60       	ori	r24, 0x01	; 1
    35c8:	80 83       	st	Z, r24
				break;
    35ca:	09 c3       	rjmp	.+1554   	; 0x3bde <process_gcode_command+0x7b4>
				//?
				//? Example: G21
				//?
				//? Units from now on are in millimeters.  (This is the RepRap default.)
				//?
				next_target.option_inches = 0;
    35cc:	e7 e8       	ldi	r30, 0x87	; 135
    35ce:	f4 e0       	ldi	r31, 0x04	; 4
    35d0:	80 81       	ld	r24, Z
    35d2:	8e 7f       	andi	r24, 0xFE	; 254
    35d4:	80 83       	st	Z, r24
				break;
    35d6:	03 c3       	rjmp	.+1542   	; 0x3bde <process_gcode_command+0x7b4>
    35d8:	40 e0       	ldi	r20, 0x00	; 0
    35da:	60 e0       	ldi	r22, 0x00	; 0
    35dc:	8a e8       	ldi	r24, 0x8A	; 138
    35de:	94 e0       	ldi	r25, 0x04	; 4
    35e0:	da d9       	rcall	.-3148   	; 0x2996 <enqueue_home>
				//? G28 X0 Y72.3
				//?
				//? will zero the X and Y axes, but not Z.  The actual coordinate values are ignored.
				//?

				queue_wait();
    35e2:	92 da       	rcall	.-2780   	; 0x2b08 <queue_wait>

				if (next_target.seen_X) {
    35e4:	80 91 85 04 	lds	r24, 0x0485
    35e8:	82 ff       	sbrs	r24, 2
    35ea:	03 c0       	rjmp	.+6      	; 0x35f2 <process_gcode_command+0x1c8>
					#if defined	X_MIN_PIN
						home_x_negative();
    35ec:	a8 d7       	rcall	.+3920   	; 0x453e <home_x_negative>
					#elif defined X_MAX_PIN
						home_x_positive();
					#endif
					axisSelected = 1;
    35ee:	81 e0       	ldi	r24, 0x01	; 1
    35f0:	01 c0       	rjmp	.+2      	; 0x35f4 <process_gcode_command+0x1ca>

	    next_tool = next_target.T;
	}

	if (next_target.seen_G) {
		uint8_t axisSelected = 0;
    35f2:	80 e0       	ldi	r24, 0x00	; 0
					#elif defined X_MAX_PIN
						home_x_positive();
					#endif
					axisSelected = 1;
				}
				if (next_target.seen_Y) {
    35f4:	90 91 85 04 	lds	r25, 0x0485
    35f8:	93 ff       	sbrs	r25, 3
    35fa:	06 c0       	rjmp	.+12     	; 0x3608 <process_gcode_command+0x1de>
					#if defined	Y_MIN_PIN
						home_y_negative();
    35fc:	fd d7       	rcall	.+4090   	; 0x45f8 <home_y_negative>
					#elif defined Y_MAX_PIN
						home_y_positive();
					#endif
					axisSelected = 1;
				}
				if (next_target.seen_Z) {
    35fe:	80 91 85 04 	lds	r24, 0x0485
    3602:	84 ff       	sbrs	r24, 4
    3604:	ec c2       	rjmp	.+1496   	; 0x3bde <process_gcode_command+0x7b4>
    3606:	04 c0       	rjmp	.+8      	; 0x3610 <process_gcode_command+0x1e6>
    3608:	90 91 85 04 	lds	r25, 0x0485
    360c:	94 ff       	sbrs	r25, 4
    360e:	03 c0       	rjmp	.+6      	; 0x3616 <process_gcode_command+0x1ec>
					#if defined Z_MAX_PIN
						home_z_positive();
					#elif defined	Z_MIN_PIN
						home_z_negative();
    3610:	0e 94 59 23 	call	0x46b2	; 0x46b2 <home_z_negative>
    3614:	e4 c2       	rjmp	.+1480   	; 0x3bde <process_gcode_command+0x7b4>
					#endif
					axisSelected = 1;
				}
				// there's no point in moving E, as E has no endstops

				if (!axisSelected) {
    3616:	81 11       	cpse	r24, r1
    3618:	e2 c2       	rjmp	.+1476   	; 0x3bde <process_gcode_command+0x7b4>
					home();
    361a:	0e 94 b5 23 	call	0x476a	; 0x476a <home>
    361e:	df c2       	rjmp	.+1470   	; 0x3bde <process_gcode_command+0x7b4>
				//? coordinate system while E doesn't change it's position in the
				//? coordinate system on relative movements.
				//?

				// No wait_queue() needed.
				next_target.option_all_relative = 0;
    3620:	e6 e8       	ldi	r30, 0x86	; 134
    3622:	f4 e0       	ldi	r31, 0x04	; 4
    3624:	80 81       	ld	r24, Z
    3626:	8f 7b       	andi	r24, 0xBF	; 191
    3628:	80 83       	st	Z, r24
				break;
    362a:	d9 c2       	rjmp	.+1458   	; 0x3bde <process_gcode_command+0x7b4>
				//?
				//? All coordinates from now on are relative to the last position.
				//?

				// No wait_queue() needed.
				next_target.option_all_relative = 1;
    362c:	e6 e8       	ldi	r30, 0x86	; 134
    362e:	f4 e0       	ldi	r31, 0x04	; 4
    3630:	80 81       	ld	r24, Z
    3632:	80 64       	ori	r24, 0x40	; 64
    3634:	80 83       	st	Z, r24
				break;
    3636:	d3 c2       	rjmp	.+1446   	; 0x3bde <process_gcode_command+0x7b4>
				//? Example: G92 X10 E90
				//?
				//? Allows programming of absolute zero point, by reseting the current position to the values specified.  This would set the machine's X coordinate to 10, and the extrude coordinate to 90. No physical motion will occur.
				//?

				queue_wait();
    3638:	67 da       	rcall	.-2866   	; 0x2b08 <queue_wait>

				if (next_target.seen_X) {
    363a:	20 91 85 04 	lds	r18, 0x0485
    363e:	22 ff       	sbrs	r18, 2
    3640:	12 c0       	rjmp	.+36     	; 0x3666 <process_gcode_command+0x23c>
					startpoint.X = next_target.target.X;
    3642:	80 91 8a 04 	lds	r24, 0x048A
    3646:	90 91 8b 04 	lds	r25, 0x048B
    364a:	a0 91 8c 04 	lds	r26, 0x048C
    364e:	b0 91 8d 04 	lds	r27, 0x048D
    3652:	80 93 90 02 	sts	0x0290, r24
    3656:	90 93 91 02 	sts	0x0291, r25
    365a:	a0 93 92 02 	sts	0x0292, r26
    365e:	b0 93 93 02 	sts	0x0293, r27
					axisSelected = 1;
    3662:	81 e0       	ldi	r24, 0x01	; 1
    3664:	01 c0       	rjmp	.+2      	; 0x3668 <process_gcode_command+0x23e>

	    next_tool = next_target.T;
	}

	if (next_target.seen_G) {
		uint8_t axisSelected = 0;
    3666:	80 e0       	ldi	r24, 0x00	; 0

				if (next_target.seen_X) {
					startpoint.X = next_target.target.X;
					axisSelected = 1;
				}
				if (next_target.seen_Y) {
    3668:	23 ff       	sbrs	r18, 3
    366a:	11 c0       	rjmp	.+34     	; 0x368e <process_gcode_command+0x264>
					startpoint.Y = next_target.target.Y;
    366c:	80 91 8e 04 	lds	r24, 0x048E
    3670:	90 91 8f 04 	lds	r25, 0x048F
    3674:	a0 91 90 04 	lds	r26, 0x0490
    3678:	b0 91 91 04 	lds	r27, 0x0491
    367c:	80 93 94 02 	sts	0x0294, r24
    3680:	90 93 95 02 	sts	0x0295, r25
    3684:	a0 93 96 02 	sts	0x0296, r26
    3688:	b0 93 97 02 	sts	0x0297, r27
					axisSelected = 1;
    368c:	81 e0       	ldi	r24, 0x01	; 1
				}
				if (next_target.seen_Z) {
    368e:	24 ff       	sbrs	r18, 4
    3690:	13 c0       	rjmp	.+38     	; 0x36b8 <process_gcode_command+0x28e>
					startpoint.Z = next_target.target.Z;
    3692:	80 91 92 04 	lds	r24, 0x0492
    3696:	90 91 93 04 	lds	r25, 0x0493
    369a:	a0 91 94 04 	lds	r26, 0x0494
    369e:	b0 91 95 04 	lds	r27, 0x0495
    36a2:	80 93 98 02 	sts	0x0298, r24
    36a6:	90 93 99 02 	sts	0x0299, r25
    36aa:	a0 93 9a 02 	sts	0x029A, r26
    36ae:	b0 93 9b 02 	sts	0x029B, r27
					axisSelected = 1;
				}
				if (next_target.seen_E) {
    36b2:	25 fd       	sbrc	r18, 5
    36b4:	03 c0       	rjmp	.+6      	; 0x36bc <process_gcode_command+0x292>
    36b6:	55 c0       	rjmp	.+170    	; 0x3762 <process_gcode_command+0x338>
    36b8:	25 ff       	sbrs	r18, 5
    36ba:	11 c0       	rjmp	.+34     	; 0x36de <process_gcode_command+0x2b4>
					startpoint.E = next_target.target.E;
    36bc:	80 91 96 04 	lds	r24, 0x0496
    36c0:	90 91 97 04 	lds	r25, 0x0497
    36c4:	a0 91 98 04 	lds	r26, 0x0498
    36c8:	b0 91 99 04 	lds	r27, 0x0499
    36cc:	80 93 9c 02 	sts	0x029C, r24
    36d0:	90 93 9d 02 	sts	0x029D, r25
    36d4:	a0 93 9e 02 	sts	0x029E, r26
    36d8:	b0 93 9f 02 	sts	0x029F, r27
    36dc:	42 c0       	rjmp	.+132    	; 0x3762 <process_gcode_command+0x338>
					axisSelected = 1;
				}

				if (axisSelected == 0) {
    36de:	81 11       	cpse	r24, r1
    36e0:	40 c0       	rjmp	.+128    	; 0x3762 <process_gcode_command+0x338>
					startpoint.X = next_target.target.X =
					startpoint.Y = next_target.target.Y =
					startpoint.Z = next_target.target.Z =
					startpoint.E = next_target.target.E = 0;
    36e2:	10 92 96 04 	sts	0x0496, r1
    36e6:	10 92 97 04 	sts	0x0497, r1
    36ea:	10 92 98 04 	sts	0x0498, r1
    36ee:	10 92 99 04 	sts	0x0499, r1
    36f2:	10 92 9c 02 	sts	0x029C, r1
    36f6:	10 92 9d 02 	sts	0x029D, r1
    36fa:	10 92 9e 02 	sts	0x029E, r1
    36fe:	10 92 9f 02 	sts	0x029F, r1
				}

				if (axisSelected == 0) {
					startpoint.X = next_target.target.X =
					startpoint.Y = next_target.target.Y =
					startpoint.Z = next_target.target.Z =
    3702:	10 92 92 04 	sts	0x0492, r1
    3706:	10 92 93 04 	sts	0x0493, r1
    370a:	10 92 94 04 	sts	0x0494, r1
    370e:	10 92 95 04 	sts	0x0495, r1
    3712:	10 92 98 02 	sts	0x0298, r1
    3716:	10 92 99 02 	sts	0x0299, r1
    371a:	10 92 9a 02 	sts	0x029A, r1
    371e:	10 92 9b 02 	sts	0x029B, r1
					axisSelected = 1;
				}

				if (axisSelected == 0) {
					startpoint.X = next_target.target.X =
					startpoint.Y = next_target.target.Y =
    3722:	10 92 8e 04 	sts	0x048E, r1
    3726:	10 92 8f 04 	sts	0x048F, r1
    372a:	10 92 90 04 	sts	0x0490, r1
    372e:	10 92 91 04 	sts	0x0491, r1
    3732:	10 92 94 02 	sts	0x0294, r1
    3736:	10 92 95 02 	sts	0x0295, r1
    373a:	10 92 96 02 	sts	0x0296, r1
    373e:	10 92 97 02 	sts	0x0297, r1
					startpoint.E = next_target.target.E;
					axisSelected = 1;
				}

				if (axisSelected == 0) {
					startpoint.X = next_target.target.X =
    3742:	10 92 8a 04 	sts	0x048A, r1
    3746:	10 92 8b 04 	sts	0x048B, r1
    374a:	10 92 8c 04 	sts	0x048C, r1
    374e:	10 92 8d 04 	sts	0x048D, r1
    3752:	10 92 90 02 	sts	0x0290, r1
    3756:	10 92 91 02 	sts	0x0291, r1
    375a:	10 92 92 02 	sts	0x0292, r1
    375e:	10 92 93 02 	sts	0x0293, r1
					startpoint.Y = next_target.target.Y =
					startpoint.Z = next_target.target.Z =
					startpoint.E = next_target.target.E = 0;
				}

				dda_new_startpoint();
    3762:	0e 94 05 07 	call	0xe0a	; 0xe0a <dda_new_startpoint>
				break;
    3766:	3b c2       	rjmp	.+1142   	; 0x3bde <process_gcode_command+0x7b4>
			case 161:
				//? --- G161: Home negative ---
				//?
				//? Find the minimum limit of the specified axes by searching for the limit switch.
				//?
				if (next_target.seen_X)
    3768:	82 fd       	sbrc	r24, 2
					home_x_negative();
    376a:	e9 d6       	rcall	.+3538   	; 0x453e <home_x_negative>
				if (next_target.seen_Y)
    376c:	80 91 85 04 	lds	r24, 0x0485
    3770:	83 fd       	sbrc	r24, 3
					home_y_negative();
    3772:	42 d7       	rcall	.+3716   	; 0x45f8 <home_y_negative>
				if (next_target.seen_Z)
    3774:	80 91 85 04 	lds	r24, 0x0485
    3778:	84 ff       	sbrs	r24, 4
    377a:	31 c2       	rjmp	.+1122   	; 0x3bde <process_gcode_command+0x7b4>
					home_z_negative();
    377c:	9a d7       	rcall	.+3892   	; 0x46b2 <home_z_negative>
    377e:	2f c2       	rjmp	.+1118   	; 0x3bde <process_gcode_command+0x7b4>
			case 162:
				//? --- G162: Home positive ---
				//?
				//? Find the maximum limit of the specified axes by searching for the limit switch.
				//?
				if (next_target.seen_X)
    3780:	82 fd       	sbrc	r24, 2
					home_x_positive();
    3782:	39 d7       	rcall	.+3698   	; 0x45f6 <home_x_positive>
				if (next_target.seen_Y)
    3784:	80 91 85 04 	lds	r24, 0x0485
    3788:	83 fd       	sbrc	r24, 3
					home_y_positive();
    378a:	92 d7       	rcall	.+3876   	; 0x46b0 <home_y_positive>
				if (next_target.seen_Z)
    378c:	80 91 85 04 	lds	r24, 0x0485
    3790:	84 ff       	sbrs	r24, 4
    3792:	25 c2       	rjmp	.+1098   	; 0x3bde <process_gcode_command+0x7b4>
					home_z_positive();
    3794:	ed d7       	rcall	.+4058   	; 0x4770 <home_z_positive>
    3796:	23 c2       	rjmp	.+1094   	; 0x3bde <process_gcode_command+0x7b4>
				break;

				// unknown gcode: spit an error
			default:
				sersendf_P(PSTR("E: Bad G-code %d"), next_target.G);
    3798:	1f 92       	push	r1
    379a:	9f 93       	push	r25
    379c:	8a e2       	ldi	r24, 0x2A	; 42
    379e:	94 e0       	ldi	r25, 0x04	; 4
    37a0:	9f 93       	push	r25
    37a2:	8f 93       	push	r24
    37a4:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
				// newline is sent from gcode_parse after we return
				return;
    37a8:	0f 90       	pop	r0
    37aa:	0f 90       	pop	r0
    37ac:	0f 90       	pop	r0
    37ae:	0f 90       	pop	r0
    37b0:	16 c2       	rjmp	.+1068   	; 0x3bde <process_gcode_command+0x7b4>
		}
	}
	else if (next_target.seen_M) {
    37b2:	81 ff       	sbrs	r24, 1
    37b4:	14 c2       	rjmp	.+1064   	; 0x3bde <process_gcode_command+0x7b4>
		uint8_t i;

		switch (next_target.M) {
    37b6:	90 91 89 04 	lds	r25, 0x0489
    37ba:	e9 2f       	mov	r30, r25
    37bc:	f0 e0       	ldi	r31, 0x00	; 0
    37be:	e2 3f       	cpi	r30, 0xF2	; 242
    37c0:	f1 05       	cpc	r31, r1
    37c2:	08 f0       	brcs	.+2      	; 0x37c6 <process_gcode_command+0x39c>
    37c4:	00 c2       	rjmp	.+1024   	; 0x3bc6 <process_gcode_command+0x79c>
    37c6:	ec 53       	subi	r30, 0x3C	; 60
    37c8:	ff 4f       	sbci	r31, 0xFF	; 255
    37ca:	0c 94 5c 2a 	jmp	0x54b8	; 0x54b8 <__tablejump2__>
				//?
				//? Example: M2
				//?
				//? http://linuxcnc.org/handbook/RS274NGC_3/RS274NGC_33a.html#1002379
				//?
				queue_wait();
    37ce:	9c d9       	rcall	.-3272   	; 0x2b08 <queue_wait>
				for (i = 0; i < NUM_HEATERS; i++)
					temp_set(i, 0);
    37d0:	60 e0       	ldi	r22, 0x00	; 0
    37d2:	70 e0       	ldi	r23, 0x00	; 0
    37d4:	80 e0       	ldi	r24, 0x00	; 0
    37d6:	0e 94 ab 28 	call	0x5156	; 0x5156 <temp_set>
    37da:	60 e0       	ldi	r22, 0x00	; 0
    37dc:	70 e0       	ldi	r23, 0x00	; 0
    37de:	81 e0       	ldi	r24, 0x01	; 1
    37e0:	0e 94 ab 28 	call	0x5156	; 0x5156 <temp_set>
				power_off();
    37e4:	0e 94 24 24 	call	0x4848	; 0x4848 <power_off>
				break;
    37e8:	fa c1       	rjmp	.+1012   	; 0x3bde <process_gcode_command+0x7b4>
				//?
				//? Any moves in progress are immediately terminated, then RepRap shuts down.  All motors and heaters are turned off.
				//? It can be started again by pressing the reset button on the master microcontroller.  See also M0.
				//?

				timer_stop();
    37ea:	0e 94 0d 2a 	call	0x541a	; 0x541a <timer_stop>
				queue_flush();
    37ee:	7e d9       	rcall	.-3332   	; 0x2aec <queue_flush>
				power_off();
    37f0:	0e 94 24 24 	call	0x4848	; 0x4848 <power_off>
				cli();
    37f4:	f8 94       	cli
    37f6:	ff cf       	rjmp	.-2      	; 0x37f6 <process_gcode_command+0x3cc>

			case 6:
				//? --- M6: tool change ---
				//?
				//? Undocumented.
				tool = next_tool;
    37f8:	80 91 d0 04 	lds	r24, 0x04D0
    37fc:	80 93 d1 04 	sts	0x04D1, r24
				break;
    3800:	ee c1       	rjmp	.+988    	; 0x3bde <process_gcode_command+0x7b4>
				//? While E does relative movements, it doesn't change its
				//? position in the coordinate system. See also comment on G90.
				//?

				// No wait_queue() needed.
				next_target.option_e_relative = 0;
    3802:	e6 e8       	ldi	r30, 0x86	; 134
    3804:	f4 e0       	ldi	r31, 0x04	; 4
    3806:	80 81       	ld	r24, Z
    3808:	8f 77       	andi	r24, 0x7F	; 127
    380a:	80 83       	st	Z, r24
				break;
    380c:	e8 c1       	rjmp	.+976    	; 0x3bde <process_gcode_command+0x7b4>
				//?
				//? Counterpart to M82.
				//?

				// No wait_queue() needed.
				next_target.option_e_relative = 1;
    380e:	e6 e8       	ldi	r30, 0x86	; 134
    3810:	f4 e0       	ldi	r31, 0x04	; 4
    3812:	80 81       	ld	r24, Z
    3814:	80 68       	ori	r24, 0x80	; 128
    3816:	80 83       	st	Z, r24
				break;
    3818:	e2 c1       	rjmp	.+964    	; 0x3bde <process_gcode_command+0x7b4>
			case 3:
			case 101:
				//? --- M101: extruder on ---
				//?
				//? Undocumented.
				if (temp_achieved() == 0) {
    381a:	0e 94 a0 28 	call	0x5140	; 0x5140 <temp_achieved>
    381e:	81 11       	cpse	r24, r1
    3820:	de c1       	rjmp	.+956    	; 0x3bde <process_gcode_command+0x7b4>
    3822:	40 e0       	ldi	r20, 0x00	; 0
    3824:	60 e0       	ldi	r22, 0x00	; 0
    3826:	80 e0       	ldi	r24, 0x00	; 0
    3828:	90 e0       	ldi	r25, 0x00	; 0
    382a:	b5 d8       	rcall	.-3734   	; 0x2996 <enqueue_home>
    382c:	d8 c1       	rjmp	.+944    	; 0x3bde <process_gcode_command+0x7b4>
        //? Teacup supports an optional P parameter as a zero-based temperature
        //? sensor index to address (e.g. M104 P1 S100 will set the temperature
        //? of the heater connected to the second temperature sensor rather
        //? than the extruder temperature).
        //?
				if ( ! next_target.seen_S)
    382e:	88 23       	and	r24, r24
    3830:	0c f0       	brlt	.+2      	; 0x3834 <process_gcode_command+0x40a>
    3832:	d5 c1       	rjmp	.+938    	; 0x3bde <process_gcode_command+0x7b4>
					break;
        #ifdef HEATER_EXTRUDER
          if ( ! next_target.seen_P)
    3834:	20 fd       	sbrc	r18, 0
    3836:	04 c0       	rjmp	.+8      	; 0x3840 <process_gcode_command+0x416>
            next_target.P = HEATER_EXTRUDER;
    3838:	10 92 a2 04 	sts	0x04A2, r1
    383c:	10 92 a1 04 	sts	0x04A1, r1
        // else use the first available device
        #endif
				temp_set(next_target.P, next_target.S);
    3840:	60 91 9f 04 	lds	r22, 0x049F
    3844:	70 91 a0 04 	lds	r23, 0x04A0
    3848:	80 91 a1 04 	lds	r24, 0x04A1
    384c:	0e 94 ab 28 	call	0x5156	; 0x5156 <temp_set>
				break;
    3850:	c6 c1       	rjmp	.+908    	; 0x3bde <process_gcode_command+0x7b4>
        //? sensor index to address.
				//?
				#ifdef ENFORCE_ORDER
					queue_wait();
				#endif
				if ( ! next_target.seen_P)
    3852:	20 fd       	sbrc	r18, 0
    3854:	06 c0       	rjmp	.+12     	; 0x3862 <process_gcode_command+0x438>
					next_target.P = TEMP_SENSOR_none;
    3856:	82 e0       	ldi	r24, 0x02	; 2
    3858:	90 e0       	ldi	r25, 0x00	; 0
    385a:	90 93 a2 04 	sts	0x04A2, r25
    385e:	80 93 a1 04 	sts	0x04A1, r24
				temp_print(next_target.P);
    3862:	80 91 a1 04 	lds	r24, 0x04A1
    3866:	0e 94 bd 28 	call	0x517a	; 0x517a <temp_print>
				break;
    386a:	b9 c1       	rjmp	.+882    	; 0x3bde <process_gcode_command+0x7b4>
        #ifdef HEATER_FAN
          if ( ! next_target.seen_P)
            next_target.P = HEATER_FAN;
        // else use the first available device
        #endif
				if ( ! next_target.seen_S)
    386c:	88 23       	and	r24, r24
    386e:	0c f0       	brlt	.+2      	; 0x3872 <process_gcode_command+0x448>
    3870:	b6 c1       	rjmp	.+876    	; 0x3bde <process_gcode_command+0x7b4>
					break;
        heater_set(next_target.P, next_target.S);
    3872:	60 91 9f 04 	lds	r22, 0x049F
    3876:	80 91 a1 04 	lds	r24, 0x04A1
    387a:	0f d3       	rcall	.+1566   	; 0x3e9a <heater_set>
				break;
    387c:	b0 c1       	rjmp	.+864    	; 0x3bde <process_gcode_command+0x7b4>
				//? #define         DEBUG_POSITION  4
				//? </pre>
				//?
				//? This command is only available in DEBUG builds of Teacup.

				if ( ! next_target.seen_S)
    387e:	88 23       	and	r24, r24
    3880:	0c f0       	brlt	.+2      	; 0x3884 <process_gcode_command+0x45a>
    3882:	ad c1       	rjmp	.+858    	; 0x3bde <process_gcode_command+0x7b4>
					break;
				debug_flags = next_target.S;
    3884:	80 91 9f 04 	lds	r24, 0x049F
    3888:	80 93 cf 04 	sts	0x04CF, r24
				break;
    388c:	a8 c1       	rjmp	.+848    	; 0x3bde <process_gcode_command+0x7b4>
				//?
				#ifdef ENFORCE_ORDER
					// wait for all moves to complete
					queue_wait();
				#endif
				update_current_position();
    388e:	0e 94 03 10 	call	0x2006	; 0x2006 <update_current_position>
				sersendf_P(PSTR("X:%lq,Y:%lq,Z:%lq,E:%lq,F:%lu"),
    3892:	e6 e7       	ldi	r30, 0x76	; 118
    3894:	f2 e0       	ldi	r31, 0x02	; 2
    3896:	83 81       	ldd	r24, Z+3	; 0x03
    3898:	8f 93       	push	r24
    389a:	82 81       	ldd	r24, Z+2	; 0x02
    389c:	8f 93       	push	r24
    389e:	81 81       	ldd	r24, Z+1	; 0x01
    38a0:	8f 93       	push	r24
    38a2:	80 81       	ld	r24, Z
    38a4:	8f 93       	push	r24
    38a6:	e2 e7       	ldi	r30, 0x72	; 114
    38a8:	f2 e0       	ldi	r31, 0x02	; 2
    38aa:	83 81       	ldd	r24, Z+3	; 0x03
    38ac:	8f 93       	push	r24
    38ae:	82 81       	ldd	r24, Z+2	; 0x02
    38b0:	8f 93       	push	r24
    38b2:	81 81       	ldd	r24, Z+1	; 0x01
    38b4:	8f 93       	push	r24
    38b6:	80 81       	ld	r24, Z
    38b8:	8f 93       	push	r24
    38ba:	ee e6       	ldi	r30, 0x6E	; 110
    38bc:	f2 e0       	ldi	r31, 0x02	; 2
    38be:	83 81       	ldd	r24, Z+3	; 0x03
    38c0:	8f 93       	push	r24
    38c2:	82 81       	ldd	r24, Z+2	; 0x02
    38c4:	8f 93       	push	r24
    38c6:	81 81       	ldd	r24, Z+1	; 0x01
    38c8:	8f 93       	push	r24
    38ca:	80 81       	ld	r24, Z
    38cc:	8f 93       	push	r24
    38ce:	ea e6       	ldi	r30, 0x6A	; 106
    38d0:	f2 e0       	ldi	r31, 0x02	; 2
    38d2:	83 81       	ldd	r24, Z+3	; 0x03
    38d4:	8f 93       	push	r24
    38d6:	82 81       	ldd	r24, Z+2	; 0x02
    38d8:	8f 93       	push	r24
    38da:	81 81       	ldd	r24, Z+1	; 0x01
    38dc:	8f 93       	push	r24
    38de:	80 81       	ld	r24, Z
    38e0:	8f 93       	push	r24
    38e2:	e6 e6       	ldi	r30, 0x66	; 102
    38e4:	f2 e0       	ldi	r31, 0x02	; 2
    38e6:	83 81       	ldd	r24, Z+3	; 0x03
    38e8:	8f 93       	push	r24
    38ea:	82 81       	ldd	r24, Z+2	; 0x02
    38ec:	8f 93       	push	r24
    38ee:	81 81       	ldd	r24, Z+1	; 0x01
    38f0:	8f 93       	push	r24
    38f2:	80 81       	ld	r24, Z
    38f4:	8f 93       	push	r24
    38f6:	8b e3       	ldi	r24, 0x3B	; 59
    38f8:	94 e0       	ldi	r25, 0x04	; 4
    38fa:	9f 93       	push	r25
    38fc:	8f 93       	push	r24
    38fe:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
				                current_position.X, current_position.Y,
				                current_position.Z, current_position.E,
				                current_position.F);

				#ifdef	DEBUG
					if (DEBUG_POSITION && (debug_flags & DEBUG_POSITION)) {
    3902:	80 91 cf 04 	lds	r24, 0x04CF
    3906:	2d b7       	in	r18, 0x3d	; 61
    3908:	3e b7       	in	r19, 0x3e	; 62
    390a:	2a 5e       	subi	r18, 0xEA	; 234
    390c:	3f 4f       	sbci	r19, 0xFF	; 255
    390e:	0f b6       	in	r0, 0x3f	; 63
    3910:	f8 94       	cli
    3912:	3e bf       	out	0x3e, r19	; 62
    3914:	0f be       	out	0x3f, r0	; 63
    3916:	2d bf       	out	0x3d, r18	; 61
    3918:	82 ff       	sbrs	r24, 2
    391a:	61 c1       	rjmp	.+706    	; 0x3bde <process_gcode_command+0x7b4>
						sersendf_P(PSTR(",c:%lu}\nEndpoint: X:%ld,Y:%ld,Z:%ld,E:%ld,F:%lu,c:%lu}"),
    391c:	e0 91 bc 04 	lds	r30, 0x04BC
    3920:	3c e3       	ldi	r19, 0x3C	; 60
    3922:	e3 9f       	mul	r30, r19
    3924:	f0 01       	movw	r30, r0
    3926:	11 24       	eor	r1, r1
    3928:	eb 55       	subi	r30, 0x5B	; 91
    392a:	fd 4f       	sbci	r31, 0xFD	; 253
    392c:	df 01       	movw	r26, r30
    392e:	9a 96       	adiw	r26, 0x2a	; 42
    3930:	82 a5       	ldd	r24, Z+42	; 0x2a
    3932:	11 96       	adiw	r26, 0x01	; 1
    3934:	9c 91       	ld	r25, X
    3936:	11 97       	sbiw	r26, 0x01	; 1
    3938:	12 96       	adiw	r26, 0x02	; 2
    393a:	2c 91       	ld	r18, X
    393c:	12 97       	sbiw	r26, 0x02	; 2
    393e:	13 96       	adiw	r26, 0x03	; 3
    3940:	3c 91       	ld	r19, X
    3942:	3f 93       	push	r19
    3944:	2f 93       	push	r18
    3946:	9f 93       	push	r25
    3948:	8f 93       	push	r24
    394a:	df 01       	movw	r26, r30
    394c:	50 96       	adiw	r26, 0x10	; 16
    394e:	13 96       	adiw	r26, 0x03	; 3
    3950:	4c 91       	ld	r20, X
    3952:	13 97       	sbiw	r26, 0x03	; 3
    3954:	4f 93       	push	r20
    3956:	12 96       	adiw	r26, 0x02	; 2
    3958:	4c 91       	ld	r20, X
    395a:	12 97       	sbiw	r26, 0x02	; 2
    395c:	4f 93       	push	r20
    395e:	11 96       	adiw	r26, 0x01	; 1
    3960:	4c 91       	ld	r20, X
    3962:	4f 93       	push	r20
    3964:	40 89       	ldd	r20, Z+16	; 0x10
    3966:	4f 93       	push	r20
    3968:	df 01       	movw	r26, r30
    396a:	1c 96       	adiw	r26, 0x0c	; 12
    396c:	13 96       	adiw	r26, 0x03	; 3
    396e:	4c 91       	ld	r20, X
    3970:	13 97       	sbiw	r26, 0x03	; 3
    3972:	4f 93       	push	r20
    3974:	12 96       	adiw	r26, 0x02	; 2
    3976:	4c 91       	ld	r20, X
    3978:	12 97       	sbiw	r26, 0x02	; 2
    397a:	4f 93       	push	r20
    397c:	11 96       	adiw	r26, 0x01	; 1
    397e:	4c 91       	ld	r20, X
    3980:	4f 93       	push	r20
    3982:	44 85       	ldd	r20, Z+12	; 0x0c
    3984:	4f 93       	push	r20
    3986:	df 01       	movw	r26, r30
    3988:	18 96       	adiw	r26, 0x08	; 8
    398a:	13 96       	adiw	r26, 0x03	; 3
    398c:	4c 91       	ld	r20, X
    398e:	13 97       	sbiw	r26, 0x03	; 3
    3990:	4f 93       	push	r20
    3992:	12 96       	adiw	r26, 0x02	; 2
    3994:	4c 91       	ld	r20, X
    3996:	12 97       	sbiw	r26, 0x02	; 2
    3998:	4f 93       	push	r20
    399a:	11 96       	adiw	r26, 0x01	; 1
    399c:	4c 91       	ld	r20, X
    399e:	4f 93       	push	r20
    39a0:	40 85       	ldd	r20, Z+8	; 0x08
    39a2:	4f 93       	push	r20
    39a4:	df 01       	movw	r26, r30
    39a6:	14 96       	adiw	r26, 0x04	; 4
    39a8:	13 96       	adiw	r26, 0x03	; 3
    39aa:	4c 91       	ld	r20, X
    39ac:	13 97       	sbiw	r26, 0x03	; 3
    39ae:	4f 93       	push	r20
    39b0:	12 96       	adiw	r26, 0x02	; 2
    39b2:	4c 91       	ld	r20, X
    39b4:	12 97       	sbiw	r26, 0x02	; 2
    39b6:	4f 93       	push	r20
    39b8:	11 96       	adiw	r26, 0x01	; 1
    39ba:	4c 91       	ld	r20, X
    39bc:	4f 93       	push	r20
    39be:	44 81       	ldd	r20, Z+4	; 0x04
    39c0:	4f 93       	push	r20
    39c2:	43 81       	ldd	r20, Z+3	; 0x03
    39c4:	4f 93       	push	r20
    39c6:	42 81       	ldd	r20, Z+2	; 0x02
    39c8:	4f 93       	push	r20
    39ca:	41 81       	ldd	r20, Z+1	; 0x01
    39cc:	4f 93       	push	r20
    39ce:	40 81       	ld	r20, Z
    39d0:	4f 93       	push	r20
    39d2:	3f 93       	push	r19
    39d4:	2f 93       	push	r18
    39d6:	9f 93       	push	r25
    39d8:	8f 93       	push	r24
    39da:	89 e5       	ldi	r24, 0x59	; 89
    39dc:	94 e0       	ldi	r25, 0x04	; 4
    39de:	9f 93       	push	r25
    39e0:	8f 93       	push	r24
    39e2:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
							movebuffer[mb_tail].end_c
						#else
							movebuffer[mb_tail].c
						#endif
						);
						print_queue();
    39e6:	5b d8       	rcall	.-3914   	; 0x2a9e <print_queue>
    39e8:	8d b7       	in	r24, 0x3d	; 61
    39ea:	9e b7       	in	r25, 0x3e	; 62
    39ec:	4e 96       	adiw	r24, 0x1e	; 30
    39ee:	0f b6       	in	r0, 0x3f	; 63
    39f0:	f8 94       	cli
    39f2:	9e bf       	out	0x3e, r25	; 62
    39f4:	0f be       	out	0x3f, r0	; 63
    39f6:	8d bf       	out	0x3d, r24	; 61
    39f8:	f2 c0       	rjmp	.+484    	; 0x3bde <process_gcode_command+0x7b4>
				//?
				//? sample data from firmware:
				//?  FIRMWARE_NAME:Teacup FIRMWARE_URL:http://github.com/triffid/Teacup_Firmware/ PROTOCOL_VERSION:1.0 MACHINE_TYPE:Mendel EXTRUDER_COUNT:1 TEMP_SENSOR_COUNT:1 HEATER_COUNT:1
				//?

				sersendf_P(PSTR("FIRMWARE_NAME:Teacup FIRMWARE_URL:http://github.com/triffid/Teacup_Firmware/ PROTOCOL_VERSION:1.0 MACHINE_TYPE:Mendel EXTRUDER_COUNT:%d TEMP_SENSOR_COUNT:%d HEATER_COUNT:%d"), 1, NUM_TEMP_SENSORS, NUM_HEATERS);
    39fa:	1f 92       	push	r1
    39fc:	82 e0       	ldi	r24, 0x02	; 2
    39fe:	8f 93       	push	r24
    3a00:	1f 92       	push	r1
    3a02:	81 e0       	ldi	r24, 0x01	; 1
    3a04:	8f 93       	push	r24
    3a06:	1f 92       	push	r1
    3a08:	8f 93       	push	r24
    3a0a:	80 e9       	ldi	r24, 0x90	; 144
    3a0c:	94 e0       	ldi	r25, 0x04	; 4
    3a0e:	9f 93       	push	r25
    3a10:	8f 93       	push	r24
    3a12:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
				// newline is sent from gcode_parse after we return
				break;
    3a16:	2d b7       	in	r18, 0x3d	; 61
    3a18:	3e b7       	in	r19, 0x3e	; 62
    3a1a:	28 5f       	subi	r18, 0xF8	; 248
    3a1c:	3f 4f       	sbci	r19, 0xFF	; 255
    3a1e:	0f b6       	in	r0, 0x3f	; 63
    3a20:	f8 94       	cli
    3a22:	3e bf       	out	0x3e, r19	; 62
    3a24:	0f be       	out	0x3f, r0	; 63
    3a26:	2d bf       	out	0x3d, r18	; 61
    3a28:	da c0       	rjmp	.+436    	; 0x3bde <process_gcode_command+0x7b4>
    3a2a:	40 e0       	ldi	r20, 0x00	; 0
    3a2c:	60 e0       	ldi	r22, 0x00	; 0
    3a2e:	80 e0       	ldi	r24, 0x00	; 0
    3a30:	90 e0       	ldi	r25, 0x00	; 0
    3a32:	0e 94 cb 14 	call	0x2996	; 0x2996 <enqueue_home>
    3a36:	d3 c0       	rjmp	.+422    	; 0x3bde <process_gcode_command+0x7b4>

      case 119:
        //? --- M119: report endstop status ---
        //? Report the current status of the endstops configured in the
        //? firmware to the host.
        power_on();
    3a38:	fd d6       	rcall	.+3578   	; 0x4834 <power_on>
        endstops_on();
        delay_ms(10); // allow the signal to stabilize
    3a3a:	6a e0       	ldi	r22, 0x0A	; 10
    3a3c:	70 e0       	ldi	r23, 0x00	; 0
    3a3e:	80 e0       	ldi	r24, 0x00	; 0
    3a40:	90 e0       	ldi	r25, 0x00	; 0
    3a42:	93 d8       	rcall	.-3802   	; 0x2b6a <delay_ms>
        #if defined(X_MIN_PIN)
          sersendf_P(PSTR("x_min:%d "), x_min());
    3a44:	c0 e0       	ldi	r28, 0x00	; 0
    3a46:	d1 e0       	ldi	r29, 0x01	; 1
    3a48:	88 81       	ld	r24, Y
    3a4a:	86 95       	lsr	r24
    3a4c:	81 70       	andi	r24, 0x01	; 1
    3a4e:	1f 92       	push	r1
    3a50:	8f 93       	push	r24
    3a52:	8d e3       	ldi	r24, 0x3D	; 61
    3a54:	95 e0       	ldi	r25, 0x05	; 5
    3a56:	9f 93       	push	r25
    3a58:	8f 93       	push	r24
    3a5a:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
        #endif
        #if defined(X_MAX_PIN)
          sersendf_P(PSTR("x_max:%d "), x_max());
    3a5e:	88 81       	ld	r24, Y
    3a60:	81 70       	andi	r24, 0x01	; 1
    3a62:	1f 92       	push	r1
    3a64:	8f 93       	push	r24
    3a66:	87 e4       	ldi	r24, 0x47	; 71
    3a68:	95 e0       	ldi	r25, 0x05	; 5
    3a6a:	9f 93       	push	r25
    3a6c:	8f 93       	push	r24
    3a6e:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
        #endif
        #if defined(Y_MIN_PIN)
          sersendf_P(PSTR("y_min:%d "), y_min());
    3a72:	c3 e0       	ldi	r28, 0x03	; 3
    3a74:	d1 e0       	ldi	r29, 0x01	; 1
    3a76:	88 81       	ld	r24, Y
    3a78:	86 95       	lsr	r24
    3a7a:	81 70       	andi	r24, 0x01	; 1
    3a7c:	1f 92       	push	r1
    3a7e:	8f 93       	push	r24
    3a80:	81 e5       	ldi	r24, 0x51	; 81
    3a82:	95 e0       	ldi	r25, 0x05	; 5
    3a84:	9f 93       	push	r25
    3a86:	8f 93       	push	r24
    3a88:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
        #endif
        #if defined(Y_MAX_PIN)
          sersendf_P(PSTR("y_max:%d "), y_max());
    3a8c:	88 81       	ld	r24, Y
    3a8e:	81 70       	andi	r24, 0x01	; 1
    3a90:	1f 92       	push	r1
    3a92:	8f 93       	push	r24
    3a94:	8b e5       	ldi	r24, 0x5B	; 91
    3a96:	95 e0       	ldi	r25, 0x05	; 5
    3a98:	9f 93       	push	r25
    3a9a:	8f 93       	push	r24
    3a9c:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
        #endif
        #if defined(Z_MIN_PIN)
          sersendf_P(PSTR("z_min:%d "), z_min());
    3aa0:	89 b1       	in	r24, 0x09	; 9
    3aa2:	83 fb       	bst	r24, 3
    3aa4:	88 27       	eor	r24, r24
    3aa6:	80 f9       	bld	r24, 0
    3aa8:	1f 92       	push	r1
    3aaa:	8f 93       	push	r24
    3aac:	85 e6       	ldi	r24, 0x65	; 101
    3aae:	95 e0       	ldi	r25, 0x05	; 5
    3ab0:	9f 93       	push	r25
    3ab2:	8f 93       	push	r24
    3ab4:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
    3ab8:	8d b7       	in	r24, 0x3d	; 61
    3aba:	9e b7       	in	r25, 0x3e	; 62
    3abc:	44 96       	adiw	r24, 0x14	; 20
    3abe:	0f b6       	in	r0, 0x3f	; 63
    3ac0:	f8 94       	cli
    3ac2:	9e bf       	out	0x3e, r25	; 62
    3ac4:	0f be       	out	0x3f, r0	; 63
    3ac6:	8d bf       	out	0x3d, r24	; 61
    3ac8:	8a c0       	rjmp	.+276    	; 0x3bde <process_gcode_command+0x7b4>
      #ifdef EECONFIG
			case 130:
				//? --- M130: heater P factor ---
				//? Undocumented.
        #ifdef HEATER_EXTRUDER
          if ( ! next_target.seen_P)
    3aca:	20 fd       	sbrc	r18, 0
    3acc:	04 c0       	rjmp	.+8      	; 0x3ad6 <process_gcode_command+0x6ac>
            next_target.P = HEATER_EXTRUDER;
    3ace:	10 92 a2 04 	sts	0x04A2, r1
    3ad2:	10 92 a1 04 	sts	0x04A1, r1
        // else use the first available device
        #endif
				if (next_target.seen_S)
    3ad6:	88 23       	and	r24, r24
    3ad8:	0c f0       	brlt	.+2      	; 0x3adc <process_gcode_command+0x6b2>
    3ada:	81 c0       	rjmp	.+258    	; 0x3bde <process_gcode_command+0x7b4>
					pid_set_p(next_target.P, next_target.S);
    3adc:	40 91 9f 04 	lds	r20, 0x049F
    3ae0:	50 91 a0 04 	lds	r21, 0x04A0
    3ae4:	66 27       	eor	r22, r22
    3ae6:	57 fd       	sbrc	r21, 7
    3ae8:	60 95       	com	r22
    3aea:	76 2f       	mov	r23, r22
    3aec:	80 91 a1 04 	lds	r24, 0x04A1
    3af0:	f2 d3       	rcall	.+2020   	; 0x42d6 <pid_set_p>
    3af2:	75 c0       	rjmp	.+234    	; 0x3bde <process_gcode_command+0x7b4>

			case 131:
				//? --- M131: heater I factor ---
				//? Undocumented.
        #ifdef HEATER_EXTRUDER
          if ( ! next_target.seen_P)
    3af4:	20 fd       	sbrc	r18, 0
    3af6:	04 c0       	rjmp	.+8      	; 0x3b00 <process_gcode_command+0x6d6>
            next_target.P = HEATER_EXTRUDER;
    3af8:	10 92 a2 04 	sts	0x04A2, r1
    3afc:	10 92 a1 04 	sts	0x04A1, r1
        #endif
				if (next_target.seen_S)
    3b00:	88 23       	and	r24, r24
    3b02:	0c f0       	brlt	.+2      	; 0x3b06 <process_gcode_command+0x6dc>
    3b04:	6c c0       	rjmp	.+216    	; 0x3bde <process_gcode_command+0x7b4>
					pid_set_i(next_target.P, next_target.S);
    3b06:	40 91 9f 04 	lds	r20, 0x049F
    3b0a:	50 91 a0 04 	lds	r21, 0x04A0
    3b0e:	66 27       	eor	r22, r22
    3b10:	57 fd       	sbrc	r21, 7
    3b12:	60 95       	com	r22
    3b14:	76 2f       	mov	r23, r22
    3b16:	80 91 a1 04 	lds	r24, 0x04A1
    3b1a:	f3 d3       	rcall	.+2022   	; 0x4302 <pid_set_i>
    3b1c:	60 c0       	rjmp	.+192    	; 0x3bde <process_gcode_command+0x7b4>

			case 132:
				//? --- M132: heater D factor ---
				//? Undocumented.
        #ifdef HEATER_EXTRUDER
          if ( ! next_target.seen_P)
    3b1e:	20 fd       	sbrc	r18, 0
    3b20:	04 c0       	rjmp	.+8      	; 0x3b2a <process_gcode_command+0x700>
            next_target.P = HEATER_EXTRUDER;
    3b22:	10 92 a2 04 	sts	0x04A2, r1
    3b26:	10 92 a1 04 	sts	0x04A1, r1
        #endif
				if (next_target.seen_S)
    3b2a:	88 23       	and	r24, r24
    3b2c:	0c f0       	brlt	.+2      	; 0x3b30 <process_gcode_command+0x706>
    3b2e:	57 c0       	rjmp	.+174    	; 0x3bde <process_gcode_command+0x7b4>
					pid_set_d(next_target.P, next_target.S);
    3b30:	40 91 9f 04 	lds	r20, 0x049F
    3b34:	50 91 a0 04 	lds	r21, 0x04A0
    3b38:	66 27       	eor	r22, r22
    3b3a:	57 fd       	sbrc	r21, 7
    3b3c:	60 95       	com	r22
    3b3e:	76 2f       	mov	r23, r22
    3b40:	80 91 a1 04 	lds	r24, 0x04A1
    3b44:	f4 d3       	rcall	.+2024   	; 0x432e <pid_set_d>
    3b46:	4b c0       	rjmp	.+150    	; 0x3bde <process_gcode_command+0x7b4>

			case 133:
				//? --- M133: heater I limit ---
				//? Undocumented.
        #ifdef HEATER_EXTRUDER
          if ( ! next_target.seen_P)
    3b48:	20 fd       	sbrc	r18, 0
    3b4a:	04 c0       	rjmp	.+8      	; 0x3b54 <process_gcode_command+0x72a>
            next_target.P = HEATER_EXTRUDER;
    3b4c:	10 92 a2 04 	sts	0x04A2, r1
    3b50:	10 92 a1 04 	sts	0x04A1, r1
        #endif
				if (next_target.seen_S)
    3b54:	88 23       	and	r24, r24
    3b56:	0c f0       	brlt	.+2      	; 0x3b5a <process_gcode_command+0x730>
    3b58:	42 c0       	rjmp	.+132    	; 0x3bde <process_gcode_command+0x7b4>
					pid_set_i_limit(next_target.P, next_target.S);
    3b5a:	40 91 9f 04 	lds	r20, 0x049F
    3b5e:	50 91 a0 04 	lds	r21, 0x04A0
    3b62:	66 27       	eor	r22, r22
    3b64:	57 fd       	sbrc	r21, 7
    3b66:	60 95       	com	r22
    3b68:	76 2f       	mov	r23, r22
    3b6a:	80 91 a1 04 	lds	r24, 0x04A1
    3b6e:	f5 d3       	rcall	.+2026   	; 0x435a <pid_set_i_limit>
    3b70:	36 c0       	rjmp	.+108    	; 0x3bde <process_gcode_command+0x7b4>
				break;

			case 134:
				//? --- M134: save PID settings to eeprom ---
				//? Undocumented.
				heater_save_settings();
    3b72:	07 d4       	rcall	.+2062   	; 0x4382 <heater_save_settings>
				break;
    3b74:	34 c0       	rjmp	.+104    	; 0x3bde <process_gcode_command+0x7b4>
			#ifdef	DEBUG
			case 136:
				//? --- M136: PRINT PID settings to host ---
				//? Undocumented.
				//? This comand is only available in DEBUG builds.
				if ( ! next_target.seen_P)
    3b76:	20 fd       	sbrc	r18, 0
    3b78:	04 c0       	rjmp	.+8      	; 0x3b82 <process_gcode_command+0x758>
					next_target.P = HEATER_EXTRUDER;
    3b7a:	10 92 a2 04 	sts	0x04A2, r1
    3b7e:	10 92 a1 04 	sts	0x04A1, r1
				heater_print(next_target.P);
    3b82:	80 91 a1 04 	lds	r24, 0x04A1
    3b86:	90 91 a2 04 	lds	r25, 0x04A2
    3b8a:	52 d4       	rcall	.+2212   	; 0x4430 <heater_print>
				break;
    3b8c:	28 c0       	rjmp	.+80     	; 0x3bde <process_gcode_command+0x7b4>

			case 140:
				//? --- M140: Set heated bed temperature ---
				//? Undocumented.
				#ifdef	HEATER_BED
					if ( ! next_target.seen_S)
    3b8e:	88 23       	and	r24, r24
    3b90:	34 f5       	brge	.+76     	; 0x3bde <process_gcode_command+0x7b4>
						break;
					temp_set(HEATER_BED, next_target.S);
    3b92:	60 91 9f 04 	lds	r22, 0x049F
    3b96:	70 91 a0 04 	lds	r23, 0x04A0
    3b9a:	81 e0       	ldi	r24, 0x01	; 1
    3b9c:	0e 94 ab 28 	call	0x5156	; 0x5156 <temp_set>
				#endif
				break;
    3ba0:	1e c0       	rjmp	.+60     	; 0x3bde <process_gcode_command+0x7b4>
			#ifdef	DEBUG
			case 240:
				//? --- M240: echo off ---
				//? Disable echo.
				//? This command is only available in DEBUG builds.
				debug_flags &= ~DEBUG_ECHO;
    3ba2:	80 91 cf 04 	lds	r24, 0x04CF
    3ba6:	8f 77       	andi	r24, 0x7F	; 127
    3ba8:	80 93 cf 04 	sts	0x04CF, r24
				serial_writestr_P(PSTR("Echo off"));
    3bac:	8f e6       	ldi	r24, 0x6F	; 111
    3bae:	95 e0       	ldi	r25, 0x05	; 5
    3bb0:	33 d7       	rcall	.+3686   	; 0x4a18 <serial_writestr_P>
				// newline is sent from gcode_parse after we return
				break;
    3bb2:	15 c0       	rjmp	.+42     	; 0x3bde <process_gcode_command+0x7b4>

			case 241:
				//? --- M241: echo on ---
				//? Enable echo.
				//? This command is only available in DEBUG builds.
				debug_flags |= DEBUG_ECHO;
    3bb4:	80 91 cf 04 	lds	r24, 0x04CF
    3bb8:	80 68       	ori	r24, 0x80	; 128
    3bba:	80 93 cf 04 	sts	0x04CF, r24
				serial_writestr_P(PSTR("Echo on"));
    3bbe:	88 e7       	ldi	r24, 0x78	; 120
    3bc0:	95 e0       	ldi	r25, 0x05	; 5
    3bc2:	2a d7       	rcall	.+3668   	; 0x4a18 <serial_writestr_P>
				// newline is sent from gcode_parse after we return
				break;
    3bc4:	0c c0       	rjmp	.+24     	; 0x3bde <process_gcode_command+0x7b4>

			#endif /* DEBUG */

				// unknown mcode: spit an error
			default:
				sersendf_P(PSTR("E: Bad M-code %d"), next_target.M);
    3bc6:	1f 92       	push	r1
    3bc8:	9f 93       	push	r25
    3bca:	80 e8       	ldi	r24, 0x80	; 128
    3bcc:	95 e0       	ldi	r25, 0x05	; 5
    3bce:	9f 93       	push	r25
    3bd0:	8f 93       	push	r24
    3bd2:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <sersendf_P>
    3bd6:	0f 90       	pop	r0
    3bd8:	0f 90       	pop	r0
    3bda:	0f 90       	pop	r0
    3bdc:	0f 90       	pop	r0
				// newline is sent from gcode_parse after we return
		} // switch (next_target.M)
	} // else if (next_target.seen_M)
} // process_gcode_command()
    3bde:	df 91       	pop	r29
    3be0:	cf 91       	pop	r28
    3be2:	ff 90       	pop	r15
    3be4:	ef 90       	pop	r14
    3be6:	df 90       	pop	r13
    3be8:	cf 90       	pop	r12
    3bea:	08 95       	ret

00003bec <heater_init>:
		if (heaters_runtime[i].heater_output > 0)
			return 0;
	}

	return 255;
}
    3bec:	2f 92       	push	r2
    3bee:	3f 92       	push	r3
    3bf0:	4f 92       	push	r4
    3bf2:	5f 92       	push	r5
    3bf4:	6f 92       	push	r6
    3bf6:	7f 92       	push	r7
    3bf8:	9f 92       	push	r9
    3bfa:	af 92       	push	r10
    3bfc:	bf 92       	push	r11
    3bfe:	cf 92       	push	r12
    3c00:	df 92       	push	r13
    3c02:	ef 92       	push	r14
    3c04:	ff 92       	push	r15
    3c06:	0f 93       	push	r16
    3c08:	1f 93       	push	r17
    3c0a:	cf 93       	push	r28
    3c0c:	df 93       	push	r29
    3c0e:	93 e0       	ldi	r25, 0x03	; 3
    3c10:	94 bd       	out	0x24, r25	; 36
    3c12:	81 e0       	ldi	r24, 0x01	; 1
    3c14:	85 bd       	out	0x25, r24	; 37
    3c16:	25 e0       	ldi	r18, 0x05	; 5
    3c18:	25 bd       	out	0x25, r18	; 37
    3c1a:	10 92 6e 00 	sts	0x006E, r1
    3c1e:	17 bc       	out	0x27, r1	; 39
    3c20:	18 bc       	out	0x28, r1	; 40
    3c22:	90 93 b0 00 	sts	0x00B0, r25
    3c26:	e1 eb       	ldi	r30, 0xB1	; 177
    3c28:	f0 e0       	ldi	r31, 0x00	; 0
    3c2a:	80 83       	st	Z, r24
    3c2c:	97 e0       	ldi	r25, 0x07	; 7
    3c2e:	90 83       	st	Z, r25
    3c30:	10 92 70 00 	sts	0x0070, r1
    3c34:	10 92 b3 00 	sts	0x00B3, r1
    3c38:	10 92 b4 00 	sts	0x00B4, r1
    3c3c:	80 93 a0 00 	sts	0x00A0, r24
    3c40:	99 e0       	ldi	r25, 0x09	; 9
    3c42:	90 93 a1 00 	sts	0x00A1, r25
    3c46:	10 92 72 00 	sts	0x0072, r1
    3c4a:	10 92 a9 00 	sts	0x00A9, r1
    3c4e:	10 92 a8 00 	sts	0x00A8, r1
    3c52:	10 92 ab 00 	sts	0x00AB, r1
    3c56:	10 92 aa 00 	sts	0x00AA, r1
    3c5a:	80 93 20 01 	sts	0x0120, r24
    3c5e:	90 93 21 01 	sts	0x0121, r25
    3c62:	10 92 73 00 	sts	0x0073, r1
    3c66:	10 92 29 01 	sts	0x0129, r1
    3c6a:	10 92 28 01 	sts	0x0128, r1
    3c6e:	10 92 2b 01 	sts	0x012B, r1
    3c72:	10 92 2a 01 	sts	0x012A, r1
    3c76:	91 2c       	mov	r9, r1
    3c78:	c1 2c       	mov	r12, r1
    3c7a:	d1 2c       	mov	r13, r1
    3c7c:	76 01       	movw	r14, r12
    3c7e:	68 94       	set
    3c80:	d5 f8       	bld	r13, 5
    3c82:	41 2c       	mov	r4, r1
    3c84:	51 2c       	mov	r5, r1
    3c86:	32 01       	movw	r6, r4
    3c88:	68 94       	set
    3c8a:	51 f8       	bld	r5, 1
    3c8c:	68 94       	set
    3c8e:	22 24       	eor	r2, r2
    3c90:	27 f8       	bld	r2, 7
    3c92:	33 24       	eor	r3, r3
    3c94:	33 94       	inc	r3
    3c96:	a9 2c       	mov	r10, r9
    3c98:	b1 2c       	mov	r11, r1
    3c9a:	f5 01       	movw	r30, r10
    3c9c:	ee 0f       	add	r30, r30
    3c9e:	ff 1f       	adc	r31, r31
    3ca0:	ee 0f       	add	r30, r30
    3ca2:	ff 1f       	adc	r31, r31
    3ca4:	ea 0d       	add	r30, r10
    3ca6:	fb 1d       	adc	r31, r11
    3ca8:	e0 50       	subi	r30, 0x00	; 0
    3caa:	fe 4f       	sbci	r31, 0xFE	; 254
    3cac:	03 80       	ldd	r0, Z+3	; 0x03
    3cae:	f4 81       	ldd	r31, Z+4	; 0x04
    3cb0:	e0 2d       	mov	r30, r0
    3cb2:	30 97       	sbiw	r30, 0x00	; 0
    3cb4:	09 f4       	brne	.+2      	; 0x3cb8 <heater_init+0xcc>
    3cb6:	63 c0       	rjmp	.+198    	; 0x3d7e <heater_init+0x192>
    3cb8:	10 82       	st	Z, r1
    3cba:	ec 3a       	cpi	r30, 0xAC	; 172
    3cbc:	f1 05       	cpc	r31, r1
    3cbe:	09 f4       	brne	.+2      	; 0x3cc2 <heater_init+0xd6>
    3cc0:	47 c0       	rjmp	.+142    	; 0x3d50 <heater_init+0x164>
    3cc2:	88 f4       	brcc	.+34     	; 0x3ce6 <heater_init+0xfa>
    3cc4:	e8 34       	cpi	r30, 0x48	; 72
    3cc6:	f1 05       	cpc	r31, r1
    3cc8:	39 f1       	breq	.+78     	; 0x3d18 <heater_init+0x12c>
    3cca:	28 f4       	brcc	.+10     	; 0x3cd6 <heater_init+0xea>
    3ccc:	e7 34       	cpi	r30, 0x47	; 71
    3cce:	f1 05       	cpc	r31, r1
    3cd0:	09 f0       	breq	.+2      	; 0x3cd4 <heater_init+0xe8>
    3cd2:	55 c0       	rjmp	.+170    	; 0x3d7e <heater_init+0x192>
    3cd4:	1d c0       	rjmp	.+58     	; 0x3d10 <heater_init+0x124>
    3cd6:	e8 3a       	cpi	r30, 0xA8	; 168
    3cd8:	f1 05       	cpc	r31, r1
    3cda:	71 f1       	breq	.+92     	; 0x3d38 <heater_init+0x14c>
    3cdc:	ea 3a       	cpi	r30, 0xAA	; 170
    3cde:	f1 05       	cpc	r31, r1
    3ce0:	09 f0       	breq	.+2      	; 0x3ce4 <heater_init+0xf8>
    3ce2:	4d c0       	rjmp	.+154    	; 0x3d7e <heater_init+0x192>
    3ce4:	2f c0       	rjmp	.+94     	; 0x3d44 <heater_init+0x158>
    3ce6:	e8 32       	cpi	r30, 0x28	; 40
    3ce8:	81 e0       	ldi	r24, 0x01	; 1
    3cea:	f8 07       	cpc	r31, r24
    3cec:	b9 f1       	breq	.+110    	; 0x3d5c <heater_init+0x170>
    3cee:	40 f4       	brcc	.+16     	; 0x3d00 <heater_init+0x114>
    3cf0:	e3 3b       	cpi	r30, 0xB3	; 179
    3cf2:	f1 05       	cpc	r31, r1
    3cf4:	a9 f0       	breq	.+42     	; 0x3d20 <heater_init+0x134>
    3cf6:	e4 3b       	cpi	r30, 0xB4	; 180
    3cf8:	f1 05       	cpc	r31, r1
    3cfa:	09 f0       	breq	.+2      	; 0x3cfe <heater_init+0x112>
    3cfc:	40 c0       	rjmp	.+128    	; 0x3d7e <heater_init+0x192>
    3cfe:	16 c0       	rjmp	.+44     	; 0x3d2c <heater_init+0x140>
    3d00:	ea 32       	cpi	r30, 0x2A	; 42
    3d02:	a1 e0       	ldi	r26, 0x01	; 1
    3d04:	fa 07       	cpc	r31, r26
    3d06:	81 f1       	breq	.+96     	; 0x3d68 <heater_init+0x17c>
    3d08:	ec 32       	cpi	r30, 0x2C	; 44
    3d0a:	f1 40       	sbci	r31, 0x01	; 1
    3d0c:	c1 f5       	brne	.+112    	; 0x3d7e <heater_init+0x192>
    3d0e:	32 c0       	rjmp	.+100    	; 0x3d74 <heater_init+0x188>
    3d10:	84 b5       	in	r24, 0x24	; 36
    3d12:	80 68       	ori	r24, 0x80	; 128
    3d14:	84 bd       	out	0x24, r24	; 36
    3d16:	33 c0       	rjmp	.+102    	; 0x3d7e <heater_init+0x192>
    3d18:	84 b5       	in	r24, 0x24	; 36
    3d1a:	80 62       	ori	r24, 0x20	; 32
    3d1c:	84 bd       	out	0x24, r24	; 36
    3d1e:	2f c0       	rjmp	.+94     	; 0x3d7e <heater_init+0x192>
    3d20:	e0 eb       	ldi	r30, 0xB0	; 176
    3d22:	f0 e0       	ldi	r31, 0x00	; 0
    3d24:	80 81       	ld	r24, Z
    3d26:	80 68       	ori	r24, 0x80	; 128
    3d28:	80 83       	st	Z, r24
    3d2a:	29 c0       	rjmp	.+82     	; 0x3d7e <heater_init+0x192>
    3d2c:	a0 eb       	ldi	r26, 0xB0	; 176
    3d2e:	b0 e0       	ldi	r27, 0x00	; 0
    3d30:	8c 91       	ld	r24, X
    3d32:	80 62       	ori	r24, 0x20	; 32
    3d34:	8c 93       	st	X, r24
    3d36:	23 c0       	rjmp	.+70     	; 0x3d7e <heater_init+0x192>
    3d38:	e0 ea       	ldi	r30, 0xA0	; 160
    3d3a:	f0 e0       	ldi	r31, 0x00	; 0
    3d3c:	80 81       	ld	r24, Z
    3d3e:	80 68       	ori	r24, 0x80	; 128
    3d40:	80 83       	st	Z, r24
    3d42:	1d c0       	rjmp	.+58     	; 0x3d7e <heater_init+0x192>
    3d44:	a0 ea       	ldi	r26, 0xA0	; 160
    3d46:	b0 e0       	ldi	r27, 0x00	; 0
    3d48:	8c 91       	ld	r24, X
    3d4a:	80 62       	ori	r24, 0x20	; 32
    3d4c:	8c 93       	st	X, r24
    3d4e:	17 c0       	rjmp	.+46     	; 0x3d7e <heater_init+0x192>
    3d50:	e0 ea       	ldi	r30, 0xA0	; 160
    3d52:	f0 e0       	ldi	r31, 0x00	; 0
    3d54:	80 81       	ld	r24, Z
    3d56:	88 60       	ori	r24, 0x08	; 8
    3d58:	80 83       	st	Z, r24
    3d5a:	11 c0       	rjmp	.+34     	; 0x3d7e <heater_init+0x192>
    3d5c:	a0 e2       	ldi	r26, 0x20	; 32
    3d5e:	b1 e0       	ldi	r27, 0x01	; 1
    3d60:	8c 91       	ld	r24, X
    3d62:	80 68       	ori	r24, 0x80	; 128
    3d64:	8c 93       	st	X, r24
    3d66:	0b c0       	rjmp	.+22     	; 0x3d7e <heater_init+0x192>
    3d68:	e0 e2       	ldi	r30, 0x20	; 32
    3d6a:	f1 e0       	ldi	r31, 0x01	; 1
    3d6c:	80 81       	ld	r24, Z
    3d6e:	80 62       	ori	r24, 0x20	; 32
    3d70:	80 83       	st	Z, r24
    3d72:	05 c0       	rjmp	.+10     	; 0x3d7e <heater_init+0x192>
    3d74:	a0 e2       	ldi	r26, 0x20	; 32
    3d76:	b1 e0       	ldi	r27, 0x01	; 1
    3d78:	8c 91       	ld	r24, X
    3d7a:	88 60       	ori	r24, 0x08	; 8
    3d7c:	8c 93       	st	X, r24
    3d7e:	e5 01       	movw	r28, r10
    3d80:	c2 95       	swap	r28
    3d82:	d2 95       	swap	r29
    3d84:	d0 7f       	andi	r29, 0xF0	; 240
    3d86:	dc 27       	eor	r29, r28
    3d88:	c0 7f       	andi	r28, 0xF0	; 240
    3d8a:	dc 27       	eor	r29, r28
    3d8c:	ce 01       	movw	r24, r28
    3d8e:	80 50       	subi	r24, 0x00	; 0
    3d90:	90 40       	sbci	r25, 0x00	; 0
    3d92:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <__eerd_dword_m2560>
    3d96:	95 01       	movw	r18, r10
    3d98:	22 0f       	add	r18, r18
    3d9a:	33 1f       	adc	r19, r19
    3d9c:	89 01       	movw	r16, r18
    3d9e:	00 0f       	add	r16, r16
    3da0:	11 1f       	adc	r17, r17
    3da2:	00 0f       	add	r16, r16
    3da4:	11 1f       	adc	r17, r17
    3da6:	00 0f       	add	r16, r16
    3da8:	11 1f       	adc	r17, r17
    3daa:	02 1b       	sub	r16, r18
    3dac:	13 0b       	sbc	r17, r19
    3dae:	06 50       	subi	r16, 0x06	; 6
    3db0:	1b 4f       	sbci	r17, 0xFB	; 251
    3db2:	f8 01       	movw	r30, r16
    3db4:	60 83       	st	Z, r22
    3db6:	71 83       	std	Z+1, r23	; 0x01
    3db8:	82 83       	std	Z+2, r24	; 0x02
    3dba:	93 83       	std	Z+3, r25	; 0x03
    3dbc:	ce 01       	movw	r24, r28
    3dbe:	8c 5f       	subi	r24, 0xFC	; 252
    3dc0:	9f 4f       	sbci	r25, 0xFF	; 255
    3dc2:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <__eerd_dword_m2560>
    3dc6:	d8 01       	movw	r26, r16
    3dc8:	14 96       	adiw	r26, 0x04	; 4
    3dca:	6d 93       	st	X+, r22
    3dcc:	7d 93       	st	X+, r23
    3dce:	8d 93       	st	X+, r24
    3dd0:	9c 93       	st	X, r25
    3dd2:	17 97       	sbiw	r26, 0x07	; 7
    3dd4:	ce 01       	movw	r24, r28
    3dd6:	88 5f       	subi	r24, 0xF8	; 248
    3dd8:	9f 4f       	sbci	r25, 0xFF	; 255
    3dda:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <__eerd_dword_m2560>
    3dde:	f8 01       	movw	r30, r16
    3de0:	60 87       	std	Z+8, r22	; 0x08
    3de2:	71 87       	std	Z+9, r23	; 0x09
    3de4:	82 87       	std	Z+10, r24	; 0x0a
    3de6:	93 87       	std	Z+11, r25	; 0x0b
    3de8:	ce 01       	movw	r24, r28
    3dea:	84 5f       	subi	r24, 0xF4	; 244
    3dec:	9f 4f       	sbci	r25, 0xFF	; 255
    3dee:	0e 94 83 2a 	call	0x5506	; 0x5506 <__eerd_word_m2560>
    3df2:	d8 01       	movw	r26, r16
    3df4:	1d 96       	adiw	r26, 0x0d	; 13
    3df6:	9c 93       	st	X, r25
    3df8:	8e 93       	st	-X, r24
    3dfa:	1c 97       	sbiw	r26, 0x0c	; 12
    3dfc:	6e e0       	ldi	r22, 0x0E	; 14
    3dfe:	70 e0       	ldi	r23, 0x00	; 0
    3e00:	c8 01       	movw	r24, r16
    3e02:	0e 94 6f 06 	call	0xcde	; 0xcde <crc_block>
    3e06:	8c 01       	movw	r16, r24
    3e08:	ce 01       	movw	r24, r28
    3e0a:	82 5f       	subi	r24, 0xF2	; 242
    3e0c:	9f 4f       	sbci	r25, 0xFF	; 255
    3e0e:	0e 94 83 2a 	call	0x5506	; 0x5506 <__eerd_word_m2560>
    3e12:	08 17       	cp	r16, r24
    3e14:	19 07       	cpc	r17, r25
    3e16:	f9 f0       	breq	.+62     	; 0x3e56 <heater_init+0x26a>
    3e18:	aa 0c       	add	r10, r10
    3e1a:	bb 1c       	adc	r11, r11
    3e1c:	f5 01       	movw	r30, r10
    3e1e:	ee 0f       	add	r30, r30
    3e20:	ff 1f       	adc	r31, r31
    3e22:	ee 0f       	add	r30, r30
    3e24:	ff 1f       	adc	r31, r31
    3e26:	ee 0f       	add	r30, r30
    3e28:	ff 1f       	adc	r31, r31
    3e2a:	ea 19       	sub	r30, r10
    3e2c:	fb 09       	sbc	r31, r11
    3e2e:	e6 50       	subi	r30, 0x06	; 6
    3e30:	fb 4f       	sbci	r31, 0xFB	; 251
    3e32:	c0 82       	st	Z, r12
    3e34:	d1 82       	std	Z+1, r13	; 0x01
    3e36:	e2 82       	std	Z+2, r14	; 0x02
    3e38:	f3 82       	std	Z+3, r15	; 0x03
    3e3a:	44 82       	std	Z+4, r4	; 0x04
    3e3c:	55 82       	std	Z+5, r5	; 0x05
    3e3e:	66 82       	std	Z+6, r6	; 0x06
    3e40:	77 82       	std	Z+7, r7	; 0x07
    3e42:	80 e0       	ldi	r24, 0x00	; 0
    3e44:	90 e6       	ldi	r25, 0x60	; 96
    3e46:	a0 e0       	ldi	r26, 0x00	; 0
    3e48:	b0 e0       	ldi	r27, 0x00	; 0
    3e4a:	80 87       	std	Z+8, r24	; 0x08
    3e4c:	91 87       	std	Z+9, r25	; 0x09
    3e4e:	a2 87       	std	Z+10, r26	; 0x0a
    3e50:	b3 87       	std	Z+11, r27	; 0x0b
    3e52:	35 86       	std	Z+13, r3	; 0x0d
    3e54:	24 86       	std	Z+12, r2	; 0x0c
    3e56:	93 94       	inc	r9
    3e58:	92 e0       	ldi	r25, 0x02	; 2
    3e5a:	99 12       	cpse	r9, r25
    3e5c:	1c cf       	rjmp	.-456    	; 0x3c96 <heater_init+0xaa>
    3e5e:	2c 98       	cbi	0x05, 4	; 5
    3e60:	24 9a       	sbi	0x04, 4	; 4
    3e62:	e2 e0       	ldi	r30, 0x02	; 2
    3e64:	f1 e0       	ldi	r31, 0x01	; 1
    3e66:	80 81       	ld	r24, Z
    3e68:	8f 7d       	andi	r24, 0xDF	; 223
    3e6a:	80 83       	st	Z, r24
    3e6c:	e1 e0       	ldi	r30, 0x01	; 1
    3e6e:	f1 e0       	ldi	r31, 0x01	; 1
    3e70:	80 81       	ld	r24, Z
    3e72:	80 62       	ori	r24, 0x20	; 32
    3e74:	80 83       	st	Z, r24
    3e76:	df 91       	pop	r29
    3e78:	cf 91       	pop	r28
    3e7a:	1f 91       	pop	r17
    3e7c:	0f 91       	pop	r16
    3e7e:	ff 90       	pop	r15
    3e80:	ef 90       	pop	r14
    3e82:	df 90       	pop	r13
    3e84:	cf 90       	pop	r12
    3e86:	bf 90       	pop	r11
    3e88:	af 90       	pop	r10
    3e8a:	9f 90       	pop	r9
    3e8c:	7f 90       	pop	r7
    3e8e:	6f 90       	pop	r6
    3e90:	5f 90       	pop	r5
    3e92:	4f 90       	pop	r4
    3e94:	3f 90       	pop	r3
    3e96:	2f 90       	pop	r2
    3e98:	08 95       	ret

00003e9a <heater_set>:
    3e9a:	cf 93       	push	r28
    3e9c:	c6 2f       	mov	r28, r22
    3e9e:	82 30       	cpi	r24, 0x02	; 2
    3ea0:	08 f0       	brcs	.+2      	; 0x3ea4 <heater_set+0xa>
    3ea2:	66 c0       	rjmp	.+204    	; 0x3f70 <heater_set+0xd6>
    3ea4:	28 2f       	mov	r18, r24
    3ea6:	30 e0       	ldi	r19, 0x00	; 0
    3ea8:	94 e1       	ldi	r25, 0x14	; 20
    3eaa:	89 9f       	mul	r24, r25
    3eac:	f0 01       	movw	r30, r0
    3eae:	11 24       	eor	r1, r1
    3eb0:	ee 52       	subi	r30, 0x2E	; 46
    3eb2:	fb 4f       	sbci	r31, 0xFB	; 251
    3eb4:	63 8b       	std	Z+19, r22	; 0x13
    3eb6:	f9 01       	movw	r30, r18
    3eb8:	ee 0f       	add	r30, r30
    3eba:	ff 1f       	adc	r31, r31
    3ebc:	ee 0f       	add	r30, r30
    3ebe:	ff 1f       	adc	r31, r31
    3ec0:	e2 0f       	add	r30, r18
    3ec2:	f3 1f       	adc	r31, r19
    3ec4:	e0 50       	subi	r30, 0x00	; 0
    3ec6:	fe 4f       	sbci	r31, 0xFE	; 254
    3ec8:	03 80       	ldd	r0, Z+3	; 0x03
    3eca:	f4 81       	ldd	r31, Z+4	; 0x04
    3ecc:	e0 2d       	mov	r30, r0
    3ece:	30 97       	sbiw	r30, 0x00	; 0
    3ed0:	b1 f0       	breq	.+44     	; 0x3efe <heater_set+0x64>
    3ed2:	60 83       	st	Z, r22
    3ed4:	90 91 cf 04 	lds	r25, 0x04CF
    3ed8:	90 ff       	sbrs	r25, 0
    3eda:	48 c0       	rjmp	.+144    	; 0x3f6c <heater_set+0xd2>
    3edc:	90 81       	ld	r25, Z
    3ede:	1f 92       	push	r1
    3ee0:	9f 93       	push	r25
    3ee2:	1f 92       	push	r1
    3ee4:	8f 93       	push	r24
    3ee6:	80 ee       	ldi	r24, 0xE0	; 224
    3ee8:	95 e0       	ldi	r25, 0x05	; 5
    3eea:	9f 93       	push	r25
    3eec:	8f 93       	push	r24
    3eee:	b5 d6       	rcall	.+3434   	; 0x4c5a <sersendf_P>
    3ef0:	0f 90       	pop	r0
    3ef2:	0f 90       	pop	r0
    3ef4:	0f 90       	pop	r0
    3ef6:	0f 90       	pop	r0
    3ef8:	0f 90       	pop	r0
    3efa:	0f 90       	pop	r0
    3efc:	37 c0       	rjmp	.+110    	; 0x3f6c <heater_set+0xd2>
    3efe:	68 30       	cpi	r22, 0x08	; 8
    3f00:	d8 f0       	brcs	.+54     	; 0x3f38 <heater_set+0x9e>
    3f02:	d9 01       	movw	r26, r18
    3f04:	aa 0f       	add	r26, r26
    3f06:	bb 1f       	adc	r27, r27
    3f08:	aa 0f       	add	r26, r26
    3f0a:	bb 1f       	adc	r27, r27
    3f0c:	2a 0f       	add	r18, r26
    3f0e:	3b 1f       	adc	r19, r27
    3f10:	d9 01       	movw	r26, r18
    3f12:	a0 50       	subi	r26, 0x00	; 0
    3f14:	be 4f       	sbci	r27, 0xFE	; 254
    3f16:	ed 91       	ld	r30, X+
    3f18:	fc 91       	ld	r31, X
    3f1a:	11 97       	sbiw	r26, 0x01	; 1
    3f1c:	40 81       	ld	r20, Z
    3f1e:	21 e0       	ldi	r18, 0x01	; 1
    3f20:	30 e0       	ldi	r19, 0x00	; 0
    3f22:	c9 01       	movw	r24, r18
    3f24:	12 96       	adiw	r26, 0x02	; 2
    3f26:	0c 90       	ld	r0, X
    3f28:	02 c0       	rjmp	.+4      	; 0x3f2e <heater_set+0x94>
    3f2a:	88 0f       	add	r24, r24
    3f2c:	99 1f       	adc	r25, r25
    3f2e:	0a 94       	dec	r0
    3f30:	e2 f7       	brpl	.-8      	; 0x3f2a <heater_set+0x90>
    3f32:	84 2b       	or	r24, r20
    3f34:	80 83       	st	Z, r24
    3f36:	1a c0       	rjmp	.+52     	; 0x3f6c <heater_set+0xd2>
    3f38:	d9 01       	movw	r26, r18
    3f3a:	aa 0f       	add	r26, r26
    3f3c:	bb 1f       	adc	r27, r27
    3f3e:	aa 0f       	add	r26, r26
    3f40:	bb 1f       	adc	r27, r27
    3f42:	2a 0f       	add	r18, r26
    3f44:	3b 1f       	adc	r19, r27
    3f46:	d9 01       	movw	r26, r18
    3f48:	a0 50       	subi	r26, 0x00	; 0
    3f4a:	be 4f       	sbci	r27, 0xFE	; 254
    3f4c:	ed 91       	ld	r30, X+
    3f4e:	fc 91       	ld	r31, X
    3f50:	11 97       	sbiw	r26, 0x01	; 1
    3f52:	20 81       	ld	r18, Z
    3f54:	81 e0       	ldi	r24, 0x01	; 1
    3f56:	90 e0       	ldi	r25, 0x00	; 0
    3f58:	12 96       	adiw	r26, 0x02	; 2
    3f5a:	0c 90       	ld	r0, X
    3f5c:	02 c0       	rjmp	.+4      	; 0x3f62 <heater_set+0xc8>
    3f5e:	88 0f       	add	r24, r24
    3f60:	99 1f       	adc	r25, r25
    3f62:	0a 94       	dec	r0
    3f64:	e2 f7       	brpl	.-8      	; 0x3f5e <heater_set+0xc4>
    3f66:	80 95       	com	r24
    3f68:	82 23       	and	r24, r18
    3f6a:	80 83       	st	Z, r24
    3f6c:	c1 11       	cpse	r28, r1
    3f6e:	62 d4       	rcall	.+2244   	; 0x4834 <power_on>
    3f70:	cf 91       	pop	r28
    3f72:	08 95       	ret

00003f74 <heater_tick>:
    3f74:	2f 92       	push	r2
    3f76:	3f 92       	push	r3
    3f78:	4f 92       	push	r4
    3f7a:	5f 92       	push	r5
    3f7c:	6f 92       	push	r6
    3f7e:	7f 92       	push	r7
    3f80:	8f 92       	push	r8
    3f82:	9f 92       	push	r9
    3f84:	af 92       	push	r10
    3f86:	bf 92       	push	r11
    3f88:	cf 92       	push	r12
    3f8a:	df 92       	push	r13
    3f8c:	ef 92       	push	r14
    3f8e:	ff 92       	push	r15
    3f90:	0f 93       	push	r16
    3f92:	1f 93       	push	r17
    3f94:	cf 93       	push	r28
    3f96:	df 93       	push	r29
    3f98:	cd b7       	in	r28, 0x3d	; 61
    3f9a:	de b7       	in	r29, 0x3e	; 62
    3f9c:	2f 97       	sbiw	r28, 0x0f	; 15
    3f9e:	0f b6       	in	r0, 0x3f	; 63
    3fa0:	f8 94       	cli
    3fa2:	de bf       	out	0x3e, r29	; 62
    3fa4:	0f be       	out	0x3f, r0	; 63
    3fa6:	cd bf       	out	0x3d, r28	; 61
    3fa8:	8e 87       	std	Y+14, r24	; 0x0e
    3faa:	82 30       	cpi	r24, 0x02	; 2
    3fac:	08 f0       	brcs	.+2      	; 0x3fb0 <heater_tick+0x3c>
    3fae:	6c c1       	rjmp	.+728    	; 0x4288 <heater_tick+0x314>
    3fb0:	21 15       	cp	r18, r1
    3fb2:	31 05       	cpc	r19, r1
    3fb4:	19 f4       	brne	.+6      	; 0x3fbc <heater_tick+0x48>
    3fb6:	60 e0       	ldi	r22, 0x00	; 0
    3fb8:	70 df       	rcall	.-288    	; 0x3e9a <heater_set>
    3fba:	66 c1       	rjmp	.+716    	; 0x4288 <heater_tick+0x314>
    3fbc:	39 01       	movw	r6, r18
    3fbe:	64 1a       	sub	r6, r20
    3fc0:	75 0a       	sbc	r7, r21
    3fc2:	2e 85       	ldd	r18, Y+14	; 0x0e
    3fc4:	82 2f       	mov	r24, r18
    3fc6:	90 e0       	ldi	r25, 0x00	; 0
    3fc8:	34 e1       	ldi	r19, 0x14	; 20
    3fca:	23 9f       	mul	r18, r19
    3fcc:	f0 01       	movw	r30, r0
    3fce:	11 24       	eor	r1, r1
    3fd0:	ee 52       	subi	r30, 0x2E	; 46
    3fd2:	fb 4f       	sbci	r31, 0xFB	; 251
    3fd4:	62 89       	ldd	r22, Z+18	; 0x12
    3fd6:	9c 01       	movw	r18, r24
    3fd8:	22 0f       	add	r18, r18
    3fda:	33 1f       	adc	r19, r19
    3fdc:	dc 01       	movw	r26, r24
    3fde:	aa 0f       	add	r26, r26
    3fe0:	bb 1f       	adc	r27, r27
    3fe2:	aa 0f       	add	r26, r26
    3fe4:	bb 1f       	adc	r27, r27
    3fe6:	aa 0f       	add	r26, r26
    3fe8:	bb 1f       	adc	r27, r27
    3fea:	a2 0f       	add	r26, r18
    3fec:	b3 1f       	adc	r27, r19
    3fee:	a6 0f       	add	r26, r22
    3ff0:	b1 1d       	adc	r27, r1
    3ff2:	aa 0f       	add	r26, r26
    3ff4:	bb 1f       	adc	r27, r27
    3ff6:	ac 52       	subi	r26, 0x2C	; 44
    3ff8:	bb 4f       	sbci	r27, 0xFB	; 251
    3ffa:	4d 93       	st	X+, r20
    3ffc:	5c 93       	st	X, r21
    3ffe:	6f 5f       	subi	r22, 0xFF	; 255
    4000:	67 70       	andi	r22, 0x07	; 7
    4002:	62 8b       	std	Z+18, r22	; 0x12
    4004:	60 81       	ld	r22, Z
    4006:	71 81       	ldd	r23, Z+1	; 0x01
    4008:	66 0d       	add	r22, r6
    400a:	77 1d       	adc	r23, r7
    400c:	71 83       	std	Z+1, r23	; 0x01
    400e:	60 83       	st	Z, r22
    4010:	f9 01       	movw	r30, r18
    4012:	ee 0f       	add	r30, r30
    4014:	ff 1f       	adc	r31, r31
    4016:	ee 0f       	add	r30, r30
    4018:	ff 1f       	adc	r31, r31
    401a:	ee 0f       	add	r30, r30
    401c:	ff 1f       	adc	r31, r31
    401e:	e2 1b       	sub	r30, r18
    4020:	f3 0b       	sbc	r31, r19
    4022:	e6 50       	subi	r30, 0x06	; 6
    4024:	fb 4f       	sbci	r31, 0xFB	; 251
    4026:	24 85       	ldd	r18, Z+12	; 0x0c
    4028:	35 85       	ldd	r19, Z+13	; 0x0d
    402a:	26 17       	cp	r18, r22
    402c:	37 07       	cpc	r19, r23
    402e:	5c f4       	brge	.+22     	; 0x4046 <heater_tick+0xd2>
    4030:	64 e1       	ldi	r22, 0x14	; 20
    4032:	68 9f       	mul	r22, r24
    4034:	f0 01       	movw	r30, r0
    4036:	69 9f       	mul	r22, r25
    4038:	f0 0d       	add	r31, r0
    403a:	11 24       	eor	r1, r1
    403c:	ee 52       	subi	r30, 0x2E	; 46
    403e:	fb 4f       	sbci	r31, 0xFB	; 251
    4040:	31 83       	std	Z+1, r19	; 0x01
    4042:	20 83       	st	Z, r18
    4044:	10 c0       	rjmp	.+32     	; 0x4066 <heater_tick+0xf2>
    4046:	31 95       	neg	r19
    4048:	21 95       	neg	r18
    404a:	31 09       	sbc	r19, r1
    404c:	62 17       	cp	r22, r18
    404e:	73 07       	cpc	r23, r19
    4050:	54 f4       	brge	.+20     	; 0x4066 <heater_tick+0xf2>
    4052:	64 e1       	ldi	r22, 0x14	; 20
    4054:	68 9f       	mul	r22, r24
    4056:	f0 01       	movw	r30, r0
    4058:	69 9f       	mul	r22, r25
    405a:	f0 0d       	add	r31, r0
    405c:	11 24       	eor	r1, r1
    405e:	ee 52       	subi	r30, 0x2E	; 46
    4060:	fb 4f       	sbci	r31, 0xFB	; 251
    4062:	31 83       	std	Z+1, r19	; 0x01
    4064:	20 83       	st	Z, r18
    4066:	24 e1       	ldi	r18, 0x14	; 20
    4068:	28 9f       	mul	r18, r24
    406a:	80 01       	movw	r16, r0
    406c:	29 9f       	mul	r18, r25
    406e:	10 0d       	add	r17, r0
    4070:	11 24       	eor	r1, r1
    4072:	0e 52       	subi	r16, 0x2E	; 46
    4074:	1b 4f       	sbci	r17, 0xFB	; 251
    4076:	d8 01       	movw	r26, r16
    4078:	52 96       	adiw	r26, 0x12	; 18
    407a:	6c 91       	ld	r22, X
    407c:	9c 01       	movw	r18, r24
    407e:	22 0f       	add	r18, r18
    4080:	33 1f       	adc	r19, r19
    4082:	fc 01       	movw	r30, r24
    4084:	ee 0f       	add	r30, r30
    4086:	ff 1f       	adc	r31, r31
    4088:	ee 0f       	add	r30, r30
    408a:	ff 1f       	adc	r31, r31
    408c:	ee 0f       	add	r30, r30
    408e:	ff 1f       	adc	r31, r31
    4090:	e2 0f       	add	r30, r18
    4092:	f3 1f       	adc	r31, r19
    4094:	e6 0f       	add	r30, r22
    4096:	f1 1d       	adc	r31, r1
    4098:	ee 0f       	add	r30, r30
    409a:	ff 1f       	adc	r31, r31
    409c:	ec 52       	subi	r30, 0x2C	; 44
    409e:	fb 4f       	sbci	r31, 0xFB	; 251
    40a0:	80 81       	ld	r24, Z
    40a2:	91 81       	ldd	r25, Z+1	; 0x01
    40a4:	fc 01       	movw	r30, r24
    40a6:	e4 1b       	sub	r30, r20
    40a8:	f5 0b       	sbc	r31, r21
    40aa:	fa 83       	std	Y+2, r31	; 0x02
    40ac:	e9 83       	std	Y+1, r30	; 0x01
    40ae:	f9 01       	movw	r30, r18
    40b0:	ee 0f       	add	r30, r30
    40b2:	ff 1f       	adc	r31, r31
    40b4:	ee 0f       	add	r30, r30
    40b6:	ff 1f       	adc	r31, r31
    40b8:	ee 0f       	add	r30, r30
    40ba:	ff 1f       	adc	r31, r31
    40bc:	e2 1b       	sub	r30, r18
    40be:	f3 0b       	sbc	r31, r19
    40c0:	9f 01       	movw	r18, r30
    40c2:	26 50       	subi	r18, 0x06	; 6
    40c4:	3b 4f       	sbci	r19, 0xFB	; 251
    40c6:	3b 87       	std	Y+11, r19	; 0x0b
    40c8:	2a 87       	std	Y+10, r18	; 0x0a
    40ca:	f9 01       	movw	r30, r18
    40cc:	f0 81       	ld	r31, Z
    40ce:	fb 83       	std	Y+3, r31	; 0x03
    40d0:	f9 01       	movw	r30, r18
    40d2:	f1 81       	ldd	r31, Z+1	; 0x01
    40d4:	fc 83       	std	Y+4, r31	; 0x04
    40d6:	f9 01       	movw	r30, r18
    40d8:	f2 81       	ldd	r31, Z+2	; 0x02
    40da:	fd 83       	std	Y+5, r31	; 0x05
    40dc:	f9 01       	movw	r30, r18
    40de:	f3 81       	ldd	r31, Z+3	; 0x03
    40e0:	fe 83       	std	Y+6, r31	; 0x06
    40e2:	d3 01       	movw	r26, r6
    40e4:	2b 81       	ldd	r18, Y+3	; 0x03
    40e6:	3c 81       	ldd	r19, Y+4	; 0x04
    40e8:	4d 81       	ldd	r20, Y+5	; 0x05
    40ea:	5f 2f       	mov	r21, r31
    40ec:	0e 94 78 2a 	call	0x54f0	; 0x54f0 <__mulshisi3>
    40f0:	6b 01       	movw	r12, r22
    40f2:	7c 01       	movw	r14, r24
    40f4:	d8 01       	movw	r26, r16
    40f6:	bc 91       	ld	r27, X
    40f8:	bf 83       	std	Y+7, r27	; 0x07
    40fa:	f8 01       	movw	r30, r16
    40fc:	11 81       	ldd	r17, Z+1	; 0x01
    40fe:	ea 85       	ldd	r30, Y+10	; 0x0a
    4100:	fb 85       	ldd	r31, Y+11	; 0x0b
    4102:	04 81       	ldd	r16, Z+4	; 0x04
    4104:	f5 81       	ldd	r31, Z+5	; 0x05
    4106:	f8 87       	std	Y+8, r31	; 0x08
    4108:	ea 85       	ldd	r30, Y+10	; 0x0a
    410a:	fb 85       	ldd	r31, Y+11	; 0x0b
    410c:	f6 81       	ldd	r31, Z+6	; 0x06
    410e:	f9 87       	std	Y+9, r31	; 0x09
    4110:	ea 85       	ldd	r30, Y+10	; 0x0a
    4112:	fb 85       	ldd	r31, Y+11	; 0x0b
    4114:	57 80       	ldd	r5, Z+7	; 0x07
    4116:	ab 2f       	mov	r26, r27
    4118:	b1 2f       	mov	r27, r17
    411a:	20 2f       	mov	r18, r16
    411c:	38 85       	ldd	r19, Y+8	; 0x08
    411e:	49 85       	ldd	r20, Y+9	; 0x09
    4120:	55 2d       	mov	r21, r5
    4122:	0e 94 78 2a 	call	0x54f0	; 0x54f0 <__mulshisi3>
    4126:	4b 01       	movw	r8, r22
    4128:	5c 01       	movw	r10, r24
    412a:	40 84       	ldd	r4, Z+8	; 0x08
    412c:	31 84       	ldd	r3, Z+9	; 0x09
    412e:	22 84       	ldd	r2, Z+10	; 0x0a
    4130:	f3 85       	ldd	r31, Z+11	; 0x0b
    4132:	ff 87       	std	Y+15, r31	; 0x0f
    4134:	a9 81       	ldd	r26, Y+1	; 0x01
    4136:	ba 81       	ldd	r27, Y+2	; 0x02
    4138:	24 2d       	mov	r18, r4
    413a:	33 2d       	mov	r19, r3
    413c:	42 2d       	mov	r20, r2
    413e:	5f 2f       	mov	r21, r31
    4140:	0e 94 78 2a 	call	0x54f0	; 0x54f0 <__mulshisi3>
    4144:	a7 01       	movw	r20, r14
    4146:	96 01       	movw	r18, r12
    4148:	28 0d       	add	r18, r8
    414a:	39 1d       	adc	r19, r9
    414c:	4a 1d       	adc	r20, r10
    414e:	5b 1d       	adc	r21, r11
    4150:	26 0f       	add	r18, r22
    4152:	37 1f       	adc	r19, r23
    4154:	48 1f       	adc	r20, r24
    4156:	59 1f       	adc	r21, r25
    4158:	2a 87       	std	Y+10, r18	; 0x0a
    415a:	3b 87       	std	Y+11, r19	; 0x0b
    415c:	4c 87       	std	Y+12, r20	; 0x0c
    415e:	5d 87       	std	Y+13, r21	; 0x0d
    4160:	55 23       	and	r21, r21
    4162:	24 f4       	brge	.+8      	; 0x416c <heater_tick+0x1f8>
    4164:	21 50       	subi	r18, 0x01	; 1
    4166:	3c 4f       	sbci	r19, 0xFC	; 252
    4168:	4f 4f       	sbci	r20, 0xFF	; 255
    416a:	5f 4f       	sbci	r21, 0xFF	; 255
    416c:	01 2e       	mov	r0, r17
    416e:	1a e0       	ldi	r17, 0x0A	; 10
    4170:	55 95       	asr	r21
    4172:	47 95       	ror	r20
    4174:	37 95       	ror	r19
    4176:	27 95       	ror	r18
    4178:	1a 95       	dec	r17
    417a:	d1 f7       	brne	.-12     	; 0x4170 <heater_tick+0x1fc>
    417c:	10 2d       	mov	r17, r0
    417e:	2f 3f       	cpi	r18, 0xFF	; 255
    4180:	31 05       	cpc	r19, r1
    4182:	41 05       	cpc	r20, r1
    4184:	51 05       	cpc	r21, r1
    4186:	09 f0       	breq	.+2      	; 0x418a <heater_tick+0x216>
    4188:	24 f4       	brge	.+8      	; 0x4192 <heater_tick+0x21e>
    418a:	55 23       	and	r21, r21
    418c:	2c f0       	brlt	.+10     	; 0x4198 <heater_tick+0x224>
    418e:	2a 87       	std	Y+10, r18	; 0x0a
    4190:	04 c0       	rjmp	.+8      	; 0x419a <heater_tick+0x226>
    4192:	af ef       	ldi	r26, 0xFF	; 255
    4194:	aa 87       	std	Y+10, r26	; 0x0a
    4196:	01 c0       	rjmp	.+2      	; 0x419a <heater_tick+0x226>
    4198:	1a 86       	std	Y+10, r1	; 0x0a
    419a:	f0 91 cf 04 	lds	r31, 0x04CF
    419e:	f0 ff       	sbrs	r31, 0
    41a0:	70 c0       	rjmp	.+224    	; 0x4282 <heater_tick+0x30e>
    41a2:	1f 92       	push	r1
    41a4:	ba 85       	ldd	r27, Y+10	; 0x0a
    41a6:	bf 93       	push	r27
    41a8:	5f 93       	push	r21
    41aa:	4f 93       	push	r20
    41ac:	3f 93       	push	r19
    41ae:	2f 93       	push	r18
    41b0:	9b 01       	movw	r18, r22
    41b2:	ac 01       	movw	r20, r24
    41b4:	99 23       	and	r25, r25
    41b6:	24 f4       	brge	.+8      	; 0x41c0 <heater_tick+0x24c>
    41b8:	21 50       	subi	r18, 0x01	; 1
    41ba:	3c 4f       	sbci	r19, 0xFC	; 252
    41bc:	4f 4f       	sbci	r20, 0xFF	; 255
    41be:	5f 4f       	sbci	r21, 0xFF	; 255
    41c0:	da 01       	movw	r26, r20
    41c2:	c9 01       	movw	r24, r18
    41c4:	07 2e       	mov	r0, r23
    41c6:	7a e0       	ldi	r23, 0x0A	; 10
    41c8:	b5 95       	asr	r27
    41ca:	a7 95       	ror	r26
    41cc:	97 95       	ror	r25
    41ce:	87 95       	ror	r24
    41d0:	7a 95       	dec	r23
    41d2:	d1 f7       	brne	.-12     	; 0x41c8 <heater_tick+0x254>
    41d4:	70 2d       	mov	r23, r0
    41d6:	bf 93       	push	r27
    41d8:	af 93       	push	r26
    41da:	9f 93       	push	r25
    41dc:	8f 93       	push	r24
    41de:	ef 85       	ldd	r30, Y+15	; 0x0f
    41e0:	ef 93       	push	r30
    41e2:	2f 92       	push	r2
    41e4:	3f 92       	push	r3
    41e6:	4f 92       	push	r4
    41e8:	fa 81       	ldd	r31, Y+2	; 0x02
    41ea:	ff 93       	push	r31
    41ec:	29 81       	ldd	r18, Y+1	; 0x01
    41ee:	2f 93       	push	r18
    41f0:	d5 01       	movw	r26, r10
    41f2:	c4 01       	movw	r24, r8
    41f4:	bb 20       	and	r11, r11
    41f6:	24 f4       	brge	.+8      	; 0x4200 <heater_tick+0x28c>
    41f8:	81 50       	subi	r24, 0x01	; 1
    41fa:	9c 4f       	sbci	r25, 0xFC	; 252
    41fc:	af 4f       	sbci	r26, 0xFF	; 255
    41fe:	bf 4f       	sbci	r27, 0xFF	; 255
    4200:	07 2e       	mov	r0, r23
    4202:	7a e0       	ldi	r23, 0x0A	; 10
    4204:	b5 95       	asr	r27
    4206:	a7 95       	ror	r26
    4208:	97 95       	ror	r25
    420a:	87 95       	ror	r24
    420c:	7a 95       	dec	r23
    420e:	d1 f7       	brne	.-12     	; 0x4204 <heater_tick+0x290>
    4210:	70 2d       	mov	r23, r0
    4212:	bf 93       	push	r27
    4214:	af 93       	push	r26
    4216:	9f 93       	push	r25
    4218:	8f 93       	push	r24
    421a:	5f 92       	push	r5
    421c:	e9 85       	ldd	r30, Y+9	; 0x09
    421e:	ef 93       	push	r30
    4220:	f8 85       	ldd	r31, Y+8	; 0x08
    4222:	ff 93       	push	r31
    4224:	0f 93       	push	r16
    4226:	1f 93       	push	r17
    4228:	ef 81       	ldd	r30, Y+7	; 0x07
    422a:	ef 93       	push	r30
    422c:	d7 01       	movw	r26, r14
    422e:	c6 01       	movw	r24, r12
    4230:	ff 20       	and	r15, r15
    4232:	24 f4       	brge	.+8      	; 0x423c <heater_tick+0x2c8>
    4234:	81 50       	subi	r24, 0x01	; 1
    4236:	9c 4f       	sbci	r25, 0xFC	; 252
    4238:	af 4f       	sbci	r26, 0xFF	; 255
    423a:	bf 4f       	sbci	r27, 0xFF	; 255
    423c:	07 2e       	mov	r0, r23
    423e:	7a e0       	ldi	r23, 0x0A	; 10
    4240:	b5 95       	asr	r27
    4242:	a7 95       	ror	r26
    4244:	97 95       	ror	r25
    4246:	87 95       	ror	r24
    4248:	7a 95       	dec	r23
    424a:	d1 f7       	brne	.-12     	; 0x4240 <heater_tick+0x2cc>
    424c:	70 2d       	mov	r23, r0
    424e:	bf 93       	push	r27
    4250:	af 93       	push	r26
    4252:	9f 93       	push	r25
    4254:	8f 93       	push	r24
    4256:	fe 81       	ldd	r31, Y+6	; 0x06
    4258:	ff 93       	push	r31
    425a:	ed 81       	ldd	r30, Y+5	; 0x05
    425c:	ef 93       	push	r30
    425e:	fc 81       	ldd	r31, Y+4	; 0x04
    4260:	ff 93       	push	r31
    4262:	eb 81       	ldd	r30, Y+3	; 0x03
    4264:	ef 93       	push	r30
    4266:	7f 92       	push	r7
    4268:	6f 92       	push	r6
    426a:	7f 92       	push	r7
    426c:	6f 92       	push	r6
    426e:	81 e9       	ldi	r24, 0x91	; 145
    4270:	95 e0       	ldi	r25, 0x05	; 5
    4272:	9f 93       	push	r25
    4274:	8f 93       	push	r24
    4276:	f1 d4       	rcall	.+2530   	; 0x4c5a <sersendf_P>
    4278:	0f b6       	in	r0, 0x3f	; 63
    427a:	f8 94       	cli
    427c:	de bf       	out	0x3e, r29	; 62
    427e:	0f be       	out	0x3f, r0	; 63
    4280:	cd bf       	out	0x3d, r28	; 61
    4282:	6a 85       	ldd	r22, Y+10	; 0x0a
    4284:	8e 85       	ldd	r24, Y+14	; 0x0e
    4286:	09 de       	rcall	.-1006   	; 0x3e9a <heater_set>
    4288:	2f 96       	adiw	r28, 0x0f	; 15
    428a:	0f b6       	in	r0, 0x3f	; 63
    428c:	f8 94       	cli
    428e:	de bf       	out	0x3e, r29	; 62
    4290:	0f be       	out	0x3f, r0	; 63
    4292:	cd bf       	out	0x3d, r28	; 61
    4294:	df 91       	pop	r29
    4296:	cf 91       	pop	r28
    4298:	1f 91       	pop	r17
    429a:	0f 91       	pop	r16
    429c:	ff 90       	pop	r15
    429e:	ef 90       	pop	r14
    42a0:	df 90       	pop	r13
    42a2:	cf 90       	pop	r12
    42a4:	bf 90       	pop	r11
    42a6:	af 90       	pop	r10
    42a8:	9f 90       	pop	r9
    42aa:	8f 90       	pop	r8
    42ac:	7f 90       	pop	r7
    42ae:	6f 90       	pop	r6
    42b0:	5f 90       	pop	r5
    42b2:	4f 90       	pop	r4
    42b4:	3f 90       	pop	r3
    42b6:	2f 90       	pop	r2
    42b8:	08 95       	ret

000042ba <heaters_all_zero>:
    42ba:	80 91 e5 04 	lds	r24, 0x04E5
    42be:	81 11       	cpse	r24, r1
    42c0:	06 c0       	rjmp	.+12     	; 0x42ce <heaters_all_zero+0x14>
    42c2:	80 91 f9 04 	lds	r24, 0x04F9
    42c6:	88 23       	and	r24, r24
    42c8:	21 f0       	breq	.+8      	; 0x42d2 <heaters_all_zero+0x18>
    42ca:	80 e0       	ldi	r24, 0x00	; 0
    42cc:	08 95       	ret
    42ce:	80 e0       	ldi	r24, 0x00	; 0
    42d0:	08 95       	ret
    42d2:	8f ef       	ldi	r24, 0xFF	; 255
    42d4:	08 95       	ret

000042d6 <pid_set_p>:
	\param index heater to change factor for
	\param p scaled P factor
*/
void pid_set_p(heater_t index, int32_t p) {
	#ifndef	BANG_BANG
		if (index >= NUM_HEATERS)
    42d6:	82 30       	cpi	r24, 0x02	; 2
    42d8:	98 f4       	brcc	.+38     	; 0x4300 <pid_set_p+0x2a>
			return;

		heaters_pid[index].p_factor = p;
    42da:	28 2f       	mov	r18, r24
    42dc:	30 e0       	ldi	r19, 0x00	; 0
    42de:	22 0f       	add	r18, r18
    42e0:	33 1f       	adc	r19, r19
    42e2:	f9 01       	movw	r30, r18
    42e4:	ee 0f       	add	r30, r30
    42e6:	ff 1f       	adc	r31, r31
    42e8:	ee 0f       	add	r30, r30
    42ea:	ff 1f       	adc	r31, r31
    42ec:	ee 0f       	add	r30, r30
    42ee:	ff 1f       	adc	r31, r31
    42f0:	e2 1b       	sub	r30, r18
    42f2:	f3 0b       	sbc	r31, r19
    42f4:	e6 50       	subi	r30, 0x06	; 6
    42f6:	fb 4f       	sbci	r31, 0xFB	; 251
    42f8:	40 83       	st	Z, r20
    42fa:	51 83       	std	Z+1, r21	; 0x01
    42fc:	62 83       	std	Z+2, r22	; 0x02
    42fe:	73 83       	std	Z+3, r23	; 0x03
    4300:	08 95       	ret

00004302 <pid_set_i>:
	\param index heater to change I factor for
	\param i scaled I factor
*/
void pid_set_i(heater_t index, int32_t i) {
	#ifndef	BANG_BANG
		if (index >= NUM_HEATERS)
    4302:	82 30       	cpi	r24, 0x02	; 2
    4304:	98 f4       	brcc	.+38     	; 0x432c <pid_set_i+0x2a>
			return;

		heaters_pid[index].i_factor = i;
    4306:	28 2f       	mov	r18, r24
    4308:	30 e0       	ldi	r19, 0x00	; 0
    430a:	22 0f       	add	r18, r18
    430c:	33 1f       	adc	r19, r19
    430e:	f9 01       	movw	r30, r18
    4310:	ee 0f       	add	r30, r30
    4312:	ff 1f       	adc	r31, r31
    4314:	ee 0f       	add	r30, r30
    4316:	ff 1f       	adc	r31, r31
    4318:	ee 0f       	add	r30, r30
    431a:	ff 1f       	adc	r31, r31
    431c:	e2 1b       	sub	r30, r18
    431e:	f3 0b       	sbc	r31, r19
    4320:	e6 50       	subi	r30, 0x06	; 6
    4322:	fb 4f       	sbci	r31, 0xFB	; 251
    4324:	44 83       	std	Z+4, r20	; 0x04
    4326:	55 83       	std	Z+5, r21	; 0x05
    4328:	66 83       	std	Z+6, r22	; 0x06
    432a:	77 83       	std	Z+7, r23	; 0x07
    432c:	08 95       	ret

0000432e <pid_set_d>:
	\param index heater to change D factor for
	\param d scaled D factor
*/
void pid_set_d(heater_t index, int32_t d) {
	#ifndef	BANG_BANG
		if (index >= NUM_HEATERS)
    432e:	82 30       	cpi	r24, 0x02	; 2
    4330:	98 f4       	brcc	.+38     	; 0x4358 <pid_set_d+0x2a>
			return;

		heaters_pid[index].d_factor = d;
    4332:	28 2f       	mov	r18, r24
    4334:	30 e0       	ldi	r19, 0x00	; 0
    4336:	22 0f       	add	r18, r18
    4338:	33 1f       	adc	r19, r19
    433a:	f9 01       	movw	r30, r18
    433c:	ee 0f       	add	r30, r30
    433e:	ff 1f       	adc	r31, r31
    4340:	ee 0f       	add	r30, r30
    4342:	ff 1f       	adc	r31, r31
    4344:	ee 0f       	add	r30, r30
    4346:	ff 1f       	adc	r31, r31
    4348:	e2 1b       	sub	r30, r18
    434a:	f3 0b       	sbc	r31, r19
    434c:	e6 50       	subi	r30, 0x06	; 6
    434e:	fb 4f       	sbci	r31, 0xFB	; 251
    4350:	40 87       	std	Z+8, r20	; 0x08
    4352:	51 87       	std	Z+9, r21	; 0x09
    4354:	62 87       	std	Z+10, r22	; 0x0a
    4356:	73 87       	std	Z+11, r23	; 0x0b
    4358:	08 95       	ret

0000435a <pid_set_i_limit>:
	\param index heater to set I limit for
	\param i_limit scaled I limit
*/
void pid_set_i_limit(heater_t index, int32_t i_limit) {
	#ifndef	BANG_BANG
		if (index >= NUM_HEATERS)
    435a:	82 30       	cpi	r24, 0x02	; 2
    435c:	88 f4       	brcc	.+34     	; 0x4380 <pid_set_i_limit+0x26>
			return;

		heaters_pid[index].i_limit = i_limit;
    435e:	28 2f       	mov	r18, r24
    4360:	30 e0       	ldi	r19, 0x00	; 0
    4362:	22 0f       	add	r18, r18
    4364:	33 1f       	adc	r19, r19
    4366:	f9 01       	movw	r30, r18
    4368:	ee 0f       	add	r30, r30
    436a:	ff 1f       	adc	r31, r31
    436c:	ee 0f       	add	r30, r30
    436e:	ff 1f       	adc	r31, r31
    4370:	ee 0f       	add	r30, r30
    4372:	ff 1f       	adc	r31, r31
    4374:	e2 1b       	sub	r30, r18
    4376:	f3 0b       	sbc	r31, r19
    4378:	e6 50       	subi	r30, 0x06	; 6
    437a:	fb 4f       	sbci	r31, 0xFB	; 251
    437c:	55 87       	std	Z+13, r21	; 0x0d
    437e:	44 87       	std	Z+12, r20	; 0x0c
    4380:	08 95       	ret

00004382 <heater_save_settings>:
	#endif /* BANG_BANG */
}

/// \brief Write PID factors to eeprom
void heater_save_settings() {
    4382:	ff 92       	push	r15
    4384:	0f 93       	push	r16
    4386:	1f 93       	push	r17
    4388:	cf 93       	push	r28
    438a:	df 93       	push	r29
  #ifndef BANG_BANG
    heater_t i;
    for (i = 0; i < NUM_HEATERS; i++) {
    438c:	f1 2c       	mov	r15, r1
      eeprom_write_dword((uint32_t *) &EE_factors[i].EE_p_factor, heaters_pid[i].p_factor);
    438e:	cf 2d       	mov	r28, r15
    4390:	d0 e0       	ldi	r29, 0x00	; 0
    4392:	ce 01       	movw	r24, r28
    4394:	88 0f       	add	r24, r24
    4396:	99 1f       	adc	r25, r25
    4398:	8c 01       	movw	r16, r24
    439a:	00 0f       	add	r16, r16
    439c:	11 1f       	adc	r17, r17
    439e:	00 0f       	add	r16, r16
    43a0:	11 1f       	adc	r17, r17
    43a2:	00 0f       	add	r16, r16
    43a4:	11 1f       	adc	r17, r17
    43a6:	08 1b       	sub	r16, r24
    43a8:	19 0b       	sbc	r17, r25
    43aa:	06 50       	subi	r16, 0x06	; 6
    43ac:	1b 4f       	sbci	r17, 0xFB	; 251
    43ae:	f8 01       	movw	r30, r16
    43b0:	40 81       	ld	r20, Z
    43b2:	51 81       	ldd	r21, Z+1	; 0x01
    43b4:	62 81       	ldd	r22, Z+2	; 0x02
    43b6:	73 81       	ldd	r23, Z+3	; 0x03
    43b8:	c2 95       	swap	r28
    43ba:	d2 95       	swap	r29
    43bc:	d0 7f       	andi	r29, 0xF0	; 240
    43be:	dc 27       	eor	r29, r28
    43c0:	c0 7f       	andi	r28, 0xF0	; 240
    43c2:	dc 27       	eor	r29, r28
    43c4:	ce 01       	movw	r24, r28
    43c6:	80 50       	subi	r24, 0x00	; 0
    43c8:	90 40       	sbci	r25, 0x00	; 0
    43ca:	0e 94 88 2a 	call	0x5510	; 0x5510 <__eewr_dword_m2560>
      eeprom_write_dword((uint32_t *) &EE_factors[i].EE_i_factor, heaters_pid[i].i_factor);
    43ce:	f8 01       	movw	r30, r16
    43d0:	44 81       	ldd	r20, Z+4	; 0x04
    43d2:	55 81       	ldd	r21, Z+5	; 0x05
    43d4:	66 81       	ldd	r22, Z+6	; 0x06
    43d6:	77 81       	ldd	r23, Z+7	; 0x07
    43d8:	ce 01       	movw	r24, r28
    43da:	8c 5f       	subi	r24, 0xFC	; 252
    43dc:	9f 4f       	sbci	r25, 0xFF	; 255
    43de:	0e 94 88 2a 	call	0x5510	; 0x5510 <__eewr_dword_m2560>
      eeprom_write_dword((uint32_t *) &EE_factors[i].EE_d_factor, heaters_pid[i].d_factor);
    43e2:	f8 01       	movw	r30, r16
    43e4:	40 85       	ldd	r20, Z+8	; 0x08
    43e6:	51 85       	ldd	r21, Z+9	; 0x09
    43e8:	62 85       	ldd	r22, Z+10	; 0x0a
    43ea:	73 85       	ldd	r23, Z+11	; 0x0b
    43ec:	ce 01       	movw	r24, r28
    43ee:	88 5f       	subi	r24, 0xF8	; 248
    43f0:	9f 4f       	sbci	r25, 0xFF	; 255
    43f2:	0e 94 88 2a 	call	0x5510	; 0x5510 <__eewr_dword_m2560>
      eeprom_write_word((uint16_t *) &EE_factors[i].EE_i_limit, heaters_pid[i].i_limit);
    43f6:	f8 01       	movw	r30, r16
    43f8:	64 85       	ldd	r22, Z+12	; 0x0c
    43fa:	75 85       	ldd	r23, Z+13	; 0x0d
    43fc:	ce 01       	movw	r24, r28
    43fe:	84 5f       	subi	r24, 0xF4	; 244
    4400:	9f 4f       	sbci	r25, 0xFF	; 255
    4402:	0e 94 8d 2a 	call	0x551a	; 0x551a <__eewr_word_m2560>
      eeprom_write_word((uint16_t *) &EE_factors[i].crc, crc_block(&heaters_pid[i].p_factor, 14));
    4406:	6e e0       	ldi	r22, 0x0E	; 14
    4408:	70 e0       	ldi	r23, 0x00	; 0
    440a:	c8 01       	movw	r24, r16
    440c:	0e 94 6f 06 	call	0xcde	; 0xcde <crc_block>
    4410:	bc 01       	movw	r22, r24
    4412:	ce 01       	movw	r24, r28
    4414:	82 5f       	subi	r24, 0xF2	; 242
    4416:	9f 4f       	sbci	r25, 0xFF	; 255
    4418:	0e 94 8d 2a 	call	0x551a	; 0x551a <__eewr_word_m2560>

/// \brief Write PID factors to eeprom
void heater_save_settings() {
  #ifndef BANG_BANG
    heater_t i;
    for (i = 0; i < NUM_HEATERS; i++) {
    441c:	f3 94       	inc	r15
    441e:	f2 e0       	ldi	r31, 0x02	; 2
    4420:	ff 12       	cpse	r15, r31
    4422:	b5 cf       	rjmp	.-150    	; 0x438e <heater_save_settings+0xc>
      eeprom_write_dword((uint32_t *) &EE_factors[i].EE_d_factor, heaters_pid[i].d_factor);
      eeprom_write_word((uint16_t *) &EE_factors[i].EE_i_limit, heaters_pid[i].i_limit);
      eeprom_write_word((uint16_t *) &EE_factors[i].crc, crc_block(&heaters_pid[i].p_factor, 14));
    }
  #endif /* BANG_BANG */
}
    4424:	df 91       	pop	r29
    4426:	cf 91       	pop	r28
    4428:	1f 91       	pop	r17
    442a:	0f 91       	pop	r16
    442c:	ff 90       	pop	r15
    442e:	08 95       	ret

00004430 <heater_print>:

#ifndef	EXTRUDER
/** \brief send heater debug info to host
	\param i index of heater to send info for
*/
void heater_print(uint16_t i) {
    4430:	cf 93       	push	r28
    4432:	df 93       	push	r29
    4434:	d8 2f       	mov	r29, r24
    4436:	c9 2f       	mov	r28, r25
	sersendf_P(PSTR("P:%ld I:%ld D:%ld Ilim:%u crc:%u "), heaters_pid[i].p_factor, heaters_pid[i].i_factor, heaters_pid[i].d_factor, heaters_pid[i].i_limit, crc_block(&heaters_pid[i].p_factor, 14));
    4438:	28 2f       	mov	r18, r24
    443a:	39 2f       	mov	r19, r25
    443c:	22 0f       	add	r18, r18
    443e:	33 1f       	adc	r19, r19
    4440:	c9 01       	movw	r24, r18
    4442:	88 0f       	add	r24, r24
    4444:	99 1f       	adc	r25, r25
    4446:	88 0f       	add	r24, r24
    4448:	99 1f       	adc	r25, r25
    444a:	88 0f       	add	r24, r24
    444c:	99 1f       	adc	r25, r25
    444e:	82 1b       	sub	r24, r18
    4450:	93 0b       	sbc	r25, r19
    4452:	6e e0       	ldi	r22, 0x0E	; 14
    4454:	70 e0       	ldi	r23, 0x00	; 0
    4456:	86 50       	subi	r24, 0x06	; 6
    4458:	9b 4f       	sbci	r25, 0xFB	; 251
    445a:	0e 94 6f 06 	call	0xcde	; 0xcde <crc_block>
    445e:	9f 93       	push	r25
    4460:	8f 93       	push	r24
    4462:	2d 2f       	mov	r18, r29
    4464:	3c 2f       	mov	r19, r28
    4466:	22 0f       	add	r18, r18
    4468:	33 1f       	adc	r19, r19
    446a:	f9 01       	movw	r30, r18
    446c:	ee 0f       	add	r30, r30
    446e:	ff 1f       	adc	r31, r31
    4470:	ee 0f       	add	r30, r30
    4472:	ff 1f       	adc	r31, r31
    4474:	ee 0f       	add	r30, r30
    4476:	ff 1f       	adc	r31, r31
    4478:	e2 1b       	sub	r30, r18
    447a:	f3 0b       	sbc	r31, r19
    447c:	e6 50       	subi	r30, 0x06	; 6
    447e:	fb 4f       	sbci	r31, 0xFB	; 251
    4480:	85 85       	ldd	r24, Z+13	; 0x0d
    4482:	8f 93       	push	r24
    4484:	84 85       	ldd	r24, Z+12	; 0x0c
    4486:	8f 93       	push	r24
    4488:	2d 2f       	mov	r18, r29
    448a:	3c 2f       	mov	r19, r28
    448c:	22 0f       	add	r18, r18
    448e:	33 1f       	adc	r19, r19
    4490:	d9 01       	movw	r26, r18
    4492:	aa 0f       	add	r26, r26
    4494:	bb 1f       	adc	r27, r27
    4496:	aa 0f       	add	r26, r26
    4498:	bb 1f       	adc	r27, r27
    449a:	aa 0f       	add	r26, r26
    449c:	bb 1f       	adc	r27, r27
    449e:	a2 1b       	sub	r26, r18
    44a0:	b3 0b       	sbc	r27, r19
    44a2:	a6 50       	subi	r26, 0x06	; 6
    44a4:	bb 4f       	sbci	r27, 0xFB	; 251
    44a6:	fd 01       	movw	r30, r26
    44a8:	38 96       	adiw	r30, 0x08	; 8
    44aa:	83 81       	ldd	r24, Z+3	; 0x03
    44ac:	8f 93       	push	r24
    44ae:	82 81       	ldd	r24, Z+2	; 0x02
    44b0:	8f 93       	push	r24
    44b2:	81 81       	ldd	r24, Z+1	; 0x01
    44b4:	8f 93       	push	r24
    44b6:	18 96       	adiw	r26, 0x08	; 8
    44b8:	8c 91       	ld	r24, X
    44ba:	8f 93       	push	r24
    44bc:	2d 2f       	mov	r18, r29
    44be:	3c 2f       	mov	r19, r28
    44c0:	22 0f       	add	r18, r18
    44c2:	33 1f       	adc	r19, r19
    44c4:	d9 01       	movw	r26, r18
    44c6:	aa 0f       	add	r26, r26
    44c8:	bb 1f       	adc	r27, r27
    44ca:	aa 0f       	add	r26, r26
    44cc:	bb 1f       	adc	r27, r27
    44ce:	aa 0f       	add	r26, r26
    44d0:	bb 1f       	adc	r27, r27
    44d2:	a2 1b       	sub	r26, r18
    44d4:	b3 0b       	sbc	r27, r19
    44d6:	a6 50       	subi	r26, 0x06	; 6
    44d8:	bb 4f       	sbci	r27, 0xFB	; 251
    44da:	fd 01       	movw	r30, r26
    44dc:	34 96       	adiw	r30, 0x04	; 4
    44de:	83 81       	ldd	r24, Z+3	; 0x03
    44e0:	8f 93       	push	r24
    44e2:	82 81       	ldd	r24, Z+2	; 0x02
    44e4:	8f 93       	push	r24
    44e6:	81 81       	ldd	r24, Z+1	; 0x01
    44e8:	8f 93       	push	r24
    44ea:	14 96       	adiw	r26, 0x04	; 4
    44ec:	8c 91       	ld	r24, X
    44ee:	8f 93       	push	r24
    44f0:	2d 2f       	mov	r18, r29
    44f2:	3c 2f       	mov	r19, r28
    44f4:	22 0f       	add	r18, r18
    44f6:	33 1f       	adc	r19, r19
    44f8:	f9 01       	movw	r30, r18
    44fa:	ee 0f       	add	r30, r30
    44fc:	ff 1f       	adc	r31, r31
    44fe:	ee 0f       	add	r30, r30
    4500:	ff 1f       	adc	r31, r31
    4502:	ee 0f       	add	r30, r30
    4504:	ff 1f       	adc	r31, r31
    4506:	e2 1b       	sub	r30, r18
    4508:	f3 0b       	sbc	r31, r19
    450a:	e6 50       	subi	r30, 0x06	; 6
    450c:	fb 4f       	sbci	r31, 0xFB	; 251
    450e:	83 81       	ldd	r24, Z+3	; 0x03
    4510:	8f 93       	push	r24
    4512:	82 81       	ldd	r24, Z+2	; 0x02
    4514:	8f 93       	push	r24
    4516:	81 81       	ldd	r24, Z+1	; 0x01
    4518:	8f 93       	push	r24
    451a:	80 81       	ld	r24, Z
    451c:	8f 93       	push	r24
    451e:	8e ee       	ldi	r24, 0xEE	; 238
    4520:	95 e0       	ldi	r25, 0x05	; 5
    4522:	9f 93       	push	r25
    4524:	8f 93       	push	r24
    4526:	99 d3       	rcall	.+1842   	; 0x4c5a <sersendf_P>
    4528:	8d b7       	in	r24, 0x3d	; 61
    452a:	9e b7       	in	r25, 0x3e	; 62
    452c:	42 96       	adiw	r24, 0x12	; 18
    452e:	0f b6       	in	r0, 0x3f	; 63
    4530:	f8 94       	cli
    4532:	9e bf       	out	0x3e, r25	; 62
    4534:	0f be       	out	0x3f, r0	; 63
    4536:	8d bf       	out	0x3d, r24	; 61
}
    4538:	df 91       	pop	r29
    453a:	cf 91       	pop	r28
    453c:	08 95       	ret

0000453e <home_x_negative>:
		home_z_positive();
	#endif
}

/// find X MIN endstop
void home_x_negative() {
    453e:	cf 93       	push	r28
    4540:	df 93       	push	r29
    4542:	cd b7       	in	r28, 0x3d	; 61
    4544:	de b7       	in	r29, 0x3e	; 62
    4546:	65 97       	sbiw	r28, 0x15	; 21
    4548:	0f b6       	in	r0, 0x3f	; 63
    454a:	f8 94       	cli
    454c:	de bf       	out	0x3e, r29	; 62
    454e:	0f be       	out	0x3f, r0	; 63
    4550:	cd bf       	out	0x3d, r28	; 61
	#if defined X_MIN_PIN
		TARGET t = startpoint;
    4552:	85 e1       	ldi	r24, 0x15	; 21
    4554:	e0 e9       	ldi	r30, 0x90	; 144
    4556:	f2 e0       	ldi	r31, 0x02	; 2
    4558:	de 01       	movw	r26, r28
    455a:	11 96       	adiw	r26, 0x01	; 1
    455c:	01 90       	ld	r0, Z+
    455e:	0d 92       	st	X+, r0
    4560:	8a 95       	dec	r24
    4562:	e1 f7       	brne	.-8      	; 0x455c <home_x_negative+0x1e>

		t.X = -1000000;
    4564:	80 ec       	ldi	r24, 0xC0	; 192
    4566:	9d eb       	ldi	r25, 0xBD	; 189
    4568:	a0 ef       	ldi	r26, 0xF0	; 240
    456a:	bf ef       	ldi	r27, 0xFF	; 255
    456c:	89 83       	std	Y+1, r24	; 0x01
    456e:	9a 83       	std	Y+2, r25	; 0x02
    4570:	ab 83       	std	Y+3, r26	; 0x03
    4572:	bc 83       	std	Y+4, r27	; 0x04
		#ifdef SLOW_HOMING
			// hit home soft
			t.F = SEARCH_FEEDRATE_X;
		#else
			// hit home hard
			t.F = MAXIMUM_FEEDRATE_X;
    4574:	88 ec       	ldi	r24, 0xC8	; 200
    4576:	90 e0       	ldi	r25, 0x00	; 0
    4578:	a0 e0       	ldi	r26, 0x00	; 0
    457a:	b0 e0       	ldi	r27, 0x00	; 0
    457c:	89 8b       	std	Y+17, r24	; 0x11
    457e:	9a 8b       	std	Y+18, r25	; 0x12
    4580:	ab 8b       	std	Y+19, r26	; 0x13
    4582:	bc 8b       	std	Y+20, r27	; 0x14
		#endif
		enqueue_home(&t, 0x1, 1);
    4584:	41 e0       	ldi	r20, 0x01	; 1
    4586:	61 e0       	ldi	r22, 0x01	; 1
    4588:	ce 01       	movw	r24, r28
    458a:	01 96       	adiw	r24, 0x01	; 1
    458c:	0e 94 cb 14 	call	0x2996	; 0x2996 <enqueue_home>

		#ifndef SLOW_HOMING
			// back off slowly
			t.X = +1000000;
    4590:	80 e4       	ldi	r24, 0x40	; 64
    4592:	92 e4       	ldi	r25, 0x42	; 66
    4594:	af e0       	ldi	r26, 0x0F	; 15
    4596:	b0 e0       	ldi	r27, 0x00	; 0
    4598:	89 83       	std	Y+1, r24	; 0x01
    459a:	9a 83       	std	Y+2, r25	; 0x02
    459c:	ab 83       	std	Y+3, r26	; 0x03
    459e:	bc 83       	std	Y+4, r27	; 0x04
			t.F = SEARCH_FEEDRATE_X;
    45a0:	82 e3       	ldi	r24, 0x32	; 50
    45a2:	90 e0       	ldi	r25, 0x00	; 0
    45a4:	a0 e0       	ldi	r26, 0x00	; 0
    45a6:	b0 e0       	ldi	r27, 0x00	; 0
    45a8:	89 8b       	std	Y+17, r24	; 0x11
    45aa:	9a 8b       	std	Y+18, r25	; 0x12
    45ac:	ab 8b       	std	Y+19, r26	; 0x13
    45ae:	bc 8b       	std	Y+20, r27	; 0x14
			enqueue_home(&t, 0x1, 0);
    45b0:	40 e0       	ldi	r20, 0x00	; 0
    45b2:	61 e0       	ldi	r22, 0x01	; 1
    45b4:	ce 01       	movw	r24, r28
    45b6:	01 96       	adiw	r24, 0x01	; 1
    45b8:	0e 94 cb 14 	call	0x2996	; 0x2996 <enqueue_home>
		#endif

		// set X home
		queue_wait(); // we have to wait here, see G92
    45bc:	0e 94 84 15 	call	0x2b08	; 0x2b08 <queue_wait>
		#ifdef X_MIN
			startpoint.X = next_target.target.X = (int32_t)(X_MIN * 1000.0);
		#else
			startpoint.X = next_target.target.X = 0;
    45c0:	10 92 8a 04 	sts	0x048A, r1
    45c4:	10 92 8b 04 	sts	0x048B, r1
    45c8:	10 92 8c 04 	sts	0x048C, r1
    45cc:	10 92 8d 04 	sts	0x048D, r1
    45d0:	10 92 90 02 	sts	0x0290, r1
    45d4:	10 92 91 02 	sts	0x0291, r1
    45d8:	10 92 92 02 	sts	0x0292, r1
    45dc:	10 92 93 02 	sts	0x0293, r1
		#endif
		dda_new_startpoint();
    45e0:	0e 94 05 07 	call	0xe0a	; 0xe0a <dda_new_startpoint>
	#endif
}
    45e4:	65 96       	adiw	r28, 0x15	; 21
    45e6:	0f b6       	in	r0, 0x3f	; 63
    45e8:	f8 94       	cli
    45ea:	de bf       	out	0x3e, r29	; 62
    45ec:	0f be       	out	0x3f, r0	; 63
    45ee:	cd bf       	out	0x3d, r28	; 61
    45f0:	df 91       	pop	r29
    45f2:	cf 91       	pop	r28
    45f4:	08 95       	ret

000045f6 <home_x_positive>:

/// find X_MAX endstop
void home_x_positive() {
    45f6:	08 95       	ret

000045f8 <home_y_negative>:
		enqueue(&t);
	#endif
}

/// fund Y MIN endstop
void home_y_negative() {
    45f8:	cf 93       	push	r28
    45fa:	df 93       	push	r29
    45fc:	cd b7       	in	r28, 0x3d	; 61
    45fe:	de b7       	in	r29, 0x3e	; 62
    4600:	65 97       	sbiw	r28, 0x15	; 21
    4602:	0f b6       	in	r0, 0x3f	; 63
    4604:	f8 94       	cli
    4606:	de bf       	out	0x3e, r29	; 62
    4608:	0f be       	out	0x3f, r0	; 63
    460a:	cd bf       	out	0x3d, r28	; 61
	#if defined Y_MIN_PIN
		TARGET t = startpoint;
    460c:	85 e1       	ldi	r24, 0x15	; 21
    460e:	e0 e9       	ldi	r30, 0x90	; 144
    4610:	f2 e0       	ldi	r31, 0x02	; 2
    4612:	de 01       	movw	r26, r28
    4614:	11 96       	adiw	r26, 0x01	; 1
    4616:	01 90       	ld	r0, Z+
    4618:	0d 92       	st	X+, r0
    461a:	8a 95       	dec	r24
    461c:	e1 f7       	brne	.-8      	; 0x4616 <home_y_negative+0x1e>

		t.Y = -1000000;
    461e:	80 ec       	ldi	r24, 0xC0	; 192
    4620:	9d eb       	ldi	r25, 0xBD	; 189
    4622:	a0 ef       	ldi	r26, 0xF0	; 240
    4624:	bf ef       	ldi	r27, 0xFF	; 255
    4626:	8d 83       	std	Y+5, r24	; 0x05
    4628:	9e 83       	std	Y+6, r25	; 0x06
    462a:	af 83       	std	Y+7, r26	; 0x07
    462c:	b8 87       	std	Y+8, r27	; 0x08
		#ifdef SLOW_HOMING
			// hit home soft
			t.F = SEARCH_FEEDRATE_Y;
		#else
			// hit home hard
			t.F = MAXIMUM_FEEDRATE_Y;
    462e:	88 ec       	ldi	r24, 0xC8	; 200
    4630:	90 e0       	ldi	r25, 0x00	; 0
    4632:	a0 e0       	ldi	r26, 0x00	; 0
    4634:	b0 e0       	ldi	r27, 0x00	; 0
    4636:	89 8b       	std	Y+17, r24	; 0x11
    4638:	9a 8b       	std	Y+18, r25	; 0x12
    463a:	ab 8b       	std	Y+19, r26	; 0x13
    463c:	bc 8b       	std	Y+20, r27	; 0x14
		#endif
		enqueue_home(&t, 0x2, 1);
    463e:	41 e0       	ldi	r20, 0x01	; 1
    4640:	62 e0       	ldi	r22, 0x02	; 2
    4642:	ce 01       	movw	r24, r28
    4644:	01 96       	adiw	r24, 0x01	; 1
    4646:	0e 94 cb 14 	call	0x2996	; 0x2996 <enqueue_home>

		#ifndef SLOW_HOMING
			// back off slowly
			t.Y = +1000000;
    464a:	80 e4       	ldi	r24, 0x40	; 64
    464c:	92 e4       	ldi	r25, 0x42	; 66
    464e:	af e0       	ldi	r26, 0x0F	; 15
    4650:	b0 e0       	ldi	r27, 0x00	; 0
    4652:	8d 83       	std	Y+5, r24	; 0x05
    4654:	9e 83       	std	Y+6, r25	; 0x06
    4656:	af 83       	std	Y+7, r26	; 0x07
    4658:	b8 87       	std	Y+8, r27	; 0x08
			t.F = SEARCH_FEEDRATE_Y;
    465a:	82 e3       	ldi	r24, 0x32	; 50
    465c:	90 e0       	ldi	r25, 0x00	; 0
    465e:	a0 e0       	ldi	r26, 0x00	; 0
    4660:	b0 e0       	ldi	r27, 0x00	; 0
    4662:	89 8b       	std	Y+17, r24	; 0x11
    4664:	9a 8b       	std	Y+18, r25	; 0x12
    4666:	ab 8b       	std	Y+19, r26	; 0x13
    4668:	bc 8b       	std	Y+20, r27	; 0x14
			enqueue_home(&t, 0x2, 0);
    466a:	40 e0       	ldi	r20, 0x00	; 0
    466c:	62 e0       	ldi	r22, 0x02	; 2
    466e:	ce 01       	movw	r24, r28
    4670:	01 96       	adiw	r24, 0x01	; 1
    4672:	0e 94 cb 14 	call	0x2996	; 0x2996 <enqueue_home>
		#endif

		// set Y home
		queue_wait();
    4676:	0e 94 84 15 	call	0x2b08	; 0x2b08 <queue_wait>
		#ifdef	Y_MIN
			startpoint.Y = next_target.target.Y = (int32_t)(Y_MIN * 1000.);
		#else
			startpoint.Y = next_target.target.Y = 0;
    467a:	10 92 8e 04 	sts	0x048E, r1
    467e:	10 92 8f 04 	sts	0x048F, r1
    4682:	10 92 90 04 	sts	0x0490, r1
    4686:	10 92 91 04 	sts	0x0491, r1
    468a:	10 92 94 02 	sts	0x0294, r1
    468e:	10 92 95 02 	sts	0x0295, r1
    4692:	10 92 96 02 	sts	0x0296, r1
    4696:	10 92 97 02 	sts	0x0297, r1
		#endif
		dda_new_startpoint();
    469a:	0e 94 05 07 	call	0xe0a	; 0xe0a <dda_new_startpoint>
	#endif
}
    469e:	65 96       	adiw	r28, 0x15	; 21
    46a0:	0f b6       	in	r0, 0x3f	; 63
    46a2:	f8 94       	cli
    46a4:	de bf       	out	0x3e, r29	; 62
    46a6:	0f be       	out	0x3f, r0	; 63
    46a8:	cd bf       	out	0x3d, r28	; 61
    46aa:	df 91       	pop	r29
    46ac:	cf 91       	pop	r28
    46ae:	08 95       	ret

000046b0 <home_y_positive>:

/// find Y MAX endstop
void home_y_positive() {
    46b0:	08 95       	ret

000046b2 <home_z_negative>:
		enqueue(&t);
	#endif
}

/// find Z MIN endstop
void home_z_negative() {
    46b2:	cf 93       	push	r28
    46b4:	df 93       	push	r29
    46b6:	cd b7       	in	r28, 0x3d	; 61
    46b8:	de b7       	in	r29, 0x3e	; 62
    46ba:	65 97       	sbiw	r28, 0x15	; 21
    46bc:	0f b6       	in	r0, 0x3f	; 63
    46be:	f8 94       	cli
    46c0:	de bf       	out	0x3e, r29	; 62
    46c2:	0f be       	out	0x3f, r0	; 63
    46c4:	cd bf       	out	0x3d, r28	; 61
	#if defined Z_MIN_PIN
		TARGET t = startpoint;
    46c6:	85 e1       	ldi	r24, 0x15	; 21
    46c8:	e0 e9       	ldi	r30, 0x90	; 144
    46ca:	f2 e0       	ldi	r31, 0x02	; 2
    46cc:	de 01       	movw	r26, r28
    46ce:	11 96       	adiw	r26, 0x01	; 1
    46d0:	01 90       	ld	r0, Z+
    46d2:	0d 92       	st	X+, r0
    46d4:	8a 95       	dec	r24
    46d6:	e1 f7       	brne	.-8      	; 0x46d0 <home_z_negative+0x1e>

		t.Z = -1000000;
    46d8:	80 ec       	ldi	r24, 0xC0	; 192
    46da:	9d eb       	ldi	r25, 0xBD	; 189
    46dc:	a0 ef       	ldi	r26, 0xF0	; 240
    46de:	bf ef       	ldi	r27, 0xFF	; 255
    46e0:	89 87       	std	Y+9, r24	; 0x09
    46e2:	9a 87       	std	Y+10, r25	; 0x0a
    46e4:	ab 87       	std	Y+11, r26	; 0x0b
    46e6:	bc 87       	std	Y+12, r27	; 0x0c
		#ifdef SLOW_HOMING
			// hit home soft
			t.F = SEARCH_FEEDRATE_Z;
		#else
			// hit home hard
			t.F = MAXIMUM_FEEDRATE_Z;
    46e8:	84 e6       	ldi	r24, 0x64	; 100
    46ea:	90 e0       	ldi	r25, 0x00	; 0
    46ec:	a0 e0       	ldi	r26, 0x00	; 0
    46ee:	b0 e0       	ldi	r27, 0x00	; 0
    46f0:	89 8b       	std	Y+17, r24	; 0x11
    46f2:	9a 8b       	std	Y+18, r25	; 0x12
    46f4:	ab 8b       	std	Y+19, r26	; 0x13
    46f6:	bc 8b       	std	Y+20, r27	; 0x14
		#endif
		enqueue_home(&t, 0x4, 1);
    46f8:	41 e0       	ldi	r20, 0x01	; 1
    46fa:	64 e0       	ldi	r22, 0x04	; 4
    46fc:	ce 01       	movw	r24, r28
    46fe:	01 96       	adiw	r24, 0x01	; 1
    4700:	0e 94 cb 14 	call	0x2996	; 0x2996 <enqueue_home>

		#ifndef SLOW_HOMING
			// back off slowly
			t.Z = +1000000;
    4704:	80 e4       	ldi	r24, 0x40	; 64
    4706:	92 e4       	ldi	r25, 0x42	; 66
    4708:	af e0       	ldi	r26, 0x0F	; 15
    470a:	b0 e0       	ldi	r27, 0x00	; 0
    470c:	89 87       	std	Y+9, r24	; 0x09
    470e:	9a 87       	std	Y+10, r25	; 0x0a
    4710:	ab 87       	std	Y+11, r26	; 0x0b
    4712:	bc 87       	std	Y+12, r27	; 0x0c
			t.F = SEARCH_FEEDRATE_Z;
    4714:	81 e0       	ldi	r24, 0x01	; 1
    4716:	90 e0       	ldi	r25, 0x00	; 0
    4718:	a0 e0       	ldi	r26, 0x00	; 0
    471a:	b0 e0       	ldi	r27, 0x00	; 0
    471c:	89 8b       	std	Y+17, r24	; 0x11
    471e:	9a 8b       	std	Y+18, r25	; 0x12
    4720:	ab 8b       	std	Y+19, r26	; 0x13
    4722:	bc 8b       	std	Y+20, r27	; 0x14
			enqueue_home(&t, 0x4, 0);
    4724:	40 e0       	ldi	r20, 0x00	; 0
    4726:	64 e0       	ldi	r22, 0x04	; 4
    4728:	ce 01       	movw	r24, r28
    472a:	01 96       	adiw	r24, 0x01	; 1
    472c:	0e 94 cb 14 	call	0x2996	; 0x2996 <enqueue_home>
		#endif

		// set Z home
		queue_wait();
    4730:	0e 94 84 15 	call	0x2b08	; 0x2b08 <queue_wait>
		#ifdef Z_MIN
			startpoint.Z = next_target.target.Z = (int32_t)(Z_MIN * 1000.);
		#else
			startpoint.Z = next_target.target.Z = 0;
    4734:	10 92 92 04 	sts	0x0492, r1
    4738:	10 92 93 04 	sts	0x0493, r1
    473c:	10 92 94 04 	sts	0x0494, r1
    4740:	10 92 95 04 	sts	0x0495, r1
    4744:	10 92 98 02 	sts	0x0298, r1
    4748:	10 92 99 02 	sts	0x0299, r1
    474c:	10 92 9a 02 	sts	0x029A, r1
    4750:	10 92 9b 02 	sts	0x029B, r1
		#endif
		dda_new_startpoint();
    4754:	0e 94 05 07 	call	0xe0a	; 0xe0a <dda_new_startpoint>
		z_disable();
	#endif
}
    4758:	65 96       	adiw	r28, 0x15	; 21
    475a:	0f b6       	in	r0, 0x3f	; 63
    475c:	f8 94       	cli
    475e:	de bf       	out	0x3e, r29	; 62
    4760:	0f be       	out	0x3f, r0	; 63
    4762:	cd bf       	out	0x3d, r28	; 61
    4764:	df 91       	pop	r29
    4766:	cf 91       	pop	r28
    4768:	08 95       	ret

0000476a <home>:
#include	"gcode_parse.h"

/// home all 3 axes
void home() {
	#if defined	X_MIN_PIN
		home_x_negative();
    476a:	e9 de       	rcall	.-558    	; 0x453e <home_x_negative>
	#elif defined X_MAX_PIN
		home_x_positive();
	#endif

	#if defined	Y_MIN_PIN
		home_y_negative();
    476c:	45 df       	rcall	.-374    	; 0x45f8 <home_y_negative>
	#elif defined Y_MAX_PIN
		home_y_positive();
	#endif

	#if defined Z_MIN_PIN
		home_z_negative();
    476e:	a1 cf       	rjmp	.-190    	; 0x46b2 <home_z_negative>

00004770 <home_z_positive>:
		z_disable();
	#endif
}

/// find Z MAX endstop
void home_z_positive() {
    4770:	08 95       	ret

00004772 <io_init>:
void io_init(void) {
	// disable modules we don't use
	#ifdef PRR
		PRR = MASK(PRTWI) | MASK(PRADC) | MASK(PRSPI);
	#elif defined PRR0
		PRR0 = MASK(PRTWI) | MASK(PRADC) | MASK(PRSPI);
    4772:	85 e8       	ldi	r24, 0x85	; 133
    4774:	80 93 64 00 	sts	0x0064, r24
		#if defined(PRUSART3)
			// don't use USART2 or USART3- leave USART1 for GEN3 and derivatives
			PRR1 |= MASK(PRUSART3) | MASK(PRUSART2);
    4778:	e5 e6       	ldi	r30, 0x65	; 101
    477a:	f0 e0       	ldi	r31, 0x00	; 0
    477c:	80 81       	ld	r24, Z
    477e:	86 60       	ori	r24, 0x06	; 6
    4780:	80 83       	st	Z, r24
		#endif
		#if defined(PRUSART2)
			// don't use USART2 or USART3- leave USART1 for GEN3 and derivatives
			PRR1 |= MASK(PRUSART2);
    4782:	80 81       	ld	r24, Z
    4784:	82 60       	ori	r24, 0x02	; 2
    4786:	80 83       	st	Z, r24
		#endif
	#endif
	ACSR = MASK(ACD);
    4788:	80 e8       	ldi	r24, 0x80	; 128
    478a:	80 bf       	out	0x30, r24	; 48

	// X Stepper
	//WRITE(X_STEP_PIN, 0);	SET_OUTPUT(X_STEP_PIN);
	//WRITE(X_DIR_PIN,  0);	SET_OUTPUT(X_DIR_PIN);
	#ifdef X_MIN_PIN
		SET_INPUT(X_MIN_PIN);
    478c:	a1 e0       	ldi	r26, 0x01	; 1
    478e:	b1 e0       	ldi	r27, 0x01	; 1
    4790:	8c 91       	ld	r24, X
    4792:	8d 7f       	andi	r24, 0xFD	; 253
    4794:	8c 93       	st	X, r24
		WRITE(X_MIN_PIN, 0); // pullup resistors off
    4796:	e2 e0       	ldi	r30, 0x02	; 2
    4798:	f1 e0       	ldi	r31, 0x01	; 1
    479a:	80 81       	ld	r24, Z
    479c:	8d 7f       	andi	r24, 0xFD	; 253
    479e:	80 83       	st	Z, r24
	#endif
	#ifdef X_MAX_PIN
		SET_INPUT(X_MAX_PIN);
    47a0:	8c 91       	ld	r24, X
    47a2:	8e 7f       	andi	r24, 0xFE	; 254
    47a4:	8c 93       	st	X, r24
		WRITE(X_MAX_PIN, 0); // pullup resistors off
    47a6:	80 81       	ld	r24, Z
    47a8:	8e 7f       	andi	r24, 0xFE	; 254
    47aa:	80 83       	st	Z, r24

	// Y Stepper
	//WRITE(Y_STEP_PIN, 0);	SET_OUTPUT(Y_STEP_PIN);
	//WRITE(Y_DIR_PIN,  0);	SET_OUTPUT(Y_DIR_PIN);
	#ifdef Y_MIN_PIN
		SET_INPUT(Y_MIN_PIN);
    47ac:	a4 e0       	ldi	r26, 0x04	; 4
    47ae:	b1 e0       	ldi	r27, 0x01	; 1
    47b0:	8c 91       	ld	r24, X
    47b2:	8d 7f       	andi	r24, 0xFD	; 253
    47b4:	8c 93       	st	X, r24
		WRITE(Y_MIN_PIN, 0); // pullup resistors off
    47b6:	e5 e0       	ldi	r30, 0x05	; 5
    47b8:	f1 e0       	ldi	r31, 0x01	; 1
    47ba:	80 81       	ld	r24, Z
    47bc:	8d 7f       	andi	r24, 0xFD	; 253
    47be:	80 83       	st	Z, r24
	#endif
	#ifdef Y_MAX_PIN
		SET_INPUT(Y_MAX_PIN);
    47c0:	8c 91       	ld	r24, X
    47c2:	8e 7f       	andi	r24, 0xFE	; 254
    47c4:	8c 93       	st	X, r24
		WRITE(Y_MAX_PIN, 0); // pullup resistors off
    47c6:	80 81       	ld	r24, Z
    47c8:	8e 7f       	andi	r24, 0xFE	; 254
    47ca:	80 83       	st	Z, r24
	#endif

	// Z Stepper
	#if defined Z_STEP_PIN && defined Z_DIR_PIN
		WRITE(Z_STEP_PIN, 0);	SET_OUTPUT(Z_STEP_PIN);
    47cc:	ab e0       	ldi	r26, 0x0B	; 11
    47ce:	b1 e0       	ldi	r27, 0x01	; 1
    47d0:	8c 91       	ld	r24, X
    47d2:	87 7f       	andi	r24, 0xF7	; 247
    47d4:	8c 93       	st	X, r24
    47d6:	ea e0       	ldi	r30, 0x0A	; 10
    47d8:	f1 e0       	ldi	r31, 0x01	; 1
    47da:	80 81       	ld	r24, Z
    47dc:	88 60       	ori	r24, 0x08	; 8
    47de:	80 83       	st	Z, r24
		WRITE(Z_DIR_PIN,  0);	SET_OUTPUT(Z_DIR_PIN);
    47e0:	8c 91       	ld	r24, X
    47e2:	8d 7f       	andi	r24, 0xFD	; 253
    47e4:	8c 93       	st	X, r24
    47e6:	80 81       	ld	r24, Z
    47e8:	82 60       	ori	r24, 0x02	; 2
    47ea:	80 83       	st	Z, r24
	#endif
	#ifdef Z_MIN_PIN
		SET_INPUT(Z_MIN_PIN);
    47ec:	53 98       	cbi	0x0a, 3	; 10
		WRITE(Z_MIN_PIN, 0); // pullup resistors off
    47ee:	5b 98       	cbi	0x0b, 3	; 11
		SET_INPUT(Z_MAX_PIN);
		WRITE(Z_MAX_PIN, 0); // pullup resistors off
	#endif

	#if defined E_STEP_PIN && defined E_DIR_PIN
		WRITE(E_STEP_PIN, 0);	SET_OUTPUT(E_STEP_PIN);
    47f0:	14 98       	cbi	0x02, 4	; 2
    47f2:	0c 9a       	sbi	0x01, 4	; 1
		WRITE(E_DIR_PIN,  0);	SET_OUTPUT(E_DIR_PIN);
    47f4:	16 98       	cbi	0x02, 6	; 2
    47f6:	0e 9a       	sbi	0x01, 6	; 1
    47f8:	08 95       	ret

000047fa <init>:
void init(void) {
	// set up watchdog
	wd_init();

	// set up serial
	serial_init();
    47fa:	29 d0       	rcall	.+82     	; 0x484e <serial_init>

	// set up G-code parsing
	gcode_init();
    47fc:	0e 94 82 16 	call	0x2d04	; 0x2d04 <gcode_init>

	// set up inputs and outputs
	io_init();
    4800:	b8 df       	rcall	.-144    	; 0x4772 <io_init>

	// set up timers
	timer_init();
    4802:	9f d5       	rcall	.+2878   	; 0x5342 <timer_init>

	// read PID settings from EEPROM
	heater_init();
    4804:	f3 d9       	rcall	.-3098   	; 0x3bec <heater_init>

	// set up dda
	dda_init();
    4806:	0e 94 98 06 	call	0xd30	; 0xd30 <dda_init>

	// start up analog read interrupt loop,
	// if any of the temp sensors in your config.h use analog interface
	analog_init();
    480a:	0e 94 fd 04 	call	0x9fa	; 0x9fa <analog_init>

	// set up temperature inputs
	temp_init();
    480e:	24 d3       	rcall	.+1608   	; 0x4e58 <temp_init>

	// enable interrupts
	sei();
    4810:	78 94       	sei

	// reset watchdog
	wd_reset();

	// say hi to host
	serial_writestr_P(PSTR("start\nok\n"));
    4812:	80 e1       	ldi	r24, 0x10	; 16
    4814:	96 e0       	ldi	r25, 0x06	; 6
    4816:	00 c1       	rjmp	.+512    	; 0x4a18 <serial_writestr_P>

00004818 <main>:
/// this is where it all starts, and ends
///
/// just run init(), then run an endless loop where we pass characters from the serial RX buffer to gcode_parse_char() and check the clocks
int main (void)
{
	init();
    4818:	f0 df       	rcall	.-32     	; 0x47fa <init>

	// main loop
	for (;;)
	{
		// if queue is full, no point in reading chars- host will just have to wait
		if ((serial_rxchars() != 0) && (queue_full() == 0)) {
    481a:	a1 d0       	rcall	.+322    	; 0x495e <serial_rxchars>
    481c:	88 23       	and	r24, r24
    481e:	39 f0       	breq	.+14     	; 0x482e <main+0x16>
    4820:	0e 94 67 14 	call	0x28ce	; 0x28ce <queue_full>
    4824:	81 11       	cpse	r24, r1
    4826:	03 c0       	rjmp	.+6      	; 0x482e <main+0x16>
			uint8_t c = serial_popchar();
    4828:	a1 d0       	rcall	.+322    	; 0x496c <serial_popchar>
			gcode_parse_char(c);
    482a:	0e 94 90 16 	call	0x2d20	; 0x2d20 <gcode_parse_char>
		}

		clock();
    482e:	0e 94 62 05 	call	0xac4	; 0xac4 <clock>
		}
    4832:	f3 cf       	rjmp	.-26     	; 0x481a <main+0x2>

00004834 <power_on>:
/// step/psu timeout
volatile uint8_t	psu_timeout = 0;

void power_on() {

	if (ps_is_on == 0) {
    4834:	80 91 c0 04 	lds	r24, 0x04C0
    4838:	81 11       	cpse	r24, r1
    483a:	03 c0       	rjmp	.+6      	; 0x4842 <power_on+0xe>
		#ifdef	PS_ON_PIN
			WRITE(PS_ON_PIN, 0);
			SET_OUTPUT(PS_ON_PIN);
			delay_ms(500);
		#endif
		ps_is_on = 1;
    483c:	81 e0       	ldi	r24, 0x01	; 1
    483e:	80 93 c0 04 	sts	0x04C0, r24
	}

	psu_timeout = 0;
    4842:	10 92 bf 04 	sts	0x04BF, r1
    4846:	08 95       	ret

00004848 <power_off>:

	#ifdef	PS_ON_PIN
		SET_INPUT(PS_ON_PIN);
	#endif

	ps_is_on = 0;
    4848:	10 92 c0 04 	sts	0x04C0, r1
    484c:	08 95       	ret

0000484e <serial_init>:
{
	int i;

	for (i = 0; i < datalen; i++)
		serial_writechar(pgm_read_byte(&data[i]));
}
    484e:	82 e0       	ldi	r24, 0x02	; 2
    4850:	80 93 c0 00 	sts	0x00C0, r24
    4854:	80 e1       	ldi	r24, 0x10	; 16
    4856:	90 e0       	ldi	r25, 0x00	; 0
    4858:	90 93 c5 00 	sts	0x00C5, r25
    485c:	80 93 c4 00 	sts	0x00C4, r24
    4860:	e1 ec       	ldi	r30, 0xC1	; 193
    4862:	f0 e0       	ldi	r31, 0x00	; 0
    4864:	88 e1       	ldi	r24, 0x18	; 24
    4866:	80 83       	st	Z, r24
    4868:	86 e0       	ldi	r24, 0x06	; 6
    486a:	80 93 c2 00 	sts	0x00C2, r24
    486e:	80 81       	ld	r24, Z
    4870:	80 6a       	ori	r24, 0xA0	; 160
    4872:	80 83       	st	Z, r24
    4874:	08 95       	ret

00004876 <__vector_25>:
    4876:	1f 92       	push	r1
    4878:	0f 92       	push	r0
    487a:	0f b6       	in	r0, 0x3f	; 63
    487c:	0f 92       	push	r0
    487e:	11 24       	eor	r1, r1
    4880:	0b b6       	in	r0, 0x3b	; 59
    4882:	0f 92       	push	r0
    4884:	2f 93       	push	r18
    4886:	3f 93       	push	r19
    4888:	8f 93       	push	r24
    488a:	9f 93       	push	r25
    488c:	ef 93       	push	r30
    488e:	ff 93       	push	r31
    4890:	2f b7       	in	r18, 0x3f	; 63
    4892:	80 91 c3 04 	lds	r24, 0x04C3
    4896:	30 91 c4 04 	lds	r19, 0x04C4
    489a:	90 e0       	ldi	r25, 0x00	; 0
    489c:	83 1b       	sub	r24, r19
    489e:	91 09       	sbc	r25, r1
    48a0:	01 97       	sbiw	r24, 0x01	; 1
    48a2:	8f 73       	andi	r24, 0x3F	; 63
    48a4:	99 27       	eor	r25, r25
    48a6:	89 2b       	or	r24, r25
    48a8:	79 f0       	breq	.+30     	; 0x48c8 <__vector_25+0x52>
    48aa:	e0 91 c4 04 	lds	r30, 0x04C4
    48ae:	f0 e0       	ldi	r31, 0x00	; 0
    48b0:	80 91 c6 00 	lds	r24, 0x00C6
    48b4:	ea 5e       	subi	r30, 0xEA	; 234
    48b6:	fa 4f       	sbci	r31, 0xFA	; 250
    48b8:	80 83       	st	Z, r24
    48ba:	80 91 c4 04 	lds	r24, 0x04C4
    48be:	8f 5f       	subi	r24, 0xFF	; 255
    48c0:	8f 73       	andi	r24, 0x3F	; 63
    48c2:	80 93 c4 04 	sts	0x04C4, r24
    48c6:	02 c0       	rjmp	.+4      	; 0x48cc <__vector_25+0x56>
    48c8:	80 91 c6 00 	lds	r24, 0x00C6
    48cc:	2f bf       	out	0x3f, r18	; 63
    48ce:	ff 91       	pop	r31
    48d0:	ef 91       	pop	r30
    48d2:	9f 91       	pop	r25
    48d4:	8f 91       	pop	r24
    48d6:	3f 91       	pop	r19
    48d8:	2f 91       	pop	r18
    48da:	0f 90       	pop	r0
    48dc:	0b be       	out	0x3b, r0	; 59
    48de:	0f 90       	pop	r0
    48e0:	0f be       	out	0x3f, r0	; 63
    48e2:	0f 90       	pop	r0
    48e4:	1f 90       	pop	r1
    48e6:	18 95       	reti

000048e8 <__vector_26>:
    48e8:	1f 92       	push	r1
    48ea:	0f 92       	push	r0
    48ec:	0f b6       	in	r0, 0x3f	; 63
    48ee:	0f 92       	push	r0
    48f0:	11 24       	eor	r1, r1
    48f2:	0b b6       	in	r0, 0x3b	; 59
    48f4:	0f 92       	push	r0
    48f6:	2f 93       	push	r18
    48f8:	3f 93       	push	r19
    48fa:	8f 93       	push	r24
    48fc:	9f 93       	push	r25
    48fe:	ef 93       	push	r30
    4900:	ff 93       	push	r31
    4902:	2f b7       	in	r18, 0x3f	; 63
    4904:	80 91 c2 04 	lds	r24, 0x04C2
    4908:	30 91 c1 04 	lds	r19, 0x04C1
    490c:	90 e0       	ldi	r25, 0x00	; 0
    490e:	83 1b       	sub	r24, r19
    4910:	91 09       	sbc	r25, r1
    4912:	8f 73       	andi	r24, 0x3F	; 63
    4914:	99 27       	eor	r25, r25
    4916:	89 2b       	or	r24, r25
    4918:	79 f0       	breq	.+30     	; 0x4938 <__vector_26+0x50>
    491a:	e0 91 c1 04 	lds	r30, 0x04C1
    491e:	f0 e0       	ldi	r31, 0x00	; 0
    4920:	ea 5a       	subi	r30, 0xAA	; 170
    4922:	fa 4f       	sbci	r31, 0xFA	; 250
    4924:	80 81       	ld	r24, Z
    4926:	80 93 c6 00 	sts	0x00C6, r24
    492a:	80 91 c1 04 	lds	r24, 0x04C1
    492e:	8f 5f       	subi	r24, 0xFF	; 255
    4930:	8f 73       	andi	r24, 0x3F	; 63
    4932:	80 93 c1 04 	sts	0x04C1, r24
    4936:	05 c0       	rjmp	.+10     	; 0x4942 <__vector_26+0x5a>
    4938:	e1 ec       	ldi	r30, 0xC1	; 193
    493a:	f0 e0       	ldi	r31, 0x00	; 0
    493c:	80 81       	ld	r24, Z
    493e:	8f 7d       	andi	r24, 0xDF	; 223
    4940:	80 83       	st	Z, r24
    4942:	2f bf       	out	0x3f, r18	; 63
    4944:	ff 91       	pop	r31
    4946:	ef 91       	pop	r30
    4948:	9f 91       	pop	r25
    494a:	8f 91       	pop	r24
    494c:	3f 91       	pop	r19
    494e:	2f 91       	pop	r18
    4950:	0f 90       	pop	r0
    4952:	0b be       	out	0x3b, r0	; 59
    4954:	0f 90       	pop	r0
    4956:	0f be       	out	0x3f, r0	; 63
    4958:	0f 90       	pop	r0
    495a:	1f 90       	pop	r1
    495c:	18 95       	reti

0000495e <serial_rxchars>:
    495e:	80 91 c4 04 	lds	r24, 0x04C4
    4962:	90 91 c3 04 	lds	r25, 0x04C3
    4966:	89 1b       	sub	r24, r25
    4968:	8f 73       	andi	r24, 0x3F	; 63
    496a:	08 95       	ret

0000496c <serial_popchar>:
    496c:	80 91 c4 04 	lds	r24, 0x04C4
    4970:	20 91 c3 04 	lds	r18, 0x04C3
    4974:	90 e0       	ldi	r25, 0x00	; 0
    4976:	82 1b       	sub	r24, r18
    4978:	91 09       	sbc	r25, r1
    497a:	8f 73       	andi	r24, 0x3F	; 63
    497c:	99 27       	eor	r25, r25
    497e:	89 2b       	or	r24, r25
    4980:	69 f0       	breq	.+26     	; 0x499c <serial_popchar+0x30>
    4982:	e0 91 c3 04 	lds	r30, 0x04C3
    4986:	f0 e0       	ldi	r31, 0x00	; 0
    4988:	ea 5e       	subi	r30, 0xEA	; 234
    498a:	fa 4f       	sbci	r31, 0xFA	; 250
    498c:	80 81       	ld	r24, Z
    498e:	90 91 c3 04 	lds	r25, 0x04C3
    4992:	9f 5f       	subi	r25, 0xFF	; 255
    4994:	9f 73       	andi	r25, 0x3F	; 63
    4996:	90 93 c3 04 	sts	0x04C3, r25
    499a:	08 95       	ret
    499c:	80 e0       	ldi	r24, 0x00	; 0
    499e:	08 95       	ret

000049a0 <serial_writechar>:
    49a0:	0f b6       	in	r0, 0x3f	; 63
    49a2:	07 fe       	sbrs	r0, 7
    49a4:	1a c0       	rjmp	.+52     	; 0x49da <serial_writechar+0x3a>
    49a6:	20 91 c1 04 	lds	r18, 0x04C1
    49aa:	90 91 c2 04 	lds	r25, 0x04C2
    49ae:	30 e0       	ldi	r19, 0x00	; 0
    49b0:	29 1b       	sub	r18, r25
    49b2:	31 09       	sbc	r19, r1
    49b4:	21 50       	subi	r18, 0x01	; 1
    49b6:	31 09       	sbc	r19, r1
    49b8:	2f 73       	andi	r18, 0x3F	; 63
    49ba:	33 27       	eor	r19, r19
    49bc:	23 2b       	or	r18, r19
    49be:	99 f3       	breq	.-26     	; 0x49a6 <serial_writechar+0x6>
    49c0:	e0 91 c2 04 	lds	r30, 0x04C2
    49c4:	f0 e0       	ldi	r31, 0x00	; 0
    49c6:	ea 5a       	subi	r30, 0xAA	; 170
    49c8:	fa 4f       	sbci	r31, 0xFA	; 250
    49ca:	80 83       	st	Z, r24
    49cc:	80 91 c2 04 	lds	r24, 0x04C2
    49d0:	8f 5f       	subi	r24, 0xFF	; 255
    49d2:	8f 73       	andi	r24, 0x3F	; 63
    49d4:	80 93 c2 04 	sts	0x04C2, r24
    49d8:	19 c0       	rjmp	.+50     	; 0x4a0c <serial_writechar+0x6c>
    49da:	20 91 c1 04 	lds	r18, 0x04C1
    49de:	90 91 c2 04 	lds	r25, 0x04C2
    49e2:	30 e0       	ldi	r19, 0x00	; 0
    49e4:	29 1b       	sub	r18, r25
    49e6:	31 09       	sbc	r19, r1
    49e8:	21 50       	subi	r18, 0x01	; 1
    49ea:	31 09       	sbc	r19, r1
    49ec:	2f 73       	andi	r18, 0x3F	; 63
    49ee:	33 27       	eor	r19, r19
    49f0:	23 2b       	or	r18, r19
    49f2:	61 f0       	breq	.+24     	; 0x4a0c <serial_writechar+0x6c>
    49f4:	e0 91 c2 04 	lds	r30, 0x04C2
    49f8:	f0 e0       	ldi	r31, 0x00	; 0
    49fa:	ea 5a       	subi	r30, 0xAA	; 170
    49fc:	fa 4f       	sbci	r31, 0xFA	; 250
    49fe:	80 83       	st	Z, r24
    4a00:	80 91 c2 04 	lds	r24, 0x04C2
    4a04:	8f 5f       	subi	r24, 0xFF	; 255
    4a06:	8f 73       	andi	r24, 0x3F	; 63
    4a08:	80 93 c2 04 	sts	0x04C2, r24
    4a0c:	e1 ec       	ldi	r30, 0xC1	; 193
    4a0e:	f0 e0       	ldi	r31, 0x00	; 0
    4a10:	80 81       	ld	r24, Z
    4a12:	80 62       	ori	r24, 0x20	; 32
    4a14:	80 83       	st	Z, r24
    4a16:	08 95       	ret

00004a18 <serial_writestr_P>:

/// Write string from FLASH
void serial_writestr_P(PGM_P data)
{
    4a18:	1f 93       	push	r17
    4a1a:	cf 93       	push	r28
    4a1c:	df 93       	push	r29
    4a1e:	ec 01       	movw	r28, r24
	uint8_t r, i = 0;
	// yes, this is *supposed* to be assignment rather than comparison, so we break when r is assigned zero
	while ((r = pgm_read_byte(&data[i++])))
    4a20:	fc 01       	movw	r30, r24
    4a22:	84 91       	lpm	r24, Z
    4a24:	88 23       	and	r24, r24
    4a26:	49 f0       	breq	.+18     	; 0x4a3a <serial_writestr_P+0x22>
    4a28:	11 e0       	ldi	r17, 0x01	; 1
		serial_writechar(r);
    4a2a:	ba df       	rcall	.-140    	; 0x49a0 <serial_writechar>
/// Write string from FLASH
void serial_writestr_P(PGM_P data)
{
	uint8_t r, i = 0;
	// yes, this is *supposed* to be assignment rather than comparison, so we break when r is assigned zero
	while ((r = pgm_read_byte(&data[i++])))
    4a2c:	fe 01       	movw	r30, r28
    4a2e:	e1 0f       	add	r30, r17
    4a30:	f1 1d       	adc	r31, r1
    4a32:	1f 5f       	subi	r17, 0xFF	; 255
    4a34:	84 91       	lpm	r24, Z
    4a36:	81 11       	cpse	r24, r1
    4a38:	f8 cf       	rjmp	.-16     	; 0x4a2a <serial_writestr_P+0x12>
		serial_writechar(r);
}
    4a3a:	df 91       	pop	r29
    4a3c:	cf 91       	pop	r28
    4a3e:	1f 91       	pop	r17
    4a40:	08 95       	ret

00004a42 <serwrite_hex4>:

/** write a single hex digit
	\param v hex digit to write, higher nibble ignored
*/
void serwrite_hex4(uint8_t v) {
	v &= 0xF;
    4a42:	8f 70       	andi	r24, 0x0F	; 15
	if (v < 10)
    4a44:	8a 30       	cpi	r24, 0x0A	; 10
    4a46:	10 f4       	brcc	.+4      	; 0x4a4c <serwrite_hex4+0xa>
		serial_writechar('0' + v);
    4a48:	80 5d       	subi	r24, 0xD0	; 208
    4a4a:	aa cf       	rjmp	.-172    	; 0x49a0 <serial_writechar>
	else
		serial_writechar('A' - 10 + v);
    4a4c:	89 5c       	subi	r24, 0xC9	; 201
    4a4e:	a8 cf       	rjmp	.-176    	; 0x49a0 <serial_writechar>

00004a50 <serwrite_hex8>:
}

/** write a pair of hex digits
	\param v byte to write. One byte gives two hex digits
*/
void serwrite_hex8(uint8_t v) {
    4a50:	cf 93       	push	r28
    4a52:	c8 2f       	mov	r28, r24
	serwrite_hex4(v >> 4);
    4a54:	82 95       	swap	r24
    4a56:	8f 70       	andi	r24, 0x0F	; 15
    4a58:	f4 df       	rcall	.-24     	; 0x4a42 <serwrite_hex4>
	serwrite_hex4(v & 0x0F);
    4a5a:	8c 2f       	mov	r24, r28
    4a5c:	8f 70       	andi	r24, 0x0F	; 15
    4a5e:	f1 df       	rcall	.-30     	; 0x4a42 <serwrite_hex4>
}
    4a60:	cf 91       	pop	r28
    4a62:	08 95       	ret

00004a64 <serwrite_hex16>:

/** write four hex digits
	\param v word to write
*/
void serwrite_hex16(uint16_t v) {
    4a64:	cf 93       	push	r28
    4a66:	c8 2f       	mov	r28, r24
	serwrite_hex8(v >> 8);
    4a68:	89 2f       	mov	r24, r25
    4a6a:	f2 df       	rcall	.-28     	; 0x4a50 <serwrite_hex8>
	serwrite_hex8(v & 0xFF);
    4a6c:	8c 2f       	mov	r24, r28
    4a6e:	f0 df       	rcall	.-32     	; 0x4a50 <serwrite_hex8>
}
    4a70:	cf 91       	pop	r28
    4a72:	08 95       	ret

00004a74 <serwrite_hex32>:

/** write eight hex digits
	\param v long word to write
*/
void serwrite_hex32(uint32_t v) {
    4a74:	cf 92       	push	r12
    4a76:	df 92       	push	r13
    4a78:	ef 92       	push	r14
    4a7a:	ff 92       	push	r15
    4a7c:	6b 01       	movw	r12, r22
    4a7e:	7c 01       	movw	r14, r24
	serwrite_hex16(v >> 16);
    4a80:	c7 01       	movw	r24, r14
    4a82:	f0 df       	rcall	.-32     	; 0x4a64 <serwrite_hex16>
	serwrite_hex16(v & 0xFFFF);
    4a84:	c6 01       	movw	r24, r12
    4a86:	ee df       	rcall	.-36     	; 0x4a64 <serwrite_hex16>
}
    4a88:	ff 90       	pop	r15
    4a8a:	ef 90       	pop	r14
    4a8c:	df 90       	pop	r13
    4a8e:	cf 90       	pop	r12
    4a90:	08 95       	ret

00004a92 <serwrite_uint32>:
const uint32_t powers[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};

/** write decimal digits from a long unsigned int
	\param v number to send
*/
void serwrite_uint32(uint32_t v) {
    4a92:	cf 92       	push	r12
    4a94:	df 92       	push	r13
    4a96:	ef 92       	push	r14
    4a98:	ff 92       	push	r15
    4a9a:	cf 93       	push	r28
    4a9c:	df 93       	push	r29
    4a9e:	6b 01       	movw	r12, r22
    4aa0:	7c 01       	movw	r14, r24
	uint8_t e, t;

	for (e = 9; e > 0; e--) {
		if (v >= powers[e])
    4aa2:	c1 14       	cp	r12, r1
    4aa4:	8a ec       	ldi	r24, 0xCA	; 202
    4aa6:	d8 06       	cpc	r13, r24
    4aa8:	8a e9       	ldi	r24, 0x9A	; 154
    4aaa:	e8 06       	cpc	r14, r24
    4aac:	8b e3       	ldi	r24, 0x3B	; 59
    4aae:	f8 06       	cpc	r15, r24
    4ab0:	78 f4       	brcc	.+30     	; 0x4ad0 <serwrite_uint32+0x3e>
    4ab2:	ee e2       	ldi	r30, 0x2E	; 46
    4ab4:	f2 e0       	ldi	r31, 0x02	; 2
	\param v number to send
*/
void serwrite_uint32(uint32_t v) {
	uint8_t e, t;

	for (e = 9; e > 0; e--) {
    4ab6:	c8 e0       	ldi	r28, 0x08	; 8
		if (v >= powers[e])
    4ab8:	b2 91       	ld	r27, -Z
    4aba:	a2 91       	ld	r26, -Z
    4abc:	92 91       	ld	r25, -Z
    4abe:	82 91       	ld	r24, -Z
    4ac0:	c8 16       	cp	r12, r24
    4ac2:	d9 06       	cpc	r13, r25
    4ac4:	ea 06       	cpc	r14, r26
    4ac6:	fb 06       	cpc	r15, r27
    4ac8:	38 f4       	brcc	.+14     	; 0x4ad8 <serwrite_uint32+0x46>
	\param v number to send
*/
void serwrite_uint32(uint32_t v) {
	uint8_t e, t;

	for (e = 9; e > 0; e--) {
    4aca:	c1 50       	subi	r28, 0x01	; 1
    4acc:	a9 f7       	brne	.-22     	; 0x4ab8 <serwrite_uint32+0x26>
    4ace:	04 c0       	rjmp	.+8      	; 0x4ad8 <serwrite_uint32+0x46>
    4ad0:	c9 e0       	ldi	r28, 0x09	; 9
    4ad2:	02 c0       	rjmp	.+4      	; 0x4ad8 <serwrite_uint32+0x46>
	do
	{
		for (t = 0; v >= powers[e]; v -= powers[e], t++);
		serial_writechar(t + '0');
	}
	while (e--);
    4ad4:	c8 2f       	mov	r28, r24
    4ad6:	01 c0       	rjmp	.+2      	; 0x4ada <serwrite_uint32+0x48>
			break;
	}

	do
	{
		for (t = 0; v >= powers[e]; v -= powers[e], t++);
    4ad8:	d0 e0       	ldi	r29, 0x00	; 0
    4ada:	ec 2f       	mov	r30, r28
    4adc:	f0 e0       	ldi	r31, 0x00	; 0
    4ade:	ee 0f       	add	r30, r30
    4ae0:	ff 1f       	adc	r31, r31
    4ae2:	ee 0f       	add	r30, r30
    4ae4:	ff 1f       	adc	r31, r31
    4ae6:	e6 5f       	subi	r30, 0xF6	; 246
    4ae8:	fd 4f       	sbci	r31, 0xFD	; 253
    4aea:	40 81       	ld	r20, Z
    4aec:	51 81       	ldd	r21, Z+1	; 0x01
    4aee:	62 81       	ldd	r22, Z+2	; 0x02
    4af0:	73 81       	ldd	r23, Z+3	; 0x03
    4af2:	c4 16       	cp	r12, r20
    4af4:	d5 06       	cpc	r13, r21
    4af6:	e6 06       	cpc	r14, r22
    4af8:	f7 06       	cpc	r15, r23
    4afa:	60 f0       	brcs	.+24     	; 0x4b14 <serwrite_uint32+0x82>
    4afc:	8d 2f       	mov	r24, r29
const uint32_t powers[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};

/** write decimal digits from a long unsigned int
	\param v number to send
*/
void serwrite_uint32(uint32_t v) {
    4afe:	c4 1a       	sub	r12, r20
    4b00:	d5 0a       	sbc	r13, r21
    4b02:	e6 0a       	sbc	r14, r22
    4b04:	f7 0a       	sbc	r15, r23
			break;
	}

	do
	{
		for (t = 0; v >= powers[e]; v -= powers[e], t++);
    4b06:	8f 5f       	subi	r24, 0xFF	; 255
    4b08:	c4 16       	cp	r12, r20
    4b0a:	d5 06       	cpc	r13, r21
    4b0c:	e6 06       	cpc	r14, r22
    4b0e:	f7 06       	cpc	r15, r23
    4b10:	b0 f7       	brcc	.-20     	; 0x4afe <serwrite_uint32+0x6c>
    4b12:	01 c0       	rjmp	.+2      	; 0x4b16 <serwrite_uint32+0x84>
    4b14:	8d 2f       	mov	r24, r29
		serial_writechar(t + '0');
    4b16:	80 5d       	subi	r24, 0xD0	; 208
    4b18:	43 df       	rcall	.-378    	; 0x49a0 <serial_writechar>
	}
	while (e--);
    4b1a:	8c 2f       	mov	r24, r28
    4b1c:	81 50       	subi	r24, 0x01	; 1
    4b1e:	c1 11       	cpse	r28, r1
    4b20:	d9 cf       	rjmp	.-78     	; 0x4ad4 <serwrite_uint32+0x42>
}
    4b22:	df 91       	pop	r29
    4b24:	cf 91       	pop	r28
    4b26:	ff 90       	pop	r15
    4b28:	ef 90       	pop	r14
    4b2a:	df 90       	pop	r13
    4b2c:	cf 90       	pop	r12
    4b2e:	08 95       	ret

00004b30 <serwrite_int32>:

/** write decimal digits from a long signed int
	\param v number to send
*/
void serwrite_int32(int32_t v) {
    4b30:	cf 92       	push	r12
    4b32:	df 92       	push	r13
    4b34:	ef 92       	push	r14
    4b36:	ff 92       	push	r15
    4b38:	6b 01       	movw	r12, r22
    4b3a:	7c 01       	movw	r14, r24
	if (v < 0) {
    4b3c:	99 23       	and	r25, r25
    4b3e:	54 f4       	brge	.+20     	; 0x4b54 <serwrite_int32+0x24>
		serial_writechar('-');
    4b40:	8d e2       	ldi	r24, 0x2D	; 45
    4b42:	2e df       	rcall	.-420    	; 0x49a0 <serial_writechar>
		v = -v;
    4b44:	f0 94       	com	r15
    4b46:	e0 94       	com	r14
    4b48:	d0 94       	com	r13
    4b4a:	c0 94       	com	r12
    4b4c:	c1 1c       	adc	r12, r1
    4b4e:	d1 1c       	adc	r13, r1
    4b50:	e1 1c       	adc	r14, r1
    4b52:	f1 1c       	adc	r15, r1
	}

	serwrite_uint32(v);
    4b54:	c7 01       	movw	r24, r14
    4b56:	b6 01       	movw	r22, r12
    4b58:	9c df       	rcall	.-200    	; 0x4a92 <serwrite_uint32>
}
    4b5a:	ff 90       	pop	r15
    4b5c:	ef 90       	pop	r14
    4b5e:	df 90       	pop	r13
    4b60:	cf 90       	pop	r12
    4b62:	08 95       	ret

00004b64 <serwrite_uint32_vf>:

/** write decimal digits from a long unsigned int
\param v number to send
*/
void serwrite_uint32_vf(uint32_t v, uint8_t fp) {
    4b64:	bf 92       	push	r11
    4b66:	cf 92       	push	r12
    4b68:	df 92       	push	r13
    4b6a:	ef 92       	push	r14
    4b6c:	ff 92       	push	r15
    4b6e:	0f 93       	push	r16
    4b70:	1f 93       	push	r17
    4b72:	cf 93       	push	r28
    4b74:	df 93       	push	r29
    4b76:	6b 01       	movw	r12, r22
    4b78:	7c 01       	movw	r14, r24
    4b7a:	c4 2f       	mov	r28, r20
	uint8_t e, t;

	for (e = 9; e > 0; e--) {
		if (v >= powers[e])
    4b7c:	c1 14       	cp	r12, r1
    4b7e:	8a ec       	ldi	r24, 0xCA	; 202
    4b80:	d8 06       	cpc	r13, r24
    4b82:	8a e9       	ldi	r24, 0x9A	; 154
    4b84:	e8 06       	cpc	r14, r24
    4b86:	8b e3       	ldi	r24, 0x3B	; 59
    4b88:	f8 06       	cpc	r15, r24
    4b8a:	78 f4       	brcc	.+30     	; 0x4baa <serwrite_uint32_vf+0x46>
    4b8c:	ee e2       	ldi	r30, 0x2E	; 46
    4b8e:	f2 e0       	ldi	r31, 0x02	; 2
\param v number to send
*/
void serwrite_uint32_vf(uint32_t v, uint8_t fp) {
	uint8_t e, t;

	for (e = 9; e > 0; e--) {
    4b90:	d8 e0       	ldi	r29, 0x08	; 8
		if (v >= powers[e])
    4b92:	b2 91       	ld	r27, -Z
    4b94:	a2 91       	ld	r26, -Z
    4b96:	92 91       	ld	r25, -Z
    4b98:	82 91       	ld	r24, -Z
    4b9a:	c8 16       	cp	r12, r24
    4b9c:	d9 06       	cpc	r13, r25
    4b9e:	ea 06       	cpc	r14, r26
    4ba0:	fb 06       	cpc	r15, r27
    4ba2:	20 f4       	brcc	.+8      	; 0x4bac <serwrite_uint32_vf+0x48>
\param v number to send
*/
void serwrite_uint32_vf(uint32_t v, uint8_t fp) {
	uint8_t e, t;

	for (e = 9; e > 0; e--) {
    4ba4:	d1 50       	subi	r29, 0x01	; 1
    4ba6:	a9 f7       	brne	.-22     	; 0x4b92 <serwrite_uint32_vf+0x2e>
    4ba8:	01 c0       	rjmp	.+2      	; 0x4bac <serwrite_uint32_vf+0x48>
    4baa:	d9 e0       	ldi	r29, 0x09	; 9
    4bac:	dc 17       	cp	r29, r28
    4bae:	20 f4       	brcc	.+8      	; 0x4bb8 <serwrite_uint32_vf+0x54>
    4bb0:	dc 2f       	mov	r29, r28
    4bb2:	02 c0       	rjmp	.+4      	; 0x4bb8 <serwrite_uint32_vf+0x54>
		for (t = 0; v >= powers[e]; v -= powers[e], t++);
		serial_writechar(t + '0');
		if (e == fp)
			serial_writechar('.');
	}
	while (e--);
    4bb4:	d8 2f       	mov	r29, r24
    4bb6:	01 c0       	rjmp	.+2      	; 0x4bba <serwrite_uint32_vf+0x56>
	if (e < fp)
		e = fp;

	do
	{
		for (t = 0; v >= powers[e]; v -= powers[e], t++);
    4bb8:	b1 2c       	mov	r11, r1
    4bba:	ed 2f       	mov	r30, r29
    4bbc:	f0 e0       	ldi	r31, 0x00	; 0
    4bbe:	ee 0f       	add	r30, r30
    4bc0:	ff 1f       	adc	r31, r31
    4bc2:	ee 0f       	add	r30, r30
    4bc4:	ff 1f       	adc	r31, r31
    4bc6:	e6 5f       	subi	r30, 0xF6	; 246
    4bc8:	fd 4f       	sbci	r31, 0xFD	; 253
    4bca:	00 81       	ld	r16, Z
    4bcc:	11 81       	ldd	r17, Z+1	; 0x01
    4bce:	22 81       	ldd	r18, Z+2	; 0x02
    4bd0:	33 81       	ldd	r19, Z+3	; 0x03
    4bd2:	c0 16       	cp	r12, r16
    4bd4:	d1 06       	cpc	r13, r17
    4bd6:	e2 06       	cpc	r14, r18
    4bd8:	f3 06       	cpc	r15, r19
    4bda:	60 f0       	brcs	.+24     	; 0x4bf4 <serwrite_uint32_vf+0x90>
    4bdc:	8b 2d       	mov	r24, r11
}

/** write decimal digits from a long unsigned int
\param v number to send
*/
void serwrite_uint32_vf(uint32_t v, uint8_t fp) {
    4bde:	c0 1a       	sub	r12, r16
    4be0:	d1 0a       	sbc	r13, r17
    4be2:	e2 0a       	sbc	r14, r18
    4be4:	f3 0a       	sbc	r15, r19
	if (e < fp)
		e = fp;

	do
	{
		for (t = 0; v >= powers[e]; v -= powers[e], t++);
    4be6:	8f 5f       	subi	r24, 0xFF	; 255
    4be8:	c0 16       	cp	r12, r16
    4bea:	d1 06       	cpc	r13, r17
    4bec:	e2 06       	cpc	r14, r18
    4bee:	f3 06       	cpc	r15, r19
    4bf0:	b0 f7       	brcc	.-20     	; 0x4bde <serwrite_uint32_vf+0x7a>
    4bf2:	01 c0       	rjmp	.+2      	; 0x4bf6 <serwrite_uint32_vf+0x92>
    4bf4:	8b 2d       	mov	r24, r11
		serial_writechar(t + '0');
    4bf6:	80 5d       	subi	r24, 0xD0	; 208
    4bf8:	d3 de       	rcall	.-602    	; 0x49a0 <serial_writechar>
		if (e == fp)
    4bfa:	dc 13       	cpse	r29, r28
    4bfc:	02 c0       	rjmp	.+4      	; 0x4c02 <serwrite_uint32_vf+0x9e>
			serial_writechar('.');
    4bfe:	8e e2       	ldi	r24, 0x2E	; 46
    4c00:	cf de       	rcall	.-610    	; 0x49a0 <serial_writechar>
	}
	while (e--);
    4c02:	8d 2f       	mov	r24, r29
    4c04:	81 50       	subi	r24, 0x01	; 1
    4c06:	d1 11       	cpse	r29, r1
    4c08:	d5 cf       	rjmp	.-86     	; 0x4bb4 <serwrite_uint32_vf+0x50>
}
    4c0a:	df 91       	pop	r29
    4c0c:	cf 91       	pop	r28
    4c0e:	1f 91       	pop	r17
    4c10:	0f 91       	pop	r16
    4c12:	ff 90       	pop	r15
    4c14:	ef 90       	pop	r14
    4c16:	df 90       	pop	r13
    4c18:	cf 90       	pop	r12
    4c1a:	bf 90       	pop	r11
    4c1c:	08 95       	ret

00004c1e <serwrite_int32_vf>:

/** write decimal digits from a long signed int
\param v number to send
*/
void serwrite_int32_vf(int32_t v, uint8_t fp) {
    4c1e:	cf 92       	push	r12
    4c20:	df 92       	push	r13
    4c22:	ef 92       	push	r14
    4c24:	ff 92       	push	r15
    4c26:	cf 93       	push	r28
    4c28:	6b 01       	movw	r12, r22
    4c2a:	7c 01       	movw	r14, r24
    4c2c:	c4 2f       	mov	r28, r20
	if (v < 0) {
    4c2e:	99 23       	and	r25, r25
    4c30:	54 f4       	brge	.+20     	; 0x4c46 <serwrite_int32_vf+0x28>
		serial_writechar('-');
    4c32:	8d e2       	ldi	r24, 0x2D	; 45
    4c34:	b5 de       	rcall	.-662    	; 0x49a0 <serial_writechar>
		v = -v;
    4c36:	f0 94       	com	r15
    4c38:	e0 94       	com	r14
    4c3a:	d0 94       	com	r13
    4c3c:	c0 94       	com	r12
    4c3e:	c1 1c       	adc	r12, r1
    4c40:	d1 1c       	adc	r13, r1
    4c42:	e1 1c       	adc	r14, r1
    4c44:	f1 1c       	adc	r15, r1
	}

	serwrite_uint32_vf(v, fp);
    4c46:	4c 2f       	mov	r20, r28
    4c48:	c7 01       	movw	r24, r14
    4c4a:	b6 01       	movw	r22, r12
    4c4c:	8b df       	rcall	.-234    	; 0x4b64 <serwrite_uint32_vf>
}
    4c4e:	cf 91       	pop	r28
    4c50:	ff 90       	pop	r15
    4c52:	ef 90       	pop	r14
    4c54:	df 90       	pop	r13
    4c56:	cf 90       	pop	r12
    4c58:	08 95       	ret

00004c5a <sersendf_P>:

	Example:

	\code sersendf_P(PSTR("X:%ld Y:%ld temp:%u.%d flags:%sx Q%su/%su%c\n"), target.X, target.Y, current_temp >> 2, (current_temp & 3) * 25, dda.allflags, mb_head, mb_tail, (queue_full()?'F':(queue_empty()?'E':' '))) \endcode
*/
void sersendf_P(PGM_P format, ...) {
    4c5a:	8f 92       	push	r8
    4c5c:	9f 92       	push	r9
    4c5e:	af 92       	push	r10
    4c60:	bf 92       	push	r11
    4c62:	cf 92       	push	r12
    4c64:	df 92       	push	r13
    4c66:	ef 92       	push	r14
    4c68:	ff 92       	push	r15
    4c6a:	0f 93       	push	r16
    4c6c:	1f 93       	push	r17
    4c6e:	cf 93       	push	r28
    4c70:	df 93       	push	r29
    4c72:	cd b7       	in	r28, 0x3d	; 61
    4c74:	de b7       	in	r29, 0x3e	; 62
	va_list args;
	va_start(args, format);
    4c76:	7e 01       	movw	r14, r28
    4c78:	82 e1       	ldi	r24, 0x12	; 18
    4c7a:	e8 0e       	add	r14, r24
    4c7c:	f1 1c       	adc	r15, r1
    4c7e:	08 89       	ldd	r16, Y+16	; 0x10
    4c80:	19 89       	ldd	r17, Y+17	; 0x11

	uint16_t i = 0;
	uint8_t c = 1, j = 0;
    4c82:	d1 2c       	mov	r13, r1
					break;
			}
		}
		else {
			if (c == '%') {
				j = 2;
    4c84:	68 94       	set
    4c86:	aa 24       	eor	r10, r10
    4c88:	a1 f8       	bld	r10, 1
					break;
/*				case 'p':
					serwrite_hex16(va_arg(args, uint16_t));*/
				case 'q':
					serwrite_int32_vf(va_arg(args, int32_t), 3);
					j = 0;
    4c8a:	b1 2c       	mov	r11, r1
	uint8_t c = 1, j = 0;
	while ((c = pgm_read_byte(&format[i++]))) {
		if (j) {
			switch(c) {
				case 's':
					j = 1;
    4c8c:	99 24       	eor	r9, r9
    4c8e:	93 94       	inc	r9
					break;
				case 'l':
					j = 4;
    4c90:	68 94       	set
    4c92:	88 24       	eor	r8, r8
    4c94:	82 f8       	bld	r8, 2
	va_list args;
	va_start(args, format);

	uint16_t i = 0;
	uint8_t c = 1, j = 0;
	while ((c = pgm_read_byte(&format[i++]))) {
    4c96:	a5 c0       	rjmp	.+330    	; 0x4de2 <sersendf_P+0x188>
		if (j) {
    4c98:	dd 20       	and	r13, r13
    4c9a:	09 f4       	brne	.+2      	; 0x4c9e <sersendf_P+0x44>
    4c9c:	99 c0       	rjmp	.+306    	; 0x4dd0 <sersendf_P+0x176>
			switch(c) {
    4c9e:	81 37       	cpi	r24, 0x71	; 113
    4ca0:	09 f4       	brne	.+2      	; 0x4ca4 <sersendf_P+0x4a>
    4ca2:	85 c0       	rjmp	.+266    	; 0x4dae <sersendf_P+0x154>
    4ca4:	48 f4       	brcc	.+18     	; 0x4cb8 <sersendf_P+0x5e>
    4ca6:	84 36       	cpi	r24, 0x64	; 100
    4ca8:	71 f1       	breq	.+92     	; 0x4d06 <sersendf_P+0xac>
    4caa:	8c 36       	cpi	r24, 0x6C	; 108
    4cac:	09 f4       	brne	.+2      	; 0x4cb0 <sersendf_P+0x56>
    4cae:	94 c0       	rjmp	.+296    	; 0x4dd8 <sersendf_P+0x17e>
    4cb0:	83 36       	cpi	r24, 0x63	; 99
    4cb2:	09 f0       	breq	.+2      	; 0x4cb6 <sersendf_P+0x5c>
    4cb4:	8a c0       	rjmp	.+276    	; 0x4dca <sersendf_P+0x170>
    4cb6:	46 c0       	rjmp	.+140    	; 0x4d44 <sersendf_P+0xea>
    4cb8:	85 37       	cpi	r24, 0x75	; 117
    4cba:	41 f0       	breq	.+16     	; 0x4ccc <sersendf_P+0x72>
    4cbc:	88 37       	cpi	r24, 0x78	; 120
    4cbe:	09 f4       	brne	.+2      	; 0x4cc2 <sersendf_P+0x68>
    4cc0:	4b c0       	rjmp	.+150    	; 0x4d58 <sersendf_P+0xfe>
    4cc2:	83 37       	cpi	r24, 0x73	; 115
    4cc4:	09 f0       	breq	.+2      	; 0x4cc8 <sersendf_P+0x6e>
    4cc6:	81 c0       	rjmp	.+258    	; 0x4dca <sersendf_P+0x170>
				case 's':
					j = 1;
    4cc8:	d9 2c       	mov	r13, r9
    4cca:	89 c0       	rjmp	.+274    	; 0x4dde <sersendf_P+0x184>
					break;
				case 'l':
					j = 4;
					break;
				case 'u':
					if (j == 4)
    4ccc:	e4 e0       	ldi	r30, 0x04	; 4
    4cce:	de 12       	cpse	r13, r30
    4cd0:	0d c0       	rjmp	.+26     	; 0x4cec <sersendf_P+0x92>
						serwrite_uint32(va_arg(args, uint32_t));
    4cd2:	67 01       	movw	r12, r14
    4cd4:	f4 e0       	ldi	r31, 0x04	; 4
    4cd6:	cf 0e       	add	r12, r31
    4cd8:	d1 1c       	adc	r13, r1
    4cda:	f7 01       	movw	r30, r14
    4cdc:	60 81       	ld	r22, Z
    4cde:	71 81       	ldd	r23, Z+1	; 0x01
    4ce0:	82 81       	ldd	r24, Z+2	; 0x02
    4ce2:	93 81       	ldd	r25, Z+3	; 0x03
    4ce4:	d6 de       	rcall	.-596    	; 0x4a92 <serwrite_uint32>
    4ce6:	76 01       	movw	r14, r12
					else
						serwrite_uint16(va_arg(args, uint16_t));
					j = 0;
    4ce8:	db 2c       	mov	r13, r11
    4cea:	79 c0       	rjmp	.+242    	; 0x4dde <sersendf_P+0x184>
					break;
				case 'u':
					if (j == 4)
						serwrite_uint32(va_arg(args, uint32_t));
					else
						serwrite_uint16(va_arg(args, uint16_t));
    4cec:	67 01       	movw	r12, r14
    4cee:	f2 e0       	ldi	r31, 0x02	; 2
    4cf0:	cf 0e       	add	r12, r31
    4cf2:	d1 1c       	adc	r13, r1
    4cf4:	f7 01       	movw	r30, r14
    4cf6:	60 81       	ld	r22, Z
    4cf8:	71 81       	ldd	r23, Z+1	; 0x01
    4cfa:	80 e0       	ldi	r24, 0x00	; 0
    4cfc:	90 e0       	ldi	r25, 0x00	; 0
    4cfe:	c9 de       	rcall	.-622    	; 0x4a92 <serwrite_uint32>
    4d00:	76 01       	movw	r14, r12
					j = 0;
    4d02:	db 2c       	mov	r13, r11
    4d04:	6c c0       	rjmp	.+216    	; 0x4dde <sersendf_P+0x184>
					break;
				case 'd':
					if (j == 4)
    4d06:	f4 e0       	ldi	r31, 0x04	; 4
    4d08:	df 12       	cpse	r13, r31
    4d0a:	0d c0       	rjmp	.+26     	; 0x4d26 <sersendf_P+0xcc>
						serwrite_int32(va_arg(args, int32_t));
    4d0c:	67 01       	movw	r12, r14
    4d0e:	84 e0       	ldi	r24, 0x04	; 4
    4d10:	c8 0e       	add	r12, r24
    4d12:	d1 1c       	adc	r13, r1
    4d14:	f7 01       	movw	r30, r14
    4d16:	60 81       	ld	r22, Z
    4d18:	71 81       	ldd	r23, Z+1	; 0x01
    4d1a:	82 81       	ldd	r24, Z+2	; 0x02
    4d1c:	93 81       	ldd	r25, Z+3	; 0x03
    4d1e:	08 df       	rcall	.-496    	; 0x4b30 <serwrite_int32>
    4d20:	76 01       	movw	r14, r12
					else
						serwrite_int16(va_arg(args, int16_t));
					j = 0;
    4d22:	db 2c       	mov	r13, r11
    4d24:	5c c0       	rjmp	.+184    	; 0x4dde <sersendf_P+0x184>
					break;
				case 'd':
					if (j == 4)
						serwrite_int32(va_arg(args, int32_t));
					else
						serwrite_int16(va_arg(args, int16_t));
    4d26:	67 01       	movw	r12, r14
    4d28:	f2 e0       	ldi	r31, 0x02	; 2
    4d2a:	cf 0e       	add	r12, r31
    4d2c:	d1 1c       	adc	r13, r1
    4d2e:	f7 01       	movw	r30, r14
    4d30:	60 81       	ld	r22, Z
    4d32:	71 81       	ldd	r23, Z+1	; 0x01
    4d34:	88 27       	eor	r24, r24
    4d36:	77 fd       	sbrc	r23, 7
    4d38:	80 95       	com	r24
    4d3a:	98 2f       	mov	r25, r24
    4d3c:	f9 de       	rcall	.-526    	; 0x4b30 <serwrite_int32>
    4d3e:	76 01       	movw	r14, r12
					j = 0;
    4d40:	db 2c       	mov	r13, r11
    4d42:	4d c0       	rjmp	.+154    	; 0x4dde <sersendf_P+0x184>
					break;
				case 'c':
					serial_writechar(va_arg(args, uint16_t));
    4d44:	67 01       	movw	r12, r14
    4d46:	f2 e0       	ldi	r31, 0x02	; 2
    4d48:	cf 0e       	add	r12, r31
    4d4a:	d1 1c       	adc	r13, r1
    4d4c:	f7 01       	movw	r30, r14
    4d4e:	80 81       	ld	r24, Z
    4d50:	27 de       	rcall	.-946    	; 0x49a0 <serial_writechar>
    4d52:	76 01       	movw	r14, r12
					j = 0;
    4d54:	db 2c       	mov	r13, r11
					break;
    4d56:	43 c0       	rjmp	.+134    	; 0x4dde <sersendf_P+0x184>
				case 'x':
					serial_writestr_P(PSTR("0x"));
    4d58:	8a e1       	ldi	r24, 0x1A	; 26
    4d5a:	96 e0       	ldi	r25, 0x06	; 6
    4d5c:	5d de       	rcall	.-838    	; 0x4a18 <serial_writestr_P>
					if (j == 4)
    4d5e:	f4 e0       	ldi	r31, 0x04	; 4
    4d60:	df 12       	cpse	r13, r31
    4d62:	0d c0       	rjmp	.+26     	; 0x4d7e <sersendf_P+0x124>
						serwrite_hex32(va_arg(args, uint32_t));
    4d64:	67 01       	movw	r12, r14
    4d66:	84 e0       	ldi	r24, 0x04	; 4
    4d68:	c8 0e       	add	r12, r24
    4d6a:	d1 1c       	adc	r13, r1
    4d6c:	f7 01       	movw	r30, r14
    4d6e:	60 81       	ld	r22, Z
    4d70:	71 81       	ldd	r23, Z+1	; 0x01
    4d72:	82 81       	ldd	r24, Z+2	; 0x02
    4d74:	93 81       	ldd	r25, Z+3	; 0x03
    4d76:	7e de       	rcall	.-772    	; 0x4a74 <serwrite_hex32>
    4d78:	76 01       	movw	r14, r12
					else if (j == 1)
						serwrite_hex8(va_arg(args, uint16_t));
					else
						serwrite_hex16(va_arg(args, uint16_t));
					j = 0;
    4d7a:	db 2c       	mov	r13, r11
    4d7c:	30 c0       	rjmp	.+96     	; 0x4dde <sersendf_P+0x184>
					break;
				case 'x':
					serial_writestr_P(PSTR("0x"));
					if (j == 4)
						serwrite_hex32(va_arg(args, uint32_t));
					else if (j == 1)
    4d7e:	f1 e0       	ldi	r31, 0x01	; 1
    4d80:	df 12       	cpse	r13, r31
    4d82:	0a c0       	rjmp	.+20     	; 0x4d98 <sersendf_P+0x13e>
						serwrite_hex8(va_arg(args, uint16_t));
    4d84:	67 01       	movw	r12, r14
    4d86:	82 e0       	ldi	r24, 0x02	; 2
    4d88:	c8 0e       	add	r12, r24
    4d8a:	d1 1c       	adc	r13, r1
    4d8c:	f7 01       	movw	r30, r14
    4d8e:	80 81       	ld	r24, Z
    4d90:	5f de       	rcall	.-834    	; 0x4a50 <serwrite_hex8>
    4d92:	76 01       	movw	r14, r12
					else
						serwrite_hex16(va_arg(args, uint16_t));
					j = 0;
    4d94:	db 2c       	mov	r13, r11
    4d96:	23 c0       	rjmp	.+70     	; 0x4dde <sersendf_P+0x184>
					if (j == 4)
						serwrite_hex32(va_arg(args, uint32_t));
					else if (j == 1)
						serwrite_hex8(va_arg(args, uint16_t));
					else
						serwrite_hex16(va_arg(args, uint16_t));
    4d98:	67 01       	movw	r12, r14
    4d9a:	f2 e0       	ldi	r31, 0x02	; 2
    4d9c:	cf 0e       	add	r12, r31
    4d9e:	d1 1c       	adc	r13, r1
    4da0:	f7 01       	movw	r30, r14
    4da2:	80 81       	ld	r24, Z
    4da4:	91 81       	ldd	r25, Z+1	; 0x01
    4da6:	5e de       	rcall	.-836    	; 0x4a64 <serwrite_hex16>
    4da8:	76 01       	movw	r14, r12
					j = 0;
    4daa:	db 2c       	mov	r13, r11
    4dac:	18 c0       	rjmp	.+48     	; 0x4dde <sersendf_P+0x184>
					break;
/*				case 'p':
					serwrite_hex16(va_arg(args, uint16_t));*/
				case 'q':
					serwrite_int32_vf(va_arg(args, int32_t), 3);
    4dae:	67 01       	movw	r12, r14
    4db0:	f4 e0       	ldi	r31, 0x04	; 4
    4db2:	cf 0e       	add	r12, r31
    4db4:	d1 1c       	adc	r13, r1
    4db6:	f7 01       	movw	r30, r14
    4db8:	60 81       	ld	r22, Z
    4dba:	71 81       	ldd	r23, Z+1	; 0x01
    4dbc:	82 81       	ldd	r24, Z+2	; 0x02
    4dbe:	93 81       	ldd	r25, Z+3	; 0x03
    4dc0:	43 e0       	ldi	r20, 0x03	; 3
    4dc2:	2d df       	rcall	.-422    	; 0x4c1e <serwrite_int32_vf>
    4dc4:	76 01       	movw	r14, r12
					j = 0;
    4dc6:	db 2c       	mov	r13, r11
					break;
    4dc8:	0a c0       	rjmp	.+20     	; 0x4dde <sersendf_P+0x184>
				default:
					serial_writechar(c);
    4dca:	ea dd       	rcall	.-1068   	; 0x49a0 <serial_writechar>
					j = 0;
    4dcc:	db 2c       	mov	r13, r11
					break;
    4dce:	07 c0       	rjmp	.+14     	; 0x4dde <sersendf_P+0x184>
			}
		}
		else {
			if (c == '%') {
    4dd0:	85 32       	cpi	r24, 0x25	; 37
    4dd2:	21 f0       	breq	.+8      	; 0x4ddc <sersendf_P+0x182>
				j = 2;
			}
			else {
				serial_writechar(c);
    4dd4:	e5 dd       	rcall	.-1078   	; 0x49a0 <serial_writechar>
    4dd6:	03 c0       	rjmp	.+6      	; 0x4dde <sersendf_P+0x184>
			switch(c) {
				case 's':
					j = 1;
					break;
				case 'l':
					j = 4;
    4dd8:	d8 2c       	mov	r13, r8
    4dda:	01 c0       	rjmp	.+2      	; 0x4dde <sersendf_P+0x184>
					break;
			}
		}
		else {
			if (c == '%') {
				j = 2;
    4ddc:	da 2c       	mov	r13, r10
    4dde:	0f 5f       	subi	r16, 0xFF	; 255
    4de0:	1f 4f       	sbci	r17, 0xFF	; 255
	va_list args;
	va_start(args, format);

	uint16_t i = 0;
	uint8_t c = 1, j = 0;
	while ((c = pgm_read_byte(&format[i++]))) {
    4de2:	f8 01       	movw	r30, r16
    4de4:	84 91       	lpm	r24, Z
    4de6:	81 11       	cpse	r24, r1
    4de8:	57 cf       	rjmp	.-338    	; 0x4c98 <sersendf_P+0x3e>
				serial_writechar(c);
			}
		}
	}
	va_end(args);
}
    4dea:	df 91       	pop	r29
    4dec:	cf 91       	pop	r28
    4dee:	1f 91       	pop	r17
    4df0:	0f 91       	pop	r16
    4df2:	ff 90       	pop	r15
    4df4:	ef 90       	pop	r14
    4df6:	df 90       	pop	r13
    4df8:	cf 90       	pop	r12
    4dfa:	bf 90       	pop	r11
    4dfc:	af 90       	pop	r10
    4dfe:	9f 90       	pop	r9
    4e00:	8f 90       	pop	r8
    4e02:	08 95       	ret

00004e04 <single_temp_print>:
uint16_t temp_get(temp_sensor_t index) {
	if (index >= NUM_TEMP_SENSORS)
		return 0;

	return temp_sensors_runtime[index].last_read_temp;
}
    4e04:	90 e0       	ldi	r25, 0x00	; 0
    4e06:	fc 01       	movw	r30, r24
    4e08:	ee 0f       	add	r30, r30
    4e0a:	ff 1f       	adc	r31, r31
    4e0c:	ee 0f       	add	r30, r30
    4e0e:	ff 1f       	adc	r31, r31
    4e10:	ee 0f       	add	r30, r30
    4e12:	ff 1f       	adc	r31, r31
    4e14:	8e 0f       	add	r24, r30
    4e16:	9f 1f       	adc	r25, r31
    4e18:	fc 01       	movw	r30, r24
    4e1a:	ea 56       	subi	r30, 0x6A	; 106
    4e1c:	fa 4f       	sbci	r31, 0xFA	; 250
    4e1e:	81 81       	ldd	r24, Z+1	; 0x01
    4e20:	92 81       	ldd	r25, Z+2	; 0x02
    4e22:	9c 01       	movw	r18, r24
    4e24:	23 70       	andi	r18, 0x03	; 3
    4e26:	33 27       	eor	r19, r19
    4e28:	39 e1       	ldi	r19, 0x19	; 25
    4e2a:	23 9f       	mul	r18, r19
    4e2c:	20 2d       	mov	r18, r0
    4e2e:	11 24       	eor	r1, r1
    4e30:	1f 92       	push	r1
    4e32:	2f 93       	push	r18
    4e34:	96 95       	lsr	r25
    4e36:	87 95       	ror	r24
    4e38:	96 95       	lsr	r25
    4e3a:	87 95       	ror	r24
    4e3c:	9f 93       	push	r25
    4e3e:	8f 93       	push	r24
    4e40:	8f ea       	ldi	r24, 0xAF	; 175
    4e42:	99 e0       	ldi	r25, 0x09	; 9
    4e44:	9f 93       	push	r25
    4e46:	8f 93       	push	r24
    4e48:	08 df       	rcall	.-496    	; 0x4c5a <sersendf_P>
    4e4a:	0f 90       	pop	r0
    4e4c:	0f 90       	pop	r0
    4e4e:	0f 90       	pop	r0
    4e50:	0f 90       	pop	r0
    4e52:	0f 90       	pop	r0
    4e54:	0f 90       	pop	r0
    4e56:	08 95       	ret

00004e58 <temp_init>:
    4e58:	08 95       	ret

00004e5a <temp_sensor_tick>:
    4e5a:	4f 92       	push	r4
    4e5c:	5f 92       	push	r5
    4e5e:	6f 92       	push	r6
    4e60:	7f 92       	push	r7
    4e62:	9f 92       	push	r9
    4e64:	af 92       	push	r10
    4e66:	bf 92       	push	r11
    4e68:	cf 92       	push	r12
    4e6a:	df 92       	push	r13
    4e6c:	ef 92       	push	r14
    4e6e:	ff 92       	push	r15
    4e70:	0f 93       	push	r16
    4e72:	1f 93       	push	r17
    4e74:	cf 93       	push	r28
    4e76:	df 93       	push	r29
    4e78:	80 91 9d 05 	lds	r24, 0x059D
    4e7c:	90 91 9e 05 	lds	r25, 0x059E
    4e80:	00 97       	sbiw	r24, 0x00	; 0
    4e82:	31 f0       	breq	.+12     	; 0x4e90 <temp_sensor_tick+0x36>
    4e84:	01 97       	sbiw	r24, 0x01	; 1
    4e86:	90 93 9e 05 	sts	0x059E, r25
    4e8a:	80 93 9d 05 	sts	0x059D, r24
    4e8e:	d7 c0       	rjmp	.+430    	; 0x503e <temp_sensor_tick+0x1e4>
    4e90:	80 e0       	ldi	r24, 0x00	; 0
    4e92:	0e 94 54 05 	call	0xaa8	; 0xaa8 <analog_read>
    4e96:	6c 01       	movw	r12, r24
    4e98:	c1 e2       	ldi	r28, 0x21	; 33
    4e9a:	d6 e0       	ldi	r29, 0x06	; 6
    4e9c:	fe 01       	movw	r30, r28
    4e9e:	85 91       	lpm	r24, Z+
    4ea0:	94 91       	lpm	r25, Z
    4ea2:	c8 16       	cp	r12, r24
    4ea4:	d9 06       	cpc	r13, r25
    4ea6:	98 f0       	brcs	.+38     	; 0x4ece <temp_sensor_tick+0x74>
    4ea8:	82 e0       	ldi	r24, 0x02	; 2
    4eaa:	90 e0       	ldi	r25, 0x00	; 0
    4eac:	98 2e       	mov	r9, r24
    4eae:	8c 01       	movw	r16, r24
    4eb0:	ec 01       	movw	r28, r24
    4eb2:	cc 0f       	add	r28, r28
    4eb4:	dd 1f       	adc	r29, r29
    4eb6:	cc 0f       	add	r28, r28
    4eb8:	dd 1f       	adc	r29, r29
    4eba:	c3 5e       	subi	r28, 0xE3	; 227
    4ebc:	d9 4f       	sbci	r29, 0xF9	; 249
    4ebe:	fe 01       	movw	r30, r28
    4ec0:	25 91       	lpm	r18, Z+
    4ec2:	34 91       	lpm	r19, Z
    4ec4:	c2 16       	cp	r12, r18
    4ec6:	d3 06       	cpc	r13, r19
    4ec8:	08 f0       	brcs	.+2      	; 0x4ecc <temp_sensor_tick+0x72>
    4eca:	7f c0       	rjmp	.+254    	; 0x4fca <temp_sensor_tick+0x170>
    4ecc:	04 c0       	rjmp	.+8      	; 0x4ed6 <temp_sensor_tick+0x7c>
    4ece:	01 e0       	ldi	r16, 0x01	; 1
    4ed0:	10 e0       	ldi	r17, 0x00	; 0
    4ed2:	99 24       	eor	r9, r9
    4ed4:	93 94       	inc	r9
    4ed6:	80 91 cf 04 	lds	r24, 0x04CF
    4eda:	80 ff       	sbrs	r24, 0
    4edc:	14 c0       	rjmp	.+40     	; 0x4f06 <temp_sensor_tick+0xac>
    4ede:	1f 93       	push	r17
    4ee0:	0f 93       	push	r16
    4ee2:	df 92       	push	r13
    4ee4:	cf 92       	push	r12
    4ee6:	1f 92       	push	r1
    4ee8:	8d e0       	ldi	r24, 0x0D	; 13
    4eea:	8f 93       	push	r24
    4eec:	8d e4       	ldi	r24, 0x4D	; 77
    4eee:	99 e0       	ldi	r25, 0x09	; 9
    4ef0:	9f 93       	push	r25
    4ef2:	8f 93       	push	r24
    4ef4:	b2 de       	rcall	.-668    	; 0x4c5a <sersendf_P>
    4ef6:	8d b7       	in	r24, 0x3d	; 61
    4ef8:	9e b7       	in	r25, 0x3e	; 62
    4efa:	08 96       	adiw	r24, 0x08	; 8
    4efc:	0f b6       	in	r0, 0x3f	; 63
    4efe:	f8 94       	cli
    4f00:	9e bf       	out	0x3e, r25	; 62
    4f02:	0f be       	out	0x3f, r0	; 63
    4f04:	8d bf       	out	0x3d, r24	; 61
    4f06:	e1 2c       	mov	r14, r1
    4f08:	f1 2c       	mov	r15, r1
    4f0a:	c8 01       	movw	r24, r16
    4f0c:	01 97       	sbiw	r24, 0x01	; 1
    4f0e:	88 0f       	add	r24, r24
    4f10:	99 1f       	adc	r25, r25
    4f12:	88 0f       	add	r24, r24
    4f14:	99 1f       	adc	r25, r25
    4f16:	fc 01       	movw	r30, r24
    4f18:	e3 5e       	subi	r30, 0xE3	; 227
    4f1a:	f9 4f       	sbci	r31, 0xF9	; 249
    4f1c:	a5 90       	lpm	r10, Z+
    4f1e:	b4 90       	lpm	r11, Z
    4f20:	f8 01       	movw	r30, r16
    4f22:	ee 0f       	add	r30, r30
    4f24:	ff 1f       	adc	r31, r31
    4f26:	ee 0f       	add	r30, r30
    4f28:	ff 1f       	adc	r31, r31
    4f2a:	e1 5e       	subi	r30, 0xE1	; 225
    4f2c:	f9 4f       	sbci	r31, 0xF9	; 249
    4f2e:	a5 91       	lpm	r26, Z+
    4f30:	b4 91       	lpm	r27, Z
    4f32:	fe 01       	movw	r30, r28
    4f34:	05 91       	lpm	r16, Z+
    4f36:	14 91       	lpm	r17, Z
    4f38:	fc 01       	movw	r30, r24
    4f3a:	e1 5e       	subi	r30, 0xE1	; 225
    4f3c:	f9 4f       	sbci	r31, 0xF9	; 249
    4f3e:	c5 91       	lpm	r28, Z+
    4f40:	d4 91       	lpm	r29, Z
    4f42:	a7 01       	movw	r20, r14
    4f44:	96 01       	movw	r18, r12
    4f46:	2a 19       	sub	r18, r10
    4f48:	3b 09       	sbc	r19, r11
    4f4a:	41 09       	sbc	r20, r1
    4f4c:	51 09       	sbc	r21, r1
    4f4e:	c6 d2       	rcall	.+1420   	; 0x54dc <__muluhisi3>
    4f50:	2b 01       	movw	r4, r22
    4f52:	3c 01       	movw	r6, r24
    4f54:	c8 01       	movw	r24, r16
    4f56:	a0 e0       	ldi	r26, 0x00	; 0
    4f58:	b0 e0       	ldi	r27, 0x00	; 0
    4f5a:	9c 01       	movw	r18, r24
    4f5c:	ad 01       	movw	r20, r26
    4f5e:	2c 19       	sub	r18, r12
    4f60:	3d 09       	sbc	r19, r13
    4f62:	4e 09       	sbc	r20, r14
    4f64:	5f 09       	sbc	r21, r15
    4f66:	de 01       	movw	r26, r28
    4f68:	b9 d2       	rcall	.+1394   	; 0x54dc <__muluhisi3>
    4f6a:	64 0d       	add	r22, r4
    4f6c:	75 1d       	adc	r23, r5
    4f6e:	86 1d       	adc	r24, r6
    4f70:	97 1d       	adc	r25, r7
    4f72:	98 01       	movw	r18, r16
    4f74:	2a 19       	sub	r18, r10
    4f76:	3b 09       	sbc	r19, r11
    4f78:	40 e0       	ldi	r20, 0x00	; 0
    4f7a:	50 e0       	ldi	r21, 0x00	; 0
    4f7c:	60 d2       	rcall	.+1216   	; 0x543e <__udivmodsi4>
    4f7e:	69 01       	movw	r12, r18
    4f80:	80 91 cf 04 	lds	r24, 0x04CF
    4f84:	80 ff       	sbrs	r24, 0
    4f86:	27 c0       	rjmp	.+78     	; 0x4fd6 <temp_sensor_tick+0x17c>
    4f88:	89 01       	movw	r16, r18
    4f8a:	9a 01       	movw	r18, r20
    4f8c:	03 70       	andi	r16, 0x03	; 3
    4f8e:	11 27       	eor	r17, r17
    4f90:	22 27       	eor	r18, r18
    4f92:	33 27       	eor	r19, r19
    4f94:	69 e1       	ldi	r22, 0x19	; 25
    4f96:	60 9f       	mul	r22, r16
    4f98:	c0 01       	movw	r24, r0
    4f9a:	61 9f       	mul	r22, r17
    4f9c:	90 0d       	add	r25, r0
    4f9e:	11 24       	eor	r1, r1
    4fa0:	9f 93       	push	r25
    4fa2:	8f 93       	push	r24
    4fa4:	c6 01       	movw	r24, r12
    4fa6:	96 95       	lsr	r25
    4fa8:	87 95       	ror	r24
    4faa:	96 95       	lsr	r25
    4fac:	87 95       	ror	r24
    4fae:	9f 93       	push	r25
    4fb0:	8f 93       	push	r24
    4fb2:	8f e6       	ldi	r24, 0x6F	; 111
    4fb4:	99 e0       	ldi	r25, 0x09	; 9
    4fb6:	9f 93       	push	r25
    4fb8:	8f 93       	push	r24
    4fba:	4f de       	rcall	.-866    	; 0x4c5a <sersendf_P>
    4fbc:	0f 90       	pop	r0
    4fbe:	0f 90       	pop	r0
    4fc0:	0f 90       	pop	r0
    4fc2:	0f 90       	pop	r0
    4fc4:	0f 90       	pop	r0
    4fc6:	0f 90       	pop	r0
    4fc8:	06 c0       	rjmp	.+12     	; 0x4fd6 <temp_sensor_tick+0x17c>
    4fca:	93 94       	inc	r9
    4fcc:	01 96       	adiw	r24, 0x01	; 1
    4fce:	86 36       	cpi	r24, 0x66	; 102
    4fd0:	91 05       	cpc	r25, r1
    4fd2:	09 f0       	breq	.+2      	; 0x4fd6 <temp_sensor_tick+0x17c>
    4fd4:	6b cf       	rjmp	.-298    	; 0x4eac <temp_sensor_tick+0x52>
    4fd6:	80 91 cf 04 	lds	r24, 0x04CF
    4fda:	80 ff       	sbrs	r24, 0
    4fdc:	0b c0       	rjmp	.+22     	; 0x4ff4 <temp_sensor_tick+0x19a>
    4fde:	1f 92       	push	r1
    4fe0:	1f 92       	push	r1
    4fe2:	8b e7       	ldi	r24, 0x7B	; 123
    4fe4:	99 e0       	ldi	r25, 0x09	; 9
    4fe6:	9f 93       	push	r25
    4fe8:	8f 93       	push	r24
    4fea:	37 de       	rcall	.-914    	; 0x4c5a <sersendf_P>
    4fec:	0f 90       	pop	r0
    4fee:	0f 90       	pop	r0
    4ff0:	0f 90       	pop	r0
    4ff2:	0f 90       	pop	r0
    4ff4:	96 e6       	ldi	r25, 0x66	; 102
    4ff6:	99 12       	cpse	r9, r25
    4ff8:	02 c0       	rjmp	.+4      	; 0x4ffe <temp_sensor_tick+0x1a4>
    4ffa:	c1 2c       	mov	r12, r1
    4ffc:	d1 2c       	mov	r13, r1
    4ffe:	10 92 9e 05 	sts	0x059E, r1
    5002:	10 92 9d 05 	sts	0x059D, r1
    5006:	e7 e9       	ldi	r30, 0x97	; 151
    5008:	f5 e0       	ldi	r31, 0x05	; 5
    500a:	96 01       	movw	r18, r12
    500c:	a6 e6       	ldi	r26, 0x66	; 102
    500e:	b0 e0       	ldi	r27, 0x00	; 0
    5010:	59 d2       	rcall	.+1202   	; 0x54c4 <__umulhisi3>
    5012:	6b 01       	movw	r12, r22
    5014:	7c 01       	movw	r14, r24
    5016:	20 81       	ld	r18, Z
    5018:	31 81       	ldd	r19, Z+1	; 0x01
    501a:	aa e9       	ldi	r26, 0x9A	; 154
    501c:	b3 e0       	ldi	r27, 0x03	; 3
    501e:	52 d2       	rcall	.+1188   	; 0x54c4 <__umulhisi3>
    5020:	c6 0e       	add	r12, r22
    5022:	d7 1e       	adc	r13, r23
    5024:	e8 1e       	adc	r14, r24
    5026:	f9 1e       	adc	r15, r25
    5028:	0b 2e       	mov	r0, r27
    502a:	ba e0       	ldi	r27, 0x0A	; 10
    502c:	f5 94       	asr	r15
    502e:	e7 94       	ror	r14
    5030:	d7 94       	ror	r13
    5032:	c7 94       	ror	r12
    5034:	ba 95       	dec	r27
    5036:	d1 f7       	brne	.-12     	; 0x502c <temp_sensor_tick+0x1d2>
    5038:	b0 2d       	mov	r27, r0
    503a:	d1 82       	std	Z+1, r13	; 0x01
    503c:	c0 82       	st	Z, r12
    503e:	80 91 97 05 	lds	r24, 0x0597
    5042:	90 91 98 05 	lds	r25, 0x0598
    5046:	20 91 99 05 	lds	r18, 0x0599
    504a:	30 91 9a 05 	lds	r19, 0x059A
    504e:	82 1b       	sub	r24, r18
    5050:	93 0b       	sbc	r25, r19
    5052:	8d 3e       	cpi	r24, 0xED	; 237
    5054:	2f ef       	ldi	r18, 0xFF	; 255
    5056:	92 07       	cpc	r25, r18
    5058:	84 f0       	brlt	.+32     	; 0x507a <temp_sensor_tick+0x220>
    505a:	44 97       	sbiw	r24, 0x14	; 20
    505c:	74 f4       	brge	.+28     	; 0x507a <temp_sensor_tick+0x220>
    505e:	80 91 9b 05 	lds	r24, 0x059B
    5062:	90 91 9c 05 	lds	r25, 0x059C
    5066:	80 32       	cpi	r24, 0x20	; 32
    5068:	2c e1       	ldi	r18, 0x1C	; 28
    506a:	92 07       	cpc	r25, r18
    506c:	b8 f4       	brcc	.+46     	; 0x509c <temp_sensor_tick+0x242>
    506e:	01 96       	adiw	r24, 0x01	; 1
    5070:	90 93 9c 05 	sts	0x059C, r25
    5074:	80 93 9b 05 	sts	0x059B, r24
    5078:	11 c0       	rjmp	.+34     	; 0x509c <temp_sensor_tick+0x242>
    507a:	80 91 9b 05 	lds	r24, 0x059B
    507e:	90 91 9c 05 	lds	r25, 0x059C
    5082:	8b 30       	cpi	r24, 0x0B	; 11
    5084:	91 05       	cpc	r25, r1
    5086:	30 f0       	brcs	.+12     	; 0x5094 <temp_sensor_tick+0x23a>
    5088:	0a 97       	sbiw	r24, 0x0a	; 10
    508a:	90 93 9c 05 	sts	0x059C, r25
    508e:	80 93 9b 05 	sts	0x059B, r24
    5092:	04 c0       	rjmp	.+8      	; 0x509c <temp_sensor_tick+0x242>
    5094:	10 92 9c 05 	sts	0x059C, r1
    5098:	10 92 9b 05 	sts	0x059B, r1
    509c:	20 91 99 05 	lds	r18, 0x0599
    50a0:	30 91 9a 05 	lds	r19, 0x059A
    50a4:	40 91 97 05 	lds	r20, 0x0597
    50a8:	50 91 98 05 	lds	r21, 0x0598
    50ac:	60 e0       	ldi	r22, 0x00	; 0
    50ae:	80 e0       	ldi	r24, 0x00	; 0
    50b0:	0e 94 ba 1f 	call	0x3f74	; 0x3f74 <heater_tick>
    50b4:	80 91 cf 04 	lds	r24, 0x04CF
    50b8:	80 ff       	sbrs	r24, 0
    50ba:	27 c0       	rjmp	.+78     	; 0x510a <temp_sensor_tick+0x2b0>
    50bc:	80 91 97 05 	lds	r24, 0x0597
    50c0:	90 91 98 05 	lds	r25, 0x0598
    50c4:	ac 01       	movw	r20, r24
    50c6:	43 70       	andi	r20, 0x03	; 3
    50c8:	55 27       	eor	r21, r21
    50ca:	69 e1       	ldi	r22, 0x19	; 25
    50cc:	64 9f       	mul	r22, r20
    50ce:	90 01       	movw	r18, r0
    50d0:	65 9f       	mul	r22, r21
    50d2:	30 0d       	add	r19, r0
    50d4:	11 24       	eor	r1, r1
    50d6:	3f 93       	push	r19
    50d8:	2f 93       	push	r18
    50da:	9c 01       	movw	r18, r24
    50dc:	36 95       	lsr	r19
    50de:	27 95       	ror	r18
    50e0:	36 95       	lsr	r19
    50e2:	27 95       	ror	r18
    50e4:	3f 93       	push	r19
    50e6:	2f 93       	push	r18
    50e8:	9f 93       	push	r25
    50ea:	8f 93       	push	r24
    50ec:	1f 92       	push	r1
    50ee:	1f 92       	push	r1
    50f0:	87 e8       	ldi	r24, 0x87	; 135
    50f2:	99 e0       	ldi	r25, 0x09	; 9
    50f4:	9f 93       	push	r25
    50f6:	8f 93       	push	r24
    50f8:	b0 dd       	rcall	.-1184   	; 0x4c5a <sersendf_P>
    50fa:	8d b7       	in	r24, 0x3d	; 61
    50fc:	9e b7       	in	r25, 0x3e	; 62
    50fe:	0a 96       	adiw	r24, 0x0a	; 10
    5100:	0f b6       	in	r0, 0x3f	; 63
    5102:	f8 94       	cli
    5104:	9e bf       	out	0x3e, r25	; 62
    5106:	0f be       	out	0x3f, r0	; 63
    5108:	8d bf       	out	0x3d, r24	; 61
    510a:	80 91 cf 04 	lds	r24, 0x04CF
    510e:	80 ff       	sbrs	r24, 0
    5110:	07 c0       	rjmp	.+14     	; 0x5120 <temp_sensor_tick+0x2c6>
    5112:	8e e9       	ldi	r24, 0x9E	; 158
    5114:	99 e0       	ldi	r25, 0x09	; 9
    5116:	9f 93       	push	r25
    5118:	8f 93       	push	r24
    511a:	9f dd       	rcall	.-1218   	; 0x4c5a <sersendf_P>
    511c:	0f 90       	pop	r0
    511e:	0f 90       	pop	r0
    5120:	df 91       	pop	r29
    5122:	cf 91       	pop	r28
    5124:	1f 91       	pop	r17
    5126:	0f 91       	pop	r16
    5128:	ff 90       	pop	r15
    512a:	ef 90       	pop	r14
    512c:	df 90       	pop	r13
    512e:	cf 90       	pop	r12
    5130:	bf 90       	pop	r11
    5132:	af 90       	pop	r10
    5134:	9f 90       	pop	r9
    5136:	7f 90       	pop	r7
    5138:	6f 90       	pop	r6
    513a:	5f 90       	pop	r5
    513c:	4f 90       	pop	r4
    513e:	08 95       	ret

00005140 <temp_achieved>:
    5140:	80 91 9b 05 	lds	r24, 0x059B
    5144:	90 91 9c 05 	lds	r25, 0x059C
    5148:	80 37       	cpi	r24, 0x70	; 112
    514a:	97 41       	sbci	r25, 0x17	; 23
    514c:	10 f0       	brcs	.+4      	; 0x5152 <temp_achieved+0x12>
    514e:	8f ef       	ldi	r24, 0xFF	; 255
    5150:	08 95       	ret
    5152:	80 e0       	ldi	r24, 0x00	; 0
    5154:	08 95       	ret

00005156 <temp_set>:
    5156:	81 11       	cpse	r24, r1
    5158:	0f c0       	rjmp	.+30     	; 0x5178 <temp_set+0x22>
    515a:	80 91 99 05 	lds	r24, 0x0599
    515e:	90 91 9a 05 	lds	r25, 0x059A
    5162:	86 17       	cp	r24, r22
    5164:	97 07       	cpc	r25, r23
    5166:	41 f0       	breq	.+16     	; 0x5178 <temp_set+0x22>
    5168:	70 93 9a 05 	sts	0x059A, r23
    516c:	60 93 99 05 	sts	0x0599, r22
    5170:	10 92 9c 05 	sts	0x059C, r1
    5174:	10 92 9b 05 	sts	0x059B, r1
    5178:	08 95       	ret

0000517a <temp_print>:

/// send temperatures to host
/// \param index sensor value to send
void temp_print(temp_sensor_t index) {

	if (index == TEMP_SENSOR_none) { // standard behaviour
    517a:	82 30       	cpi	r24, 0x02	; 2
    517c:	99 f4       	brne	.+38     	; 0x51a4 <temp_print+0x2a>
		#ifdef HEATER_EXTRUDER
			sersendf_P(PSTR("T:"));
    517e:	80 ea       	ldi	r24, 0xA0	; 160
    5180:	99 e0       	ldi	r25, 0x09	; 9
    5182:	9f 93       	push	r25
    5184:	8f 93       	push	r24
    5186:	69 dd       	rcall	.-1326   	; 0x4c5a <sersendf_P>
			single_temp_print(HEATER_EXTRUDER);
    5188:	80 e0       	ldi	r24, 0x00	; 0
    518a:	3c de       	rcall	.-904    	; 0x4e04 <single_temp_print>
		#endif
		#ifdef HEATER_BED
			sersendf_P(PSTR(" B:"));
    518c:	83 ea       	ldi	r24, 0xA3	; 163
    518e:	99 e0       	ldi	r25, 0x09	; 9
    5190:	9f 93       	push	r25
    5192:	8f 93       	push	r24
    5194:	62 dd       	rcall	.-1340   	; 0x4c5a <sersendf_P>
			single_temp_print(HEATER_BED);
    5196:	81 e0       	ldi	r24, 0x01	; 1
    5198:	35 de       	rcall	.-918    	; 0x4e04 <single_temp_print>
    519a:	0f 90       	pop	r0
    519c:	0f 90       	pop	r0
    519e:	0f 90       	pop	r0
    51a0:	0f 90       	pop	r0
    51a2:	08 95       	ret
		#endif
	}
	else {
		if (index >= NUM_TEMP_SENSORS)
    51a4:	81 11       	cpse	r24, r1
    51a6:	0d c0       	rjmp	.+26     	; 0x51c2 <temp_print+0x48>
			return;
		sersendf_P(PSTR("T[%su]:"), index);
    51a8:	1f 92       	push	r1
    51aa:	1f 92       	push	r1
    51ac:	87 ea       	ldi	r24, 0xA7	; 167
    51ae:	99 e0       	ldi	r25, 0x09	; 9
    51b0:	9f 93       	push	r25
    51b2:	8f 93       	push	r24
    51b4:	52 dd       	rcall	.-1372   	; 0x4c5a <sersendf_P>
		single_temp_print(index);
    51b6:	80 e0       	ldi	r24, 0x00	; 0
    51b8:	25 de       	rcall	.-950    	; 0x4e04 <single_temp_print>
    51ba:	0f 90       	pop	r0
    51bc:	0f 90       	pop	r0
    51be:	0f 90       	pop	r0
    51c0:	0f 90       	pop	r0
    51c2:	08 95       	ret

000051c4 <__vector_43>:
volatile uint8_t	clock_flag_10ms = 0;
volatile uint8_t	clock_flag_250ms = 0;
volatile uint8_t	clock_flag_1s = 0;

/// comparator B is the system clock, happens every TICK_TIME
ISR(TIMER4_COMPB_vect) {
    51c4:	1f 92       	push	r1
    51c6:	0f 92       	push	r0
    51c8:	0f b6       	in	r0, 0x3f	; 63
    51ca:	0f 92       	push	r0
    51cc:	11 24       	eor	r1, r1
    51ce:	0b b6       	in	r0, 0x3b	; 59
    51d0:	0f 92       	push	r0
    51d2:	2f 93       	push	r18
    51d4:	8f 93       	push	r24
    51d6:	9f 93       	push	r25
    51d8:	ef 93       	push	r30
    51da:	ff 93       	push	r31
	// save status register
	uint8_t sreg_save = SREG;
    51dc:	2f b7       	in	r18, 0x3f	; 63

	// set output compare register to the next clock tick
	OCR4B = (OCR4B + TICK_TIME) & 0xFFFF;
    51de:	ea ea       	ldi	r30, 0xAA	; 170
    51e0:	f0 e0       	ldi	r31, 0x00	; 0
    51e2:	80 81       	ld	r24, Z
    51e4:	91 81       	ldd	r25, Z+1	; 0x01
    51e6:	93 58       	subi	r25, 0x83	; 131
    51e8:	91 83       	std	Z+1, r25	; 0x01
    51ea:	80 83       	st	Z, r24

	/*
	clock stuff
	*/
	clock_counter_10ms += TICK_TIME_MS;
    51ec:	80 91 ca 04 	lds	r24, 0x04CA
    51f0:	98 2f       	mov	r25, r24
    51f2:	9e 5f       	subi	r25, 0xFE	; 254
	if (clock_counter_10ms >= 10) {
    51f4:	9a 30       	cpi	r25, 0x0A	; 10
    51f6:	18 f4       	brcc	.+6      	; 0x51fe <__vector_43+0x3a>
	OCR4B = (OCR4B + TICK_TIME) & 0xFFFF;

	/*
	clock stuff
	*/
	clock_counter_10ms += TICK_TIME_MS;
    51f8:	90 93 ca 04 	sts	0x04CA, r25
    51fc:	20 c0       	rjmp	.+64     	; 0x523e <__vector_43+0x7a>
	if (clock_counter_10ms >= 10) {
		clock_counter_10ms -= 10;
    51fe:	88 50       	subi	r24, 0x08	; 8
    5200:	80 93 ca 04 	sts	0x04CA, r24
		clock_flag_10ms = 1;
    5204:	81 e0       	ldi	r24, 0x01	; 1
    5206:	80 93 c7 04 	sts	0x04C7, r24

		clock_counter_250ms++;
    520a:	80 91 c9 04 	lds	r24, 0x04C9
    520e:	8f 5f       	subi	r24, 0xFF	; 255
		if (clock_counter_250ms >= 25) {
    5210:	89 31       	cpi	r24, 0x19	; 25
    5212:	18 f4       	brcc	.+6      	; 0x521a <__vector_43+0x56>
	clock_counter_10ms += TICK_TIME_MS;
	if (clock_counter_10ms >= 10) {
		clock_counter_10ms -= 10;
		clock_flag_10ms = 1;

		clock_counter_250ms++;
    5214:	80 93 c9 04 	sts	0x04C9, r24
    5218:	12 c0       	rjmp	.+36     	; 0x523e <__vector_43+0x7a>
		if (clock_counter_250ms >= 25) {
			clock_counter_250ms = 0;
    521a:	10 92 c9 04 	sts	0x04C9, r1
			clock_flag_250ms = 1;
    521e:	81 e0       	ldi	r24, 0x01	; 1
    5220:	80 93 c6 04 	sts	0x04C6, r24

			clock_counter_1s++;
    5224:	80 91 c8 04 	lds	r24, 0x04C8
    5228:	8f 5f       	subi	r24, 0xFF	; 255
			if (clock_counter_1s >= 4) {
    522a:	84 30       	cpi	r24, 0x04	; 4
    522c:	18 f4       	brcc	.+6      	; 0x5234 <__vector_43+0x70>
		clock_counter_250ms++;
		if (clock_counter_250ms >= 25) {
			clock_counter_250ms = 0;
			clock_flag_250ms = 1;

			clock_counter_1s++;
    522e:	80 93 c8 04 	sts	0x04C8, r24
    5232:	05 c0       	rjmp	.+10     	; 0x523e <__vector_43+0x7a>
			if (clock_counter_1s >= 4) {
				clock_counter_1s = 0;
    5234:	10 92 c8 04 	sts	0x04C8, r1
				clock_flag_1s = 1;
    5238:	81 e0       	ldi	r24, 0x01	; 1
    523a:	80 93 c5 04 	sts	0x04C5, r24
		}
	}

	// restore status register
	MEMORY_BARRIER();
	SREG = sreg_save;
    523e:	2f bf       	out	0x3f, r18	; 63
}
    5240:	ff 91       	pop	r31
    5242:	ef 91       	pop	r30
    5244:	9f 91       	pop	r25
    5246:	8f 91       	pop	r24
    5248:	2f 91       	pop	r18
    524a:	0f 90       	pop	r0
    524c:	0b be       	out	0x3b, r0	; 59
    524e:	0f 90       	pop	r0
    5250:	0f be       	out	0x3f, r0	; 63
    5252:	0f 90       	pop	r0
    5254:	1f 90       	pop	r1
    5256:	18 95       	reti

00005258 <__vector_42>:

#ifdef	MOTHERBOARD

/// comparator A is the step timer. It has higher priority then B.
ISR(TIMER4_COMPA_vect) {
    5258:	1f 92       	push	r1
    525a:	0f 92       	push	r0
    525c:	0f b6       	in	r0, 0x3f	; 63
    525e:	0f 92       	push	r0
    5260:	11 24       	eor	r1, r1
    5262:	0b b6       	in	r0, 0x3b	; 59
    5264:	0f 92       	push	r0
    5266:	2f 93       	push	r18
    5268:	3f 93       	push	r19
    526a:	4f 93       	push	r20
    526c:	5f 93       	push	r21
    526e:	6f 93       	push	r22
    5270:	7f 93       	push	r23
    5272:	8f 93       	push	r24
    5274:	9f 93       	push	r25
    5276:	af 93       	push	r26
    5278:	bf 93       	push	r27
    527a:	ef 93       	push	r30
    527c:	ff 93       	push	r31
	// save status register
	uint8_t sreg_save = SREG;
    527e:	4f b7       	in	r20, 0x3f	; 63

	// Check if this is a real step, or just a next_step_time "overflow"
	if (next_step_time < 65536) {
    5280:	80 91 9f 05 	lds	r24, 0x059F
    5284:	90 91 a0 05 	lds	r25, 0x05A0
    5288:	a0 91 a1 05 	lds	r26, 0x05A1
    528c:	b0 91 a2 05 	lds	r27, 0x05A2
    5290:	00 97       	sbiw	r24, 0x00	; 0
    5292:	21 e0       	ldi	r18, 0x01	; 1
    5294:	a2 07       	cpc	r26, r18
    5296:	b1 05       	cpc	r27, r1
    5298:	40 f4       	brcc	.+16     	; 0x52aa <__vector_42+0x52>
		#ifdef DEBUG_LED_PIN
			WRITE(DEBUG_LED_PIN, 1);
		#endif

		// disable this interrupt. if we set a new timeout, it will be re-enabled when appropriate
		TIMSK4 &= ~MASK(OCIE4A);
    529a:	e2 e7       	ldi	r30, 0x72	; 114
    529c:	f0 e0       	ldi	r31, 0x00	; 0
    529e:	80 81       	ld	r24, Z
    52a0:	8d 7f       	andi	r24, 0xFD	; 253
    52a2:	80 83       	st	Z, r24
		
		// stepper tick
		queue_step();
    52a4:	0e 94 24 15 	call	0x2a48	; 0x2a48 <queue_step>
		// led off
		#ifdef DEBUG_LED_PIN
			WRITE(DEBUG_LED_PIN, 0);
		#endif

		return;
    52a8:	39 c0       	rjmp	.+114    	; 0x531c <__vector_42+0xc4>
	}

	next_step_time -= 65536;
    52aa:	11 97       	sbiw	r26, 0x01	; 1
    52ac:	80 93 9f 05 	sts	0x059F, r24
    52b0:	90 93 a0 05 	sts	0x05A0, r25
    52b4:	a0 93 a1 05 	sts	0x05A1, r26
    52b8:	b0 93 a2 05 	sts	0x05A2, r27

	// similar algorithm as described in setTimer below.
	if (next_step_time < 65536) {
    52bc:	00 97       	sbiw	r24, 0x00	; 0
    52be:	21 e0       	ldi	r18, 0x01	; 1
    52c0:	a2 07       	cpc	r26, r18
    52c2:	b1 05       	cpc	r27, r1
    52c4:	48 f4       	brcc	.+18     	; 0x52d8 <__vector_42+0x80>
		OCR4A = (OCR4A + next_step_time) & 0xFFFF;
    52c6:	e8 ea       	ldi	r30, 0xA8	; 168
    52c8:	f0 e0       	ldi	r31, 0x00	; 0
    52ca:	20 81       	ld	r18, Z
    52cc:	31 81       	ldd	r19, Z+1	; 0x01
    52ce:	82 0f       	add	r24, r18
    52d0:	93 1f       	adc	r25, r19
    52d2:	91 83       	std	Z+1, r25	; 0x01
    52d4:	80 83       	st	Z, r24
    52d6:	21 c0       	rjmp	.+66     	; 0x531a <__vector_42+0xc2>
	} else if(next_step_time < 75536){
    52d8:	80 31       	cpi	r24, 0x10	; 16
    52da:	97 42       	sbci	r25, 0x27	; 39
    52dc:	a1 40       	sbci	r26, 0x01	; 1
    52de:	b1 05       	cpc	r27, r1
    52e0:	e0 f4       	brcc	.+56     	; 0x531a <__vector_42+0xc2>
		OCR4A = (OCR4A - 10000) & 0xFFFF;
    52e2:	e8 ea       	ldi	r30, 0xA8	; 168
    52e4:	f0 e0       	ldi	r31, 0x00	; 0
    52e6:	80 81       	ld	r24, Z
    52e8:	91 81       	ldd	r25, Z+1	; 0x01
    52ea:	80 51       	subi	r24, 0x10	; 16
    52ec:	97 42       	sbci	r25, 0x27	; 39
    52ee:	91 83       	std	Z+1, r25	; 0x01
    52f0:	80 83       	st	Z, r24
		next_step_time += 10000;
    52f2:	80 91 9f 05 	lds	r24, 0x059F
    52f6:	90 91 a0 05 	lds	r25, 0x05A0
    52fa:	a0 91 a1 05 	lds	r26, 0x05A1
    52fe:	b0 91 a2 05 	lds	r27, 0x05A2
    5302:	80 5f       	subi	r24, 0xF0	; 240
    5304:	98 4d       	sbci	r25, 0xD8	; 216
    5306:	af 4f       	sbci	r26, 0xFF	; 255
    5308:	bf 4f       	sbci	r27, 0xFF	; 255
    530a:	80 93 9f 05 	sts	0x059F, r24
    530e:	90 93 a0 05 	sts	0x05A0, r25
    5312:	a0 93 a1 05 	sts	0x05A1, r26
    5316:	b0 93 a2 05 	sts	0x05A2, r27
	}
	// leave OCR4A as it was

	// restore status register
	MEMORY_BARRIER();
	SREG = sreg_save;
    531a:	4f bf       	out	0x3f, r20	; 63
}
    531c:	ff 91       	pop	r31
    531e:	ef 91       	pop	r30
    5320:	bf 91       	pop	r27
    5322:	af 91       	pop	r26
    5324:	9f 91       	pop	r25
    5326:	8f 91       	pop	r24
    5328:	7f 91       	pop	r23
    532a:	6f 91       	pop	r22
    532c:	5f 91       	pop	r21
    532e:	4f 91       	pop	r20
    5330:	3f 91       	pop	r19
    5332:	2f 91       	pop	r18
    5334:	0f 90       	pop	r0
    5336:	0b be       	out	0x3b, r0	; 59
    5338:	0f 90       	pop	r0
    533a:	0f be       	out	0x3f, r0	; 63
    533c:	0f 90       	pop	r0
    533e:	1f 90       	pop	r1
    5340:	18 95       	reti

00005342 <timer_init>:
/// initialise timer and enable system clock interrupt.
/// step interrupt is enabled later when we start using it
void timer_init()
{
	// no outputs
	TCCR4A = 0;
    5342:	10 92 a0 00 	sts	0x00A0, r1
	// Normal Mode
	TCCR4B = MASK(CS40);
    5346:	81 e0       	ldi	r24, 0x01	; 1
    5348:	80 93 a1 00 	sts	0x00A1, r24
	// set up "clock" comparator for first tick
	OCR4B = TICK_TIME & 0xFFFF;
    534c:	80 e0       	ldi	r24, 0x00	; 0
    534e:	9d e7       	ldi	r25, 0x7D	; 125
    5350:	90 93 ab 00 	sts	0x00AB, r25
    5354:	80 93 aa 00 	sts	0x00AA, r24
	// enable interrupt
	TIMSK4 = MASK(OCIE4B);
    5358:	84 e0       	ldi	r24, 0x04	; 4
    535a:	80 93 72 00 	sts	0x0072, r24
    535e:	08 95       	ret

00005360 <setTimer>:
	So, if you use it from inside the step interrupt, make sure to do so
	as late as possible. If you use it from outside the step interrupt,
	do a sei() after it to make the interrupt actually fire.
*/
void setTimer(uint32_t delay)
{
    5360:	0f 93       	push	r16
    5362:	1f 93       	push	r17
	uint16_t current_time;
	uint32_t earliest_time, actual_time;
	#endif /* ACCELERATION_TEMPORAL */

	// re-enable clock interrupt in case we're recovering from emergency stop
	TIMSK1 |= MASK(OCIE4B);
    5364:	ef e6       	ldi	r30, 0x6F	; 111
    5366:	f0 e0       	ldi	r31, 0x00	; 0
    5368:	20 81       	ld	r18, Z
    536a:	24 60       	ori	r18, 0x04	; 4
    536c:	20 83       	st	Z, r18

	// An interrupt would make all our timing calculations invalid,
	// so stop that here.
	cli();
    536e:	f8 94       	cli

	// Assume all steps belong to one move. Within one move the delay is
	// from one step to the next one, which should be more or less the same
	// as from one step interrupt to the next one. The last step interrupt happend
	// at OCR1A, so start delay from there.
	step_start = OCR4A;
    5370:	40 91 a8 00 	lds	r20, 0x00A8
    5374:	50 91 a9 00 	lds	r21, 0x00A9
	if (next_step_time == 0) {
    5378:	00 91 9f 05 	lds	r16, 0x059F
    537c:	10 91 a0 05 	lds	r17, 0x05A0
    5380:	20 91 a1 05 	lds	r18, 0x05A1
    5384:	30 91 a2 05 	lds	r19, 0x05A2
    5388:	01 2b       	or	r16, r17
    538a:	02 2b       	or	r16, r18
    538c:	03 2b       	or	r16, r19
    538e:	21 f4       	brne	.+8      	; 0x5398 <setTimer+0x38>
		// new move, take current time as start value
		step_start = TCNT4;
    5390:	40 91 a4 00 	lds	r20, 0x00A4
    5394:	50 91 a5 00 	lds	r21, 0x00A5
	}
	next_step_time = delay;
    5398:	60 93 9f 05 	sts	0x059F, r22
    539c:	70 93 a0 05 	sts	0x05A0, r23
    53a0:	80 93 a1 05 	sts	0x05A1, r24
    53a4:	90 93 a2 05 	sts	0x05A2, r25
		}
	}
	#endif /* ACCELERATION_TEMPORAL */

	// Now we know how long we actually want to delay, so set the timer.
	if (next_step_time < 65536) {
    53a8:	61 15       	cp	r22, r1
    53aa:	71 05       	cpc	r23, r1
    53ac:	21 e0       	ldi	r18, 0x01	; 1
    53ae:	82 07       	cpc	r24, r18
    53b0:	91 05       	cpc	r25, r1
    53b2:	38 f4       	brcc	.+14     	; 0x53c2 <setTimer+0x62>
		// set the comparator directly to the next real step
		OCR4A = (next_step_time + step_start) & 0xFFFF;
    53b4:	64 0f       	add	r22, r20
    53b6:	75 1f       	adc	r23, r21
    53b8:	70 93 a9 00 	sts	0x00A9, r23
    53bc:	60 93 a8 00 	sts	0x00A8, r22
    53c0:	24 c0       	rjmp	.+72     	; 0x540a <setTimer+0xaa>
	}
	else if (next_step_time < 75536) {
    53c2:	60 31       	cpi	r22, 0x10	; 16
    53c4:	77 42       	sbci	r23, 0x27	; 39
    53c6:	81 40       	sbci	r24, 0x01	; 1
    53c8:	91 05       	cpc	r25, r1
    53ca:	d8 f4       	brcc	.+54     	; 0x5402 <setTimer+0xa2>
		// Next comparator interrupt would have to trigger another
		// interrupt within a short time (possibly within 1 cycle).
		// Avoid the impossible by firing the interrupt earlier.
		OCR4A = (step_start - 10000) & 0xFFFF;
    53cc:	40 51       	subi	r20, 0x10	; 16
    53ce:	57 42       	sbci	r21, 0x27	; 39
    53d0:	50 93 a9 00 	sts	0x00A9, r21
    53d4:	40 93 a8 00 	sts	0x00A8, r20
		next_step_time += 10000;
    53d8:	80 91 9f 05 	lds	r24, 0x059F
    53dc:	90 91 a0 05 	lds	r25, 0x05A0
    53e0:	a0 91 a1 05 	lds	r26, 0x05A1
    53e4:	b0 91 a2 05 	lds	r27, 0x05A2
    53e8:	80 5f       	subi	r24, 0xF0	; 240
    53ea:	98 4d       	sbci	r25, 0xD8	; 216
    53ec:	af 4f       	sbci	r26, 0xFF	; 255
    53ee:	bf 4f       	sbci	r27, 0xFF	; 255
    53f0:	80 93 9f 05 	sts	0x059F, r24
    53f4:	90 93 a0 05 	sts	0x05A0, r25
    53f8:	a0 93 a1 05 	sts	0x05A1, r26
    53fc:	b0 93 a2 05 	sts	0x05A2, r27
    5400:	04 c0       	rjmp	.+8      	; 0x540a <setTimer+0xaa>
	}
	else {
		OCR4A = step_start;
    5402:	50 93 a9 00 	sts	0x00A9, r21
    5406:	40 93 a8 00 	sts	0x00A8, r20

	// Enable this interrupt, but only do it after disabling
	// global interrupts (see above). This will cause push any possible
	// timer1a interrupt to the far side of the return, protecting the 
	// stack from recursively clobbering memory.
	TIMSK4 |= MASK(OCIE4A);
    540a:	e2 e7       	ldi	r30, 0x72	; 114
    540c:	f0 e0       	ldi	r31, 0x00	; 0
    540e:	80 81       	ld	r24, Z
    5410:	82 60       	ori	r24, 0x02	; 2
    5412:	80 83       	st	Z, r24
}
    5414:	1f 91       	pop	r17
    5416:	0f 91       	pop	r16
    5418:	08 95       	ret

0000541a <timer_stop>:

/// stop timers - emergency stop
void timer_stop() {
	// disable all interrupts
	TIMSK4 = 0;
    541a:	10 92 72 00 	sts	0x0072, r1
    541e:	08 95       	ret

00005420 <__mulsi3>:
    5420:	db 01       	movw	r26, r22
    5422:	8f 93       	push	r24
    5424:	9f 93       	push	r25
    5426:	5a d0       	rcall	.+180    	; 0x54dc <__muluhisi3>
    5428:	bf 91       	pop	r27
    542a:	af 91       	pop	r26
    542c:	a2 9f       	mul	r26, r18
    542e:	80 0d       	add	r24, r0
    5430:	91 1d       	adc	r25, r1
    5432:	a3 9f       	mul	r26, r19
    5434:	90 0d       	add	r25, r0
    5436:	b2 9f       	mul	r27, r18
    5438:	90 0d       	add	r25, r0
    543a:	11 24       	eor	r1, r1
    543c:	08 95       	ret

0000543e <__udivmodsi4>:
    543e:	a1 e2       	ldi	r26, 0x21	; 33
    5440:	1a 2e       	mov	r1, r26
    5442:	aa 1b       	sub	r26, r26
    5444:	bb 1b       	sub	r27, r27
    5446:	fd 01       	movw	r30, r26
    5448:	0d c0       	rjmp	.+26     	; 0x5464 <__udivmodsi4_ep>

0000544a <__udivmodsi4_loop>:
    544a:	aa 1f       	adc	r26, r26
    544c:	bb 1f       	adc	r27, r27
    544e:	ee 1f       	adc	r30, r30
    5450:	ff 1f       	adc	r31, r31
    5452:	a2 17       	cp	r26, r18
    5454:	b3 07       	cpc	r27, r19
    5456:	e4 07       	cpc	r30, r20
    5458:	f5 07       	cpc	r31, r21
    545a:	20 f0       	brcs	.+8      	; 0x5464 <__udivmodsi4_ep>
    545c:	a2 1b       	sub	r26, r18
    545e:	b3 0b       	sbc	r27, r19
    5460:	e4 0b       	sbc	r30, r20
    5462:	f5 0b       	sbc	r31, r21

00005464 <__udivmodsi4_ep>:
    5464:	66 1f       	adc	r22, r22
    5466:	77 1f       	adc	r23, r23
    5468:	88 1f       	adc	r24, r24
    546a:	99 1f       	adc	r25, r25
    546c:	1a 94       	dec	r1
    546e:	69 f7       	brne	.-38     	; 0x544a <__udivmodsi4_loop>
    5470:	60 95       	com	r22
    5472:	70 95       	com	r23
    5474:	80 95       	com	r24
    5476:	90 95       	com	r25
    5478:	9b 01       	movw	r18, r22
    547a:	ac 01       	movw	r20, r24
    547c:	bd 01       	movw	r22, r26
    547e:	cf 01       	movw	r24, r30
    5480:	08 95       	ret

00005482 <__divmodsi4>:
    5482:	05 2e       	mov	r0, r21
    5484:	97 fb       	bst	r25, 7
    5486:	16 f4       	brtc	.+4      	; 0x548c <__divmodsi4+0xa>
    5488:	00 94       	com	r0
    548a:	06 d0       	rcall	.+12     	; 0x5498 <__divmodsi4_neg1>
    548c:	57 fd       	sbrc	r21, 7
    548e:	0c d0       	rcall	.+24     	; 0x54a8 <__divmodsi4_neg2>
    5490:	d6 df       	rcall	.-84     	; 0x543e <__udivmodsi4>
    5492:	07 fc       	sbrc	r0, 7
    5494:	09 d0       	rcall	.+18     	; 0x54a8 <__divmodsi4_neg2>
    5496:	7e f4       	brtc	.+30     	; 0x54b6 <__divmodsi4_exit>

00005498 <__divmodsi4_neg1>:
    5498:	90 95       	com	r25
    549a:	80 95       	com	r24
    549c:	70 95       	com	r23
    549e:	61 95       	neg	r22
    54a0:	7f 4f       	sbci	r23, 0xFF	; 255
    54a2:	8f 4f       	sbci	r24, 0xFF	; 255
    54a4:	9f 4f       	sbci	r25, 0xFF	; 255
    54a6:	08 95       	ret

000054a8 <__divmodsi4_neg2>:
    54a8:	50 95       	com	r21
    54aa:	40 95       	com	r20
    54ac:	30 95       	com	r19
    54ae:	21 95       	neg	r18
    54b0:	3f 4f       	sbci	r19, 0xFF	; 255
    54b2:	4f 4f       	sbci	r20, 0xFF	; 255
    54b4:	5f 4f       	sbci	r21, 0xFF	; 255

000054b6 <__divmodsi4_exit>:
    54b6:	08 95       	ret

000054b8 <__tablejump2__>:
    54b8:	ee 0f       	add	r30, r30
    54ba:	ff 1f       	adc	r31, r31

000054bc <__tablejump__>:
    54bc:	05 90       	lpm	r0, Z+
    54be:	f4 91       	lpm	r31, Z
    54c0:	e0 2d       	mov	r30, r0
    54c2:	19 94       	eijmp

000054c4 <__umulhisi3>:
    54c4:	a2 9f       	mul	r26, r18
    54c6:	b0 01       	movw	r22, r0
    54c8:	b3 9f       	mul	r27, r19
    54ca:	c0 01       	movw	r24, r0
    54cc:	a3 9f       	mul	r26, r19
    54ce:	01 d0       	rcall	.+2      	; 0x54d2 <__umulhisi3+0xe>
    54d0:	b2 9f       	mul	r27, r18
    54d2:	70 0d       	add	r23, r0
    54d4:	81 1d       	adc	r24, r1
    54d6:	11 24       	eor	r1, r1
    54d8:	91 1d       	adc	r25, r1
    54da:	08 95       	ret

000054dc <__muluhisi3>:
    54dc:	f3 df       	rcall	.-26     	; 0x54c4 <__umulhisi3>
    54de:	a5 9f       	mul	r26, r21
    54e0:	90 0d       	add	r25, r0
    54e2:	b4 9f       	mul	r27, r20
    54e4:	90 0d       	add	r25, r0
    54e6:	a4 9f       	mul	r26, r20
    54e8:	80 0d       	add	r24, r0
    54ea:	91 1d       	adc	r25, r1
    54ec:	11 24       	eor	r1, r1
    54ee:	08 95       	ret

000054f0 <__mulshisi3>:
    54f0:	b7 ff       	sbrs	r27, 7
    54f2:	f4 cf       	rjmp	.-24     	; 0x54dc <__muluhisi3>

000054f4 <__mulohisi3>:
    54f4:	f3 df       	rcall	.-26     	; 0x54dc <__muluhisi3>
    54f6:	82 1b       	sub	r24, r18
    54f8:	93 0b       	sbc	r25, r19
    54fa:	08 95       	ret

000054fc <__eerd_dword_m2560>:
    54fc:	a6 e1       	ldi	r26, 0x16	; 22
    54fe:	b0 e0       	ldi	r27, 0x00	; 0
    5500:	44 e0       	ldi	r20, 0x04	; 4
    5502:	50 e0       	ldi	r21, 0x00	; 0
    5504:	0f c0       	rjmp	.+30     	; 0x5524 <__eerd_blraw_m2560>

00005506 <__eerd_word_m2560>:
    5506:	a8 e1       	ldi	r26, 0x18	; 24
    5508:	b0 e0       	ldi	r27, 0x00	; 0
    550a:	42 e0       	ldi	r20, 0x02	; 2
    550c:	50 e0       	ldi	r21, 0x00	; 0
    550e:	0a c0       	rjmp	.+20     	; 0x5524 <__eerd_blraw_m2560>

00005510 <__eewr_dword_m2560>:
    5510:	24 2f       	mov	r18, r20
    5512:	17 d0       	rcall	.+46     	; 0x5542 <__eewr_r18_m2560>
    5514:	25 2f       	mov	r18, r21
    5516:	15 d0       	rcall	.+42     	; 0x5542 <__eewr_r18_m2560>
    5518:	00 c0       	rjmp	.+0      	; 0x551a <__eewr_word_m2560>

0000551a <__eewr_word_m2560>:
    551a:	12 d0       	rcall	.+36     	; 0x5540 <__eewr_byte_m2560>
    551c:	27 2f       	mov	r18, r23
    551e:	11 c0       	rjmp	.+34     	; 0x5542 <__eewr_r18_m2560>

00005520 <__eerd_block_m2560>:
    5520:	dc 01       	movw	r26, r24
    5522:	cb 01       	movw	r24, r22

00005524 <__eerd_blraw_m2560>:
    5524:	fc 01       	movw	r30, r24
    5526:	f9 99       	sbic	0x1f, 1	; 31
    5528:	fe cf       	rjmp	.-4      	; 0x5526 <__eerd_blraw_m2560+0x2>
    552a:	06 c0       	rjmp	.+12     	; 0x5538 <__eerd_blraw_m2560+0x14>
    552c:	f2 bd       	out	0x22, r31	; 34
    552e:	e1 bd       	out	0x21, r30	; 33
    5530:	f8 9a       	sbi	0x1f, 0	; 31
    5532:	31 96       	adiw	r30, 0x01	; 1
    5534:	00 b4       	in	r0, 0x20	; 32
    5536:	0d 92       	st	X+, r0
    5538:	41 50       	subi	r20, 0x01	; 1
    553a:	50 40       	sbci	r21, 0x00	; 0
    553c:	b8 f7       	brcc	.-18     	; 0x552c <__eerd_blraw_m2560+0x8>
    553e:	08 95       	ret

00005540 <__eewr_byte_m2560>:
    5540:	26 2f       	mov	r18, r22

00005542 <__eewr_r18_m2560>:
    5542:	f9 99       	sbic	0x1f, 1	; 31
    5544:	fe cf       	rjmp	.-4      	; 0x5542 <__eewr_r18_m2560>
    5546:	1f ba       	out	0x1f, r1	; 31
    5548:	92 bd       	out	0x22, r25	; 34
    554a:	81 bd       	out	0x21, r24	; 33
    554c:	20 bd       	out	0x20, r18	; 32
    554e:	0f b6       	in	r0, 0x3f	; 63
    5550:	f8 94       	cli
    5552:	fa 9a       	sbi	0x1f, 2	; 31
    5554:	f9 9a       	sbi	0x1f, 1	; 31
    5556:	0f be       	out	0x3f, r0	; 63
    5558:	01 96       	adiw	r24, 0x01	; 1
    555a:	08 95       	ret

0000555c <_exit>:
    555c:	f8 94       	cli

0000555e <__stop_program>:
    555e:	ff cf       	rjmp	.-2      	; 0x555e <__stop_program>
