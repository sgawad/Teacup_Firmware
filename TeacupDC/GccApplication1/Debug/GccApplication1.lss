
GccApplication1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000032  00800200  00005912  000059c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005912  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000371  00800232  00800232  000059f8  2**0
                  ALLOC
  3 .eeprom       00000020  00810000  00810000  000059f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00001074  00000000  00000000  00005a18  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000526  00000000  00000000  00006a8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      0000002f  00000000  00000000  00006fb2  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000004e0  00000000  00000000  00006fe1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00004db8  00000000  00000000  000074c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00001acb  00000000  00000000  0000c279  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00003b82  00000000  00000000  0000dd44  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00001128  00000000  00000000  000118c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0000108d  00000000  00000000  000129f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    000041fe  00000000  00000000  00013a7d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000390  00000000  00000000  00017c7b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	da c4       	rjmp	.+2484   	; 0x9b6 <__ctors_end>
       2:	00 00       	nop
       4:	f9 c4       	rjmp	.+2546   	; 0x9f8 <__bad_interrupt>
       6:	00 00       	nop
       8:	f7 c4       	rjmp	.+2542   	; 0x9f8 <__bad_interrupt>
       a:	00 00       	nop
       c:	0c 94 60 11 	jmp	0x22c0	; 0x22c0 <__vector_3>
      10:	0c 94 af 11 	jmp	0x235e	; 0x235e <__vector_4>
      14:	f1 c4       	rjmp	.+2530   	; 0x9f8 <__bad_interrupt>
      16:	00 00       	nop
      18:	ef c4       	rjmp	.+2526   	; 0x9f8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ed c4       	rjmp	.+2522   	; 0x9f8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	eb c4       	rjmp	.+2518   	; 0x9f8 <__bad_interrupt>
      22:	00 00       	nop
      24:	e9 c4       	rjmp	.+2514   	; 0x9f8 <__bad_interrupt>
      26:	00 00       	nop
      28:	e7 c4       	rjmp	.+2510   	; 0x9f8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e5 c4       	rjmp	.+2506   	; 0x9f8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	e3 c4       	rjmp	.+2502   	; 0x9f8 <__bad_interrupt>
      32:	00 00       	nop
      34:	e1 c4       	rjmp	.+2498   	; 0x9f8 <__bad_interrupt>
      36:	00 00       	nop
      38:	df c4       	rjmp	.+2494   	; 0x9f8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	dd c4       	rjmp	.+2490   	; 0x9f8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	db c4       	rjmp	.+2486   	; 0x9f8 <__bad_interrupt>
      42:	00 00       	nop
      44:	d9 c4       	rjmp	.+2482   	; 0x9f8 <__bad_interrupt>
      46:	00 00       	nop
      48:	d7 c4       	rjmp	.+2478   	; 0x9f8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d5 c4       	rjmp	.+2474   	; 0x9f8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	d3 c4       	rjmp	.+2470   	; 0x9f8 <__bad_interrupt>
      52:	00 00       	nop
      54:	d1 c4       	rjmp	.+2466   	; 0x9f8 <__bad_interrupt>
      56:	00 00       	nop
      58:	cf c4       	rjmp	.+2462   	; 0x9f8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	cd c4       	rjmp	.+2458   	; 0x9f8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	cb c4       	rjmp	.+2454   	; 0x9f8 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 ab 25 	jmp	0x4b56	; 0x4b56 <__vector_25>
      68:	0c 94 e4 25 	jmp	0x4bc8	; 0x4bc8 <__vector_26>
      6c:	c5 c4       	rjmp	.+2442   	; 0x9f8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	c3 c4       	rjmp	.+2438   	; 0x9f8 <__bad_interrupt>
      72:	00 00       	nop
      74:	e2 c4       	rjmp	.+2500   	; 0xa3a <__vector_29>
      76:	00 00       	nop
      78:	bf c4       	rjmp	.+2430   	; 0x9f8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	bd c4       	rjmp	.+2426   	; 0x9f8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	bb c4       	rjmp	.+2422   	; 0x9f8 <__bad_interrupt>
      82:	00 00       	nop
      84:	b9 c4       	rjmp	.+2418   	; 0x9f8 <__bad_interrupt>
      86:	00 00       	nop
      88:	b7 c4       	rjmp	.+2414   	; 0x9f8 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b5 c4       	rjmp	.+2410   	; 0x9f8 <__bad_interrupt>
      8e:	00 00       	nop
      90:	b3 c4       	rjmp	.+2406   	; 0x9f8 <__bad_interrupt>
      92:	00 00       	nop
      94:	b1 c4       	rjmp	.+2402   	; 0x9f8 <__bad_interrupt>
      96:	00 00       	nop
      98:	af c4       	rjmp	.+2398   	; 0x9f8 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ad c4       	rjmp	.+2394   	; 0x9f8 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ab c4       	rjmp	.+2390   	; 0x9f8 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	a9 c4       	rjmp	.+2386   	; 0x9f8 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 9c 2a 	jmp	0x5538	; 0x5538 <__vector_42>
      ac:	0c 94 52 2a 	jmp	0x54a4	; 0x54a4 <__vector_43>
      b0:	a3 c4       	rjmp	.+2374   	; 0x9f8 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a1 c4       	rjmp	.+2370   	; 0x9f8 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	9f c4       	rjmp	.+2366   	; 0x9f8 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	9d c4       	rjmp	.+2362   	; 0x9f8 <__bad_interrupt>
      be:	00 00       	nop
      c0:	9b c4       	rjmp	.+2358   	; 0x9f8 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	99 c4       	rjmp	.+2354   	; 0x9f8 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	97 c4       	rjmp	.+2350   	; 0x9f8 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	95 c4       	rjmp	.+2346   	; 0x9f8 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	93 c4       	rjmp	.+2342   	; 0x9f8 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	91 c4       	rjmp	.+2338   	; 0x9f8 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	8f c4       	rjmp	.+2334   	; 0x9f8 <__bad_interrupt>
      da:	00 00       	nop
      dc:	8d c4       	rjmp	.+2330   	; 0x9f8 <__bad_interrupt>
      de:	00 00       	nop
      e0:	8b c4       	rjmp	.+2326   	; 0x9f8 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	62 19       	sub	r22, r2
      e6:	62 19       	sub	r22, r2
      e8:	4f 19       	sub	r20, r15
      ea:	4f 19       	sub	r20, r15
      ec:	62 19       	sub	r22, r2
      ee:	4f 19       	sub	r20, r15
      f0:	4f 19       	sub	r20, r15
      f2:	4f 19       	sub	r20, r15
      f4:	4f 19       	sub	r20, r15
      f6:	4f 19       	sub	r20, r15
      f8:	4f 19       	sub	r20, r15
      fa:	4f 19       	sub	r20, r15
      fc:	4f 19       	sub	r20, r15
      fe:	4f 19       	sub	r20, r15
     100:	4f 19       	sub	r20, r15
     102:	4f 19       	sub	r20, r15
     104:	4f 19       	sub	r20, r15
     106:	4f 19       	sub	r20, r15
     108:	4f 19       	sub	r20, r15
     10a:	4f 19       	sub	r20, r15
     10c:	4f 19       	sub	r20, r15
     10e:	4f 19       	sub	r20, r15
     110:	4f 19       	sub	r20, r15
     112:	62 19       	sub	r22, r2
     114:	4f 19       	sub	r20, r15
     116:	4f 19       	sub	r20, r15
     118:	4f 19       	sub	r20, r15
     11a:	4f 19       	sub	r20, r15
     11c:	4f 19       	sub	r20, r15
     11e:	4f 19       	sub	r20, r15
     120:	4f 19       	sub	r20, r15
     122:	32 19       	sub	r19, r2
     124:	4f 19       	sub	r20, r15
     126:	26 19       	sub	r18, r6
     128:	4f 19       	sub	r20, r15
     12a:	4f 19       	sub	r20, r15
     12c:	38 19       	sub	r19, r8
     12e:	44 19       	sub	r20, r4
     130:	4f 19       	sub	r20, r15
     132:	4f 19       	sub	r20, r15
     134:	4f 19       	sub	r20, r15
     136:	4f 19       	sub	r20, r15
     138:	4f 19       	sub	r20, r15
     13a:	4f 19       	sub	r20, r15
     13c:	4f 19       	sub	r20, r15
     13e:	4f 19       	sub	r20, r15
     140:	4f 19       	sub	r20, r15
     142:	4f 19       	sub	r20, r15
     144:	4f 19       	sub	r20, r15
     146:	4f 19       	sub	r20, r15
     148:	2c 19       	sub	r18, r12
     14a:	4f 19       	sub	r20, r15
     14c:	4f 19       	sub	r20, r15
     14e:	4f 19       	sub	r20, r15
     150:	4f 19       	sub	r20, r15
     152:	4f 19       	sub	r20, r15
     154:	4f 19       	sub	r20, r15
     156:	4f 19       	sub	r20, r15
     158:	4f 19       	sub	r20, r15
     15a:	4f 19       	sub	r20, r15
     15c:	02 19       	sub	r16, r2
     15e:	08 19       	sub	r16, r8
     160:	de 18       	sub	r13, r14
     162:	4f 19       	sub	r20, r15
     164:	4f 19       	sub	r20, r15
     166:	4f 19       	sub	r20, r15
     168:	4f 19       	sub	r20, r15
     16a:	4f 19       	sub	r20, r15
     16c:	e7 18       	sub	r14, r7
     16e:	20 19       	sub	r18, r0
     170:	4f 19       	sub	r20, r15
     172:	14 19       	sub	r17, r4
     174:	4f 19       	sub	r20, r15
     176:	4f 19       	sub	r20, r15
     178:	0e 19       	sub	r16, r14
     17a:	1a 19       	sub	r17, r10
     17c:	4f 19       	sub	r20, r15
     17e:	4f 19       	sub	r20, r15
     180:	4f 19       	sub	r20, r15
     182:	f0 18       	sub	r15, r0
     184:	f6 18       	sub	r15, r6
     186:	fc 18       	sub	r15, r12
     188:	63 1c       	adc	r6, r3
     18a:	63 1e       	adc	r6, r19
     18c:	63 1c       	adc	r6, r3
     18e:	89 1c       	adc	r8, r9
     190:	63 1e       	adc	r6, r19
     192:	6f 1e       	adc	r6, r31
     194:	78 1c       	adc	r7, r8
     196:	b2 1c       	adc	r11, r2
     198:	63 1e       	adc	r6, r19
     19a:	63 1e       	adc	r6, r19
     19c:	63 1e       	adc	r6, r19
     19e:	63 1e       	adc	r6, r19
     1a0:	63 1e       	adc	r6, r19
     1a2:	63 1e       	adc	r6, r19
     1a4:	63 1e       	adc	r6, r19
     1a6:	63 1e       	adc	r6, r19
     1a8:	63 1e       	adc	r6, r19
     1aa:	63 1e       	adc	r6, r19
     1ac:	63 1e       	adc	r6, r19
     1ae:	63 1e       	adc	r6, r19
     1b0:	63 1e       	adc	r6, r19
     1b2:	63 1e       	adc	r6, r19
     1b4:	63 1e       	adc	r6, r19
     1b6:	63 1e       	adc	r6, r19
     1b8:	63 1e       	adc	r6, r19
     1ba:	63 1e       	adc	r6, r19
     1bc:	63 1e       	adc	r6, r19
     1be:	63 1e       	adc	r6, r19
     1c0:	63 1e       	adc	r6, r19
     1c2:	63 1e       	adc	r6, r19
     1c4:	63 1e       	adc	r6, r19
     1c6:	63 1e       	adc	r6, r19
     1c8:	63 1e       	adc	r6, r19
     1ca:	63 1e       	adc	r6, r19
     1cc:	63 1e       	adc	r6, r19
     1ce:	63 1e       	adc	r6, r19
     1d0:	63 1e       	adc	r6, r19
     1d2:	63 1e       	adc	r6, r19
     1d4:	63 1e       	adc	r6, r19
     1d6:	63 1e       	adc	r6, r19
     1d8:	63 1e       	adc	r6, r19
     1da:	63 1e       	adc	r6, r19
     1dc:	63 1e       	adc	r6, r19
     1de:	63 1e       	adc	r6, r19
     1e0:	63 1e       	adc	r6, r19
     1e2:	63 1e       	adc	r6, r19
     1e4:	63 1e       	adc	r6, r19
     1e6:	63 1e       	adc	r6, r19
     1e8:	63 1e       	adc	r6, r19
     1ea:	63 1e       	adc	r6, r19
     1ec:	63 1e       	adc	r6, r19
     1ee:	63 1e       	adc	r6, r19
     1f0:	63 1e       	adc	r6, r19
     1f2:	63 1e       	adc	r6, r19
     1f4:	63 1e       	adc	r6, r19
     1f6:	63 1e       	adc	r6, r19
     1f8:	63 1e       	adc	r6, r19
     1fa:	63 1e       	adc	r6, r19
     1fc:	63 1e       	adc	r6, r19
     1fe:	63 1e       	adc	r6, r19
     200:	63 1e       	adc	r6, r19
     202:	63 1e       	adc	r6, r19
     204:	63 1e       	adc	r6, r19
     206:	63 1e       	adc	r6, r19
     208:	63 1e       	adc	r6, r19
     20a:	63 1e       	adc	r6, r19
     20c:	63 1e       	adc	r6, r19
     20e:	63 1e       	adc	r6, r19
     210:	63 1e       	adc	r6, r19
     212:	63 1e       	adc	r6, r19
     214:	63 1e       	adc	r6, r19
     216:	63 1e       	adc	r6, r19
     218:	63 1e       	adc	r6, r19
     21a:	63 1e       	adc	r6, r19
     21c:	63 1e       	adc	r6, r19
     21e:	63 1e       	adc	r6, r19
     220:	63 1e       	adc	r6, r19
     222:	63 1e       	adc	r6, r19
     224:	63 1e       	adc	r6, r19
     226:	63 1e       	adc	r6, r19
     228:	63 1e       	adc	r6, r19
     22a:	63 1e       	adc	r6, r19
     22c:	7d 1c       	adc	r7, r13
     22e:	83 1c       	adc	r8, r3
     230:	63 1c       	adc	r6, r3
     232:	63 1e       	adc	r6, r19
     234:	63 1e       	adc	r6, r19
     236:	63 1e       	adc	r6, r19
     238:	63 1e       	adc	r6, r19
     23a:	63 1e       	adc	r6, r19
     23c:	63 1e       	adc	r6, r19
     23e:	63 1e       	adc	r6, r19
     240:	63 1e       	adc	r6, r19
     242:	63 1e       	adc	r6, r19
     244:	63 1e       	adc	r6, r19
     246:	63 1e       	adc	r6, r19
     248:	63 1e       	adc	r6, r19
     24a:	63 1e       	adc	r6, r19
     24c:	63 1e       	adc	r6, r19
     24e:	63 1e       	adc	r6, r19
     250:	63 1e       	adc	r6, r19
     252:	89 1c       	adc	r8, r9
     254:	63 1e       	adc	r6, r19
     256:	6f 1e       	adc	r6, r31
     258:	93 1c       	adc	r9, r3
     25a:	a5 1c       	adc	r10, r5
     25c:	b2 1c       	adc	r11, r2
     25e:	63 1e       	adc	r6, r19
     260:	63 1e       	adc	r6, r19
     262:	63 1e       	adc	r6, r19
     264:	6f 1e       	adc	r6, r31
     266:	bb 1c       	adc	r11, r11
     268:	71 1c       	adc	r7, r1
     26a:	63 1e       	adc	r6, r19
     26c:	c3 1c       	adc	r12, r3
     26e:	7a 1d       	adc	r23, r10
     270:	92 1d       	adc	r25, r2
     272:	63 1e       	adc	r6, r19
     274:	63 1e       	adc	r6, r19
     276:	99 1d       	adc	r25, r9
     278:	63 1e       	adc	r6, r19
     27a:	63 1e       	adc	r6, r19
     27c:	63 1e       	adc	r6, r19
     27e:	63 1e       	adc	r6, r19
     280:	63 1e       	adc	r6, r19
     282:	63 1e       	adc	r6, r19
     284:	63 1e       	adc	r6, r19
     286:	63 1e       	adc	r6, r19
     288:	63 1e       	adc	r6, r19
     28a:	63 1e       	adc	r6, r19
     28c:	e3 1d       	adc	r30, r3
     28e:	f8 1d       	adc	r31, r8
     290:	0d 1e       	adc	r0, r29
     292:	22 1e       	adc	r2, r18
     294:	37 1e       	adc	r3, r23
     296:	63 1e       	adc	r6, r19
     298:	39 1e       	adc	r3, r25
     29a:	63 1e       	adc	r6, r19
     29c:	63 1e       	adc	r6, r19
     29e:	63 1e       	adc	r6, r19
     2a0:	45 1e       	adc	r4, r21
     2a2:	63 1e       	adc	r6, r19
     2a4:	63 1e       	adc	r6, r19
     2a6:	63 1e       	adc	r6, r19
     2a8:	63 1e       	adc	r6, r19
     2aa:	63 1e       	adc	r6, r19
     2ac:	63 1e       	adc	r6, r19
     2ae:	63 1e       	adc	r6, r19
     2b0:	63 1e       	adc	r6, r19
     2b2:	63 1e       	adc	r6, r19
     2b4:	63 1e       	adc	r6, r19
     2b6:	63 1e       	adc	r6, r19
     2b8:	63 1e       	adc	r6, r19
     2ba:	63 1e       	adc	r6, r19
     2bc:	63 1e       	adc	r6, r19
     2be:	63 1e       	adc	r6, r19
     2c0:	63 1e       	adc	r6, r19
     2c2:	63 1e       	adc	r6, r19
     2c4:	63 1e       	adc	r6, r19
     2c6:	63 1e       	adc	r6, r19
     2c8:	63 1e       	adc	r6, r19
     2ca:	63 1e       	adc	r6, r19
     2cc:	63 1e       	adc	r6, r19
     2ce:	63 1e       	adc	r6, r19
     2d0:	63 1e       	adc	r6, r19
     2d2:	63 1e       	adc	r6, r19
     2d4:	63 1e       	adc	r6, r19
     2d6:	63 1e       	adc	r6, r19
     2d8:	63 1e       	adc	r6, r19
     2da:	63 1e       	adc	r6, r19
     2dc:	63 1e       	adc	r6, r19
     2de:	63 1e       	adc	r6, r19
     2e0:	63 1e       	adc	r6, r19
     2e2:	63 1e       	adc	r6, r19
     2e4:	63 1e       	adc	r6, r19
     2e6:	63 1e       	adc	r6, r19
     2e8:	63 1e       	adc	r6, r19
     2ea:	63 1e       	adc	r6, r19
     2ec:	63 1e       	adc	r6, r19
     2ee:	63 1e       	adc	r6, r19
     2f0:	63 1e       	adc	r6, r19
     2f2:	63 1e       	adc	r6, r19
     2f4:	63 1e       	adc	r6, r19
     2f6:	63 1e       	adc	r6, r19
     2f8:	63 1e       	adc	r6, r19
     2fa:	63 1e       	adc	r6, r19
     2fc:	63 1e       	adc	r6, r19
     2fe:	63 1e       	adc	r6, r19
     300:	63 1e       	adc	r6, r19
     302:	63 1e       	adc	r6, r19
     304:	63 1e       	adc	r6, r19
     306:	63 1e       	adc	r6, r19
     308:	63 1e       	adc	r6, r19
     30a:	63 1e       	adc	r6, r19
     30c:	63 1e       	adc	r6, r19
     30e:	63 1e       	adc	r6, r19
     310:	63 1e       	adc	r6, r19
     312:	63 1e       	adc	r6, r19
     314:	63 1e       	adc	r6, r19
     316:	63 1e       	adc	r6, r19
     318:	63 1e       	adc	r6, r19
     31a:	63 1e       	adc	r6, r19
     31c:	63 1e       	adc	r6, r19
     31e:	63 1e       	adc	r6, r19
     320:	63 1e       	adc	r6, r19
     322:	63 1e       	adc	r6, r19
     324:	63 1e       	adc	r6, r19
     326:	63 1e       	adc	r6, r19
     328:	63 1e       	adc	r6, r19
     32a:	63 1e       	adc	r6, r19
     32c:	63 1e       	adc	r6, r19
     32e:	63 1e       	adc	r6, r19
     330:	63 1e       	adc	r6, r19
     332:	63 1e       	adc	r6, r19
     334:	63 1e       	adc	r6, r19
     336:	63 1e       	adc	r6, r19
     338:	63 1e       	adc	r6, r19
     33a:	63 1e       	adc	r6, r19
     33c:	63 1e       	adc	r6, r19
     33e:	63 1e       	adc	r6, r19
     340:	63 1e       	adc	r6, r19
     342:	63 1e       	adc	r6, r19
     344:	63 1e       	adc	r6, r19
     346:	63 1e       	adc	r6, r19
     348:	63 1e       	adc	r6, r19
     34a:	63 1e       	adc	r6, r19
     34c:	63 1e       	adc	r6, r19
     34e:	63 1e       	adc	r6, r19
     350:	63 1e       	adc	r6, r19
     352:	63 1e       	adc	r6, r19
     354:	63 1e       	adc	r6, r19
     356:	63 1e       	adc	r6, r19
     358:	63 1e       	adc	r6, r19
     35a:	63 1e       	adc	r6, r19
     35c:	63 1e       	adc	r6, r19
     35e:	63 1e       	adc	r6, r19
     360:	63 1e       	adc	r6, r19
     362:	63 1e       	adc	r6, r19
     364:	63 1e       	adc	r6, r19
     366:	63 1e       	adc	r6, r19
     368:	4f 1e       	adc	r4, r31
     36a:	59 1e       	adc	r5, r25

0000036c <__c.1751>:
     36c:	50 6f 73 3a 20 25 6c 71 2c 25 6c 71 2c 25 6c 71     Pos: %lq,%lq,%lq
     37c:	2c 25 6c 71 2c 25 6c 75 0a 00                       ,%lq,%lu..

00000386 <__c.1753>:
     386:	44 73 74 3a 20 25 6c 71 2c 25 6c 71 2c 25 6c 71     Dst: %lq,%lq,%lq
     396:	2c 25 6c 71 2c 25 6c 75 0a 00                       ,%lq,%lu..

000003a0 <__c.2132>:
     3a0:	0a 7b 44 44 41 5f 43 52 45 41 54 45 3a 20 5b 00     .{DDA_CREATE: [.

000003b0 <__c.2134>:
     3b0:	25 6c 64 2c 25 6c 64 2c 25 6c 64 2c 25 6c 64 5d     %ld,%ld,%ld,%ld]
     3c0:	20 5b 00                                             [.

000003c3 <__c.2136>:
     3c3:	74 73 3a 25 6c 75 00                                ts:%lu.

000003ca <__c.2138>:
     3ca:	2c 64 73 3a 25 6c 75 00                             ,ds:%lu.

000003d2 <__c.2141>:
     3d2:	5d 20 7d 0a 00                                      ] }..

000003d7 <__c.1852>:
     3d7:	54 65 6d 70 20 61 63 68 69 65 76 65 64 0a 00        Temp achieved..

000003e6 <__c.1871>:
     3e6:	57 61 69 74 69 6e 67 20 66 6f 72 20 74 61 72 67     Waiting for targ
     3f6:	65 74 20 74 65 6d 70 0a 00                          et temp..

000003ff <__c.1878>:
     3ff:	51 25 64 2f 25 64 25 63 00                          Q%d/%d%c.

00000408 <__c.1960>:
     408:	6f 6b 20 00                                         ok .

0000040c <__c.1962>:
     40c:	72 73 20 4e 25 6c 64 20 45 78 70 65 63 74 65 64     rs N%ld Expected
     41c:	20 63 68 65 63 6b 73 75 6d 20 25 64 0a 00            checksum %d..

0000042a <__c.1963>:
     42a:	45 3a 20 42 61 64 20 47 2d 63 6f 64 65 20 25 64     E: Bad G-code %d
	...

0000043b <__c.1989>:
     43b:	58 3a 25 6c 71 2c 59 3a 25 6c 71 2c 5a 3a 25 6c     X:%lq,Y:%lq,Z:%l
     44b:	71 2c 45 3a 25 6c 71 2c 46 3a 25 6c 75 00           q,E:%lq,F:%lu.

00000459 <__c.1991>:
     459:	2c 63 3a 25 6c 75 7d 0a 45 6e 64 70 6f 69 6e 74     ,c:%lu}.Endpoint
     469:	3a 20 58 3a 25 6c 64 2c 59 3a 25 6c 64 2c 5a 3a     : X:%ld,Y:%ld,Z:
     479:	25 6c 64 2c 45 3a 25 6c 64 2c 46 3a 25 6c 75 2c     %ld,E:%ld,F:%lu,
     489:	63 3a 25 6c 75 7d 00                                c:%lu}.

00000490 <__c.1994>:
     490:	46 49 52 4d 57 41 52 45 5f 4e 41 4d 45 3a 54 65     FIRMWARE_NAME:Te
     4a0:	61 63 75 70 20 46 49 52 4d 57 41 52 45 5f 55 52     acup FIRMWARE_UR
     4b0:	4c 3a 68 74 74 70 3a 2f 2f 67 69 74 68 75 62 2e     L:http://github.
     4c0:	63 6f 6d 2f 74 72 69 66 66 69 64 2f 54 65 61 63     com/triffid/Teac
     4d0:	75 70 5f 46 69 72 6d 77 61 72 65 2f 20 50 52 4f     up_Firmware/ PRO
     4e0:	54 4f 43 4f 4c 5f 56 45 52 53 49 4f 4e 3a 31 2e     TOCOL_VERSION:1.
     4f0:	30 20 4d 41 43 48 49 4e 45 5f 54 59 50 45 3a 4d     0 MACHINE_TYPE:M
     500:	65 6e 64 65 6c 20 45 58 54 52 55 44 45 52 5f 43     endel EXTRUDER_C
     510:	4f 55 4e 54 3a 25 64 20 54 45 4d 50 5f 53 45 4e     OUNT:%d TEMP_SEN
     520:	53 4f 52 5f 43 4f 55 4e 54 3a 25 64 20 48 45 41     SOR_COUNT:%d HEA
     530:	54 45 52 5f 43 4f 55 4e 54 3a 25 64 00              TER_COUNT:%d.

0000053d <__c.1998>:
     53d:	78 5f 6d 69 6e 3a 25 64 20 00                       x_min:%d .

00000547 <__c.2000>:
     547:	78 5f 6d 61 78 3a 25 64 20 00                       x_max:%d .

00000551 <__c.2002>:
     551:	79 5f 6d 69 6e 3a 25 64 20 00                       y_min:%d .

0000055b <__c.2004>:
     55b:	79 5f 6d 61 78 3a 25 64 20 00                       y_max:%d .

00000565 <__c.2006>:
     565:	7a 5f 6d 69 6e 3a 25 64 20 00                       z_min:%d .

0000056f <__c.2016>:
     56f:	45 63 68 6f 20 6f 66 66 00                          Echo off.

00000578 <__c.2019>:
     578:	45 63 68 6f 20 6f 6e 00                             Echo on.

00000580 <__c.2022>:
     580:	45 3a 20 42 61 64 20 4d 2d 63 6f 64 65 20 25 64     E: Bad M-code %d
	...

00000591 <__c.1803>:
     591:	54 7b 45 3a 25 64 2c 20 50 3a 25 64 20 2a 20 25     T{E:%d, P:%d * %
     5a1:	6c 64 20 3d 20 25 6c 64 20 2f 20 49 3a 25 64 20     ld = %ld / I:%d 
     5b1:	2a 20 25 6c 64 20 3d 20 25 6c 64 20 2f 20 44 3a     * %ld = %ld / D:
     5c1:	25 64 20 2a 20 25 6c 64 20 3d 20 25 6c 64 20 23     %d * %ld = %ld #
     5d1:	20 4f 3a 20 25 6c 64 20 3d 20 25 75 7d 0a 00         O: %ld = %u}..

000005e0 <__c.1809>:
     5e0:	50 57 4d 7b 25 75 20 3d 20 25 75 7d 0a 00           PWM{%u = %u}..

000005ee <__c.1848>:
     5ee:	50 3a 25 6c 64 20 49 3a 25 6c 64 20 44 3a 25 6c     P:%ld I:%ld D:%l
     5fe:	64 20 49 6c 69 6d 3a 25 75 20 63 72 63 3a 25 75     d Ilim:%u crc:%u
     60e:	20 00                                                .

00000610 <__c.1848>:
     610:	73 74 61 72 74 0a 6f 6b 0a 00                       start.ok..

0000061a <__c.1571>:
     61a:	30 78 00                                            0x.

0000061d <temptable>:
     61d:	01 00 fc 0c 0b 00 31 06 15 00 2d 05 1f 00 a6 04     ......1...-.....
     62d:	29 00 4d 04 33 00 0c 04 3d 00 d9 03 47 00 af 03     ).M.3...=...G...
     63d:	51 00 8c 03 5b 00 6d 03 65 00 52 03 6f 00 3a 03     Q...[.m.e.R.o.:.
     64d:	79 00 24 03 83 00 11 03 8d 00 ff 02 97 00 ee 02     y.$.............
     65d:	a1 00 de 02 ab 00 d0 02 b5 00 c2 02 bf 00 b5 02     ................
     66d:	c9 00 a9 02 d3 00 9d 02 dd 00 92 02 e7 00 88 02     ................
     67d:	f1 00 7e 02 fb 00 74 02 05 01 6b 02 0f 01 61 02     ..~...t...k...a.
     68d:	19 01 59 02 23 01 50 02 2d 01 48 02 37 01 40 02     ..Y.#.P.-.H.7.@.
     69d:	41 01 38 02 4b 01 31 02 55 01 29 02 5f 01 22 02     A.8.K.1.U.)._.".
     6ad:	69 01 1b 02 73 01 14 02 7d 01 0e 02 87 01 07 02     i...s...}.......
     6bd:	91 01 00 02 9b 01 fa 01 a5 01 f4 01 af 01 ed 01     ................
     6cd:	b9 01 e7 01 c3 01 e1 01 cd 01 db 01 d7 01 d5 01     ................
     6dd:	e1 01 d0 01 eb 01 ca 01 f5 01 c4 01 ff 01 be 01     ................
     6ed:	09 02 b9 01 13 02 b3 01 1d 02 ae 01 27 02 a8 01     ............'...
     6fd:	31 02 a3 01 3b 02 9d 01 45 02 98 01 4f 02 92 01     1...;...E...O...
     70d:	59 02 8d 01 63 02 87 01 6d 02 82 01 77 02 7c 01     Y...c...m...w.|.
     71d:	81 02 77 01 8b 02 71 01 95 02 6c 01 9f 02 66 01     ..w...q...l...f.
     72d:	a9 02 61 01 b3 02 5b 01 bd 02 55 01 c7 02 50 01     ..a...[...U...P.
     73d:	d1 02 4a 01 db 02 44 01 e5 02 3e 01 ef 02 38 01     ..J...D...>...8.
     74d:	f9 02 32 01 03 03 2c 01 0d 03 26 01 17 03 1f 01     ..2...,...&.....
     75d:	21 03 19 01 2b 03 12 01 35 03 0b 01 3f 03 04 01     !...+...5...?...
     76d:	49 03 fd 00 53 03 f5 00 5d 03 ee 00 67 03 e6 00     I...S...]...g...
     77d:	71 03 dd 00 7b 03 d4 00 85 03 cb 00 8f 03 c1 00     q...{...........
     78d:	99 03 b7 00 a3 03 ac 00 ad 03 a0 00 b7 03 93 00     ................
     79d:	c1 03 84 00 cb 03 73 00 d5 03 60 00 df 03 49 00     ......s...`...I.
     7ad:	e9 03 2b 00 f3 03 00 00 01 00 f6 0c 0b 00 2e 06     ..+.............
     7bd:	15 00 2b 05 1f 00 a4 04 29 00 4c 04 33 00 0b 04     ..+.....).L.3...
     7cd:	3d 00 d8 03 47 00 ae 03 51 00 8a 03 5b 00 6c 03     =...G...Q...[.l.
     7dd:	65 00 51 03 6f 00 39 03 79 00 23 03 83 00 10 03     e.Q.o.9.y.#.....
     7ed:	8d 00 fe 02 97 00 ed 02 a1 00 dd 02 ab 00 cf 02     ................
     7fd:	b5 00 c1 02 bf 00 b4 02 c9 00 a8 02 d3 00 9c 02     ................
     80d:	dd 00 91 02 e7 00 87 02 f1 00 7d 02 fb 00 73 02     ..........}...s.
     81d:	05 01 6a 02 0f 01 60 02 19 01 58 02 23 01 4f 02     ..j...`...X.#.O.
     82d:	2d 01 47 02 37 01 3f 02 41 01 37 02 4b 01 30 02     -.G.7.?.A.7.K.0.
     83d:	55 01 28 02 5f 01 21 02 69 01 1a 02 73 01 13 02     U.(._.!.i...s...
     84d:	7d 01 0d 02 87 01 06 02 91 01 00 02 9b 01 f9 01     }...............
     85d:	a5 01 f3 01 af 01 ed 01 b9 01 e7 01 c3 01 e0 01     ................
     86d:	cd 01 db 01 d7 01 d5 01 e1 01 cf 01 eb 01 c9 01     ................
     87d:	f5 01 c3 01 ff 01 be 01 09 02 b8 01 13 02 b2 01     ................
     88d:	1d 02 ad 01 27 02 a7 01 31 02 a2 01 3b 02 9c 01     ....'...1...;...
     89d:	45 02 97 01 4f 02 91 01 59 02 8c 01 63 02 86 01     E...O...Y...c...
     8ad:	6d 02 81 01 77 02 7c 01 81 02 76 01 8b 02 71 01     m...w.|...v...q.
     8bd:	95 02 6b 01 9f 02 66 01 a9 02 60 01 b3 02 5a 01     ..k...f...`...Z.
     8cd:	bd 02 55 01 c7 02 4f 01 d1 02 49 01 db 02 43 01     ..U...O...I...C.
     8dd:	e5 02 3d 01 ef 02 38 01 f9 02 31 01 03 03 2b 01     ..=...8...1...+.
     8ed:	0d 03 25 01 17 03 1f 01 21 03 18 01 2b 03 11 01     ..%.....!...+...
     8fd:	35 03 0b 01 3f 03 04 01 49 03 fc 00 53 03 f5 00     5...?...I...S...
     90d:	5d 03 ed 00 67 03 e5 00 71 03 dd 00 7b 03 d4 00     ]...g...q...{...
     91d:	85 03 cb 00 8f 03 c1 00 99 03 b6 00 a3 03 ab 00     ................
     92d:	ad 03 9f 00 b7 03 92 00 c1 03 83 00 cb 03 73 00     ..............s.
     93d:	d5 03 60 00 df 03 48 00 e9 03 2a 00 f2 03 04 00     ..`...H...*.....

0000094d <__c.1772>:
     94d:	70 69 6e 3a 25 64 20 52 61 77 20 41 44 43 3a 25     pin:%d Raw ADC:%
     95d:	64 20 74 61 62 6c 65 20 65 6e 74 72 79 3a 20 25     d table entry: %
     96d:	64 00                                               d.

0000096f <__c.1792>:
     96f:	20 74 65 6d 70 3a 25 64 2e 25 64 00                  temp:%d.%d.

0000097b <__c.1797>:
     97b:	20 53 65 6e 73 6f 72 3a 25 64 0a 00                  Sensor:%d..

00000987 <__c.1801>:
     987:	44 55 20 74 65 6d 70 3a 20 7b 25 64 20 25 64 20     DU temp: {%d %d 
     997:	25 64 2e 25 64 7d 00                                %d.%d}.

0000099e <__c.1806>:
     99e:	0a 00                                               ..

000009a0 <__c.1831>:
     9a0:	54 3a 00                                            T:.

000009a3 <__c.1833>:
     9a3:	20 42 3a 00                                          B:.

000009a7 <__c.1835>:
     9a7:	54 5b 25 73 75 5d 3a 00                             T[%su]:.

000009af <__c.1826>:
     9af:	25 75 2e 25 75 00 00                                %u.%u..

000009b6 <__ctors_end>:
     9b6:	11 24       	eor	r1, r1
     9b8:	1f be       	out	0x3f, r1	; 63
     9ba:	cf ef       	ldi	r28, 0xFF	; 255
     9bc:	d1 e2       	ldi	r29, 0x21	; 33
     9be:	de bf       	out	0x3e, r29	; 62
     9c0:	cd bf       	out	0x3d, r28	; 61
     9c2:	00 e0       	ldi	r16, 0x00	; 0
     9c4:	0c bf       	out	0x3c, r16	; 60

000009c6 <__do_copy_data>:
     9c6:	12 e0       	ldi	r17, 0x02	; 2
     9c8:	a0 e0       	ldi	r26, 0x00	; 0
     9ca:	b2 e0       	ldi	r27, 0x02	; 2
     9cc:	e2 e1       	ldi	r30, 0x12	; 18
     9ce:	f9 e5       	ldi	r31, 0x59	; 89
     9d0:	00 e0       	ldi	r16, 0x00	; 0
     9d2:	0b bf       	out	0x3b, r16	; 59
     9d4:	02 c0       	rjmp	.+4      	; 0x9da <__do_copy_data+0x14>
     9d6:	07 90       	elpm	r0, Z+
     9d8:	0d 92       	st	X+, r0
     9da:	a2 33       	cpi	r26, 0x32	; 50
     9dc:	b1 07       	cpc	r27, r17
     9de:	d9 f7       	brne	.-10     	; 0x9d6 <__do_copy_data+0x10>

000009e0 <__do_clear_bss>:
     9e0:	25 e0       	ldi	r18, 0x05	; 5
     9e2:	a2 e3       	ldi	r26, 0x32	; 50
     9e4:	b2 e0       	ldi	r27, 0x02	; 2
     9e6:	01 c0       	rjmp	.+2      	; 0x9ea <.do_clear_bss_start>

000009e8 <.do_clear_bss_loop>:
     9e8:	1d 92       	st	X+, r1

000009ea <.do_clear_bss_start>:
     9ea:	a3 3a       	cpi	r26, 0xA3	; 163
     9ec:	b2 07       	cpc	r27, r18
     9ee:	e1 f7       	brne	.-8      	; 0x9e8 <.do_clear_bss_loop>
     9f0:	0e 94 7c 25 	call	0x4af8	; 0x4af8 <main>
     9f4:	0c 94 87 2c 	jmp	0x590e	; 0x590e <_exit>

000009f8 <__bad_interrupt>:
     9f8:	03 cb       	rjmp	.-2554   	; 0x0 <__vectors>

000009fa <analog_init>:
	if (analog_mask > 0) {
		// clear ADC bit in power reduction register because of ADC use.
		#ifdef	PRR
			PRR &= ~MASK(PRADC);
		#elif defined PRR0
			PRR0 &= ~MASK(PRADC);
     9fa:	e4 e6       	ldi	r30, 0x64	; 100
     9fc:	f0 e0       	ldi	r31, 0x00	; 0
     9fe:	80 81       	ld	r24, Z
     a00:	8e 7f       	andi	r24, 0xFE	; 254
     a02:	80 83       	st	Z, r24
		#endif

		// select reference signal to use, set right adjusted results and select ADC input 0
		ADMUX = REFERENCE;
     a04:	80 e4       	ldi	r24, 0x40	; 64
     a06:	80 93 7c 00 	sts	0x007C, r24

		// ADC frequency must be less than 200khz or we lose precision. At 16MHz system clock, we must use the full prescale value of 128 to get an ADC clock of 125khz.
		ADCSRA = MASK(ADEN) | MASK(ADPS2) | MASK(ADPS1) | MASK(ADPS0);
     a0a:	ea e7       	ldi	r30, 0x7A	; 122
     a0c:	f0 e0       	ldi	r31, 0x00	; 0
     a0e:	87 e8       	ldi	r24, 0x87	; 135
     a10:	80 83       	st	Z, r24
		#ifdef	ADCSRB
			ADCSRB = 0;
     a12:	10 92 7b 00 	sts	0x007B, r1
		#endif

		adc_counter = 0;
     a16:	10 92 b3 04 	sts	0x04B3, r1

		// clear analog inputs in the data direction register(s)
		AIO0_DDR &= ~analog_mask;
     a1a:	80 b3       	in	r24, 0x10	; 16
     a1c:	80 bb       	out	0x10, r24	; 16
		#ifdef	AIO8_DDR
			AIO8_DDR &= ~(analog_mask >> 8);
     a1e:	a7 e0       	ldi	r26, 0x07	; 7
     a20:	b1 e0       	ldi	r27, 0x01	; 1
     a22:	8c 91       	ld	r24, X
     a24:	8f 7d       	andi	r24, 0xDF	; 223
     a26:	8c 93       	st	X, r24
		#endif

		// disable the analog inputs for digital use.
		DIDR0 = analog_mask & 0xFF;
     a28:	10 92 7e 00 	sts	0x007E, r1
		#ifdef	DIDR2
			DIDR2 = (analog_mask >> 8) & 0xFF;
     a2c:	80 e2       	ldi	r24, 0x20	; 32
     a2e:	80 93 7d 00 	sts	0x007D, r24
		#endif

		// now we start the first conversion and leave the rest to the interrupt
		ADCSRA |= MASK(ADIE) | MASK(ADSC);
     a32:	80 81       	ld	r24, Z
     a34:	88 64       	ori	r24, 0x48	; 72
     a36:	80 83       	st	Z, r24
     a38:	08 95       	ret

00000a3a <__vector_29>:

/*! Analog Interrupt

	This is where we read our analog value and store it in an array for later retrieval
*/
ISR(ADC_vect, ISR_NOBLOCK) {
     a3a:	78 94       	sei
     a3c:	1f 92       	push	r1
     a3e:	0f 92       	push	r0
     a40:	0f b6       	in	r0, 0x3f	; 63
     a42:	0f 92       	push	r0
     a44:	11 24       	eor	r1, r1
     a46:	0b b6       	in	r0, 0x3b	; 59
     a48:	0f 92       	push	r0
     a4a:	2f 93       	push	r18
     a4c:	8f 93       	push	r24
     a4e:	9f 93       	push	r25
     a50:	ef 93       	push	r30
     a52:	ff 93       	push	r31
	// save status register
	uint8_t sreg_save = SREG;
     a54:	2f b7       	in	r18, 0x3f	; 63

	// emulate free-running mode but be more deterministic about exactly which result we have, since this project has long-running interrupts
	if (analog_mask > 0) { // at least one temp sensor uses an analog channel
		// store next result
		adc_result[adc_counter] = ADC;
     a56:	e0 91 b3 04 	lds	r30, 0x04B3
     a5a:	f0 e0       	ldi	r31, 0x00	; 0
     a5c:	80 91 78 00 	lds	r24, 0x0078
     a60:	90 91 79 00 	lds	r25, 0x0079
     a64:	ee 0f       	add	r30, r30
     a66:	ff 1f       	adc	r31, r31
     a68:	ee 5c       	subi	r30, 0xCE	; 206
     a6a:	fd 4f       	sbci	r31, 0xFD	; 253
     a6c:	91 83       	std	Z+1, r25	; 0x01
     a6e:	80 83       	st	Z, r24

		// next channel
		do {
			adc_counter++;
			if (adc_counter >= sizeof(adc_channel))
				adc_counter = 0;
     a70:	10 92 b3 04 	sts	0x04B3, r1
		} while (adc_channel[adc_counter] == 255);

		// start next conversion
		ADMUX = (adc_channel[adc_counter] & 0x07) | REFERENCE;
     a74:	85 e4       	ldi	r24, 0x45	; 69
     a76:	80 93 7c 00 	sts	0x007C, r24
		#ifdef	MUX5
			if (adc_channel[adc_counter] & 0x08)
				ADCSRB |= MASK(MUX5);
     a7a:	eb e7       	ldi	r30, 0x7B	; 123
     a7c:	f0 e0       	ldi	r31, 0x00	; 0
     a7e:	80 81       	ld	r24, Z
     a80:	88 60       	ori	r24, 0x08	; 8
     a82:	80 83       	st	Z, r24
			else
				ADCSRB &= ~MASK(MUX5);
		#endif

		// After the mux has been set, start a new conversion 
		ADCSRA |= MASK(ADSC);
     a84:	ea e7       	ldi	r30, 0x7A	; 122
     a86:	f0 e0       	ldi	r31, 0x00	; 0
     a88:	80 81       	ld	r24, Z
     a8a:	80 64       	ori	r24, 0x40	; 64
     a8c:	80 83       	st	Z, r24
	}

	// restore status register
	MEMORY_BARRIER();
	SREG = sreg_save;
     a8e:	2f bf       	out	0x3f, r18	; 63
}
     a90:	ff 91       	pop	r31
     a92:	ef 91       	pop	r30
     a94:	9f 91       	pop	r25
     a96:	8f 91       	pop	r24
     a98:	2f 91       	pop	r18
     a9a:	0f 90       	pop	r0
     a9c:	0b be       	out	0x3b, r0	; 59
     a9e:	0f 90       	pop	r0
     aa0:	0f be       	out	0x3f, r0	; 63
     aa2:	0f 90       	pop	r0
     aa4:	1f 90       	pop	r1
     aa6:	18 95       	reti

00000aa8 <analog_read>:
	if (analog_mask > 0) {
		uint16_t r;

		uint8_t sreg;
		// save interrupt flag
		sreg = SREG;
     aa8:	9f b7       	in	r25, 0x3f	; 63
		// disable interrupts
		cli();
     aaa:	f8 94       	cli

		// atomic 16-bit copy
		r = adc_result[index];
     aac:	e8 2f       	mov	r30, r24
     aae:	f0 e0       	ldi	r31, 0x00	; 0
     ab0:	ee 0f       	add	r30, r30
     ab2:	ff 1f       	adc	r31, r31
     ab4:	ee 5c       	subi	r30, 0xCE	; 206
     ab6:	fd 4f       	sbci	r31, 0xFD	; 253
     ab8:	20 81       	ld	r18, Z
     aba:	31 81       	ldd	r19, Z+1	; 0x01

		// restore interrupt flag
		SREG = sreg;
     abc:	9f bf       	out	0x3f, r25	; 63

		return r;
	} else {
		return 0;
	}
}
     abe:	82 2f       	mov	r24, r18
     ac0:	93 2f       	mov	r25, r19
     ac2:	08 95       	ret

00000ac4 <clock>:

/*! do reoccuring stuff

	call it occasionally in busy loops
*/
void clock() {
     ac4:	5f 92       	push	r5
     ac6:	6f 92       	push	r6
     ac8:	7f 92       	push	r7
     aca:	8f 92       	push	r8
     acc:	9f 92       	push	r9
     ace:	af 92       	push	r10
     ad0:	bf 92       	push	r11
     ad2:	cf 92       	push	r12
     ad4:	df 92       	push	r13
     ad6:	ef 92       	push	r14
     ad8:	ff 92       	push	r15
     ada:	0f 93       	push	r16
     adc:	1f 93       	push	r17
     ade:	cf 93       	push	r28
     ae0:	df 93       	push	r29
	ifclock(clock_flag_10ms) {
     ae2:	80 91 c7 04 	lds	r24, 0x04C7
     ae6:	88 23       	and	r24, r24
     ae8:	09 f4       	brne	.+2      	; 0xaec <clock+0x28>
     aea:	e9 c0       	rjmp	.+466    	; 0xcbe <clock+0x1fa>

	ifclock(clock_flag_1s) {
		if (DEBUG_POSITION && (debug_flags & DEBUG_POSITION)) {
			// current position
			update_current_position();
			sersendf_P(PSTR("Pos: %lq,%lq,%lq,%lq,%lu\n"), current_position.X, current_position.Y, current_position.Z, current_position.E, current_position.F);
     aec:	0f 2e       	mov	r0, r31
     aee:	f6 e7       	ldi	r31, 0x76	; 118
     af0:	af 2e       	mov	r10, r31
     af2:	f2 e0       	ldi	r31, 0x02	; 2
     af4:	bf 2e       	mov	r11, r31
     af6:	f0 2d       	mov	r31, r0
     af8:	0f 2e       	mov	r0, r31
     afa:	f2 e7       	ldi	r31, 0x72	; 114
     afc:	cf 2e       	mov	r12, r31
     afe:	f2 e0       	ldi	r31, 0x02	; 2
     b00:	df 2e       	mov	r13, r31
     b02:	f0 2d       	mov	r31, r0
     b04:	0f 2e       	mov	r0, r31
     b06:	fe e6       	ldi	r31, 0x6E	; 110
     b08:	ef 2e       	mov	r14, r31
     b0a:	f2 e0       	ldi	r31, 0x02	; 2
     b0c:	ff 2e       	mov	r15, r31
     b0e:	f0 2d       	mov	r31, r0
     b10:	0a e6       	ldi	r16, 0x6A	; 106
     b12:	12 e0       	ldi	r17, 0x02	; 2
     b14:	c6 e6       	ldi	r28, 0x66	; 102
     b16:	d2 e0       	ldi	r29, 0x02	; 2
*/
static void clock_10ms(void) {
	// reset watchdog
	wd_reset();

	temp_tick();
     b18:	0e 94 9d 28 	call	0x513a	; 0x513a <temp_sensor_tick>

	ifclock(clock_flag_250ms) {
     b1c:	80 91 c6 04 	lds	r24, 0x04C6
     b20:	88 23       	and	r24, r24
     b22:	09 f4       	brne	.+2      	; 0xb26 <clock+0x62>
     b24:	c6 c0       	rjmp	.+396    	; 0xcb2 <clock+0x1ee>

	ifclock(clock_flag_1s) {
		if (DEBUG_POSITION && (debug_flags & DEBUG_POSITION)) {
			// current position
			update_current_position();
			sersendf_P(PSTR("Pos: %lq,%lq,%lq,%lq,%lu\n"), current_position.X, current_position.Y, current_position.Z, current_position.E, current_position.F);
     b26:	0f 2e       	mov	r0, r31
     b28:	fc e6       	ldi	r31, 0x6C	; 108
     b2a:	6f 2e       	mov	r6, r31
     b2c:	f3 e0       	ldi	r31, 0x03	; 3
     b2e:	7f 2e       	mov	r7, r31
     b30:	f0 2d       	mov	r31, r0

			// target position
			sersendf_P(PSTR("Dst: %lq,%lq,%lq,%lq,%lu\n"), movebuffer[mb_tail].endpoint.X, movebuffer[mb_tail].endpoint.Y, movebuffer[mb_tail].endpoint.Z, movebuffer[mb_tail].endpoint.E, movebuffer[mb_tail].endpoint.F);
     b32:	0f 2e       	mov	r0, r31
     b34:	fc e3       	ldi	r31, 0x3C	; 60
     b36:	5f 2e       	mov	r5, r31
     b38:	f0 2d       	mov	r31, r0
/*!	do stuff every 1/4 second

	called from clock_10ms(), do not call directly
*/
static void clock_250ms(void) {
  if (heaters_all_zero()) {
     b3a:	0e 94 dd 21 	call	0x43ba	; 0x43ba <heaters_all_zero>
     b3e:	88 23       	and	r24, r24
     b40:	79 f0       	breq	.+30     	; 0xb60 <clock+0x9c>
		if (psu_timeout > (30 * 4)) {
     b42:	80 91 bf 04 	lds	r24, 0x04BF
     b46:	89 37       	cpi	r24, 0x79	; 121
     b48:	18 f0       	brcs	.+6      	; 0xb50 <clock+0x8c>
			power_off();
     b4a:	0e 94 94 25 	call	0x4b28	; 0x4b28 <power_off>
     b4e:	08 c0       	rjmp	.+16     	; 0xb60 <clock+0x9c>
		}
		else {
      ATOMIC_START
     b50:	8f b7       	in	r24, 0x3f	; 63
     b52:	f8 94       	cli
        psu_timeout++;
     b54:	90 91 bf 04 	lds	r25, 0x04BF
     b58:	9f 5f       	subi	r25, 0xFF	; 255
     b5a:	90 93 bf 04 	sts	0x04BF, r25
      ATOMIC_END
     b5e:	8f bf       	out	0x3f, r24	; 63
		}
	}

	ifclock(clock_flag_1s) {
     b60:	80 91 c5 04 	lds	r24, 0x04C5
     b64:	88 23       	and	r24, r24
     b66:	09 f4       	brne	.+2      	; 0xb6a <clock+0xa6>
     b68:	9e c0       	rjmp	.+316    	; 0xca6 <clock+0x1e2>
			// current position
			update_current_position();
			sersendf_P(PSTR("Pos: %lq,%lq,%lq,%lq,%lu\n"), current_position.X, current_position.Y, current_position.Z, current_position.E, current_position.F);

			// target position
			sersendf_P(PSTR("Dst: %lq,%lq,%lq,%lq,%lu\n"), movebuffer[mb_tail].endpoint.X, movebuffer[mb_tail].endpoint.Y, movebuffer[mb_tail].endpoint.Z, movebuffer[mb_tail].endpoint.E, movebuffer[mb_tail].endpoint.F);
     b6a:	0f 2e       	mov	r0, r31
     b6c:	f6 e8       	ldi	r31, 0x86	; 134
     b6e:	8f 2e       	mov	r8, r31
     b70:	f3 e0       	ldi	r31, 0x03	; 3
     b72:	9f 2e       	mov	r9, r31
     b74:	f0 2d       	mov	r31, r0
      ATOMIC_END
		}
	}

	ifclock(clock_flag_1s) {
		if (DEBUG_POSITION && (debug_flags & DEBUG_POSITION)) {
     b76:	80 91 cf 04 	lds	r24, 0x04CF
     b7a:	82 ff       	sbrs	r24, 2
     b7c:	8e c0       	rjmp	.+284    	; 0xc9a <clock+0x1d6>
			// current position
			update_current_position();
     b7e:	0e 94 3d 10 	call	0x207a	; 0x207a <update_current_position>
			sersendf_P(PSTR("Pos: %lq,%lq,%lq,%lq,%lu\n"), current_position.X, current_position.Y, current_position.Z, current_position.E, current_position.F);
     b82:	f5 01       	movw	r30, r10
     b84:	83 81       	ldd	r24, Z+3	; 0x03
     b86:	8f 93       	push	r24
     b88:	82 81       	ldd	r24, Z+2	; 0x02
     b8a:	8f 93       	push	r24
     b8c:	81 81       	ldd	r24, Z+1	; 0x01
     b8e:	8f 93       	push	r24
     b90:	80 81       	ld	r24, Z
     b92:	8f 93       	push	r24
     b94:	f6 01       	movw	r30, r12
     b96:	83 81       	ldd	r24, Z+3	; 0x03
     b98:	8f 93       	push	r24
     b9a:	82 81       	ldd	r24, Z+2	; 0x02
     b9c:	8f 93       	push	r24
     b9e:	81 81       	ldd	r24, Z+1	; 0x01
     ba0:	8f 93       	push	r24
     ba2:	80 81       	ld	r24, Z
     ba4:	8f 93       	push	r24
     ba6:	f7 01       	movw	r30, r14
     ba8:	83 81       	ldd	r24, Z+3	; 0x03
     baa:	8f 93       	push	r24
     bac:	82 81       	ldd	r24, Z+2	; 0x02
     bae:	8f 93       	push	r24
     bb0:	81 81       	ldd	r24, Z+1	; 0x01
     bb2:	8f 93       	push	r24
     bb4:	80 81       	ld	r24, Z
     bb6:	8f 93       	push	r24
     bb8:	f8 01       	movw	r30, r16
     bba:	83 81       	ldd	r24, Z+3	; 0x03
     bbc:	8f 93       	push	r24
     bbe:	82 81       	ldd	r24, Z+2	; 0x02
     bc0:	8f 93       	push	r24
     bc2:	81 81       	ldd	r24, Z+1	; 0x01
     bc4:	8f 93       	push	r24
     bc6:	80 81       	ld	r24, Z
     bc8:	8f 93       	push	r24
     bca:	8b 81       	ldd	r24, Y+3	; 0x03
     bcc:	8f 93       	push	r24
     bce:	8a 81       	ldd	r24, Y+2	; 0x02
     bd0:	8f 93       	push	r24
     bd2:	89 81       	ldd	r24, Y+1	; 0x01
     bd4:	8f 93       	push	r24
     bd6:	88 81       	ld	r24, Y
     bd8:	8f 93       	push	r24
     bda:	7f 92       	push	r7
     bdc:	6f 92       	push	r6
     bde:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>

			// target position
			sersendf_P(PSTR("Dst: %lq,%lq,%lq,%lq,%lu\n"), movebuffer[mb_tail].endpoint.X, movebuffer[mb_tail].endpoint.Y, movebuffer[mb_tail].endpoint.Z, movebuffer[mb_tail].endpoint.E, movebuffer[mb_tail].endpoint.F);
     be2:	e0 91 bc 04 	lds	r30, 0x04BC
     be6:	5e 9e       	mul	r5, r30
     be8:	f0 01       	movw	r30, r0
     bea:	11 24       	eor	r1, r1
     bec:	eb 55       	subi	r30, 0x5B	; 91
     bee:	fd 4f       	sbci	r31, 0xFD	; 253
     bf0:	df 01       	movw	r26, r30
     bf2:	50 96       	adiw	r26, 0x10	; 16
     bf4:	13 96       	adiw	r26, 0x03	; 3
     bf6:	8c 91       	ld	r24, X
     bf8:	13 97       	sbiw	r26, 0x03	; 3
     bfa:	8f 93       	push	r24
     bfc:	12 96       	adiw	r26, 0x02	; 2
     bfe:	8c 91       	ld	r24, X
     c00:	12 97       	sbiw	r26, 0x02	; 2
     c02:	8f 93       	push	r24
     c04:	11 96       	adiw	r26, 0x01	; 1
     c06:	8c 91       	ld	r24, X
     c08:	8f 93       	push	r24
     c0a:	80 89       	ldd	r24, Z+16	; 0x10
     c0c:	8f 93       	push	r24
     c0e:	df 01       	movw	r26, r30
     c10:	1c 96       	adiw	r26, 0x0c	; 12
     c12:	13 96       	adiw	r26, 0x03	; 3
     c14:	8c 91       	ld	r24, X
     c16:	13 97       	sbiw	r26, 0x03	; 3
     c18:	8f 93       	push	r24
     c1a:	12 96       	adiw	r26, 0x02	; 2
     c1c:	8c 91       	ld	r24, X
     c1e:	12 97       	sbiw	r26, 0x02	; 2
     c20:	8f 93       	push	r24
     c22:	11 96       	adiw	r26, 0x01	; 1
     c24:	8c 91       	ld	r24, X
     c26:	8f 93       	push	r24
     c28:	84 85       	ldd	r24, Z+12	; 0x0c
     c2a:	8f 93       	push	r24
     c2c:	df 01       	movw	r26, r30
     c2e:	18 96       	adiw	r26, 0x08	; 8
     c30:	13 96       	adiw	r26, 0x03	; 3
     c32:	8c 91       	ld	r24, X
     c34:	13 97       	sbiw	r26, 0x03	; 3
     c36:	8f 93       	push	r24
     c38:	12 96       	adiw	r26, 0x02	; 2
     c3a:	8c 91       	ld	r24, X
     c3c:	12 97       	sbiw	r26, 0x02	; 2
     c3e:	8f 93       	push	r24
     c40:	11 96       	adiw	r26, 0x01	; 1
     c42:	8c 91       	ld	r24, X
     c44:	8f 93       	push	r24
     c46:	80 85       	ldd	r24, Z+8	; 0x08
     c48:	8f 93       	push	r24
     c4a:	df 01       	movw	r26, r30
     c4c:	14 96       	adiw	r26, 0x04	; 4
     c4e:	13 96       	adiw	r26, 0x03	; 3
     c50:	8c 91       	ld	r24, X
     c52:	13 97       	sbiw	r26, 0x03	; 3
     c54:	8f 93       	push	r24
     c56:	12 96       	adiw	r26, 0x02	; 2
     c58:	8c 91       	ld	r24, X
     c5a:	12 97       	sbiw	r26, 0x02	; 2
     c5c:	8f 93       	push	r24
     c5e:	11 96       	adiw	r26, 0x01	; 1
     c60:	8c 91       	ld	r24, X
     c62:	8f 93       	push	r24
     c64:	84 81       	ldd	r24, Z+4	; 0x04
     c66:	8f 93       	push	r24
     c68:	83 81       	ldd	r24, Z+3	; 0x03
     c6a:	8f 93       	push	r24
     c6c:	82 81       	ldd	r24, Z+2	; 0x02
     c6e:	8f 93       	push	r24
     c70:	81 81       	ldd	r24, Z+1	; 0x01
     c72:	8f 93       	push	r24
     c74:	80 81       	ld	r24, Z
     c76:	8f 93       	push	r24
     c78:	9f 92       	push	r9
     c7a:	8f 92       	push	r8
     c7c:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>

			// Queue
			print_queue();
     c80:	8d b7       	in	r24, 0x3d	; 61
     c82:	9e b7       	in	r25, 0x3e	; 62
     c84:	8c 96       	adiw	r24, 0x2c	; 44
     c86:	0f b6       	in	r0, 0x3f	; 63
     c88:	f8 94       	cli
     c8a:	9e bf       	out	0x3e, r25	; 62
     c8c:	0f be       	out	0x3f, r0	; 63
     c8e:	8d bf       	out	0x3d, r24	; 61
     c90:	0e 94 31 15 	call	0x2a62	; 0x2a62 <print_queue>

			// newline
			serial_writechar('\n');
     c94:	8a e0       	ldi	r24, 0x0A	; 10
     c96:	0e 94 40 26 	call	0x4c80	; 0x4c80 <serial_writechar>
        psu_timeout++;
      ATOMIC_END
		}
	}

	ifclock(clock_flag_1s) {
     c9a:	10 92 c5 04 	sts	0x04C5, r1
     c9e:	80 91 c5 04 	lds	r24, 0x04C5
     ca2:	81 11       	cpse	r24, r1
     ca4:	68 cf       	rjmp	.-304    	; 0xb76 <clock+0xb2>
	// reset watchdog
	wd_reset();

	temp_tick();

	ifclock(clock_flag_250ms) {
     ca6:	10 92 c6 04 	sts	0x04C6, r1
     caa:	80 91 c6 04 	lds	r24, 0x04C6
     cae:	81 11       	cpse	r24, r1
     cb0:	44 cf       	rjmp	.-376    	; 0xb3a <clock+0x76>
/*! do reoccuring stuff

	call it occasionally in busy loops
*/
void clock() {
	ifclock(clock_flag_10ms) {
     cb2:	10 92 c7 04 	sts	0x04C7, r1
     cb6:	80 91 c7 04 	lds	r24, 0x04C7
     cba:	81 11       	cpse	r24, r1
     cbc:	2d cf       	rjmp	.-422    	; 0xb18 <clock+0x54>
		clock_10ms();
	}
}
     cbe:	df 91       	pop	r29
     cc0:	cf 91       	pop	r28
     cc2:	1f 91       	pop	r17
     cc4:	0f 91       	pop	r16
     cc6:	ff 90       	pop	r15
     cc8:	ef 90       	pop	r14
     cca:	df 90       	pop	r13
     ccc:	cf 90       	pop	r12
     cce:	bf 90       	pop	r11
     cd0:	af 90       	pop	r10
     cd2:	9f 90       	pop	r9
     cd4:	8f 90       	pop	r8
     cd6:	7f 90       	pop	r7
     cd8:	6f 90       	pop	r6
     cda:	5f 90       	pop	r5
     cdc:	08 95       	ret

00000cde <crc_block>:
	\param len length of data
	\return uint16 crc16 of passed data

	uses avr-libc's optimised crc16 routine
*/
uint16_t	crc_block(void *data, uint16_t len) {
     cde:	fc 01       	movw	r30, r24
	uint16_t	crc = 0xfeed;
	for (; len; data++, len--) {
     ce0:	61 15       	cp	r22, r1
     ce2:	71 05       	cpc	r23, r1
     ce4:	01 f1       	breq	.+64     	; 0xd26 <crc_block+0x48>
	\param len length of data
	\return uint16 crc16 of passed data

	uses avr-libc's optimised crc16 routine
*/
uint16_t	crc_block(void *data, uint16_t len) {
     ce6:	68 0f       	add	r22, r24
     ce8:	79 1f       	adc	r23, r25
	uint16_t	crc = 0xfeed;
     cea:	2d ee       	ldi	r18, 0xED	; 237
     cec:	3e ef       	ldi	r19, 0xFE	; 254
_crc16_update(uint16_t __crc, uint8_t __data)
{
	uint8_t __tmp;
	uint16_t __ret;

	__asm__ __volatile__ (
     cee:	81 91       	ld	r24, Z+
     cf0:	28 27       	eor	r18, r24
     cf2:	82 2f       	mov	r24, r18
     cf4:	82 95       	swap	r24
     cf6:	82 27       	eor	r24, r18
     cf8:	08 2e       	mov	r0, r24
     cfa:	86 95       	lsr	r24
     cfc:	86 95       	lsr	r24
     cfe:	80 25       	eor	r24, r0
     d00:	08 2e       	mov	r0, r24
     d02:	86 95       	lsr	r24
     d04:	80 25       	eor	r24, r0
     d06:	87 70       	andi	r24, 0x07	; 7
     d08:	02 2e       	mov	r0, r18
     d0a:	23 2f       	mov	r18, r19
     d0c:	86 95       	lsr	r24
     d0e:	07 94       	ror	r0
     d10:	87 95       	ror	r24
     d12:	30 2d       	mov	r19, r0
     d14:	28 27       	eor	r18, r24
     d16:	06 94       	lsr	r0
     d18:	87 95       	ror	r24
     d1a:	30 25       	eor	r19, r0
     d1c:	28 27       	eor	r18, r24
	for (; len; data++, len--) {
     d1e:	e6 17       	cp	r30, r22
     d20:	f7 07       	cpc	r31, r23
     d22:	29 f7       	brne	.-54     	; 0xcee <crc_block+0x10>
     d24:	02 c0       	rjmp	.+4      	; 0xd2a <crc_block+0x4c>
	\return uint16 crc16 of passed data

	uses avr-libc's optimised crc16 routine
*/
uint16_t	crc_block(void *data, uint16_t len) {
	uint16_t	crc = 0xfeed;
     d26:	2d ee       	ldi	r18, 0xED	; 237
     d28:	3e ef       	ldi	r19, 0xFE	; 254
	for (; len; data++, len--) {
		crc = _crc16_update(crc, *((uint8_t *) data));
	}
	return crc;
}
     d2a:	82 2f       	mov	r24, r18
     d2c:	93 2f       	mov	r25, r19
     d2e:	08 95       	ret

00000d30 <dda_init>:

/*! Inititalise DDA movement structures
*/
void dda_init(void) {
	// set up default feedrate
	if (startpoint.F == 0)
     d30:	80 91 a0 02 	lds	r24, 0x02A0
     d34:	90 91 a1 02 	lds	r25, 0x02A1
     d38:	a0 91 a2 02 	lds	r26, 0x02A2
     d3c:	b0 91 a3 02 	lds	r27, 0x02A3
     d40:	89 2b       	or	r24, r25
     d42:	8a 2b       	or	r24, r26
     d44:	8b 2b       	or	r24, r27
     d46:	a1 f4       	brne	.+40     	; 0xd70 <dda_init+0x40>
		startpoint.F = next_target.target.F = SEARCH_FEEDRATE_Z;
     d48:	81 e0       	ldi	r24, 0x01	; 1
     d4a:	90 e0       	ldi	r25, 0x00	; 0
     d4c:	a0 e0       	ldi	r26, 0x00	; 0
     d4e:	b0 e0       	ldi	r27, 0x00	; 0
     d50:	80 93 9a 04 	sts	0x049A, r24
     d54:	90 93 9b 04 	sts	0x049B, r25
     d58:	a0 93 9c 04 	sts	0x049C, r26
     d5c:	b0 93 9d 04 	sts	0x049D, r27
     d60:	80 93 a0 02 	sts	0x02A0, r24
     d64:	90 93 a1 02 	sts	0x02A1, r25
     d68:	a0 93 a2 02 	sts	0x02A2, r26
     d6c:	b0 93 a3 02 	sts	0x02A3, r27

	#ifdef ACCELERATION_RAMPING
		move_state.n = 1;
     d70:	81 e0       	ldi	r24, 0x01	; 1
     d72:	90 e0       	ldi	r25, 0x00	; 0
     d74:	a0 e0       	ldi	r26, 0x00	; 0
     d76:	b0 e0       	ldi	r27, 0x00	; 0
     d78:	80 93 5c 02 	sts	0x025C, r24
     d7c:	90 93 5d 02 	sts	0x025D, r25
     d80:	a0 93 5e 02 	sts	0x025E, r26
     d84:	b0 93 5f 02 	sts	0x025F, r27
		move_state.c = ((uint32_t)((double)F_CPU / sqrt((double)(STEPS_PER_M_X * ACCELERATION / 1000.)))) << 8;
     d88:	80 e0       	ldi	r24, 0x00	; 0
     d8a:	93 e6       	ldi	r25, 0x63	; 99
     d8c:	a8 e5       	ldi	r26, 0x58	; 88
     d8e:	b0 e0       	ldi	r27, 0x00	; 0
     d90:	80 93 58 02 	sts	0x0258, r24
     d94:	90 93 59 02 	sts	0x0259, r25
     d98:	a0 93 5a 02 	sts	0x025A, r26
     d9c:	b0 93 5b 02 	sts	0x025B, r27
	
		// timer 1 is used for DCXYmotor
		#ifdef DCXYMOT
		// setup PWM timers: fast PWM
		// Warning 2012-01-11: these are not consistent across all AVRs
				TCCR1A = MASK(WGM10);
     da0:	e0 e8       	ldi	r30, 0x80	; 128
     da2:	f0 e0       	ldi	r31, 0x00	; 0
     da4:	81 e0       	ldi	r24, 0x01	; 1
     da6:	80 83       	st	Z, r24
				// PWM frequencies in TCCR0B, see page 108 of the ATmega644 reference.
				TCCR1B = MASK(CS10); // F_CPU / 256 (about 78(62.5) kHz on a 20(16) MHz chip)
     da8:	80 93 81 00 	sts	0x0081, r24
				//TCCR0B = MASK(CS10) | MASK(CS12); // F_CPU / 256 / 1024  (about 76(61) Hz)
				TIMSK1 = 0;
     dac:	10 92 6f 00 	sts	0x006F, r1
				OCR1A = 0;
     db0:	10 92 89 00 	sts	0x0089, r1
     db4:	10 92 88 00 	sts	0x0088, r1
				OCR1B = 0;
     db8:	10 92 8b 00 	sts	0x008B, r1
     dbc:	10 92 8a 00 	sts	0x008A, r1
				OCR1C = 0;
     dc0:	10 92 8d 00 	sts	0x008D, r1
     dc4:	10 92 8c 00 	sts	0x008C, r1
				TCCR1A |= MASK(COM1A1);
     dc8:	90 81       	ld	r25, Z
     dca:	90 68       	ori	r25, 0x80	; 128
     dcc:	90 83       	st	Z, r25
				//TCCR3A = MASK(WGM30);
				TCCR3A = MASK(WGM30);
     dce:	e0 e9       	ldi	r30, 0x90	; 144
     dd0:	f0 e0       	ldi	r31, 0x00	; 0
     dd2:	80 83       	st	Z, r24
				TCCR3B = MASK(CS30);
     dd4:	80 93 91 00 	sts	0x0091, r24
				TIMSK3 = 0;
     dd8:	10 92 71 00 	sts	0x0071, r1
				OCR3A = 0;
     ddc:	10 92 99 00 	sts	0x0099, r1
     de0:	10 92 98 00 	sts	0x0098, r1
				OCR3B = 0;
     de4:	10 92 9b 00 	sts	0x009B, r1
     de8:	10 92 9a 00 	sts	0x009A, r1
				OCR3C = 0;
     dec:	10 92 9d 00 	sts	0x009D, r1
     df0:	10 92 9c 00 	sts	0x009C, r1
				TCCR3A |= MASK(COM3C1);
     df4:	80 81       	ld	r24, Z
     df6:	88 60       	ori	r24, 0x08	; 8
     df8:	80 83       	st	Z, r24
		
		SET_OUTPUT(PE5);
     dfa:	6d 9a       	sbi	0x0d, 5	; 13
		SET_OUTPUT(PB5);
     dfc:	25 9a       	sbi	0x04, 5	; 4
		SET_OUTPUT(PB6);
     dfe:	26 9a       	sbi	0x04, 6	; 4
		SET_OUTPUT(PB7);
     e00:	27 9a       	sbi	0x04, 7	; 4
		WRITE(PB6,1);
     e02:	2e 9a       	sbi	0x05, 6	; 5
		WRITE(PB7,1);
     e04:	2f 9a       	sbi	0x05, 7	; 5
		WRITE(PB6,0);
     e06:	2e 98       	cbi	0x05, 6	; 5
		WRITE(PB7,0);
     e08:	2f 98       	cbi	0x05, 7	; 5
		//Channel A ENCODER
		DDRD &= ~(1 << DDD2);     // Clear the PD2 pin
     e0a:	52 98       	cbi	0x0a, 2	; 10
		 // PD2 (PCINT2 pin) is now an input
		PORTD |= (1 << 2);    // turn On the Pull-up
     e0c:	5a 9a       	sbi	0x0b, 2	; 11
		// PD2 is now an input with pull-up enabled
		DDRD &= ~(1 << DDD3);     // Clear the PD2 pin
     e0e:	53 98       	cbi	0x0a, 3	; 10
		// PD2 (PCINT3 pin) is now an input
		PORTD |= (1 << 3);    // turn On the Pull-up
     e10:	5b 9a       	sbi	0x0b, 3	; 11
		// PD2 is now an input with pull-up enabled
		EICRA |= (1 << ISC20 | 1 << ISC21);    // set INT2 to trigger on rising logic change
     e12:	e9 e6       	ldi	r30, 0x69	; 105
     e14:	f0 e0       	ldi	r31, 0x00	; 0
     e16:	80 81       	ld	r24, Z
     e18:	80 63       	ori	r24, 0x30	; 48
     e1a:	80 83       	st	Z, r24
		EICRA |= (1 << ISC30 | 1 << ISC31);    // set INT3 to trigger on rising logic change
     e1c:	80 81       	ld	r24, Z
     e1e:	80 6c       	ori	r24, 0xC0	; 192
     e20:	80 83       	st	Z, r24
        EIMSK |= (1 << INT2);     // Turns on INT2
     e22:	ea 9a       	sbi	0x1d, 2	; 29
		EIMSK |= (1 << INT3);     // Turns on INT3
     e24:	eb 9a       	sbi	0x1d, 3	; 29
		
		// X ENCODER
		DDRL &= ~(1 << DDL4);   // Clear the PL4 pin   Channel B  X
     e26:	aa e0       	ldi	r26, 0x0A	; 10
     e28:	b1 e0       	ldi	r27, 0x01	; 1
     e2a:	8c 91       	ld	r24, X
     e2c:	8f 7e       	andi	r24, 0xEF	; 239
     e2e:	8c 93       	st	X, r24
								// PL4  is now an input
		PORTL |= (1 << 4);		// turn On the Pull-up
     e30:	eb e0       	ldi	r30, 0x0B	; 11
     e32:	f1 e0       	ldi	r31, 0x01	; 1
     e34:	80 81       	ld	r24, Z
     e36:	80 61       	ori	r24, 0x10	; 16
     e38:	80 83       	st	Z, r24
								// PL4 (X channel B) pin 45 is now an input with pull-up enabled
		DDRL &= ~(1 << DDL2);   // Clear the PL2 pin
     e3a:	8c 91       	ld	r24, X
     e3c:	8b 7f       	andi	r24, 0xFB	; 251
     e3e:	8c 93       	st	X, r24
								// PL2 is now an input
		PORTL |= (1 << 2);		// turn On the Pull-up
     e40:	80 81       	ld	r24, Z
     e42:	84 60       	ori	r24, 0x04	; 4
     e44:	80 83       	st	Z, r24
								// PL2 (X channel I) pin 47  is now an input with pull-up enabled
		
		//Y ENCODER
		DDRG &= ~(1 << DDG0);	// Clear the PG0 pin
     e46:	98 98       	cbi	0x13, 0	; 19
								// PG0 (Y channel B) pin 41  is now an input
		PORTG |= (1 << 0);		// turn On the Pull-up
     e48:	a0 9a       	sbi	0x14, 0	; 20
								// PD2 is now an input with pull-up enabled
		DDRL &= ~(1 << DDL6);	// Clear the PG2 pin
     e4a:	8c 91       	ld	r24, X
     e4c:	8f 7b       	andi	r24, 0xBF	; 191
     e4e:	8c 93       	st	X, r24
								// PD2 (Y channel I) pin 43 is now an input
		PORTL |= (1 << 6);		// turn On the Pull-up
     e50:	80 81       	ld	r24, Z
     e52:	80 64       	ori	r24, 0x40	; 64
     e54:	80 83       	st	Z, r24
     e56:	08 95       	ret

00000e58 <dda_new_startpoint>:

/*! Distribute a new startpoint to DDA's internal structures without any movement.

	This is needed for example after homing or a G92. The new location must be in startpoint already.
*/
void dda_new_startpoint(void) {
     e58:	af 92       	push	r10
     e5a:	bf 92       	push	r11
     e5c:	cf 92       	push	r12
     e5e:	df 92       	push	r13
     e60:	ef 92       	push	r14
     e62:	ff 92       	push	r15
     e64:	0f 93       	push	r16
     e66:	1f 93       	push	r17
// it might be worth pre-calculating muldivQR()'s qn and rn in dda_init()
// as soon as STEPS_PER_M_{XYZE} is no longer a compile-time variable.

static int32_t um_to_steps_x(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_x(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_X / 1000000UL,
     e68:	60 91 90 02 	lds	r22, 0x0290
     e6c:	70 91 91 02 	lds	r23, 0x0291
     e70:	80 91 92 02 	lds	r24, 0x0292
     e74:	90 91 93 02 	lds	r25, 0x0293
     e78:	0f 2e       	mov	r0, r31
     e7a:	f0 e4       	ldi	r31, 0x40	; 64
     e7c:	af 2e       	mov	r10, r31
     e7e:	f2 e4       	ldi	r31, 0x42	; 66
     e80:	bf 2e       	mov	r11, r31
     e82:	ff e0       	ldi	r31, 0x0F	; 15
     e84:	cf 2e       	mov	r12, r31
     e86:	d1 2c       	mov	r13, r1
     e88:	f0 2d       	mov	r31, r0
     e8a:	10 e2       	ldi	r17, 0x20	; 32
     e8c:	e1 2e       	mov	r14, r17
     e8e:	11 ea       	ldi	r17, 0xA1	; 161
     e90:	f1 2e       	mov	r15, r17
     e92:	07 e0       	ldi	r16, 0x07	; 7
     e94:	10 e0       	ldi	r17, 0x00	; 0
     e96:	20 e0       	ldi	r18, 0x00	; 0
     e98:	30 e0       	ldi	r19, 0x00	; 0
     e9a:	a9 01       	movw	r20, r18
     e9c:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <muldivQR>
	startpoint_steps.X = um_to_steps_x(startpoint.X);
     ea0:	60 93 7b 02 	sts	0x027B, r22
     ea4:	70 93 7c 02 	sts	0x027C, r23
     ea8:	80 93 7d 02 	sts	0x027D, r24
     eac:	90 93 7e 02 	sts	0x027E, r25
                    STEPS_PER_M_X % 1000000UL, 1000000UL);
}

static int32_t um_to_steps_y(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_y(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_Y / 1000000UL,
     eb0:	60 91 94 02 	lds	r22, 0x0294
     eb4:	70 91 95 02 	lds	r23, 0x0295
     eb8:	80 91 96 02 	lds	r24, 0x0296
     ebc:	90 91 97 02 	lds	r25, 0x0297
     ec0:	20 e0       	ldi	r18, 0x00	; 0
     ec2:	30 e0       	ldi	r19, 0x00	; 0
     ec4:	a9 01       	movw	r20, r18
     ec6:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <muldivQR>
	startpoint_steps.Y = um_to_steps_y(startpoint.Y);
     eca:	60 93 7f 02 	sts	0x027F, r22
     ece:	70 93 80 02 	sts	0x0280, r23
     ed2:	80 93 81 02 	sts	0x0281, r24
     ed6:	90 93 82 02 	sts	0x0282, r25
                    STEPS_PER_M_Y % 1000000UL, 1000000UL);
}

static int32_t um_to_steps_z(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_z(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_Z / 1000000UL,
     eda:	60 91 98 02 	lds	r22, 0x0298
     ede:	70 91 99 02 	lds	r23, 0x0299
     ee2:	80 91 9a 02 	lds	r24, 0x029A
     ee6:	90 91 9b 02 	lds	r25, 0x029B
     eea:	18 e1       	ldi	r17, 0x18	; 24
     eec:	e1 2e       	mov	r14, r17
     eee:	17 e1       	ldi	r17, 0x17	; 23
     ef0:	f1 2e       	mov	r15, r17
     ef2:	05 e0       	ldi	r16, 0x05	; 5
     ef4:	10 e0       	ldi	r17, 0x00	; 0
     ef6:	23 e0       	ldi	r18, 0x03	; 3
     ef8:	30 e0       	ldi	r19, 0x00	; 0
     efa:	40 e0       	ldi	r20, 0x00	; 0
     efc:	50 e0       	ldi	r21, 0x00	; 0
     efe:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <muldivQR>
	startpoint_steps.Z = um_to_steps_z(startpoint.Z);
     f02:	60 93 83 02 	sts	0x0283, r22
     f06:	70 93 84 02 	sts	0x0284, r23
     f0a:	80 93 85 02 	sts	0x0285, r24
     f0e:	90 93 86 02 	sts	0x0286, r25
                    STEPS_PER_M_Z % 1000000UL, 1000000UL);
}

static int32_t um_to_steps_e(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_e(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_E / 1000000UL,
     f12:	60 91 9c 02 	lds	r22, 0x029C
     f16:	70 91 9d 02 	lds	r23, 0x029D
     f1a:	80 91 9e 02 	lds	r24, 0x029E
     f1e:	90 91 9f 02 	lds	r25, 0x029F
     f22:	1c e1       	ldi	r17, 0x1C	; 28
     f24:	e1 2e       	mov	r14, r17
     f26:	1b e2       	ldi	r17, 0x2B	; 43
     f28:	f1 2e       	mov	r15, r17
     f2a:	00 e0       	ldi	r16, 0x00	; 0
     f2c:	10 e0       	ldi	r17, 0x00	; 0
     f2e:	20 e0       	ldi	r18, 0x00	; 0
     f30:	30 e0       	ldi	r19, 0x00	; 0
     f32:	a9 01       	movw	r20, r18
     f34:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <muldivQR>
	startpoint_steps.E = um_to_steps_e(startpoint.E);
     f38:	60 93 87 02 	sts	0x0287, r22
     f3c:	70 93 88 02 	sts	0x0288, r23
     f40:	80 93 89 02 	sts	0x0289, r24
     f44:	90 93 8a 02 	sts	0x028A, r25
}
     f48:	1f 91       	pop	r17
     f4a:	0f 91       	pop	r16
     f4c:	ff 90       	pop	r15
     f4e:	ef 90       	pop	r14
     f50:	df 90       	pop	r13
     f52:	cf 90       	pop	r12
     f54:	bf 90       	pop	r11
     f56:	af 90       	pop	r10
     f58:	08 95       	ret

00000f5a <dda_create>:

	It also pre-fills any data that the selected acceleration algorithm needs, and can be pre-computed for the whole move.

	This algorithm is probably the main limiting factor to print speed in terms of firmware limitations
*/
void dda_create(DDA *dda, TARGET *target, DDA *prev_dda) {
     f5a:	2f 92       	push	r2
     f5c:	3f 92       	push	r3
     f5e:	4f 92       	push	r4
     f60:	5f 92       	push	r5
     f62:	6f 92       	push	r6
     f64:	7f 92       	push	r7
     f66:	8f 92       	push	r8
     f68:	9f 92       	push	r9
     f6a:	af 92       	push	r10
     f6c:	bf 92       	push	r11
     f6e:	cf 92       	push	r12
     f70:	df 92       	push	r13
     f72:	ef 92       	push	r14
     f74:	ff 92       	push	r15
     f76:	0f 93       	push	r16
     f78:	1f 93       	push	r17
     f7a:	cf 93       	push	r28
     f7c:	df 93       	push	r29
     f7e:	cd b7       	in	r28, 0x3d	; 61
     f80:	de b7       	in	r29, 0x3e	; 62
     f82:	6e 97       	sbiw	r28, 0x1e	; 30
     f84:	0f b6       	in	r0, 0x3f	; 63
     f86:	f8 94       	cli
     f88:	de bf       	out	0x3e, r29	; 62
     f8a:	0f be       	out	0x3f, r0	; 63
     f8c:	cd bf       	out	0x3d, r28	; 61
     f8e:	9e 8f       	std	Y+30, r25	; 0x1e
     f90:	8d 8f       	std	Y+29, r24	; 0x1d
     f92:	1b 01       	movw	r2, r22
  // Number the moves to identify them; allowed to overflow.
  static uint8_t idcnt = 0;
  #endif

	// initialise DDA to a known state
	dda->allflags = 0;
     f94:	dc 01       	movw	r26, r24
     f96:	55 96       	adiw	r26, 0x15	; 21
     f98:	1c 92       	st	X, r1

	if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
     f9a:	80 91 cf 04 	lds	r24, 0x04CF
     f9e:	81 ff       	sbrs	r24, 1
     fa0:	04 c0       	rjmp	.+8      	; 0xfaa <dda_create+0x50>
		serial_writestr_P(PSTR("\n{DDA_CREATE: ["));
     fa2:	80 ea       	ldi	r24, 0xA0	; 160
     fa4:	93 e0       	ldi	r25, 0x03	; 3
     fa6:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <serial_writestr_P>

	// we end at the passed target
	memcpy(&(dda->endpoint), target, sizeof(TARGET));
     faa:	85 e1       	ldi	r24, 0x15	; 21
     fac:	f1 01       	movw	r30, r2
     fae:	ad 8d       	ldd	r26, Y+29	; 0x1d
     fb0:	be 8d       	ldd	r27, Y+30	; 0x1e
     fb2:	01 90       	ld	r0, Z+
     fb4:	0d 92       	st	X+, r0
     fb6:	8a 95       	dec	r24
     fb8:	e1 f7       	brne	.-8      	; 0xfb2 <dda_create+0x58>
  #endif

// TODO TODO: We should really make up a loop for all axes.
//            Think of what happens when a sixth axis (multi colour extruder)
//            appears?
	x_delta_um = (uint32_t)labs(target->X - startpoint.X);
     fba:	f1 01       	movw	r30, r2
     fbc:	40 80       	ld	r4, Z
     fbe:	51 80       	ldd	r5, Z+1	; 0x01
     fc0:	62 80       	ldd	r6, Z+2	; 0x02
     fc2:	73 80       	ldd	r7, Z+3	; 0x03
     fc4:	20 91 90 02 	lds	r18, 0x0290
     fc8:	30 91 91 02 	lds	r19, 0x0291
     fcc:	40 91 92 02 	lds	r20, 0x0292
     fd0:	50 91 93 02 	lds	r21, 0x0293
     fd4:	29 83       	std	Y+1, r18	; 0x01
     fd6:	3a 83       	std	Y+2, r19	; 0x02
     fd8:	4b 83       	std	Y+3, r20	; 0x03
     fda:	5c 83       	std	Y+4, r21	; 0x04
	y_delta_um = (uint32_t)labs(target->Y - startpoint.Y);
     fdc:	84 81       	ldd	r24, Z+4	; 0x04
     fde:	95 81       	ldd	r25, Z+5	; 0x05
     fe0:	a6 81       	ldd	r26, Z+6	; 0x06
     fe2:	b7 81       	ldd	r27, Z+7	; 0x07
     fe4:	8d 83       	std	Y+5, r24	; 0x05
     fe6:	9e 83       	std	Y+6, r25	; 0x06
     fe8:	af 83       	std	Y+7, r26	; 0x07
     fea:	b8 87       	std	Y+8, r27	; 0x08
     fec:	20 91 94 02 	lds	r18, 0x0294
     ff0:	30 91 95 02 	lds	r19, 0x0295
     ff4:	40 91 96 02 	lds	r20, 0x0296
     ff8:	50 91 97 02 	lds	r21, 0x0297
     ffc:	29 87       	std	Y+9, r18	; 0x09
     ffe:	3a 87       	std	Y+10, r19	; 0x0a
    1000:	4b 87       	std	Y+11, r20	; 0x0b
    1002:	5c 87       	std	Y+12, r21	; 0x0c
	z_delta_um = (uint32_t)labs(target->Z - startpoint.Z);
    1004:	80 85       	ldd	r24, Z+8	; 0x08
    1006:	91 85       	ldd	r25, Z+9	; 0x09
    1008:	a2 85       	ldd	r26, Z+10	; 0x0a
    100a:	b3 85       	ldd	r27, Z+11	; 0x0b
    100c:	8d 8b       	std	Y+21, r24	; 0x15
    100e:	9e 8b       	std	Y+22, r25	; 0x16
    1010:	af 8b       	std	Y+23, r26	; 0x17
    1012:	b8 8f       	std	Y+24, r27	; 0x18
    1014:	20 91 98 02 	lds	r18, 0x0298
    1018:	30 91 99 02 	lds	r19, 0x0299
    101c:	40 91 9a 02 	lds	r20, 0x029A
    1020:	50 91 9b 02 	lds	r21, 0x029B
    1024:	29 8f       	std	Y+25, r18	; 0x19
    1026:	3a 8f       	std	Y+26, r19	; 0x1a
    1028:	4b 8f       	std	Y+27, r20	; 0x1b
    102a:	5c 8f       	std	Y+28, r21	; 0x1c
// it might be worth pre-calculating muldivQR()'s qn and rn in dda_init()
// as soon as STEPS_PER_M_{XYZE} is no longer a compile-time variable.

static int32_t um_to_steps_x(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_x(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_X / 1000000UL,
    102c:	0f 2e       	mov	r0, r31
    102e:	f0 e4       	ldi	r31, 0x40	; 64
    1030:	af 2e       	mov	r10, r31
    1032:	f2 e4       	ldi	r31, 0x42	; 66
    1034:	bf 2e       	mov	r11, r31
    1036:	ff e0       	ldi	r31, 0x0F	; 15
    1038:	cf 2e       	mov	r12, r31
    103a:	d1 2c       	mov	r13, r1
    103c:	f0 2d       	mov	r31, r0
    103e:	10 e2       	ldi	r17, 0x20	; 32
    1040:	e1 2e       	mov	r14, r17
    1042:	11 ea       	ldi	r17, 0xA1	; 161
    1044:	f1 2e       	mov	r15, r17
    1046:	07 e0       	ldi	r16, 0x07	; 7
    1048:	10 e0       	ldi	r17, 0x00	; 0
    104a:	20 e0       	ldi	r18, 0x00	; 0
    104c:	30 e0       	ldi	r19, 0x00	; 0
    104e:	a9 01       	movw	r20, r18
    1050:	c3 01       	movw	r24, r6
    1052:	b2 01       	movw	r22, r4
    1054:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <muldivQR>

	steps = um_to_steps_x(target->X);
	dda->x_delta = labs(steps - startpoint_steps.X);
    1058:	c0 90 7b 02 	lds	r12, 0x027B
    105c:	d0 90 7c 02 	lds	r13, 0x027C
    1060:	e0 90 7d 02 	lds	r14, 0x027D
    1064:	f0 90 7e 02 	lds	r15, 0x027E
    1068:	9b 01       	movw	r18, r22
    106a:	ac 01       	movw	r20, r24
    106c:	2c 19       	sub	r18, r12
    106e:	3d 09       	sbc	r19, r13
    1070:	4e 09       	sbc	r20, r14
    1072:	5f 09       	sbc	r21, r15
    1074:	69 01       	movw	r12, r18
    1076:	7a 01       	movw	r14, r20
    1078:	42 f4       	brpl	.+16     	; 0x108a <dda_create+0x130>
    107a:	f0 94       	com	r15
    107c:	e0 94       	com	r14
    107e:	d0 94       	com	r13
    1080:	c0 94       	com	r12
    1082:	c1 1c       	adc	r12, r1
    1084:	d1 1c       	adc	r13, r1
    1086:	e1 1c       	adc	r14, r1
    1088:	f1 1c       	adc	r15, r1
    108a:	ad 8d       	ldd	r26, Y+29	; 0x1d
    108c:	be 8d       	ldd	r27, Y+30	; 0x1e
    108e:	56 96       	adiw	r26, 0x16	; 22
    1090:	cd 92       	st	X+, r12
    1092:	dd 92       	st	X+, r13
    1094:	ed 92       	st	X+, r14
    1096:	fc 92       	st	X, r15
    1098:	59 97       	sbiw	r26, 0x19	; 25
	startpoint_steps.X = steps;
    109a:	60 93 7b 02 	sts	0x027B, r22
    109e:	70 93 7c 02 	sts	0x027C, r23
    10a2:	80 93 7d 02 	sts	0x027D, r24
    10a6:	90 93 7e 02 	sts	0x027E, r25
                    STEPS_PER_M_X % 1000000UL, 1000000UL);
}

static int32_t um_to_steps_y(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_y(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_Y / 1000000UL,
    10aa:	f1 01       	movw	r30, r2
    10ac:	64 81       	ldd	r22, Z+4	; 0x04
    10ae:	75 81       	ldd	r23, Z+5	; 0x05
    10b0:	86 81       	ldd	r24, Z+6	; 0x06
    10b2:	97 81       	ldd	r25, Z+7	; 0x07
    10b4:	0f 2e       	mov	r0, r31
    10b6:	f0 e4       	ldi	r31, 0x40	; 64
    10b8:	af 2e       	mov	r10, r31
    10ba:	f2 e4       	ldi	r31, 0x42	; 66
    10bc:	bf 2e       	mov	r11, r31
    10be:	ff e0       	ldi	r31, 0x0F	; 15
    10c0:	cf 2e       	mov	r12, r31
    10c2:	d1 2c       	mov	r13, r1
    10c4:	f0 2d       	mov	r31, r0
    10c6:	10 e2       	ldi	r17, 0x20	; 32
    10c8:	e1 2e       	mov	r14, r17
    10ca:	11 ea       	ldi	r17, 0xA1	; 161
    10cc:	f1 2e       	mov	r15, r17
    10ce:	07 e0       	ldi	r16, 0x07	; 7
    10d0:	10 e0       	ldi	r17, 0x00	; 0
    10d2:	20 e0       	ldi	r18, 0x00	; 0
    10d4:	30 e0       	ldi	r19, 0x00	; 0
    10d6:	a9 01       	movw	r20, r18
    10d8:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <muldivQR>
	steps = um_to_steps_y(target->Y);
	dda->y_delta = labs(steps - startpoint_steps.Y);
    10dc:	c0 90 7f 02 	lds	r12, 0x027F
    10e0:	d0 90 80 02 	lds	r13, 0x0280
    10e4:	e0 90 81 02 	lds	r14, 0x0281
    10e8:	f0 90 82 02 	lds	r15, 0x0282
    10ec:	9b 01       	movw	r18, r22
    10ee:	ac 01       	movw	r20, r24
    10f0:	2c 19       	sub	r18, r12
    10f2:	3d 09       	sbc	r19, r13
    10f4:	4e 09       	sbc	r20, r14
    10f6:	5f 09       	sbc	r21, r15
    10f8:	69 01       	movw	r12, r18
    10fa:	7a 01       	movw	r14, r20
    10fc:	42 f4       	brpl	.+16     	; 0x110e <dda_create+0x1b4>
    10fe:	f0 94       	com	r15
    1100:	e0 94       	com	r14
    1102:	d0 94       	com	r13
    1104:	c0 94       	com	r12
    1106:	c1 1c       	adc	r12, r1
    1108:	d1 1c       	adc	r13, r1
    110a:	e1 1c       	adc	r14, r1
    110c:	f1 1c       	adc	r15, r1
    110e:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1110:	be 8d       	ldd	r27, Y+30	; 0x1e
    1112:	5a 96       	adiw	r26, 0x1a	; 26
    1114:	cd 92       	st	X+, r12
    1116:	dd 92       	st	X+, r13
    1118:	ed 92       	st	X+, r14
    111a:	fc 92       	st	X, r15
    111c:	5d 97       	sbiw	r26, 0x1d	; 29
	startpoint_steps.Y = steps;
    111e:	60 93 7f 02 	sts	0x027F, r22
    1122:	70 93 80 02 	sts	0x0280, r23
    1126:	80 93 81 02 	sts	0x0281, r24
    112a:	90 93 82 02 	sts	0x0282, r25
                    STEPS_PER_M_Y % 1000000UL, 1000000UL);
}

static int32_t um_to_steps_z(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_z(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_Z / 1000000UL,
    112e:	f1 01       	movw	r30, r2
    1130:	60 85       	ldd	r22, Z+8	; 0x08
    1132:	71 85       	ldd	r23, Z+9	; 0x09
    1134:	82 85       	ldd	r24, Z+10	; 0x0a
    1136:	93 85       	ldd	r25, Z+11	; 0x0b
    1138:	0f 2e       	mov	r0, r31
    113a:	f0 e4       	ldi	r31, 0x40	; 64
    113c:	af 2e       	mov	r10, r31
    113e:	f2 e4       	ldi	r31, 0x42	; 66
    1140:	bf 2e       	mov	r11, r31
    1142:	ff e0       	ldi	r31, 0x0F	; 15
    1144:	cf 2e       	mov	r12, r31
    1146:	d1 2c       	mov	r13, r1
    1148:	f0 2d       	mov	r31, r0
    114a:	18 e1       	ldi	r17, 0x18	; 24
    114c:	e1 2e       	mov	r14, r17
    114e:	17 e1       	ldi	r17, 0x17	; 23
    1150:	f1 2e       	mov	r15, r17
    1152:	05 e0       	ldi	r16, 0x05	; 5
    1154:	10 e0       	ldi	r17, 0x00	; 0
    1156:	23 e0       	ldi	r18, 0x03	; 3
    1158:	30 e0       	ldi	r19, 0x00	; 0
    115a:	40 e0       	ldi	r20, 0x00	; 0
    115c:	50 e0       	ldi	r21, 0x00	; 0
    115e:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <muldivQR>
	steps = um_to_steps_z(target->Z);
	dda->z_delta = labs(steps - startpoint_steps.Z);
    1162:	c0 90 83 02 	lds	r12, 0x0283
    1166:	d0 90 84 02 	lds	r13, 0x0284
    116a:	e0 90 85 02 	lds	r14, 0x0285
    116e:	f0 90 86 02 	lds	r15, 0x0286
    1172:	9b 01       	movw	r18, r22
    1174:	ac 01       	movw	r20, r24
    1176:	2c 19       	sub	r18, r12
    1178:	3d 09       	sbc	r19, r13
    117a:	4e 09       	sbc	r20, r14
    117c:	5f 09       	sbc	r21, r15
    117e:	69 01       	movw	r12, r18
    1180:	7a 01       	movw	r14, r20
    1182:	42 f4       	brpl	.+16     	; 0x1194 <dda_create+0x23a>
    1184:	f0 94       	com	r15
    1186:	e0 94       	com	r14
    1188:	d0 94       	com	r13
    118a:	c0 94       	com	r12
    118c:	c1 1c       	adc	r12, r1
    118e:	d1 1c       	adc	r13, r1
    1190:	e1 1c       	adc	r14, r1
    1192:	f1 1c       	adc	r15, r1
    1194:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1196:	be 8d       	ldd	r27, Y+30	; 0x1e
    1198:	5e 96       	adiw	r26, 0x1e	; 30
    119a:	cd 92       	st	X+, r12
    119c:	dd 92       	st	X+, r13
    119e:	ed 92       	st	X+, r14
    11a0:	fc 92       	st	X, r15
    11a2:	91 97       	sbiw	r26, 0x21	; 33
	startpoint_steps.Z = steps;
    11a4:	60 93 83 02 	sts	0x0283, r22
    11a8:	70 93 84 02 	sts	0x0284, r23
    11ac:	80 93 85 02 	sts	0x0285, r24
    11b0:	90 93 86 02 	sts	0x0286, r25

	dda->x_direction = (target->X >= startpoint.X)?1:0;
    11b4:	21 e0       	ldi	r18, 0x01	; 1
    11b6:	f1 01       	movw	r30, r2
    11b8:	40 81       	ld	r20, Z
    11ba:	51 81       	ldd	r21, Z+1	; 0x01
    11bc:	62 81       	ldd	r22, Z+2	; 0x02
    11be:	73 81       	ldd	r23, Z+3	; 0x03
    11c0:	80 91 90 02 	lds	r24, 0x0290
    11c4:	90 91 91 02 	lds	r25, 0x0291
    11c8:	a0 91 92 02 	lds	r26, 0x0292
    11cc:	b0 91 93 02 	lds	r27, 0x0293
    11d0:	48 17       	cp	r20, r24
    11d2:	59 07       	cpc	r21, r25
    11d4:	6a 07       	cpc	r22, r26
    11d6:	7b 07       	cpc	r23, r27
    11d8:	0c f4       	brge	.+2      	; 0x11dc <dda_create+0x282>
    11da:	20 e0       	ldi	r18, 0x00	; 0
    11dc:	ad 8d       	ldd	r26, Y+29	; 0x1d
    11de:	be 8d       	ldd	r27, Y+30	; 0x1e
    11e0:	55 96       	adiw	r26, 0x15	; 21
    11e2:	8c 91       	ld	r24, X
    11e4:	55 97       	sbiw	r26, 0x15	; 21
    11e6:	20 fb       	bst	r18, 0
    11e8:	83 f9       	bld	r24, 3
    11ea:	55 96       	adiw	r26, 0x15	; 21
    11ec:	8c 93       	st	X, r24
	dda->y_direction = (target->Y >= startpoint.Y)?1:0;
    11ee:	21 e0       	ldi	r18, 0x01	; 1
    11f0:	f1 01       	movw	r30, r2
    11f2:	44 81       	ldd	r20, Z+4	; 0x04
    11f4:	55 81       	ldd	r21, Z+5	; 0x05
    11f6:	66 81       	ldd	r22, Z+6	; 0x06
    11f8:	77 81       	ldd	r23, Z+7	; 0x07
    11fa:	80 91 94 02 	lds	r24, 0x0294
    11fe:	90 91 95 02 	lds	r25, 0x0295
    1202:	a0 91 96 02 	lds	r26, 0x0296
    1206:	b0 91 97 02 	lds	r27, 0x0297
    120a:	48 17       	cp	r20, r24
    120c:	59 07       	cpc	r21, r25
    120e:	6a 07       	cpc	r22, r26
    1210:	7b 07       	cpc	r23, r27
    1212:	0c f4       	brge	.+2      	; 0x1216 <dda_create+0x2bc>
    1214:	20 e0       	ldi	r18, 0x00	; 0
    1216:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1218:	be 8d       	ldd	r27, Y+30	; 0x1e
    121a:	55 96       	adiw	r26, 0x15	; 21
    121c:	8c 91       	ld	r24, X
    121e:	55 97       	sbiw	r26, 0x15	; 21
    1220:	20 fb       	bst	r18, 0
    1222:	84 f9       	bld	r24, 4
    1224:	55 96       	adiw	r26, 0x15	; 21
    1226:	8c 93       	st	X, r24
	dda->z_direction = (target->Z >= startpoint.Z)?1:0;
    1228:	21 e0       	ldi	r18, 0x01	; 1
    122a:	f1 01       	movw	r30, r2
    122c:	40 85       	ldd	r20, Z+8	; 0x08
    122e:	51 85       	ldd	r21, Z+9	; 0x09
    1230:	62 85       	ldd	r22, Z+10	; 0x0a
    1232:	73 85       	ldd	r23, Z+11	; 0x0b
    1234:	80 91 98 02 	lds	r24, 0x0298
    1238:	90 91 99 02 	lds	r25, 0x0299
    123c:	a0 91 9a 02 	lds	r26, 0x029A
    1240:	b0 91 9b 02 	lds	r27, 0x029B
    1244:	48 17       	cp	r20, r24
    1246:	59 07       	cpc	r21, r25
    1248:	6a 07       	cpc	r22, r26
    124a:	7b 07       	cpc	r23, r27
    124c:	0c f4       	brge	.+2      	; 0x1250 <dda_create+0x2f6>
    124e:	20 e0       	ldi	r18, 0x00	; 0
    1250:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1252:	be 8d       	ldd	r27, Y+30	; 0x1e
    1254:	55 96       	adiw	r26, 0x15	; 21
    1256:	8c 91       	ld	r24, X
    1258:	55 97       	sbiw	r26, 0x15	; 21
    125a:	20 fb       	bst	r18, 0
    125c:	85 f9       	bld	r24, 5
    125e:	55 96       	adiw	r26, 0x15	; 21
    1260:	8c 93       	st	X, r24


	if (target->e_relative) {
    1262:	f1 01       	movw	r30, r2
    1264:	84 89       	ldd	r24, Z+20	; 0x14
    1266:	80 ff       	sbrs	r24, 0
    1268:	5a c0       	rjmp	.+180    	; 0x131e <dda_create+0x3c4>
		e_delta_um = labs(target->E);
    126a:	f4 85       	ldd	r31, Z+12	; 0x0c
    126c:	d1 01       	movw	r26, r2
    126e:	1d 96       	adiw	r26, 0x0d	; 13
    1270:	ec 91       	ld	r30, X
    1272:	1d 97       	sbiw	r26, 0x0d	; 13
    1274:	1e 96       	adiw	r26, 0x0e	; 14
    1276:	8c 91       	ld	r24, X
    1278:	1e 97       	sbiw	r26, 0x0e	; 14
    127a:	1f 96       	adiw	r26, 0x0f	; 15
    127c:	9c 91       	ld	r25, X
    127e:	4f 2f       	mov	r20, r31
    1280:	5e 2f       	mov	r21, r30
    1282:	68 2f       	mov	r22, r24
    1284:	79 2f       	mov	r23, r25
    1286:	77 23       	and	r23, r23
    1288:	3c f4       	brge	.+14     	; 0x1298 <dda_create+0x33e>
    128a:	70 95       	com	r23
    128c:	60 95       	com	r22
    128e:	50 95       	com	r21
    1290:	41 95       	neg	r20
    1292:	5f 4f       	sbci	r21, 0xFF	; 255
    1294:	6f 4f       	sbci	r22, 0xFF	; 255
    1296:	7f 4f       	sbci	r23, 0xFF	; 255
    1298:	4d 87       	std	Y+13, r20	; 0x0d
    129a:	5e 87       	std	Y+14, r21	; 0x0e
    129c:	6f 87       	std	Y+15, r22	; 0x0f
    129e:	78 8b       	std	Y+16, r23	; 0x10
                    STEPS_PER_M_Z % 1000000UL, 1000000UL);
}

static int32_t um_to_steps_e(int32_t) __attribute__ ((always_inline));
inline int32_t um_to_steps_e(int32_t distance) {
    return muldivQR(distance, STEPS_PER_M_E / 1000000UL,
    12a0:	0f 2e       	mov	r0, r31
    12a2:	f0 e4       	ldi	r31, 0x40	; 64
    12a4:	af 2e       	mov	r10, r31
    12a6:	f2 e4       	ldi	r31, 0x42	; 66
    12a8:	bf 2e       	mov	r11, r31
    12aa:	ff e0       	ldi	r31, 0x0F	; 15
    12ac:	cf 2e       	mov	r12, r31
    12ae:	d1 2c       	mov	r13, r1
    12b0:	f0 2d       	mov	r31, r0
    12b2:	1c e1       	ldi	r17, 0x1C	; 28
    12b4:	e1 2e       	mov	r14, r17
    12b6:	1b e2       	ldi	r17, 0x2B	; 43
    12b8:	f1 2e       	mov	r15, r17
    12ba:	00 e0       	ldi	r16, 0x00	; 0
    12bc:	10 e0       	ldi	r17, 0x00	; 0
    12be:	20 e0       	ldi	r18, 0x00	; 0
    12c0:	30 e0       	ldi	r19, 0x00	; 0
    12c2:	a9 01       	movw	r20, r18
    12c4:	6f 2f       	mov	r22, r31
    12c6:	7e 2f       	mov	r23, r30
    12c8:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <muldivQR>
		dda->e_delta = labs(um_to_steps_e(target->E));
    12cc:	46 2f       	mov	r20, r22
    12ce:	57 2f       	mov	r21, r23
    12d0:	68 2f       	mov	r22, r24
    12d2:	79 2f       	mov	r23, r25
    12d4:	77 23       	and	r23, r23
    12d6:	3c f4       	brge	.+14     	; 0x12e6 <dda_create+0x38c>
    12d8:	70 95       	com	r23
    12da:	60 95       	com	r22
    12dc:	50 95       	com	r21
    12de:	41 95       	neg	r20
    12e0:	5f 4f       	sbci	r21, 0xFF	; 255
    12e2:	6f 4f       	sbci	r22, 0xFF	; 255
    12e4:	7f 4f       	sbci	r23, 0xFF	; 255
    12e6:	ed 8d       	ldd	r30, Y+29	; 0x1d
    12e8:	fe 8d       	ldd	r31, Y+30	; 0x1e
    12ea:	42 a3       	std	Z+34, r20	; 0x22
    12ec:	53 a3       	std	Z+35, r21	; 0x23
    12ee:	64 a3       	std	Z+36, r22	; 0x24
    12f0:	75 a3       	std	Z+37, r23	; 0x25
		dda->e_direction = (target->E >= 0)?1:0;
    12f2:	f1 01       	movw	r30, r2
    12f4:	84 85       	ldd	r24, Z+12	; 0x0c
    12f6:	95 85       	ldd	r25, Z+13	; 0x0d
    12f8:	a6 85       	ldd	r26, Z+14	; 0x0e
    12fa:	b7 85       	ldd	r27, Z+15	; 0x0f
    12fc:	80 95       	com	r24
    12fe:	90 95       	com	r25
    1300:	a0 95       	com	r26
    1302:	b0 95       	com	r27
    1304:	88 27       	eor	r24, r24
    1306:	b7 fd       	sbrc	r27, 7
    1308:	83 95       	inc	r24
    130a:	99 27       	eor	r25, r25
    130c:	aa 27       	eor	r26, r26
    130e:	bb 27       	eor	r27, r27
    1310:	ed 8d       	ldd	r30, Y+29	; 0x1d
    1312:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1314:	25 89       	ldd	r18, Z+21	; 0x15
    1316:	80 fb       	bst	r24, 0
    1318:	26 f9       	bld	r18, 6
    131a:	25 8b       	std	Z+21, r18	; 0x15
    131c:	7b c0       	rjmp	.+246    	; 0x1414 <dda_create+0x4ba>
	}
	else {
		e_delta_um = (uint32_t)labs(target->E - startpoint.E);
    131e:	64 85       	ldd	r22, Z+12	; 0x0c
    1320:	75 85       	ldd	r23, Z+13	; 0x0d
    1322:	86 85       	ldd	r24, Z+14	; 0x0e
    1324:	97 85       	ldd	r25, Z+15	; 0x0f
    1326:	c0 90 9c 02 	lds	r12, 0x029C
    132a:	d0 90 9d 02 	lds	r13, 0x029D
    132e:	e0 90 9e 02 	lds	r14, 0x029E
    1332:	f0 90 9f 02 	lds	r15, 0x029F
    1336:	9b 01       	movw	r18, r22
    1338:	ac 01       	movw	r20, r24
    133a:	2c 19       	sub	r18, r12
    133c:	3d 09       	sbc	r19, r13
    133e:	4e 09       	sbc	r20, r14
    1340:	5f 09       	sbc	r21, r15
    1342:	69 01       	movw	r12, r18
    1344:	7a 01       	movw	r14, r20
    1346:	42 f4       	brpl	.+16     	; 0x1358 <dda_create+0x3fe>
    1348:	f0 94       	com	r15
    134a:	e0 94       	com	r14
    134c:	d0 94       	com	r13
    134e:	c0 94       	com	r12
    1350:	c1 1c       	adc	r12, r1
    1352:	d1 1c       	adc	r13, r1
    1354:	e1 1c       	adc	r14, r1
    1356:	f1 1c       	adc	r15, r1
    1358:	cd 86       	std	Y+13, r12	; 0x0d
    135a:	de 86       	std	Y+14, r13	; 0x0e
    135c:	ef 86       	std	Y+15, r14	; 0x0f
    135e:	f8 8a       	std	Y+16, r15	; 0x10
    1360:	0f 2e       	mov	r0, r31
    1362:	f0 e4       	ldi	r31, 0x40	; 64
    1364:	af 2e       	mov	r10, r31
    1366:	f2 e4       	ldi	r31, 0x42	; 66
    1368:	bf 2e       	mov	r11, r31
    136a:	ff e0       	ldi	r31, 0x0F	; 15
    136c:	cf 2e       	mov	r12, r31
    136e:	d1 2c       	mov	r13, r1
    1370:	f0 2d       	mov	r31, r0
    1372:	1c e1       	ldi	r17, 0x1C	; 28
    1374:	e1 2e       	mov	r14, r17
    1376:	1b e2       	ldi	r17, 0x2B	; 43
    1378:	f1 2e       	mov	r15, r17
    137a:	00 e0       	ldi	r16, 0x00	; 0
    137c:	10 e0       	ldi	r17, 0x00	; 0
    137e:	20 e0       	ldi	r18, 0x00	; 0
    1380:	30 e0       	ldi	r19, 0x00	; 0
    1382:	a9 01       	movw	r20, r18
    1384:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <muldivQR>
		steps = um_to_steps_e(target->E);
		dda->e_delta = labs(steps - startpoint_steps.E);
    1388:	c0 90 87 02 	lds	r12, 0x0287
    138c:	d0 90 88 02 	lds	r13, 0x0288
    1390:	e0 90 89 02 	lds	r14, 0x0289
    1394:	f0 90 8a 02 	lds	r15, 0x028A
    1398:	9b 01       	movw	r18, r22
    139a:	ac 01       	movw	r20, r24
    139c:	2c 19       	sub	r18, r12
    139e:	3d 09       	sbc	r19, r13
    13a0:	4e 09       	sbc	r20, r14
    13a2:	5f 09       	sbc	r21, r15
    13a4:	69 01       	movw	r12, r18
    13a6:	7a 01       	movw	r14, r20
    13a8:	42 f4       	brpl	.+16     	; 0x13ba <dda_create+0x460>
    13aa:	f0 94       	com	r15
    13ac:	e0 94       	com	r14
    13ae:	d0 94       	com	r13
    13b0:	c0 94       	com	r12
    13b2:	c1 1c       	adc	r12, r1
    13b4:	d1 1c       	adc	r13, r1
    13b6:	e1 1c       	adc	r14, r1
    13b8:	f1 1c       	adc	r15, r1
    13ba:	ad 8d       	ldd	r26, Y+29	; 0x1d
    13bc:	be 8d       	ldd	r27, Y+30	; 0x1e
    13be:	92 96       	adiw	r26, 0x22	; 34
    13c0:	cd 92       	st	X+, r12
    13c2:	dd 92       	st	X+, r13
    13c4:	ed 92       	st	X+, r14
    13c6:	fc 92       	st	X, r15
    13c8:	95 97       	sbiw	r26, 0x25	; 37
		startpoint_steps.E = steps;
    13ca:	60 93 87 02 	sts	0x0287, r22
    13ce:	70 93 88 02 	sts	0x0288, r23
    13d2:	80 93 89 02 	sts	0x0289, r24
    13d6:	90 93 8a 02 	sts	0x028A, r25
		dda->e_direction = (target->E >= startpoint.E)?1:0;
    13da:	21 e0       	ldi	r18, 0x01	; 1
    13dc:	f1 01       	movw	r30, r2
    13de:	44 85       	ldd	r20, Z+12	; 0x0c
    13e0:	55 85       	ldd	r21, Z+13	; 0x0d
    13e2:	66 85       	ldd	r22, Z+14	; 0x0e
    13e4:	77 85       	ldd	r23, Z+15	; 0x0f
    13e6:	80 91 9c 02 	lds	r24, 0x029C
    13ea:	90 91 9d 02 	lds	r25, 0x029D
    13ee:	a0 91 9e 02 	lds	r26, 0x029E
    13f2:	b0 91 9f 02 	lds	r27, 0x029F
    13f6:	48 17       	cp	r20, r24
    13f8:	59 07       	cpc	r21, r25
    13fa:	6a 07       	cpc	r22, r26
    13fc:	7b 07       	cpc	r23, r27
    13fe:	0c f4       	brge	.+2      	; 0x1402 <dda_create+0x4a8>
    1400:	20 e0       	ldi	r18, 0x00	; 0
    1402:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1404:	be 8d       	ldd	r27, Y+30	; 0x1e
    1406:	55 96       	adiw	r26, 0x15	; 21
    1408:	8c 91       	ld	r24, X
    140a:	55 97       	sbiw	r26, 0x15	; 21
    140c:	20 fb       	bst	r18, 0
    140e:	86 f9       	bld	r24, 6
    1410:	55 96       	adiw	r26, 0x15	; 21
    1412:	8c 93       	st	X, r24
  dda->delta.Y = target->Y - startpoint.Y;
  dda->delta.Z = target->Z - startpoint.Z;
  dda->delta.E = target->e_relative ? target->E : target->E - startpoint.E;
  #endif

	if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
    1414:	80 91 cf 04 	lds	r24, 0x04CF
    1418:	81 ff       	sbrs	r24, 1
    141a:	5c c0       	rjmp	.+184    	; 0x14d4 <dda_create+0x57a>
		sersendf_P(PSTR("%ld,%ld,%ld,%ld] ["), target->X - startpoint.X, target->Y - startpoint.Y, target->Z - startpoint.Z, target->E - startpoint.E);
    141c:	f1 01       	movw	r30, r2
    141e:	84 85       	ldd	r24, Z+12	; 0x0c
    1420:	95 85       	ldd	r25, Z+13	; 0x0d
    1422:	a6 85       	ldd	r26, Z+14	; 0x0e
    1424:	b7 85       	ldd	r27, Z+15	; 0x0f
    1426:	40 91 9c 02 	lds	r20, 0x029C
    142a:	50 91 9d 02 	lds	r21, 0x029D
    142e:	60 91 9e 02 	lds	r22, 0x029E
    1432:	70 91 9f 02 	lds	r23, 0x029F
    1436:	84 1b       	sub	r24, r20
    1438:	95 0b       	sbc	r25, r21
    143a:	a6 0b       	sbc	r26, r22
    143c:	b7 0b       	sbc	r27, r23
    143e:	bf 93       	push	r27
    1440:	af 93       	push	r26
    1442:	9f 93       	push	r25
    1444:	8f 93       	push	r24
    1446:	80 85       	ldd	r24, Z+8	; 0x08
    1448:	91 85       	ldd	r25, Z+9	; 0x09
    144a:	a2 85       	ldd	r26, Z+10	; 0x0a
    144c:	b3 85       	ldd	r27, Z+11	; 0x0b
    144e:	40 91 98 02 	lds	r20, 0x0298
    1452:	50 91 99 02 	lds	r21, 0x0299
    1456:	60 91 9a 02 	lds	r22, 0x029A
    145a:	70 91 9b 02 	lds	r23, 0x029B
    145e:	84 1b       	sub	r24, r20
    1460:	95 0b       	sbc	r25, r21
    1462:	a6 0b       	sbc	r26, r22
    1464:	b7 0b       	sbc	r27, r23
    1466:	bf 93       	push	r27
    1468:	af 93       	push	r26
    146a:	9f 93       	push	r25
    146c:	8f 93       	push	r24
    146e:	84 81       	ldd	r24, Z+4	; 0x04
    1470:	95 81       	ldd	r25, Z+5	; 0x05
    1472:	a6 81       	ldd	r26, Z+6	; 0x06
    1474:	b7 81       	ldd	r27, Z+7	; 0x07
    1476:	40 91 94 02 	lds	r20, 0x0294
    147a:	50 91 95 02 	lds	r21, 0x0295
    147e:	60 91 96 02 	lds	r22, 0x0296
    1482:	70 91 97 02 	lds	r23, 0x0297
    1486:	84 1b       	sub	r24, r20
    1488:	95 0b       	sbc	r25, r21
    148a:	a6 0b       	sbc	r26, r22
    148c:	b7 0b       	sbc	r27, r23
    148e:	bf 93       	push	r27
    1490:	af 93       	push	r26
    1492:	9f 93       	push	r25
    1494:	8f 93       	push	r24
    1496:	80 81       	ld	r24, Z
    1498:	91 81       	ldd	r25, Z+1	; 0x01
    149a:	a2 81       	ldd	r26, Z+2	; 0x02
    149c:	b3 81       	ldd	r27, Z+3	; 0x03
    149e:	40 91 90 02 	lds	r20, 0x0290
    14a2:	50 91 91 02 	lds	r21, 0x0291
    14a6:	60 91 92 02 	lds	r22, 0x0292
    14aa:	70 91 93 02 	lds	r23, 0x0293
    14ae:	84 1b       	sub	r24, r20
    14b0:	95 0b       	sbc	r25, r21
    14b2:	a6 0b       	sbc	r26, r22
    14b4:	b7 0b       	sbc	r27, r23
    14b6:	bf 93       	push	r27
    14b8:	af 93       	push	r26
    14ba:	9f 93       	push	r25
    14bc:	8f 93       	push	r24
    14be:	80 eb       	ldi	r24, 0xB0	; 176
    14c0:	93 e0       	ldi	r25, 0x03	; 3
    14c2:	9f 93       	push	r25
    14c4:	8f 93       	push	r24
    14c6:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
    14ca:	0f b6       	in	r0, 0x3f	; 63
    14cc:	f8 94       	cli
    14ce:	de bf       	out	0x3e, r29	; 62
    14d0:	0f be       	out	0x3f, r0	; 63
    14d2:	cd bf       	out	0x3d, r28	; 61

	dda->total_steps = dda->x_delta;
    14d4:	ed 8d       	ldd	r30, Y+29	; 0x1d
    14d6:	fe 8d       	ldd	r31, Y+30	; 0x1e
    14d8:	86 89       	ldd	r24, Z+22	; 0x16
    14da:	97 89       	ldd	r25, Z+23	; 0x17
    14dc:	a0 8d       	ldd	r26, Z+24	; 0x18
    14de:	b1 8d       	ldd	r27, Z+25	; 0x19
    14e0:	86 a3       	std	Z+38, r24	; 0x26
    14e2:	97 a3       	std	Z+39, r25	; 0x27
    14e4:	a0 a7       	std	Z+40, r26	; 0x28
    14e6:	b1 a7       	std	Z+41, r27	; 0x29
	if (dda->y_delta > dda->total_steps)
    14e8:	42 8d       	ldd	r20, Z+26	; 0x1a
    14ea:	53 8d       	ldd	r21, Z+27	; 0x1b
    14ec:	64 8d       	ldd	r22, Z+28	; 0x1c
    14ee:	75 8d       	ldd	r23, Z+29	; 0x1d
    14f0:	84 17       	cp	r24, r20
    14f2:	95 07       	cpc	r25, r21
    14f4:	a6 07       	cpc	r26, r22
    14f6:	b7 07       	cpc	r27, r23
    14f8:	20 f4       	brcc	.+8      	; 0x1502 <dda_create+0x5a8>
		dda->total_steps = dda->y_delta;
    14fa:	46 a3       	std	Z+38, r20	; 0x26
    14fc:	57 a3       	std	Z+39, r21	; 0x27
    14fe:	60 a7       	std	Z+40, r22	; 0x28
    1500:	71 a7       	std	Z+41, r23	; 0x29
	if (dda->z_delta > dda->total_steps)
    1502:	ed 8d       	ldd	r30, Y+29	; 0x1d
    1504:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1506:	86 8d       	ldd	r24, Z+30	; 0x1e
    1508:	97 8d       	ldd	r25, Z+31	; 0x1f
    150a:	a0 a1       	ldd	r26, Z+32	; 0x20
    150c:	b1 a1       	ldd	r27, Z+33	; 0x21
    150e:	46 a1       	ldd	r20, Z+38	; 0x26
    1510:	57 a1       	ldd	r21, Z+39	; 0x27
    1512:	60 a5       	ldd	r22, Z+40	; 0x28
    1514:	71 a5       	ldd	r23, Z+41	; 0x29
    1516:	48 17       	cp	r20, r24
    1518:	59 07       	cpc	r21, r25
    151a:	6a 07       	cpc	r22, r26
    151c:	7b 07       	cpc	r23, r27
    151e:	20 f4       	brcc	.+8      	; 0x1528 <dda_create+0x5ce>
		dda->total_steps = dda->z_delta;
    1520:	86 a3       	std	Z+38, r24	; 0x26
    1522:	97 a3       	std	Z+39, r25	; 0x27
    1524:	a0 a7       	std	Z+40, r26	; 0x28
    1526:	b1 a7       	std	Z+41, r27	; 0x29
	if (dda->e_delta > dda->total_steps)
    1528:	ed 8d       	ldd	r30, Y+29	; 0x1d
    152a:	fe 8d       	ldd	r31, Y+30	; 0x1e
    152c:	82 a1       	ldd	r24, Z+34	; 0x22
    152e:	93 a1       	ldd	r25, Z+35	; 0x23
    1530:	a4 a1       	ldd	r26, Z+36	; 0x24
    1532:	b5 a1       	ldd	r27, Z+37	; 0x25
    1534:	46 a1       	ldd	r20, Z+38	; 0x26
    1536:	57 a1       	ldd	r21, Z+39	; 0x27
    1538:	60 a5       	ldd	r22, Z+40	; 0x28
    153a:	71 a5       	ldd	r23, Z+41	; 0x29
    153c:	48 17       	cp	r20, r24
    153e:	59 07       	cpc	r21, r25
    1540:	6a 07       	cpc	r22, r26
    1542:	7b 07       	cpc	r23, r27
    1544:	20 f4       	brcc	.+8      	; 0x154e <dda_create+0x5f4>
		dda->total_steps = dda->e_delta;
    1546:	86 a3       	std	Z+38, r24	; 0x26
    1548:	97 a3       	std	Z+39, r25	; 0x27
    154a:	a0 a7       	std	Z+40, r26	; 0x28
    154c:	b1 a7       	std	Z+41, r27	; 0x29

	if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
    154e:	80 91 cf 04 	lds	r24, 0x04CF
    1552:	81 ff       	sbrs	r24, 1
    1554:	1d c0       	rjmp	.+58     	; 0x1590 <dda_create+0x636>
		sersendf_P(PSTR("ts:%lu"), dda->total_steps);
    1556:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1558:	be 8d       	ldd	r27, Y+30	; 0x1e
    155a:	99 96       	adiw	r26, 0x29	; 41
    155c:	8c 91       	ld	r24, X
    155e:	99 97       	sbiw	r26, 0x29	; 41
    1560:	8f 93       	push	r24
    1562:	98 96       	adiw	r26, 0x28	; 40
    1564:	8c 91       	ld	r24, X
    1566:	98 97       	sbiw	r26, 0x28	; 40
    1568:	8f 93       	push	r24
    156a:	97 96       	adiw	r26, 0x27	; 39
    156c:	8c 91       	ld	r24, X
    156e:	97 97       	sbiw	r26, 0x27	; 39
    1570:	8f 93       	push	r24
    1572:	96 96       	adiw	r26, 0x26	; 38
    1574:	8c 91       	ld	r24, X
    1576:	8f 93       	push	r24
    1578:	83 ec       	ldi	r24, 0xC3	; 195
    157a:	93 e0       	ldi	r25, 0x03	; 3
    157c:	9f 93       	push	r25
    157e:	8f 93       	push	r24
    1580:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
    1584:	0f 90       	pop	r0
    1586:	0f 90       	pop	r0
    1588:	0f 90       	pop	r0
    158a:	0f 90       	pop	r0
    158c:	0f 90       	pop	r0
    158e:	0f 90       	pop	r0

	if (dda->total_steps == 0) {
    1590:	ed 8d       	ldd	r30, Y+29	; 0x1d
    1592:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1594:	86 a1       	ldd	r24, Z+38	; 0x26
    1596:	97 a1       	ldd	r25, Z+39	; 0x27
    1598:	a0 a5       	ldd	r26, Z+40	; 0x28
    159a:	b1 a5       	ldd	r27, Z+41	; 0x29
    159c:	89 2b       	or	r24, r25
    159e:	8a 2b       	or	r24, r26
    15a0:	8b 2b       	or	r24, r27
    15a2:	21 f4       	brne	.+8      	; 0x15ac <dda_create+0x652>
		dda->nullmove = 1;
    15a4:	85 89       	ldd	r24, Z+21	; 0x15
    15a6:	81 60       	ori	r24, 0x01	; 1
    15a8:	85 8b       	std	Z+21, r24	; 0x15
    15aa:	cc c1       	rjmp	.+920    	; 0x1944 <dda_create+0x9ea>
  #endif

// TODO TODO: We should really make up a loop for all axes.
//            Think of what happens when a sixth axis (multi colour extruder)
//            appears?
	x_delta_um = (uint32_t)labs(target->X - startpoint.X);
    15ac:	29 81       	ldd	r18, Y+1	; 0x01
    15ae:	3a 81       	ldd	r19, Y+2	; 0x02
    15b0:	4b 81       	ldd	r20, Y+3	; 0x03
    15b2:	5c 81       	ldd	r21, Y+4	; 0x04
    15b4:	42 1a       	sub	r4, r18
    15b6:	53 0a       	sbc	r5, r19
    15b8:	64 0a       	sbc	r6, r20
    15ba:	75 0a       	sbc	r7, r21
    15bc:	42 f4       	brpl	.+16     	; 0x15ce <dda_create+0x674>
    15be:	70 94       	com	r7
    15c0:	60 94       	com	r6
    15c2:	50 94       	com	r5
    15c4:	40 94       	com	r4
    15c6:	41 1c       	adc	r4, r1
    15c8:	51 1c       	adc	r5, r1
    15ca:	61 1c       	adc	r6, r1
    15cc:	71 1c       	adc	r7, r1
    15ce:	49 8a       	std	Y+17, r4	; 0x11
    15d0:	5a 8a       	std	Y+18, r5	; 0x12
    15d2:	6b 8a       	std	Y+19, r6	; 0x13
    15d4:	7c 8a       	std	Y+20, r7	; 0x14
	y_delta_um = (uint32_t)labs(target->Y - startpoint.Y);
    15d6:	8d 81       	ldd	r24, Y+5	; 0x05
    15d8:	9e 81       	ldd	r25, Y+6	; 0x06
    15da:	af 81       	ldd	r26, Y+7	; 0x07
    15dc:	b8 85       	ldd	r27, Y+8	; 0x08
    15de:	29 85       	ldd	r18, Y+9	; 0x09
    15e0:	3a 85       	ldd	r19, Y+10	; 0x0a
    15e2:	4b 85       	ldd	r20, Y+11	; 0x0b
    15e4:	5c 85       	ldd	r21, Y+12	; 0x0c
    15e6:	82 1b       	sub	r24, r18
    15e8:	93 0b       	sbc	r25, r19
    15ea:	a4 0b       	sbc	r26, r20
    15ec:	b5 0b       	sbc	r27, r21
    15ee:	3a f4       	brpl	.+14     	; 0x15fe <dda_create+0x6a4>
    15f0:	b0 95       	com	r27
    15f2:	a0 95       	com	r26
    15f4:	90 95       	com	r25
    15f6:	81 95       	neg	r24
    15f8:	9f 4f       	sbci	r25, 0xFF	; 255
    15fa:	af 4f       	sbci	r26, 0xFF	; 255
    15fc:	bf 4f       	sbci	r27, 0xFF	; 255
    15fe:	8d 83       	std	Y+5, r24	; 0x05
    1600:	9e 83       	std	Y+6, r25	; 0x06
    1602:	af 83       	std	Y+7, r26	; 0x07
    1604:	b8 87       	std	Y+8, r27	; 0x08
	z_delta_um = (uint32_t)labs(target->Z - startpoint.Z);
    1606:	8d 88       	ldd	r8, Y+21	; 0x15
    1608:	9e 88       	ldd	r9, Y+22	; 0x16
    160a:	af 88       	ldd	r10, Y+23	; 0x17
    160c:	b8 8c       	ldd	r11, Y+24	; 0x18
    160e:	89 8d       	ldd	r24, Y+25	; 0x19
    1610:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1612:	ab 8d       	ldd	r26, Y+27	; 0x1b
    1614:	bc 8d       	ldd	r27, Y+28	; 0x1c
    1616:	88 1a       	sub	r8, r24
    1618:	99 0a       	sbc	r9, r25
    161a:	aa 0a       	sbc	r10, r26
    161c:	bb 0a       	sbc	r11, r27
    161e:	42 f4       	brpl	.+16     	; 0x1630 <dda_create+0x6d6>
    1620:	b0 94       	com	r11
    1622:	a0 94       	com	r10
    1624:	90 94       	com	r9
    1626:	80 94       	com	r8
    1628:	81 1c       	adc	r8, r1
    162a:	91 1c       	adc	r9, r1
    162c:	a1 1c       	adc	r10, r1
    162e:	b1 1c       	adc	r11, r1
	if (dda->total_steps == 0) {
		dda->nullmove = 1;
	}
	else {
		// get steppers ready to go
		power_on();
    1630:	0e 94 8a 25 	call	0x4b14	; 0x4b14 <power_on>
		y_enable();
		// Z is enabled in dda_start()
		e_enable();

		// since it's unusual to combine X, Y and Z changes in a single move on reprap, check if we can use simpler approximations before trying the full 3d approximation.
		if (z_delta_um == 0)
    1634:	81 14       	cp	r8, r1
    1636:	91 04       	cpc	r9, r1
    1638:	a1 04       	cpc	r10, r1
    163a:	b1 04       	cpc	r11, r1
    163c:	71 f4       	brne	.+28     	; 0x165a <dda_create+0x700>
			distance = approx_distance(x_delta_um, y_delta_um);
    163e:	2d 81       	ldd	r18, Y+5	; 0x05
    1640:	3e 81       	ldd	r19, Y+6	; 0x06
    1642:	4f 81       	ldd	r20, Y+7	; 0x07
    1644:	58 85       	ldd	r21, Y+8	; 0x08
    1646:	69 89       	ldd	r22, Y+17	; 0x11
    1648:	7a 89       	ldd	r23, Y+18	; 0x12
    164a:	8b 89       	ldd	r24, Y+19	; 0x13
    164c:	9c 89       	ldd	r25, Y+20	; 0x14
    164e:	a4 d7       	rcall	.+3912   	; 0x2598 <approx_distance>
    1650:	69 83       	std	Y+1, r22	; 0x01
    1652:	7a 83       	std	Y+2, r23	; 0x02
    1654:	8b 83       	std	Y+3, r24	; 0x03
    1656:	9c 83       	std	Y+4, r25	; 0x04
    1658:	24 c0       	rjmp	.+72     	; 0x16a2 <dda_create+0x748>
		else if (x_delta_um == 0 && y_delta_um == 0)
    165a:	29 89       	ldd	r18, Y+17	; 0x11
    165c:	3a 89       	ldd	r19, Y+18	; 0x12
    165e:	4b 89       	ldd	r20, Y+19	; 0x13
    1660:	5c 89       	ldd	r21, Y+20	; 0x14
    1662:	23 2b       	or	r18, r19
    1664:	24 2b       	or	r18, r20
    1666:	25 2b       	or	r18, r21
    1668:	41 f4       	brne	.+16     	; 0x167a <dda_create+0x720>
    166a:	8d 81       	ldd	r24, Y+5	; 0x05
    166c:	9e 81       	ldd	r25, Y+6	; 0x06
    166e:	af 81       	ldd	r26, Y+7	; 0x07
    1670:	b8 85       	ldd	r27, Y+8	; 0x08
    1672:	89 2b       	or	r24, r25
    1674:	8a 2b       	or	r24, r26
    1676:	8b 2b       	or	r24, r27
    1678:	81 f0       	breq	.+32     	; 0x169a <dda_create+0x740>
			distance = z_delta_um;
		else
			distance = approx_distance_3(x_delta_um, y_delta_um, z_delta_um);
    167a:	85 01       	movw	r16, r10
    167c:	74 01       	movw	r14, r8
    167e:	2d 81       	ldd	r18, Y+5	; 0x05
    1680:	3e 81       	ldd	r19, Y+6	; 0x06
    1682:	4f 81       	ldd	r20, Y+7	; 0x07
    1684:	58 85       	ldd	r21, Y+8	; 0x08
    1686:	69 89       	ldd	r22, Y+17	; 0x11
    1688:	7a 89       	ldd	r23, Y+18	; 0x12
    168a:	8b 89       	ldd	r24, Y+19	; 0x13
    168c:	9c 89       	ldd	r25, Y+20	; 0x14
    168e:	fe d7       	rcall	.+4092   	; 0x268c <approx_distance_3>
    1690:	69 83       	std	Y+1, r22	; 0x01
    1692:	7a 83       	std	Y+2, r23	; 0x02
    1694:	8b 83       	std	Y+3, r24	; 0x03
    1696:	9c 83       	std	Y+4, r25	; 0x04
    1698:	04 c0       	rjmp	.+8      	; 0x16a2 <dda_create+0x748>

		// since it's unusual to combine X, Y and Z changes in a single move on reprap, check if we can use simpler approximations before trying the full 3d approximation.
		if (z_delta_um == 0)
			distance = approx_distance(x_delta_um, y_delta_um);
		else if (x_delta_um == 0 && y_delta_um == 0)
			distance = z_delta_um;
    169a:	89 82       	std	Y+1, r8	; 0x01
    169c:	9a 82       	std	Y+2, r9	; 0x02
    169e:	ab 82       	std	Y+3, r10	; 0x03
    16a0:	bc 82       	std	Y+4, r11	; 0x04
		else
			distance = approx_distance_3(x_delta_um, y_delta_um, z_delta_um);

		if (distance < 2)
    16a2:	29 81       	ldd	r18, Y+1	; 0x01
    16a4:	3a 81       	ldd	r19, Y+2	; 0x02
    16a6:	4b 81       	ldd	r20, Y+3	; 0x03
    16a8:	5c 81       	ldd	r21, Y+4	; 0x04
    16aa:	22 30       	cpi	r18, 0x02	; 2
    16ac:	31 05       	cpc	r19, r1
    16ae:	41 05       	cpc	r20, r1
    16b0:	51 05       	cpc	r21, r1
    16b2:	40 f4       	brcc	.+16     	; 0x16c4 <dda_create+0x76a>
			distance = e_delta_um;
    16b4:	3d 85       	ldd	r19, Y+13	; 0x0d
    16b6:	39 83       	std	Y+1, r19	; 0x01
    16b8:	4e 85       	ldd	r20, Y+14	; 0x0e
    16ba:	4a 83       	std	Y+2, r20	; 0x02
    16bc:	5f 85       	ldd	r21, Y+15	; 0x0f
    16be:	5b 83       	std	Y+3, r21	; 0x03
    16c0:	88 89       	ldd	r24, Y+16	; 0x10
    16c2:	8c 83       	std	Y+4, r24	; 0x04

		if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
    16c4:	80 91 cf 04 	lds	r24, 0x04CF
    16c8:	81 ff       	sbrs	r24, 1
    16ca:	14 c0       	rjmp	.+40     	; 0x16f4 <dda_create+0x79a>
			sersendf_P(PSTR(",ds:%lu"), distance);
    16cc:	9c 81       	ldd	r25, Y+4	; 0x04
    16ce:	9f 93       	push	r25
    16d0:	ab 81       	ldd	r26, Y+3	; 0x03
    16d2:	af 93       	push	r26
    16d4:	ba 81       	ldd	r27, Y+2	; 0x02
    16d6:	bf 93       	push	r27
    16d8:	e9 81       	ldd	r30, Y+1	; 0x01
    16da:	ef 93       	push	r30
    16dc:	8a ec       	ldi	r24, 0xCA	; 202
    16de:	93 e0       	ldi	r25, 0x03	; 3
    16e0:	9f 93       	push	r25
    16e2:	8f 93       	push	r24
    16e4:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
    16e8:	0f 90       	pop	r0
    16ea:	0f 90       	pop	r0
    16ec:	0f 90       	pop	r0
    16ee:	0f 90       	pop	r0
    16f0:	0f 90       	pop	r0
    16f2:	0f 90       	pop	r0
			// changed * 10 to * (F_CPU / 100000) so we can work in cpu_ticks rather than microseconds.
			// timer.c setTimer() routine altered for same reason

			// changed distance * 6000 .. * F_CPU / 100000 to
			//         distance * 2400 .. * F_CPU / 40000 so we can move a distance of up to 1800mm without overflowing
			uint32_t move_duration = ((distance * 2400) / dda->total_steps) * (F_CPU / 40000);
    16f4:	ad 8d       	ldd	r26, Y+29	; 0x1d
    16f6:	be 8d       	ldd	r27, Y+30	; 0x1e
    16f8:	96 96       	adiw	r26, 0x26	; 38
    16fa:	cd 90       	ld	r12, X+
    16fc:	dd 90       	ld	r13, X+
    16fe:	ed 90       	ld	r14, X+
    1700:	fc 90       	ld	r15, X
    1702:	99 97       	sbiw	r26, 0x29	; 41
		// check X axis
		c_limit_calc = ((x_delta_um * 2400L) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_X) << 8;
		if (c_limit_calc > c_limit)
			c_limit = c_limit_calc;
		// check Y axis
		c_limit_calc = ((y_delta_um * 2400L) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_Y) << 8;
    1704:	a0 e6       	ldi	r26, 0x60	; 96
    1706:	b9 e0       	ldi	r27, 0x09	; 9
    1708:	2d 81       	ldd	r18, Y+5	; 0x05
    170a:	3e 81       	ldd	r19, Y+6	; 0x06
    170c:	4f 81       	ldd	r20, Y+7	; 0x07
    170e:	58 85       	ldd	r21, Y+8	; 0x08
    1710:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    1714:	a7 01       	movw	r20, r14
    1716:	96 01       	movw	r18, r12
    1718:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    171c:	a0 e9       	ldi	r26, 0x90	; 144
    171e:	b1 e0       	ldi	r27, 0x01	; 1
    1720:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    1724:	0f 2e       	mov	r0, r31
    1726:	f8 ec       	ldi	r31, 0xC8	; 200
    1728:	4f 2e       	mov	r4, r31
    172a:	51 2c       	mov	r5, r1
    172c:	61 2c       	mov	r6, r1
    172e:	71 2c       	mov	r7, r1
    1730:	f0 2d       	mov	r31, r0
    1732:	a3 01       	movw	r20, r6
    1734:	92 01       	movw	r18, r4
    1736:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    173a:	29 87       	std	Y+9, r18	; 0x09
    173c:	3a 87       	std	Y+10, r19	; 0x0a
    173e:	4b 87       	std	Y+11, r20	; 0x0b
    1740:	5c 87       	std	Y+12, r21	; 0x0c

		// similarly, find out how fast we can run our axes.
		// do this for each axis individually, as the combined speed of two or more axes can be higher than the capabilities of a single one.
		c_limit = 0;
		// check X axis
		c_limit_calc = ((x_delta_um * 2400L) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_X) << 8;
    1742:	a0 e6       	ldi	r26, 0x60	; 96
    1744:	b9 e0       	ldi	r27, 0x09	; 9
    1746:	29 89       	ldd	r18, Y+17	; 0x11
    1748:	3a 89       	ldd	r19, Y+18	; 0x12
    174a:	4b 89       	ldd	r20, Y+19	; 0x13
    174c:	5c 89       	ldd	r21, Y+20	; 0x14
    174e:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    1752:	a7 01       	movw	r20, r14
    1754:	96 01       	movw	r18, r12
    1756:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    175a:	a0 e9       	ldi	r26, 0x90	; 144
    175c:	b1 e0       	ldi	r27, 0x01	; 1
    175e:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    1762:	a3 01       	movw	r20, r6
    1764:	92 01       	movw	r18, r4
    1766:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    176a:	b4 2f       	mov	r27, r20
    176c:	a3 2f       	mov	r26, r19
    176e:	92 2f       	mov	r25, r18
    1770:	88 27       	eor	r24, r24
    1772:	29 85       	ldd	r18, Y+9	; 0x09
    1774:	3a 85       	ldd	r19, Y+10	; 0x0a
    1776:	4b 85       	ldd	r20, Y+11	; 0x0b
    1778:	5c 85       	ldd	r21, Y+12	; 0x0c
    177a:	44 24       	eor	r4, r4
    177c:	52 2e       	mov	r5, r18
    177e:	63 2e       	mov	r6, r19
    1780:	74 2e       	mov	r7, r20
    1782:	48 16       	cp	r4, r24
    1784:	59 06       	cpc	r5, r25
    1786:	6a 06       	cpc	r6, r26
    1788:	7b 06       	cpc	r7, r27
    178a:	10 f4       	brcc	.+4      	; 0x1790 <dda_create+0x836>
    178c:	2c 01       	movw	r4, r24
    178e:	3d 01       	movw	r6, r26
		// check Y axis
		c_limit_calc = ((y_delta_um * 2400L) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_Y) << 8;
		if (c_limit_calc > c_limit)
			c_limit = c_limit_calc;
		// check Z axis
		c_limit_calc = ((z_delta_um * 2400L) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_Z) << 8;
    1790:	a0 e6       	ldi	r26, 0x60	; 96
    1792:	b9 e0       	ldi	r27, 0x09	; 9
    1794:	a5 01       	movw	r20, r10
    1796:	94 01       	movw	r18, r8
    1798:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    179c:	a7 01       	movw	r20, r14
    179e:	96 01       	movw	r18, r12
    17a0:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    17a4:	a0 e9       	ldi	r26, 0x90	; 144
    17a6:	b1 e0       	ldi	r27, 0x01	; 1
    17a8:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    17ac:	24 e6       	ldi	r18, 0x64	; 100
    17ae:	30 e0       	ldi	r19, 0x00	; 0
    17b0:	40 e0       	ldi	r20, 0x00	; 0
    17b2:	50 e0       	ldi	r21, 0x00	; 0
    17b4:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    17b8:	b4 2f       	mov	r27, r20
    17ba:	a3 2f       	mov	r26, r19
    17bc:	92 2f       	mov	r25, r18
    17be:	88 27       	eor	r24, r24
    17c0:	48 16       	cp	r4, r24
    17c2:	59 06       	cpc	r5, r25
    17c4:	6a 06       	cpc	r6, r26
    17c6:	7b 06       	cpc	r7, r27
    17c8:	10 f4       	brcc	.+4      	; 0x17ce <dda_create+0x874>
    17ca:	2c 01       	movw	r4, r24
    17cc:	3d 01       	movw	r6, r26
		if (c_limit_calc > c_limit)
			c_limit = c_limit_calc;
		// check E axis
		c_limit_calc = ((e_delta_um * 2400L) / dda->total_steps * (F_CPU / 40000) / MAXIMUM_FEEDRATE_E) << 8;
    17ce:	a0 e6       	ldi	r26, 0x60	; 96
    17d0:	b9 e0       	ldi	r27, 0x09	; 9
    17d2:	2d 85       	ldd	r18, Y+13	; 0x0d
    17d4:	3e 85       	ldd	r19, Y+14	; 0x0e
    17d6:	4f 85       	ldd	r20, Y+15	; 0x0f
    17d8:	58 89       	ldd	r21, Y+16	; 0x10
    17da:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    17de:	a7 01       	movw	r20, r14
    17e0:	96 01       	movw	r18, r12
    17e2:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    17e6:	a0 e9       	ldi	r26, 0x90	; 144
    17e8:	b1 e0       	ldi	r27, 0x01	; 1
    17ea:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    17ee:	28 e5       	ldi	r18, 0x58	; 88
    17f0:	32 e0       	ldi	r19, 0x02	; 2
    17f2:	40 e0       	ldi	r20, 0x00	; 0
    17f4:	50 e0       	ldi	r21, 0x00	; 0
    17f6:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    17fa:	b4 2f       	mov	r27, r20
    17fc:	a3 2f       	mov	r26, r19
    17fe:	92 2f       	mov	r25, r18
    1800:	88 27       	eor	r24, r24
    1802:	48 16       	cp	r4, r24
    1804:	59 06       	cpc	r5, r25
    1806:	6a 06       	cpc	r6, r26
    1808:	7b 06       	cpc	r7, r27
    180a:	10 f4       	brcc	.+4      	; 0x1810 <dda_create+0x8b6>
    180c:	2c 01       	movw	r4, r24
    180e:	3d 01       	movw	r6, r26
			// changed * 10 to * (F_CPU / 100000) so we can work in cpu_ticks rather than microseconds.
			// timer.c setTimer() routine altered for same reason

			// changed distance * 6000 .. * F_CPU / 100000 to
			//         distance * 2400 .. * F_CPU / 40000 so we can move a distance of up to 1800mm without overflowing
			uint32_t move_duration = ((distance * 2400) / dda->total_steps) * (F_CPU / 40000);
    1810:	a0 e6       	ldi	r26, 0x60	; 96
    1812:	b9 e0       	ldi	r27, 0x09	; 9
    1814:	29 81       	ldd	r18, Y+1	; 0x01
    1816:	3a 81       	ldd	r19, Y+2	; 0x02
    1818:	4b 81       	ldd	r20, Y+3	; 0x03
    181a:	5c 81       	ldd	r21, Y+4	; 0x04
    181c:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    1820:	a7 01       	movw	r20, r14
    1822:	96 01       	movw	r18, r12
    1824:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    1828:	a0 e9       	ldi	r26, 0x90	; 144
    182a:	b1 e0       	ldi	r27, 0x01	; 1
    182c:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
		}
		else
			dda->accel = 0;
		#elif defined ACCELERATION_RAMPING
			// yes, this assumes always the x axis as the critical one regarding acceleration. If we want to implement per-axis acceleration, things get tricky ...
			dda->c_min = (move_duration / target->F) << 8;
    1830:	d1 01       	movw	r26, r2
    1832:	50 96       	adiw	r26, 0x10	; 16
    1834:	2d 91       	ld	r18, X+
    1836:	3d 91       	ld	r19, X+
    1838:	4d 91       	ld	r20, X+
    183a:	5c 91       	ld	r21, X
    183c:	53 97       	sbiw	r26, 0x13	; 19
    183e:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    1842:	b4 2f       	mov	r27, r20
    1844:	a3 2f       	mov	r26, r19
    1846:	92 2f       	mov	r25, r18
    1848:	88 27       	eor	r24, r24
			if (dda->c_min < c_limit)
    184a:	84 15       	cp	r24, r4
    184c:	95 05       	cpc	r25, r5
    184e:	a6 05       	cpc	r26, r6
    1850:	b7 05       	cpc	r27, r7
    1852:	38 f0       	brcs	.+14     	; 0x1862 <dda_create+0x908>
		}
		else
			dda->accel = 0;
		#elif defined ACCELERATION_RAMPING
			// yes, this assumes always the x axis as the critical one regarding acceleration. If we want to implement per-axis acceleration, things get tricky ...
			dda->c_min = (move_duration / target->F) << 8;
    1854:	ed 8d       	ldd	r30, Y+29	; 0x1d
    1856:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1858:	86 ab       	std	Z+54, r24	; 0x36
    185a:	97 ab       	std	Z+55, r25	; 0x37
    185c:	a0 af       	std	Z+56, r26	; 0x38
    185e:	b1 af       	std	Z+57, r27	; 0x39
    1860:	08 c0       	rjmp	.+16     	; 0x1872 <dda_create+0x918>
			if (dda->c_min < c_limit)
				dda->c_min = c_limit;
    1862:	ad 8d       	ldd	r26, Y+29	; 0x1d
    1864:	be 8d       	ldd	r27, Y+30	; 0x1e
    1866:	d6 96       	adiw	r26, 0x36	; 54
    1868:	4d 92       	st	X+, r4
    186a:	5d 92       	st	X+, r5
    186c:	6d 92       	st	X+, r6
    186e:	7c 92       	st	X, r7
    1870:	d9 97       	sbiw	r26, 0x39	; 57
                   steps = F^2 / (int)((7200000 * ACCELERATION) / STEPS_PER_M_X)
         Note 3: As mentioned, setting F to 65535 or larger will overflow the
                 calculation. Make sure this does not happen.
         Note 4: Anyone trying to run their machine at 65535 mm/min > 1m/s is nuts
       */
      if (target->F > 65534) target->F = 65534;
    1872:	f1 01       	movw	r30, r2
    1874:	80 89       	ldd	r24, Z+16	; 0x10
    1876:	91 89       	ldd	r25, Z+17	; 0x11
    1878:	a2 89       	ldd	r26, Z+18	; 0x12
    187a:	b3 89       	ldd	r27, Z+19	; 0x13
    187c:	8f 3f       	cpi	r24, 0xFF	; 255
    187e:	9f 4f       	sbci	r25, 0xFF	; 255
    1880:	a1 05       	cpc	r26, r1
    1882:	b1 05       	cpc	r27, r1
    1884:	48 f0       	brcs	.+18     	; 0x1898 <dda_create+0x93e>
    1886:	8e ef       	ldi	r24, 0xFE	; 254
    1888:	9f ef       	ldi	r25, 0xFF	; 255
    188a:	a0 e0       	ldi	r26, 0x00	; 0
    188c:	b0 e0       	ldi	r27, 0x00	; 0
    188e:	f1 01       	movw	r30, r2
    1890:	80 8b       	std	Z+16, r24	; 0x10
    1892:	91 8b       	std	Z+17, r25	; 0x11
    1894:	a2 8b       	std	Z+18, r26	; 0x12
    1896:	b3 8b       	std	Z+19, r27	; 0x13
      dda->rampup_steps = ACCELERATE_RAMP_LEN(target->F);
    1898:	d1 01       	movw	r26, r2
    189a:	50 96       	adiw	r26, 0x10	; 16
    189c:	6d 91       	ld	r22, X+
    189e:	7d 91       	ld	r23, X+
    18a0:	8d 91       	ld	r24, X+
    18a2:	9c 91       	ld	r25, X
    18a4:	53 97       	sbiw	r26, 0x13	; 19
    18a6:	9b 01       	movw	r18, r22
    18a8:	ac 01       	movw	r20, r24
    18aa:	0e 94 e9 2b 	call	0x57d2	; 0x57d2 <__mulsi3>
    18ae:	20 e4       	ldi	r18, 0x40	; 64
    18b0:	38 e3       	ldi	r19, 0x38	; 56
    18b2:	40 e0       	ldi	r20, 0x00	; 0
    18b4:	50 e0       	ldi	r21, 0x00	; 0
    18b6:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    18ba:	ed 8d       	ldd	r30, Y+29	; 0x1d
    18bc:	fe 8d       	ldd	r31, Y+30	; 0x1e
    18be:	26 a7       	std	Z+46, r18	; 0x2e
    18c0:	37 a7       	std	Z+47, r19	; 0x2f
    18c2:	40 ab       	std	Z+48, r20	; 0x30
    18c4:	51 ab       	std	Z+49, r21	; 0x31
      // Quick hack: we do not do Z move joins as jerk on the Z axis is undesirable;
      // as the ramp length is calculated for XY, its incorrect for Z: apply the original
      // 'fix' to simply specify a large enough ramp for any speed.
      if (x_delta_um == 0 && y_delta_um == 0) {
    18c6:	29 89       	ldd	r18, Y+17	; 0x11
    18c8:	3a 89       	ldd	r19, Y+18	; 0x12
    18ca:	4b 89       	ldd	r20, Y+19	; 0x13
    18cc:	5c 89       	ldd	r21, Y+20	; 0x14
    18ce:	23 2b       	or	r18, r19
    18d0:	24 2b       	or	r18, r20
    18d2:	25 2b       	or	r18, r21
    18d4:	81 f4       	brne	.+32     	; 0x18f6 <dda_create+0x99c>
    18d6:	8d 81       	ldd	r24, Y+5	; 0x05
    18d8:	9e 81       	ldd	r25, Y+6	; 0x06
    18da:	af 81       	ldd	r26, Y+7	; 0x07
    18dc:	b8 85       	ldd	r27, Y+8	; 0x08
    18de:	89 2b       	or	r24, r25
    18e0:	8a 2b       	or	r24, r26
    18e2:	8b 2b       	or	r24, r27
    18e4:	41 f4       	brne	.+16     	; 0x18f6 <dda_create+0x99c>
        dda->rampup_steps = 100000; // replace mis-calculation by a safe value
    18e6:	80 ea       	ldi	r24, 0xA0	; 160
    18e8:	96 e8       	ldi	r25, 0x86	; 134
    18ea:	a1 e0       	ldi	r26, 0x01	; 1
    18ec:	b0 e0       	ldi	r27, 0x00	; 0
    18ee:	86 a7       	std	Z+46, r24	; 0x2e
    18f0:	97 a7       	std	Z+47, r25	; 0x2f
    18f2:	a0 ab       	std	Z+48, r26	; 0x30
    18f4:	b1 ab       	std	Z+49, r27	; 0x31
      }

      if (dda->rampup_steps > dda->total_steps / 2)
    18f6:	ed 8d       	ldd	r30, Y+29	; 0x1d
    18f8:	fe 8d       	ldd	r31, Y+30	; 0x1e
    18fa:	86 a1       	ldd	r24, Z+38	; 0x26
    18fc:	97 a1       	ldd	r25, Z+39	; 0x27
    18fe:	a0 a5       	ldd	r26, Z+40	; 0x28
    1900:	b1 a5       	ldd	r27, Z+41	; 0x29
    1902:	ac 01       	movw	r20, r24
    1904:	bd 01       	movw	r22, r26
    1906:	76 95       	lsr	r23
    1908:	67 95       	ror	r22
    190a:	57 95       	ror	r21
    190c:	47 95       	ror	r20
    190e:	c6 a4       	ldd	r12, Z+46	; 0x2e
    1910:	d7 a4       	ldd	r13, Z+47	; 0x2f
    1912:	e0 a8       	ldd	r14, Z+48	; 0x30
    1914:	f1 a8       	ldd	r15, Z+49	; 0x31
    1916:	4c 15       	cp	r20, r12
    1918:	5d 05       	cpc	r21, r13
    191a:	6e 05       	cpc	r22, r14
    191c:	7f 05       	cpc	r23, r15
    191e:	20 f4       	brcc	.+8      	; 0x1928 <dda_create+0x9ce>
        dda->rampup_steps = dda->total_steps / 2;
    1920:	46 a7       	std	Z+46, r20	; 0x2e
    1922:	57 a7       	std	Z+47, r21	; 0x2f
    1924:	60 ab       	std	Z+48, r22	; 0x30
    1926:	71 ab       	std	Z+49, r23	; 0x31
      dda->rampdown_steps = dda->total_steps - dda->rampup_steps;
    1928:	ed 8d       	ldd	r30, Y+29	; 0x1d
    192a:	fe 8d       	ldd	r31, Y+30	; 0x1e
    192c:	46 a5       	ldd	r20, Z+46	; 0x2e
    192e:	57 a5       	ldd	r21, Z+47	; 0x2f
    1930:	60 a9       	ldd	r22, Z+48	; 0x30
    1932:	71 a9       	ldd	r23, Z+49	; 0x31
    1934:	84 1b       	sub	r24, r20
    1936:	95 0b       	sbc	r25, r21
    1938:	a6 0b       	sbc	r26, r22
    193a:	b7 0b       	sbc	r27, r23
    193c:	82 ab       	std	Z+50, r24	; 0x32
    193e:	93 ab       	std	Z+51, r25	; 0x33
    1940:	a4 ab       	std	Z+52, r26	; 0x34
    1942:	b5 ab       	std	Z+53, r27	; 0x35
			if (dda->c < c_limit)
				dda->c = c_limit;
		#endif
	}

	if (DEBUG_DDA && (debug_flags & DEBUG_DDA))
    1944:	80 91 cf 04 	lds	r24, 0x04CF
    1948:	81 ff       	sbrs	r24, 1
    194a:	04 c0       	rjmp	.+8      	; 0x1954 <dda_create+0x9fa>
		serial_writestr_P(PSTR("] }\n"));
    194c:	82 ed       	ldi	r24, 0xD2	; 210
    194e:	93 e0       	ldi	r25, 0x03	; 3
    1950:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <serial_writestr_P>

	// next dda starts where we finish
	memcpy(&startpoint, target, sizeof(TARGET));
    1954:	85 e1       	ldi	r24, 0x15	; 21
    1956:	f1 01       	movw	r30, r2
    1958:	a0 e9       	ldi	r26, 0x90	; 144
    195a:	b2 e0       	ldi	r27, 0x02	; 2
    195c:	01 90       	ld	r0, Z+
    195e:	0d 92       	st	X+, r0
    1960:	8a 95       	dec	r24
    1962:	e1 f7       	brne	.-8      	; 0x195c <dda_create+0xa02>
}
    1964:	6e 96       	adiw	r28, 0x1e	; 30
    1966:	0f b6       	in	r0, 0x3f	; 63
    1968:	f8 94       	cli
    196a:	de bf       	out	0x3e, r29	; 62
    196c:	0f be       	out	0x3f, r0	; 63
    196e:	cd bf       	out	0x3d, r28	; 61
    1970:	df 91       	pop	r29
    1972:	cf 91       	pop	r28
    1974:	1f 91       	pop	r17
    1976:	0f 91       	pop	r16
    1978:	ff 90       	pop	r15
    197a:	ef 90       	pop	r14
    197c:	df 90       	pop	r13
    197e:	cf 90       	pop	r12
    1980:	bf 90       	pop	r11
    1982:	af 90       	pop	r10
    1984:	9f 90       	pop	r9
    1986:	8f 90       	pop	r8
    1988:	7f 90       	pop	r7
    198a:	6f 90       	pop	r6
    198c:	5f 90       	pop	r5
    198e:	4f 90       	pop	r4
    1990:	3f 90       	pop	r3
    1992:	2f 90       	pop	r2
    1994:	08 95       	ret

00001996 <dda_start>:

	We also mark this DDA as running, so other parts of the firmware know that something is happening

	Called both inside and outside of interrupts.
*/
void dda_start(DDA *dda) {
    1996:	cf 93       	push	r28
    1998:	df 93       	push	r29
    199a:	ec 01       	movw	r28, r24
	// called from interrupt context: keep it simple!
	if ( ! dda->nullmove) {
    199c:	8d 89       	ldd	r24, Y+21	; 0x15
    199e:	80 fd       	sbrc	r24, 0
    19a0:	82 c0       	rjmp	.+260    	; 0x1aa6 <dda_start+0x110>
		// get ready to go
		psu_timeout = 0;
    19a2:	10 92 bf 04 	sts	0x04BF, r1
			z_enable();
		if (dda->endstop_check)
			endstops_on();

		// set direction outputs
		x_direction(dda->x_direction);
    19a6:	83 ff       	sbrs	r24, 3
    19a8:	02 c0       	rjmp	.+4      	; 0x19ae <dda_start+0x18>
    19aa:	2e 9a       	sbi	0x05, 6	; 5
    19ac:	01 c0       	rjmp	.+2      	; 0x19b0 <dda_start+0x1a>
    19ae:	2e 98       	cbi	0x05, 6	; 5
		y_direction(dda->y_direction);
    19b0:	8d 89       	ldd	r24, Y+21	; 0x15
    19b2:	84 fd       	sbrc	r24, 4
    19b4:	02 c0       	rjmp	.+4      	; 0x19ba <dda_start+0x24>
    19b6:	2f 9a       	sbi	0x05, 7	; 5
    19b8:	01 c0       	rjmp	.+2      	; 0x19bc <dda_start+0x26>
    19ba:	2f 98       	cbi	0x05, 7	; 5
		z_direction(dda->z_direction);
    19bc:	8d 89       	ldd	r24, Y+21	; 0x15
    19be:	85 fd       	sbrc	r24, 5
    19c0:	06 c0       	rjmp	.+12     	; 0x19ce <dda_start+0x38>
    19c2:	eb e0       	ldi	r30, 0x0B	; 11
    19c4:	f1 e0       	ldi	r31, 0x01	; 1
    19c6:	80 81       	ld	r24, Z
    19c8:	82 60       	ori	r24, 0x02	; 2
    19ca:	80 83       	st	Z, r24
    19cc:	05 c0       	rjmp	.+10     	; 0x19d8 <dda_start+0x42>
    19ce:	eb e0       	ldi	r30, 0x0B	; 11
    19d0:	f1 e0       	ldi	r31, 0x01	; 1
    19d2:	80 81       	ld	r24, Z
    19d4:	8d 7f       	andi	r24, 0xFD	; 253
    19d6:	80 83       	st	Z, r24
		e_direction(dda->e_direction);
    19d8:	8d 89       	ldd	r24, Y+21	; 0x15
    19da:	86 ff       	sbrs	r24, 6
    19dc:	02 c0       	rjmp	.+4      	; 0x19e2 <dda_start+0x4c>
    19de:	16 9a       	sbi	0x02, 6	; 2
    19e0:	01 c0       	rjmp	.+2      	; 0x19e4 <dda_start+0x4e>
    19e2:	16 98       	cbi	0x02, 6	; 2
			heater_set(DC_EXTRUDER, DC_EXTRUDER_PWM);
		#endif

		// initialise state variable
		move_state.x_counter = move_state.y_counter = move_state.z_counter = \
			move_state.e_counter = -(dda->total_steps >> 1);
    19e4:	4e a1       	ldd	r20, Y+38	; 0x26
    19e6:	5f a1       	ldd	r21, Y+39	; 0x27
    19e8:	68 a5       	ldd	r22, Y+40	; 0x28
    19ea:	79 a5       	ldd	r23, Y+41	; 0x29
    19ec:	76 95       	lsr	r23
    19ee:	67 95       	ror	r22
    19f0:	57 95       	ror	r21
    19f2:	47 95       	ror	r20
    19f4:	70 95       	com	r23
    19f6:	60 95       	com	r22
    19f8:	50 95       	com	r21
    19fa:	41 95       	neg	r20
    19fc:	5f 4f       	sbci	r21, 0xFF	; 255
    19fe:	6f 4f       	sbci	r22, 0xFF	; 255
    1a00:	7f 4f       	sbci	r23, 0xFF	; 255
    1a02:	40 93 40 02 	sts	0x0240, r20
    1a06:	50 93 41 02 	sts	0x0241, r21
    1a0a:	60 93 42 02 	sts	0x0242, r22
    1a0e:	70 93 43 02 	sts	0x0243, r23
		if (dda->e_delta)
			heater_set(DC_EXTRUDER, DC_EXTRUDER_PWM);
		#endif

		// initialise state variable
		move_state.x_counter = move_state.y_counter = move_state.z_counter = \
    1a12:	40 93 3c 02 	sts	0x023C, r20
    1a16:	50 93 3d 02 	sts	0x023D, r21
    1a1a:	60 93 3e 02 	sts	0x023E, r22
    1a1e:	70 93 3f 02 	sts	0x023F, r23
    1a22:	40 93 38 02 	sts	0x0238, r20
    1a26:	50 93 39 02 	sts	0x0239, r21
    1a2a:	60 93 3a 02 	sts	0x023A, r22
    1a2e:	70 93 3b 02 	sts	0x023B, r23
    1a32:	40 93 34 02 	sts	0x0234, r20
    1a36:	50 93 35 02 	sts	0x0235, r21
    1a3a:	60 93 36 02 	sts	0x0236, r22
    1a3e:	70 93 37 02 	sts	0x0237, r23
			move_state.e_counter = -(dda->total_steps >> 1);
		memcpy(&move_state.x_steps, &dda->x_delta, sizeof(uint32_t) * 4);
    1a42:	fe 01       	movw	r30, r28
    1a44:	76 96       	adiw	r30, 0x16	; 22
    1a46:	80 e1       	ldi	r24, 0x10	; 16
    1a48:	a4 e4       	ldi	r26, 0x44	; 68
    1a4a:	b2 e0       	ldi	r27, 0x02	; 2
    1a4c:	01 90       	ld	r0, Z+
    1a4e:	0d 92       	st	X+, r0
    1a50:	8a 95       	dec	r24
    1a52:	e1 f7       	brne	.-8      	; 0x1a4c <dda_start+0xb6>
		#ifdef ACCELERATION_RAMPING
			move_state.step_no = 0;
    1a54:	10 92 54 02 	sts	0x0254, r1
    1a58:	10 92 55 02 	sts	0x0255, r1
    1a5c:	10 92 56 02 	sts	0x0256, r1
    1a60:	10 92 57 02 	sts	0x0257, r1
		move_state.x_time = move_state.y_time = \
			move_state.z_time = move_state.e_time = 0UL;
		#endif

		// ensure this dda starts
		dda->live = 1;
    1a64:	8d 89       	ldd	r24, Y+21	; 0x15
    1a66:	82 60       	ori	r24, 0x02	; 2
    1a68:	8d 8b       	std	Y+21, r24	; 0x15

		// set timeout for first step
		#ifdef ACCELERATION_RAMPING
		if (dda->c_min > move_state.c) // can be true when look-ahead removed all deceleration steps
    1a6a:	8e a9       	ldd	r24, Y+54	; 0x36
    1a6c:	9f a9       	ldd	r25, Y+55	; 0x37
    1a6e:	a8 ad       	ldd	r26, Y+56	; 0x38
    1a70:	b9 ad       	ldd	r27, Y+57	; 0x39
    1a72:	40 91 58 02 	lds	r20, 0x0258
    1a76:	50 91 59 02 	lds	r21, 0x0259
    1a7a:	60 91 5a 02 	lds	r22, 0x025A
    1a7e:	70 91 5b 02 	lds	r23, 0x025B
    1a82:	48 17       	cp	r20, r24
    1a84:	59 07       	cpc	r21, r25
    1a86:	6a 07       	cpc	r22, r26
    1a88:	7b 07       	cpc	r23, r27
    1a8a:	38 f4       	brcc	.+14     	; 0x1a9a <dda_start+0x104>
			setTimer(dda->c_min >> 8);
    1a8c:	69 2f       	mov	r22, r25
    1a8e:	7a 2f       	mov	r23, r26
    1a90:	8b 2f       	mov	r24, r27
    1a92:	99 27       	eor	r25, r25
    1a94:	0e 94 20 2b 	call	0x5640	; 0x5640 <setTimer>
    1a98:	06 c0       	rjmp	.+12     	; 0x1aa6 <dda_start+0x110>
		else
			setTimer(move_state.c >> 8);
    1a9a:	99 27       	eor	r25, r25
    1a9c:	87 2f       	mov	r24, r23
    1a9e:	76 2f       	mov	r23, r22
    1aa0:	65 2f       	mov	r22, r21
    1aa2:	0e 94 20 2b 	call	0x5640	; 0x5640 <setTimer>
		setTimer(dda->c >> 8);
		#endif
	}
	// else just a speed change, keep dda->live = 0

	current_position.F = dda->endpoint.F;
    1aa6:	88 89       	ldd	r24, Y+16	; 0x10
    1aa8:	99 89       	ldd	r25, Y+17	; 0x11
    1aaa:	aa 89       	ldd	r26, Y+18	; 0x12
    1aac:	bb 89       	ldd	r27, Y+19	; 0x13
    1aae:	80 93 76 02 	sts	0x0276, r24
    1ab2:	90 93 77 02 	sts	0x0277, r25
    1ab6:	a0 93 78 02 	sts	0x0278, r26
    1aba:	b0 93 79 02 	sts	0x0279, r27
}
    1abe:	df 91       	pop	r29
    1ac0:	cf 91       	pop	r28
    1ac2:	08 95       	ret

00001ac4 <dda_step>:
	Then we re-enable global interrupts so serial data reception and other important things can occur while we do some math.
	Next, we work out how long until our next step using the selected acceleration algorithm and set the timer.
	Then we decide if this was the last step for this move, and if so mark this dda as dead so next timer interrupt we can start a new one.
	Finally we de-assert any asserted step pins.
*/
void dda_step(DDA *dda) {
    1ac4:	7f 92       	push	r7
    1ac6:	8f 92       	push	r8
    1ac8:	9f 92       	push	r9
    1aca:	af 92       	push	r10
    1acc:	bf 92       	push	r11
    1ace:	cf 92       	push	r12
    1ad0:	df 92       	push	r13
    1ad2:	ef 92       	push	r14
    1ad4:	ff 92       	push	r15
    1ad6:	0f 93       	push	r16
    1ad8:	1f 93       	push	r17
    1ada:	cf 93       	push	r28
    1adc:	df 93       	push	r29
    1ade:	ec 01       	movw	r28, r24
	uint8_t endstop_stop; ///< Stop due to endstop trigger
	uint8_t endstop_not_done = 0; ///< Which axes haven't finished homing

#if defined X_MIN_PIN || defined X_MAX_PIN
	if (dda->endstop_check & 0x1) {
    1ae0:	8a ad       	ldd	r24, Y+58	; 0x3a
    1ae2:	80 ff       	sbrs	r24, 0
    1ae4:	64 c2       	rjmp	.+1224   	; 0x1fae <dda_step+0x4ea>
#if defined X_MIN_PIN
		if (x_min() == dda->endstop_stop_cond)
    1ae6:	10 91 00 01 	lds	r17, 0x0100
    1aea:	8b ad       	ldd	r24, Y+59	; 0x3b
    1aec:	90 e0       	ldi	r25, 0x00	; 0
    1aee:	11 fb       	bst	r17, 1
    1af0:	aa 27       	eor	r26, r26
    1af2:	a0 f9       	bld	r26, 0
    1af4:	b0 e0       	ldi	r27, 0x00	; 0
    1af6:	a8 17       	cp	r26, r24
    1af8:	b9 07       	cpc	r27, r25
    1afa:	31 f4       	brne	.+12     	; 0x1b08 <dda_step+0x44>
			move_state.debounce_count_xmin++;
    1afc:	a0 e6       	ldi	r26, 0x60	; 96
    1afe:	b2 e0       	ldi	r27, 0x02	; 2
    1b00:	1c 91       	ld	r17, X
    1b02:	1f 5f       	subi	r17, 0xFF	; 255
    1b04:	1c 93       	st	X, r17
    1b06:	02 c0       	rjmp	.+4      	; 0x1b0c <dda_step+0x48>
		else
			move_state.debounce_count_xmin = 0;
    1b08:	10 92 60 02 	sts	0x0260, r1
#endif

#if defined X_MAX_PIN
		if (x_max() == dda->endstop_stop_cond)
    1b0c:	a0 91 00 01 	lds	r26, 0x0100
    1b10:	ea 2f       	mov	r30, r26
    1b12:	e1 70       	andi	r30, 0x01	; 1
    1b14:	f0 e0       	ldi	r31, 0x00	; 0
    1b16:	8e 17       	cp	r24, r30
    1b18:	9f 07       	cpc	r25, r31
    1b1a:	31 f4       	brne	.+12     	; 0x1b28 <dda_step+0x64>
			move_state.debounce_count_xmax++;
    1b1c:	e3 e6       	ldi	r30, 0x63	; 99
    1b1e:	f2 e0       	ldi	r31, 0x02	; 2
    1b20:	80 81       	ld	r24, Z
    1b22:	8f 5f       	subi	r24, 0xFF	; 255
    1b24:	80 83       	st	Z, r24
    1b26:	02 c0       	rjmp	.+4      	; 0x1b2c <dda_step+0x68>
		else
			move_state.debounce_count_xmax = 0;
    1b28:	10 92 63 02 	sts	0x0263, r1
#endif

		endstop_stop = move_state.debounce_count_xmin >= ENDSTOP_STEPS ||
    1b2c:	80 91 60 02 	lds	r24, 0x0260
    1b30:	84 30       	cpi	r24, 0x04	; 4
    1b32:	08 f0       	brcs	.+2      	; 0x1b36 <dda_step+0x72>
    1b34:	51 c0       	rjmp	.+162    	; 0x1bd8 <dda_step+0x114>
		               move_state.debounce_count_xmax >= ENDSTOP_STEPS;
		if (!endstop_stop)
    1b36:	80 91 63 02 	lds	r24, 0x0263
    1b3a:	84 30       	cpi	r24, 0x04	; 4
    1b3c:	08 f4       	brcc	.+2      	; 0x1b40 <dda_step+0x7c>
    1b3e:	39 c2       	rjmp	.+1138   	; 0x1fb2 <dda_step+0x4ee>
    1b40:	71 2c       	mov	r7, r1
    1b42:	4b c0       	rjmp	.+150    	; 0x1bda <dda_step+0x116>
#endif
		endstop_stop = 0;

#if ! defined ACCELERATION_TEMPORAL
	if ((move_state.x_steps) && ! endstop_stop) {
		move_state.x_counter -= dda->x_delta;
    1b44:	e4 e3       	ldi	r30, 0x34	; 52
    1b46:	f2 e0       	ldi	r31, 0x02	; 2
    1b48:	80 81       	ld	r24, Z
    1b4a:	91 81       	ldd	r25, Z+1	; 0x01
    1b4c:	a2 81       	ldd	r26, Z+2	; 0x02
    1b4e:	b3 81       	ldd	r27, Z+3	; 0x03
    1b50:	ce 88       	ldd	r12, Y+22	; 0x16
    1b52:	df 88       	ldd	r13, Y+23	; 0x17
    1b54:	e8 8c       	ldd	r14, Y+24	; 0x18
    1b56:	f9 8c       	ldd	r15, Y+25	; 0x19
    1b58:	8c 19       	sub	r24, r12
    1b5a:	9d 09       	sbc	r25, r13
    1b5c:	ae 09       	sbc	r26, r14
    1b5e:	bf 09       	sbc	r27, r15
    1b60:	80 83       	st	Z, r24
    1b62:	91 83       	std	Z+1, r25	; 0x01
    1b64:	a2 83       	std	Z+2, r26	; 0x02
    1b66:	b3 83       	std	Z+3, r27	; 0x03
		if (move_state.x_counter < 0) {
    1b68:	bb 23       	and	r27, r27
    1b6a:	bc f5       	brge	.+110    	; 0x1bda <dda_step+0x116>
			//x_step();
			x_direction(dda->x_direction);
    1b6c:	8d 89       	ldd	r24, Y+21	; 0x15
    1b6e:	83 ff       	sbrs	r24, 3
    1b70:	02 c0       	rjmp	.+4      	; 0x1b76 <dda_step+0xb2>
    1b72:	2e 9a       	sbi	0x05, 6	; 5
    1b74:	01 c0       	rjmp	.+2      	; 0x1b78 <dda_step+0xb4>
    1b76:	2e 98       	cbi	0x05, 6	; 5
			y_direction(dda->y_direction);
    1b78:	8d 89       	ldd	r24, Y+21	; 0x15
    1b7a:	84 fd       	sbrc	r24, 4
    1b7c:	02 c0       	rjmp	.+4      	; 0x1b82 <dda_step+0xbe>
    1b7e:	2f 9a       	sbi	0x05, 7	; 5
    1b80:	01 c0       	rjmp	.+2      	; 0x1b84 <dda_step+0xc0>
    1b82:	2f 98       	cbi	0x05, 7	; 5
			OCR1A=255;
    1b84:	8f ef       	ldi	r24, 0xFF	; 255
    1b86:	90 e0       	ldi	r25, 0x00	; 0
    1b88:	90 93 89 00 	sts	0x0089, r25
    1b8c:	80 93 88 00 	sts	0x0088, r24
			OCR3C=255;
    1b90:	90 93 9d 00 	sts	0x009D, r25
    1b94:	80 93 9c 00 	sts	0x009C, r24
			move_state.x_steps--;
    1b98:	e4 e4       	ldi	r30, 0x44	; 68
    1b9a:	f2 e0       	ldi	r31, 0x02	; 2
    1b9c:	80 81       	ld	r24, Z
    1b9e:	91 81       	ldd	r25, Z+1	; 0x01
    1ba0:	a2 81       	ldd	r26, Z+2	; 0x02
    1ba2:	b3 81       	ldd	r27, Z+3	; 0x03
    1ba4:	01 97       	sbiw	r24, 0x01	; 1
    1ba6:	a1 09       	sbc	r26, r1
    1ba8:	b1 09       	sbc	r27, r1
    1baa:	80 83       	st	Z, r24
    1bac:	91 83       	std	Z+1, r25	; 0x01
    1bae:	a2 83       	std	Z+2, r26	; 0x02
    1bb0:	b3 83       	std	Z+3, r27	; 0x03
			move_state.x_counter += dda->total_steps;
    1bb2:	e4 e3       	ldi	r30, 0x34	; 52
    1bb4:	f2 e0       	ldi	r31, 0x02	; 2
    1bb6:	c0 80       	ld	r12, Z
    1bb8:	d1 80       	ldd	r13, Z+1	; 0x01
    1bba:	e2 80       	ldd	r14, Z+2	; 0x02
    1bbc:	f3 80       	ldd	r15, Z+3	; 0x03
    1bbe:	8e a1       	ldd	r24, Y+38	; 0x26
    1bc0:	9f a1       	ldd	r25, Y+39	; 0x27
    1bc2:	a8 a5       	ldd	r26, Y+40	; 0x28
    1bc4:	b9 a5       	ldd	r27, Y+41	; 0x29
    1bc6:	8c 0d       	add	r24, r12
    1bc8:	9d 1d       	adc	r25, r13
    1bca:	ae 1d       	adc	r26, r14
    1bcc:	bf 1d       	adc	r27, r15
    1bce:	80 83       	st	Z, r24
    1bd0:	91 83       	std	Z+1, r25	; 0x01
    1bd2:	a2 83       	std	Z+2, r26	; 0x02
    1bd4:	b3 83       	std	Z+3, r27	; 0x03
    1bd6:	01 c0       	rjmp	.+2      	; 0x1bda <dda_step+0x116>
			move_state.debounce_count_xmax++;
		else
			move_state.debounce_count_xmax = 0;
#endif

		endstop_stop = move_state.debounce_count_xmin >= ENDSTOP_STEPS ||
    1bd8:	71 2c       	mov	r7, r1
		move_state.all_time = move_state.x_time;
	}
#endif

#if defined Y_MIN_PIN || defined Y_MAX_PIN
	if (dda->endstop_check & 0x2) {
    1bda:	1a ad       	ldd	r17, Y+58	; 0x3a
    1bdc:	11 ff       	sbrs	r17, 1
    1bde:	f9 c1       	rjmp	.+1010   	; 0x1fd2 <dda_step+0x50e>
#if defined Y_MIN_PIN
		if (y_min() == dda->endstop_stop_cond)
    1be0:	e0 91 03 01 	lds	r30, 0x0103
    1be4:	8b ad       	ldd	r24, Y+59	; 0x3b
    1be6:	90 e0       	ldi	r25, 0x00	; 0
    1be8:	e1 fb       	bst	r30, 1
    1bea:	44 27       	eor	r20, r20
    1bec:	40 f9       	bld	r20, 0
    1bee:	50 e0       	ldi	r21, 0x00	; 0
    1bf0:	48 17       	cp	r20, r24
    1bf2:	59 07       	cpc	r21, r25
    1bf4:	31 f4       	brne	.+12     	; 0x1c02 <dda_step+0x13e>
			move_state.debounce_count_ymin++;
    1bf6:	e1 e6       	ldi	r30, 0x61	; 97
    1bf8:	f2 e0       	ldi	r31, 0x02	; 2
    1bfa:	40 81       	ld	r20, Z
    1bfc:	4f 5f       	subi	r20, 0xFF	; 255
    1bfe:	40 83       	st	Z, r20
    1c00:	02 c0       	rjmp	.+4      	; 0x1c06 <dda_step+0x142>
		else
			move_state.debounce_count_ymin = 0;
    1c02:	10 92 61 02 	sts	0x0261, r1
#endif

#if defined Y_MAX_PIN
		if (y_max() == dda->endstop_stop_cond)
    1c06:	40 91 03 01 	lds	r20, 0x0103
    1c0a:	64 2f       	mov	r22, r20
    1c0c:	61 70       	andi	r22, 0x01	; 1
    1c0e:	70 e0       	ldi	r23, 0x00	; 0
    1c10:	86 17       	cp	r24, r22
    1c12:	97 07       	cpc	r25, r23
    1c14:	31 f4       	brne	.+12     	; 0x1c22 <dda_step+0x15e>
			move_state.debounce_count_ymax++;
    1c16:	e4 e6       	ldi	r30, 0x64	; 100
    1c18:	f2 e0       	ldi	r31, 0x02	; 2
    1c1a:	80 81       	ld	r24, Z
    1c1c:	8f 5f       	subi	r24, 0xFF	; 255
    1c1e:	80 83       	st	Z, r24
    1c20:	02 c0       	rjmp	.+4      	; 0x1c26 <dda_step+0x162>
		else
			move_state.debounce_count_ymax = 0;
    1c22:	10 92 64 02 	sts	0x0264, r1
#endif

		endstop_stop = move_state.debounce_count_ymin >= ENDSTOP_STEPS ||
    1c26:	80 91 61 02 	lds	r24, 0x0261
    1c2a:	84 30       	cpi	r24, 0x04	; 4
    1c2c:	c8 f5       	brcc	.+114    	; 0x1ca0 <dda_step+0x1dc>
		               move_state.debounce_count_ymax >= ENDSTOP_STEPS;
		if (!endstop_stop)
    1c2e:	80 91 64 02 	lds	r24, 0x0264
    1c32:	84 30       	cpi	r24, 0x04	; 4
    1c34:	a8 f5       	brcc	.+106    	; 0x1ca0 <dda_step+0x1dc>
			endstop_not_done |= 0x2;
    1c36:	02 e0       	ldi	r16, 0x02	; 2
    1c38:	70 2a       	or	r7, r16
    1c3a:	cb c1       	rjmp	.+918    	; 0x1fd2 <dda_step+0x50e>
#endif
		endstop_stop = 0;

#if ! defined ACCELERATION_TEMPORAL
	if ((move_state.y_steps) && ! endstop_stop) {
		move_state.y_counter -= dda->y_delta;
    1c3c:	e8 e3       	ldi	r30, 0x38	; 56
    1c3e:	f2 e0       	ldi	r31, 0x02	; 2
    1c40:	80 81       	ld	r24, Z
    1c42:	91 81       	ldd	r25, Z+1	; 0x01
    1c44:	a2 81       	ldd	r26, Z+2	; 0x02
    1c46:	b3 81       	ldd	r27, Z+3	; 0x03
    1c48:	4a 8d       	ldd	r20, Y+26	; 0x1a
    1c4a:	5b 8d       	ldd	r21, Y+27	; 0x1b
    1c4c:	6c 8d       	ldd	r22, Y+28	; 0x1c
    1c4e:	7d 8d       	ldd	r23, Y+29	; 0x1d
    1c50:	84 1b       	sub	r24, r20
    1c52:	95 0b       	sbc	r25, r21
    1c54:	a6 0b       	sbc	r26, r22
    1c56:	b7 0b       	sbc	r27, r23
    1c58:	80 83       	st	Z, r24
    1c5a:	91 83       	std	Z+1, r25	; 0x01
    1c5c:	a2 83       	std	Z+2, r26	; 0x02
    1c5e:	b3 83       	std	Z+3, r27	; 0x03
		if (move_state.y_counter < 0) {
    1c60:	bb 23       	and	r27, r27
    1c62:	f4 f4       	brge	.+60     	; 0x1ca0 <dda_step+0x1dc>
			//y_step();
			move_state.y_steps--;
    1c64:	b7 01       	movw	r22, r14
    1c66:	a6 01       	movw	r20, r12
    1c68:	41 50       	subi	r20, 0x01	; 1
    1c6a:	51 09       	sbc	r21, r1
    1c6c:	61 09       	sbc	r22, r1
    1c6e:	71 09       	sbc	r23, r1
    1c70:	40 93 48 02 	sts	0x0248, r20
    1c74:	50 93 49 02 	sts	0x0249, r21
    1c78:	60 93 4a 02 	sts	0x024A, r22
    1c7c:	70 93 4b 02 	sts	0x024B, r23
			move_state.y_counter += dda->total_steps;
    1c80:	4e a1       	ldd	r20, Y+38	; 0x26
    1c82:	5f a1       	ldd	r21, Y+39	; 0x27
    1c84:	68 a5       	ldd	r22, Y+40	; 0x28
    1c86:	79 a5       	ldd	r23, Y+41	; 0x29
    1c88:	84 0f       	add	r24, r20
    1c8a:	95 1f       	adc	r25, r21
    1c8c:	a6 1f       	adc	r26, r22
    1c8e:	b7 1f       	adc	r27, r23
    1c90:	80 93 38 02 	sts	0x0238, r24
    1c94:	90 93 39 02 	sts	0x0239, r25
    1c98:	a0 93 3a 02 	sts	0x023A, r26
    1c9c:	b0 93 3b 02 	sts	0x023B, r27
		move_state.all_time = move_state.y_time;
	}
#endif

#if defined Z_MIN_PIN || defined Z_MAX_PIN
	if (dda->endstop_check & 0x4) {
    1ca0:	12 ff       	sbrs	r17, 2
    1ca2:	a6 c1       	rjmp	.+844    	; 0x1ff0 <dda_step+0x52c>
#if defined Z_MIN_PIN
		if (z_min() == dda->endstop_stop_cond)
    1ca4:	89 b1       	in	r24, 0x09	; 9
    1ca6:	83 fb       	bst	r24, 3
    1ca8:	22 27       	eor	r18, r18
    1caa:	20 f9       	bld	r18, 0
    1cac:	30 e0       	ldi	r19, 0x00	; 0
    1cae:	8b ad       	ldd	r24, Y+59	; 0x3b
    1cb0:	90 e0       	ldi	r25, 0x00	; 0
    1cb2:	28 17       	cp	r18, r24
    1cb4:	39 07       	cpc	r19, r25
    1cb6:	49 f4       	brne	.+18     	; 0x1cca <dda_step+0x206>
			move_state.debounce_count_zmin++;
    1cb8:	e2 e6       	ldi	r30, 0x62	; 98
    1cba:	f2 e0       	ldi	r31, 0x02	; 2
    1cbc:	80 81       	ld	r24, Z
    1cbe:	8f 5f       	subi	r24, 0xFF	; 255
    1cc0:	80 83       	st	Z, r24
			move_state.debounce_count_zmax++;
		else
			move_state.debounce_count_zmax = 0;
#endif

		endstop_stop = move_state.debounce_count_zmin >= ENDSTOP_STEPS ||
    1cc2:	84 30       	cpi	r24, 0x04	; 4
    1cc4:	08 f0       	brcs	.+2      	; 0x1cc8 <dda_step+0x204>
    1cc6:	42 c0       	rjmp	.+132    	; 0x1d4c <dda_step+0x288>
    1cc8:	02 c0       	rjmp	.+4      	; 0x1cce <dda_step+0x20a>
	if (dda->endstop_check & 0x4) {
#if defined Z_MIN_PIN
		if (z_min() == dda->endstop_stop_cond)
			move_state.debounce_count_zmin++;
		else
			move_state.debounce_count_zmin = 0;
    1cca:	10 92 62 02 	sts	0x0262, r1
			move_state.debounce_count_zmax = 0;
#endif

		endstop_stop = move_state.debounce_count_zmin >= ENDSTOP_STEPS ||
		               move_state.debounce_count_zmax >= ENDSTOP_STEPS;
		if (!endstop_stop)
    1cce:	80 91 65 02 	lds	r24, 0x0265
    1cd2:	84 30       	cpi	r24, 0x04	; 4
    1cd4:	d8 f5       	brcc	.+118    	; 0x1d4c <dda_step+0x288>
			endstop_not_done |= 0x4;
    1cd6:	14 e0       	ldi	r17, 0x04	; 4
    1cd8:	71 2a       	or	r7, r17
    1cda:	8a c1       	rjmp	.+788    	; 0x1ff0 <dda_step+0x52c>
#endif
		endstop_stop = 0;

#if ! defined ACCELERATION_TEMPORAL
	if ((move_state.z_steps) && ! endstop_stop) {
		move_state.z_counter -= dda->z_delta;
    1cdc:	ec e3       	ldi	r30, 0x3C	; 60
    1cde:	f2 e0       	ldi	r31, 0x02	; 2
    1ce0:	80 81       	ld	r24, Z
    1ce2:	91 81       	ldd	r25, Z+1	; 0x01
    1ce4:	a2 81       	ldd	r26, Z+2	; 0x02
    1ce6:	b3 81       	ldd	r27, Z+3	; 0x03
    1ce8:	4e 8d       	ldd	r20, Y+30	; 0x1e
    1cea:	5f 8d       	ldd	r21, Y+31	; 0x1f
    1cec:	68 a1       	ldd	r22, Y+32	; 0x20
    1cee:	79 a1       	ldd	r23, Y+33	; 0x21
    1cf0:	84 1b       	sub	r24, r20
    1cf2:	95 0b       	sbc	r25, r21
    1cf4:	a6 0b       	sbc	r26, r22
    1cf6:	b7 0b       	sbc	r27, r23
    1cf8:	80 83       	st	Z, r24
    1cfa:	91 83       	std	Z+1, r25	; 0x01
    1cfc:	a2 83       	std	Z+2, r26	; 0x02
    1cfe:	b3 83       	std	Z+3, r27	; 0x03
		if (move_state.z_counter < 0) {
    1d00:	bb 23       	and	r27, r27
    1d02:	24 f5       	brge	.+72     	; 0x1d4c <dda_step+0x288>
			z_step();
    1d04:	eb e0       	ldi	r30, 0x0B	; 11
    1d06:	f1 e0       	ldi	r31, 0x01	; 1
    1d08:	80 81       	ld	r24, Z
    1d0a:	88 60       	ori	r24, 0x08	; 8
    1d0c:	80 83       	st	Z, r24
			move_state.z_steps--;
    1d0e:	ec e4       	ldi	r30, 0x4C	; 76
    1d10:	f2 e0       	ldi	r31, 0x02	; 2
    1d12:	80 81       	ld	r24, Z
    1d14:	91 81       	ldd	r25, Z+1	; 0x01
    1d16:	a2 81       	ldd	r26, Z+2	; 0x02
    1d18:	b3 81       	ldd	r27, Z+3	; 0x03
    1d1a:	01 97       	sbiw	r24, 0x01	; 1
    1d1c:	a1 09       	sbc	r26, r1
    1d1e:	b1 09       	sbc	r27, r1
    1d20:	80 83       	st	Z, r24
    1d22:	91 83       	std	Z+1, r25	; 0x01
    1d24:	a2 83       	std	Z+2, r26	; 0x02
    1d26:	b3 83       	std	Z+3, r27	; 0x03
			move_state.z_counter += dda->total_steps;
    1d28:	ec e3       	ldi	r30, 0x3C	; 60
    1d2a:	f2 e0       	ldi	r31, 0x02	; 2
    1d2c:	40 81       	ld	r20, Z
    1d2e:	51 81       	ldd	r21, Z+1	; 0x01
    1d30:	62 81       	ldd	r22, Z+2	; 0x02
    1d32:	73 81       	ldd	r23, Z+3	; 0x03
    1d34:	8e a1       	ldd	r24, Y+38	; 0x26
    1d36:	9f a1       	ldd	r25, Y+39	; 0x27
    1d38:	a8 a5       	ldd	r26, Y+40	; 0x28
    1d3a:	b9 a5       	ldd	r27, Y+41	; 0x29
    1d3c:	84 0f       	add	r24, r20
    1d3e:	95 1f       	adc	r25, r21
    1d40:	a6 1f       	adc	r26, r22
    1d42:	b7 1f       	adc	r27, r23
    1d44:	80 83       	st	Z, r24
    1d46:	91 83       	std	Z+1, r25	; 0x01
    1d48:	a2 83       	std	Z+2, r26	; 0x02
    1d4a:	b3 83       	std	Z+3, r27	; 0x03
		move_state.all_time = move_state.z_time;
	}
#endif

#if ! defined ACCELERATION_TEMPORAL
	if (move_state.e_steps) {
    1d4c:	80 91 50 02 	lds	r24, 0x0250
    1d50:	90 91 51 02 	lds	r25, 0x0251
    1d54:	a0 91 52 02 	lds	r26, 0x0252
    1d58:	b0 91 53 02 	lds	r27, 0x0253
    1d5c:	89 2b       	or	r24, r25
    1d5e:	8a 2b       	or	r24, r26
    1d60:	8b 2b       	or	r24, r27
    1d62:	a1 f1       	breq	.+104    	; 0x1dcc <dda_step+0x308>
		move_state.e_counter -= dda->e_delta;
    1d64:	e0 e4       	ldi	r30, 0x40	; 64
    1d66:	f2 e0       	ldi	r31, 0x02	; 2
    1d68:	80 81       	ld	r24, Z
    1d6a:	91 81       	ldd	r25, Z+1	; 0x01
    1d6c:	a2 81       	ldd	r26, Z+2	; 0x02
    1d6e:	b3 81       	ldd	r27, Z+3	; 0x03
    1d70:	4a a1       	ldd	r20, Y+34	; 0x22
    1d72:	5b a1       	ldd	r21, Y+35	; 0x23
    1d74:	6c a1       	ldd	r22, Y+36	; 0x24
    1d76:	7d a1       	ldd	r23, Y+37	; 0x25
    1d78:	84 1b       	sub	r24, r20
    1d7a:	95 0b       	sbc	r25, r21
    1d7c:	a6 0b       	sbc	r26, r22
    1d7e:	b7 0b       	sbc	r27, r23
    1d80:	80 83       	st	Z, r24
    1d82:	91 83       	std	Z+1, r25	; 0x01
    1d84:	a2 83       	std	Z+2, r26	; 0x02
    1d86:	b3 83       	std	Z+3, r27	; 0x03
		if (move_state.e_counter < 0) {
    1d88:	bb 23       	and	r27, r27
    1d8a:	04 f5       	brge	.+64     	; 0x1dcc <dda_step+0x308>
			e_step();
    1d8c:	14 9a       	sbi	0x02, 4	; 2
			move_state.e_steps--;
    1d8e:	e0 e5       	ldi	r30, 0x50	; 80
    1d90:	f2 e0       	ldi	r31, 0x02	; 2
    1d92:	80 81       	ld	r24, Z
    1d94:	91 81       	ldd	r25, Z+1	; 0x01
    1d96:	a2 81       	ldd	r26, Z+2	; 0x02
    1d98:	b3 81       	ldd	r27, Z+3	; 0x03
    1d9a:	01 97       	sbiw	r24, 0x01	; 1
    1d9c:	a1 09       	sbc	r26, r1
    1d9e:	b1 09       	sbc	r27, r1
    1da0:	80 83       	st	Z, r24
    1da2:	91 83       	std	Z+1, r25	; 0x01
    1da4:	a2 83       	std	Z+2, r26	; 0x02
    1da6:	b3 83       	std	Z+3, r27	; 0x03
			move_state.e_counter += dda->total_steps;
    1da8:	e0 e4       	ldi	r30, 0x40	; 64
    1daa:	f2 e0       	ldi	r31, 0x02	; 2
    1dac:	40 81       	ld	r20, Z
    1dae:	51 81       	ldd	r21, Z+1	; 0x01
    1db0:	62 81       	ldd	r22, Z+2	; 0x02
    1db2:	73 81       	ldd	r23, Z+3	; 0x03
    1db4:	8e a1       	ldd	r24, Y+38	; 0x26
    1db6:	9f a1       	ldd	r25, Y+39	; 0x27
    1db8:	a8 a5       	ldd	r26, Y+40	; 0x28
    1dba:	b9 a5       	ldd	r27, Y+41	; 0x29
    1dbc:	84 0f       	add	r24, r20
    1dbe:	95 1f       	adc	r25, r21
    1dc0:	a6 1f       	adc	r26, r22
    1dc2:	b7 1f       	adc	r27, r23
    1dc4:	80 83       	st	Z, r24
    1dc6:	91 83       	std	Z+1, r25	; 0x01
    1dc8:	a2 83       	std	Z+2, r26	; 0x02
    1dca:	b3 83       	std	Z+3, r27	; 0x03
		// Since we have sent steps to all the motors that will be stepping
		// and the rest of this function isn't so time critical, this interrupt
		// can now be interruptible by other interrupts.
		// The step interrupt is disabled before entering dda_step() to ensure
		// that we don't step again while computing the below.
		sei();
    1dcc:	78 94       	sei
		//if (move_state.step_no == 0) {
		//	sersendf_P(PSTR("\r\nc %lu  c_min %lu  n %d"), dda->c, dda->c_min, move_state.n);
		//}

		recalc_speed = 0;
		if (move_state.step_no < dda->rampup_steps) {
    1dce:	c0 90 54 02 	lds	r12, 0x0254
    1dd2:	d0 90 55 02 	lds	r13, 0x0255
    1dd6:	e0 90 56 02 	lds	r14, 0x0256
    1dda:	f0 90 57 02 	lds	r15, 0x0257
    1dde:	8e a5       	ldd	r24, Y+46	; 0x2e
    1de0:	9f a5       	ldd	r25, Y+47	; 0x2f
    1de2:	a8 a9       	ldd	r26, Y+48	; 0x30
    1de4:	b9 a9       	ldd	r27, Y+49	; 0x31
    1de6:	c8 16       	cp	r12, r24
    1de8:	d9 06       	cpc	r13, r25
    1dea:	ea 06       	cpc	r14, r26
    1dec:	fb 06       	cpc	r15, r27
    1dee:	f0 f4       	brcc	.+60     	; 0x1e2c <dda_step+0x368>
			if (move_state.n < 0) // wrong ramp direction
    1df0:	80 91 5c 02 	lds	r24, 0x025C
    1df4:	90 91 5d 02 	lds	r25, 0x025D
    1df8:	a0 91 5e 02 	lds	r26, 0x025E
    1dfc:	b0 91 5f 02 	lds	r27, 0x025F
    1e00:	bb 23       	and	r27, r27
    1e02:	0c f0       	brlt	.+2      	; 0x1e06 <dda_step+0x342>
    1e04:	03 c1       	rjmp	.+518    	; 0x200c <dda_step+0x548>
				move_state.n = -((int32_t)2) - move_state.n;
    1e06:	4e ef       	ldi	r20, 0xFE	; 254
    1e08:	5f ef       	ldi	r21, 0xFF	; 255
    1e0a:	6f ef       	ldi	r22, 0xFF	; 255
    1e0c:	7f ef       	ldi	r23, 0xFF	; 255
    1e0e:	8a 01       	movw	r16, r20
    1e10:	9b 01       	movw	r18, r22
    1e12:	08 1b       	sub	r16, r24
    1e14:	19 0b       	sbc	r17, r25
    1e16:	2a 0b       	sbc	r18, r26
    1e18:	3b 0b       	sbc	r19, r27
    1e1a:	00 93 5c 02 	sts	0x025C, r16
    1e1e:	10 93 5d 02 	sts	0x025D, r17
    1e22:	20 93 5e 02 	sts	0x025E, r18
    1e26:	30 93 5f 02 	sts	0x025F, r19
    1e2a:	f0 c0       	rjmp	.+480    	; 0x200c <dda_step+0x548>
			recalc_speed = 1;
		}
		else if (move_state.step_no >= dda->rampdown_steps) {
    1e2c:	8a a9       	ldd	r24, Y+50	; 0x32
    1e2e:	9b a9       	ldd	r25, Y+51	; 0x33
    1e30:	ac a9       	ldd	r26, Y+52	; 0x34
    1e32:	bd a9       	ldd	r27, Y+53	; 0x35
    1e34:	c8 16       	cp	r12, r24
    1e36:	d9 06       	cpc	r13, r25
    1e38:	ea 06       	cpc	r14, r26
    1e3a:	fb 06       	cpc	r15, r27
    1e3c:	08 f1       	brcs	.+66     	; 0x1e80 <dda_step+0x3bc>
			if (move_state.n > 0) // wrong ramp direction
    1e3e:	80 91 5c 02 	lds	r24, 0x025C
    1e42:	90 91 5d 02 	lds	r25, 0x025D
    1e46:	a0 91 5e 02 	lds	r26, 0x025E
    1e4a:	b0 91 5f 02 	lds	r27, 0x025F
    1e4e:	18 16       	cp	r1, r24
    1e50:	19 06       	cpc	r1, r25
    1e52:	1a 06       	cpc	r1, r26
    1e54:	1b 06       	cpc	r1, r27
    1e56:	0c f0       	brlt	.+2      	; 0x1e5a <dda_step+0x396>
    1e58:	d9 c0       	rjmp	.+434    	; 0x200c <dda_step+0x548>
				move_state.n = -((int32_t)2) - move_state.n;
    1e5a:	4e ef       	ldi	r20, 0xFE	; 254
    1e5c:	5f ef       	ldi	r21, 0xFF	; 255
    1e5e:	6f ef       	ldi	r22, 0xFF	; 255
    1e60:	7f ef       	ldi	r23, 0xFF	; 255
    1e62:	8a 01       	movw	r16, r20
    1e64:	9b 01       	movw	r18, r22
    1e66:	08 1b       	sub	r16, r24
    1e68:	19 0b       	sbc	r17, r25
    1e6a:	2a 0b       	sbc	r18, r26
    1e6c:	3b 0b       	sbc	r19, r27
    1e6e:	00 93 5c 02 	sts	0x025C, r16
    1e72:	10 93 5d 02 	sts	0x025D, r17
    1e76:	20 93 5e 02 	sts	0x025E, r18
    1e7a:	30 93 5f 02 	sts	0x025F, r19
    1e7e:	c6 c0       	rjmp	.+396    	; 0x200c <dda_step+0x548>
			// be careful of signedness!
			move_state.c = (int32_t)move_state.c - ((int32_t)(move_state.c * 2) / (int32_t)move_state.n);
      //sersendf_P(PSTR("n:%ld; c:%ld; steps: %ld / %lu\n"), move_state.n,
      //           move_state.c, move_state.step_no, move_state.y_steps);
		}
		move_state.step_no++;
    1e80:	1f ef       	ldi	r17, 0xFF	; 255
    1e82:	c1 1a       	sub	r12, r17
    1e84:	d1 0a       	sbc	r13, r17
    1e86:	e1 0a       	sbc	r14, r17
    1e88:	f1 0a       	sbc	r15, r17
    1e8a:	c0 92 54 02 	sts	0x0254, r12
    1e8e:	d0 92 55 02 	sts	0x0255, r13
    1e92:	e0 92 56 02 	sts	0x0256, r14
    1e96:	f0 92 57 02 	sts	0x0257, r15
		//	sersendf_P(PSTR("\r\nc %lu  c_min %lu  n %ld"),
		//	           move_state.c, dda->c_min, move_state.n);
	#endif

	// TODO: If we stop axes individually, could we home two or more axes at the same time?
	if (dda->endstop_check != 0x0 && endstop_not_done == 0x0) {
    1e9a:	8a ad       	ldd	r24, Y+58	; 0x3a
    1e9c:	88 23       	and	r24, r24
    1e9e:	21 f1       	breq	.+72     	; 0x1ee8 <dda_step+0x424>
    1ea0:	71 10       	cpse	r7, r1
    1ea2:	22 c0       	rjmp	.+68     	; 0x1ee8 <dda_step+0x424>
		move_state.x_steps = move_state.y_steps = move_state.z_steps = move_state.e_steps = 0;
    1ea4:	10 92 50 02 	sts	0x0250, r1
    1ea8:	10 92 51 02 	sts	0x0251, r1
    1eac:	10 92 52 02 	sts	0x0252, r1
    1eb0:	10 92 53 02 	sts	0x0253, r1
    1eb4:	10 92 4c 02 	sts	0x024C, r1
    1eb8:	10 92 4d 02 	sts	0x024D, r1
    1ebc:	10 92 4e 02 	sts	0x024E, r1
    1ec0:	10 92 4f 02 	sts	0x024F, r1
    1ec4:	10 92 48 02 	sts	0x0248, r1
    1ec8:	10 92 49 02 	sts	0x0249, r1
    1ecc:	10 92 4a 02 	sts	0x024A, r1
    1ed0:	10 92 4b 02 	sts	0x024B, r1
    1ed4:	10 92 44 02 	sts	0x0244, r1
    1ed8:	10 92 45 02 	sts	0x0245, r1
    1edc:	10 92 46 02 	sts	0x0246, r1
    1ee0:	10 92 47 02 	sts	0x0247, r1
		endstops_off();
		// as we stop without ramping down, we have to re-init our ramping here
		dda_init();
    1ee4:	0e 94 98 06 	call	0xd30	; 0xd30 <dda_init>
		}
		dda->c <<= 8;
	#endif

	// If there are no steps left, we have finished.
	if (move_state.x_steps == 0 && move_state.y_steps == 0 &&
    1ee8:	80 91 44 02 	lds	r24, 0x0244
    1eec:	90 91 45 02 	lds	r25, 0x0245
    1ef0:	a0 91 46 02 	lds	r26, 0x0246
    1ef4:	b0 91 47 02 	lds	r27, 0x0247
    1ef8:	89 2b       	or	r24, r25
    1efa:	8a 2b       	or	r24, r26
    1efc:	8b 2b       	or	r24, r27
    1efe:	41 f5       	brne	.+80     	; 0x1f50 <dda_step+0x48c>
    1f00:	80 91 48 02 	lds	r24, 0x0248
    1f04:	90 91 49 02 	lds	r25, 0x0249
    1f08:	a0 91 4a 02 	lds	r26, 0x024A
    1f0c:	b0 91 4b 02 	lds	r27, 0x024B
    1f10:	89 2b       	or	r24, r25
    1f12:	8a 2b       	or	r24, r26
    1f14:	8b 2b       	or	r24, r27
    1f16:	e1 f4       	brne	.+56     	; 0x1f50 <dda_step+0x48c>
    1f18:	80 91 4c 02 	lds	r24, 0x024C
    1f1c:	90 91 4d 02 	lds	r25, 0x024D
    1f20:	a0 91 4e 02 	lds	r26, 0x024E
    1f24:	b0 91 4f 02 	lds	r27, 0x024F
    1f28:	89 2b       	or	r24, r25
    1f2a:	8a 2b       	or	r24, r26
    1f2c:	8b 2b       	or	r24, r27
    1f2e:	81 f4       	brne	.+32     	; 0x1f50 <dda_step+0x48c>
	    move_state.z_steps == 0 && move_state.e_steps == 0) {
    1f30:	80 91 50 02 	lds	r24, 0x0250
    1f34:	90 91 51 02 	lds	r25, 0x0251
    1f38:	a0 91 52 02 	lds	r26, 0x0252
    1f3c:	b0 91 53 02 	lds	r27, 0x0253
    1f40:	89 2b       	or	r24, r25
    1f42:	8a 2b       	or	r24, r26
    1f44:	8b 2b       	or	r24, r27
    1f46:	21 f4       	brne	.+8      	; 0x1f50 <dda_step+0x48c>
		dda->live = 0;
    1f48:	8d 89       	ldd	r24, Y+21	; 0x15
    1f4a:	8d 7f       	andi	r24, 0xFD	; 253
    1f4c:	8d 8b       	std	Y+21, r24	; 0x15
    1f4e:	02 c0       	rjmp	.+4      	; 0x1f54 <dda_step+0x490>
		#endif
		// z stepper is only enabled while moving
		z_disable();
	}
	else
		psu_timeout = 0;
    1f50:	10 92 bf 04 	sts	0x04BF, r1

	#ifdef ACCELERATION_RAMPING
		// we don't hit maximum speed exactly with acceleration calculation, so limit it here
		// the nice thing about _not_ setting dda->c to dda->c_min is, the move stops at the exact same c as it started, so we have to calculate c only once for the time being
		// TODO: set timer only if dda->c has changed
		if (dda->c_min > move_state.c)
    1f54:	ce a8       	ldd	r12, Y+54	; 0x36
    1f56:	df a8       	ldd	r13, Y+55	; 0x37
    1f58:	e8 ac       	ldd	r14, Y+56	; 0x38
    1f5a:	f9 ac       	ldd	r15, Y+57	; 0x39
    1f5c:	80 91 58 02 	lds	r24, 0x0258
    1f60:	90 91 59 02 	lds	r25, 0x0259
    1f64:	a0 91 5a 02 	lds	r26, 0x025A
    1f68:	b0 91 5b 02 	lds	r27, 0x025B
    1f6c:	8c 15       	cp	r24, r12
    1f6e:	9d 05       	cpc	r25, r13
    1f70:	ae 05       	cpc	r26, r14
    1f72:	bf 05       	cpc	r27, r15
    1f74:	38 f4       	brcc	.+14     	; 0x1f84 <dda_step+0x4c0>
			setTimer(dda->c_min >> 8);
    1f76:	99 27       	eor	r25, r25
    1f78:	8f 2d       	mov	r24, r15
    1f7a:	7e 2d       	mov	r23, r14
    1f7c:	6d 2d       	mov	r22, r13
    1f7e:	0e 94 20 2b 	call	0x5640	; 0x5640 <setTimer>
    1f82:	06 c0       	rjmp	.+12     	; 0x1f90 <dda_step+0x4cc>
		else
			setTimer(move_state.c >> 8);
    1f84:	69 2f       	mov	r22, r25
    1f86:	7a 2f       	mov	r23, r26
    1f88:	8b 2f       	mov	r24, r27
    1f8a:	99 27       	eor	r25, r25
    1f8c:	0e 94 20 2b 	call	0x5640	; 0x5640 <setTimer>
	#endif

	// turn off step outputs, hopefully they've been on long enough by now to register with the drivers
	// if not, too bad. or insert a (very!) small delay here, or fire up a spare timer or something.
	// we also hope that we don't step before the drivers register the low- limit maximum speed if you think this is a problem.
	unstep();
    1f90:	eb e0       	ldi	r30, 0x0B	; 11
    1f92:	f1 e0       	ldi	r31, 0x01	; 1
    1f94:	80 81       	ld	r24, Z
    1f96:	87 7f       	andi	r24, 0xF7	; 247
    1f98:	80 83       	st	Z, r24
    1f9a:	14 98       	cbi	0x02, 4	; 2
	OCR1A=0;
    1f9c:	10 92 89 00 	sts	0x0089, r1
    1fa0:	10 92 88 00 	sts	0x0088, r1
	OCR3C=0;
    1fa4:	10 92 9d 00 	sts	0x009D, r1
    1fa8:	10 92 9c 00 	sts	0x009C, r1
    1fac:	58 c0       	rjmp	.+176    	; 0x205e <dda_step+0x59a>
	Then we decide if this was the last step for this move, and if so mark this dda as dead so next timer interrupt we can start a new one.
	Finally we de-assert any asserted step pins.
*/
void dda_step(DDA *dda) {
	uint8_t endstop_stop; ///< Stop due to endstop trigger
	uint8_t endstop_not_done = 0; ///< Which axes haven't finished homing
    1fae:	71 2c       	mov	r7, r1
    1fb0:	02 c0       	rjmp	.+4      	; 0x1fb6 <dda_step+0x4f2>
#endif

		endstop_stop = move_state.debounce_count_xmin >= ENDSTOP_STEPS ||
		               move_state.debounce_count_xmax >= ENDSTOP_STEPS;
		if (!endstop_stop)
			endstop_not_done |= 0x1;
    1fb2:	77 24       	eor	r7, r7
    1fb4:	73 94       	inc	r7
	} else
#endif
		endstop_stop = 0;

#if ! defined ACCELERATION_TEMPORAL
	if ((move_state.x_steps) && ! endstop_stop) {
    1fb6:	80 91 44 02 	lds	r24, 0x0244
    1fba:	90 91 45 02 	lds	r25, 0x0245
    1fbe:	a0 91 46 02 	lds	r26, 0x0246
    1fc2:	b0 91 47 02 	lds	r27, 0x0247
    1fc6:	89 2b       	or	r24, r25
    1fc8:	8a 2b       	or	r24, r26
    1fca:	8b 2b       	or	r24, r27
    1fcc:	09 f0       	breq	.+2      	; 0x1fd0 <dda_step+0x50c>
    1fce:	ba cd       	rjmp	.-1164   	; 0x1b44 <dda_step+0x80>
    1fd0:	04 ce       	rjmp	.-1016   	; 0x1bda <dda_step+0x116>
	} else
#endif
		endstop_stop = 0;

#if ! defined ACCELERATION_TEMPORAL
	if ((move_state.y_steps) && ! endstop_stop) {
    1fd2:	c0 90 48 02 	lds	r12, 0x0248
    1fd6:	d0 90 49 02 	lds	r13, 0x0249
    1fda:	e0 90 4a 02 	lds	r14, 0x024A
    1fde:	f0 90 4b 02 	lds	r15, 0x024B
    1fe2:	c1 14       	cp	r12, r1
    1fe4:	d1 04       	cpc	r13, r1
    1fe6:	e1 04       	cpc	r14, r1
    1fe8:	f1 04       	cpc	r15, r1
    1fea:	09 f0       	breq	.+2      	; 0x1fee <dda_step+0x52a>
    1fec:	27 ce       	rjmp	.-946    	; 0x1c3c <dda_step+0x178>
    1fee:	58 ce       	rjmp	.-848    	; 0x1ca0 <dda_step+0x1dc>
	} else 
#endif
		endstop_stop = 0;

#if ! defined ACCELERATION_TEMPORAL
	if ((move_state.z_steps) && ! endstop_stop) {
    1ff0:	80 91 4c 02 	lds	r24, 0x024C
    1ff4:	90 91 4d 02 	lds	r25, 0x024D
    1ff8:	a0 91 4e 02 	lds	r26, 0x024E
    1ffc:	b0 91 4f 02 	lds	r27, 0x024F
    2000:	89 2b       	or	r24, r25
    2002:	8a 2b       	or	r24, r26
    2004:	8b 2b       	or	r24, r27
    2006:	09 f0       	breq	.+2      	; 0x200a <dda_step+0x546>
    2008:	69 ce       	rjmp	.-814    	; 0x1cdc <dda_step+0x218>
    200a:	a0 ce       	rjmp	.-704    	; 0x1d4c <dda_step+0x288>
			if (move_state.n > 0) // wrong ramp direction
				move_state.n = -((int32_t)2) - move_state.n;
			recalc_speed = 1;
		}
		if (recalc_speed) {
			move_state.n += 4;
    200c:	ec e5       	ldi	r30, 0x5C	; 92
    200e:	f2 e0       	ldi	r31, 0x02	; 2
    2010:	80 81       	ld	r24, Z
    2012:	91 81       	ldd	r25, Z+1	; 0x01
    2014:	a2 81       	ldd	r26, Z+2	; 0x02
    2016:	b3 81       	ldd	r27, Z+3	; 0x03
    2018:	9c 01       	movw	r18, r24
    201a:	ad 01       	movw	r20, r26
    201c:	2c 5f       	subi	r18, 0xFC	; 252
    201e:	3f 4f       	sbci	r19, 0xFF	; 255
    2020:	4f 4f       	sbci	r20, 0xFF	; 255
    2022:	5f 4f       	sbci	r21, 0xFF	; 255
    2024:	20 83       	st	Z, r18
    2026:	31 83       	std	Z+1, r19	; 0x01
    2028:	42 83       	std	Z+2, r20	; 0x02
    202a:	53 83       	std	Z+3, r21	; 0x03
			// be careful of signedness!
			move_state.c = (int32_t)move_state.c - ((int32_t)(move_state.c * 2) / (int32_t)move_state.n);
    202c:	08 e5       	ldi	r16, 0x58	; 88
    202e:	12 e0       	ldi	r17, 0x02	; 2
    2030:	f8 01       	movw	r30, r16
    2032:	80 80       	ld	r8, Z
    2034:	91 80       	ldd	r9, Z+1	; 0x01
    2036:	a2 80       	ldd	r10, Z+2	; 0x02
    2038:	b3 80       	ldd	r11, Z+3	; 0x03
    203a:	c5 01       	movw	r24, r10
    203c:	b4 01       	movw	r22, r8
    203e:	66 0f       	add	r22, r22
    2040:	77 1f       	adc	r23, r23
    2042:	88 1f       	adc	r24, r24
    2044:	99 1f       	adc	r25, r25
    2046:	0e 94 1a 2c 	call	0x5834	; 0x5834 <__divmodsi4>
    204a:	82 1a       	sub	r8, r18
    204c:	93 0a       	sbc	r9, r19
    204e:	a4 0a       	sbc	r10, r20
    2050:	b5 0a       	sbc	r11, r21
    2052:	f8 01       	movw	r30, r16
    2054:	80 82       	st	Z, r8
    2056:	91 82       	std	Z+1, r9	; 0x01
    2058:	a2 82       	std	Z+2, r10	; 0x02
    205a:	b3 82       	std	Z+3, r11	; 0x03
    205c:	11 cf       	rjmp	.-478    	; 0x1e80 <dda_step+0x3bc>
	// if not, too bad. or insert a (very!) small delay here, or fire up a spare timer or something.
	// we also hope that we don't step before the drivers register the low- limit maximum speed if you think this is a problem.
	unstep();
	OCR1A=0;
	OCR3C=0;
}
    205e:	df 91       	pop	r29
    2060:	cf 91       	pop	r28
    2062:	1f 91       	pop	r17
    2064:	0f 91       	pop	r16
    2066:	ff 90       	pop	r15
    2068:	ef 90       	pop	r14
    206a:	df 90       	pop	r13
    206c:	cf 90       	pop	r12
    206e:	bf 90       	pop	r11
    2070:	af 90       	pop	r10
    2072:	9f 90       	pop	r9
    2074:	8f 90       	pop	r8
    2076:	7f 90       	pop	r7
    2078:	08 95       	ret

0000207a <update_current_position>:

/// update global current_position struct
void update_current_position() {
    207a:	1f 93       	push	r17
    207c:	cf 93       	push	r28
    207e:	df 93       	push	r29
	DDA *dda = &movebuffer[mb_tail];
    2080:	c0 91 bc 04 	lds	r28, 0x04BC

	if (queue_empty()) {
    2084:	21 d4       	rcall	.+2114   	; 0x28c8 <queue_empty>
    2086:	88 23       	and	r24, r24
    2088:	09 f4       	brne	.+2      	; 0x208c <update_current_position+0x12>
    208a:	41 c0       	rjmp	.+130    	; 0x210e <update_current_position+0x94>
		current_position.X = startpoint.X;
		current_position.X = _XEncoderTicks;
    208c:	80 91 b8 04 	lds	r24, 0x04B8
    2090:	90 91 b9 04 	lds	r25, 0x04B9
    2094:	a0 91 ba 04 	lds	r26, 0x04BA
    2098:	b0 91 bb 04 	lds	r27, 0x04BB
    209c:	80 93 66 02 	sts	0x0266, r24
    20a0:	90 93 67 02 	sts	0x0267, r25
    20a4:	a0 93 68 02 	sts	0x0268, r26
    20a8:	b0 93 69 02 	sts	0x0269, r27
		current_position.Y = startpoint.Y;
		current_position.Y = _YEncoderTicks;
    20ac:	80 91 b4 04 	lds	r24, 0x04B4
    20b0:	90 91 b5 04 	lds	r25, 0x04B5
    20b4:	a0 91 b6 04 	lds	r26, 0x04B6
    20b8:	b0 91 b7 04 	lds	r27, 0x04B7
    20bc:	80 93 6a 02 	sts	0x026A, r24
    20c0:	90 93 6b 02 	sts	0x026B, r25
    20c4:	a0 93 6c 02 	sts	0x026C, r26
    20c8:	b0 93 6d 02 	sts	0x026D, r27
		current_position.Z = startpoint.Z;
    20cc:	80 91 98 02 	lds	r24, 0x0298
    20d0:	90 91 99 02 	lds	r25, 0x0299
    20d4:	a0 91 9a 02 	lds	r26, 0x029A
    20d8:	b0 91 9b 02 	lds	r27, 0x029B
    20dc:	80 93 6e 02 	sts	0x026E, r24
    20e0:	90 93 6f 02 	sts	0x026F, r25
    20e4:	a0 93 70 02 	sts	0x0270, r26
    20e8:	b0 93 71 02 	sts	0x0271, r27
		current_position.E = startpoint.E;
    20ec:	80 91 9c 02 	lds	r24, 0x029C
    20f0:	90 91 9d 02 	lds	r25, 0x029D
    20f4:	a0 91 9e 02 	lds	r26, 0x029E
    20f8:	b0 91 9f 02 	lds	r27, 0x029F
    20fc:	80 93 72 02 	sts	0x0272, r24
    2100:	90 93 73 02 	sts	0x0273, r25
    2104:	a0 93 74 02 	sts	0x0274, r26
    2108:	b0 93 75 02 	sts	0x0275, r27
    210c:	d5 c0       	rjmp	.+426    	; 0x22b8 <__stack+0xb9>
	OCR3C=0;
}

/// update global current_position struct
void update_current_position() {
	DDA *dda = &movebuffer[mb_tail];
    210e:	8c e3       	ldi	r24, 0x3C	; 60
    2110:	c8 9f       	mul	r28, r24
    2112:	e0 01       	movw	r28, r0
    2114:	11 24       	eor	r1, r1
    2116:	cb 55       	subi	r28, 0x5B	; 91
    2118:	dd 4f       	sbci	r29, 0xFD	; 253
		current_position.Y = startpoint.Y;
		current_position.Y = _YEncoderTicks;
		current_position.Z = startpoint.Z;
		current_position.E = startpoint.E;
	}
	else if (dda->live) {
    211a:	1d 89       	ldd	r17, Y+21	; 0x15
    211c:	11 ff       	sbrs	r17, 1
    211e:	cc c0       	rjmp	.+408    	; 0x22b8 <__stack+0xb9>
			                     // but x_steps can be like 1000000 already, so we'd overflow
			                     move_state.x_steps * 1000 / ((STEPS_PER_M_X + 500) / 1000);					 
		else
			current_position.X = dda->endpoint.X +
			                     move_state.x_steps * 1000 / ((STEPS_PER_M_X + 500) / 1000);
			current_position.X = _XEncoderTicks;
    2120:	80 91 b8 04 	lds	r24, 0x04B8
    2124:	90 91 b9 04 	lds	r25, 0x04B9
    2128:	a0 91 ba 04 	lds	r26, 0x04BA
    212c:	b0 91 bb 04 	lds	r27, 0x04BB
    2130:	80 93 66 02 	sts	0x0266, r24
    2134:	90 93 67 02 	sts	0x0267, r25
    2138:	a0 93 68 02 	sts	0x0268, r26
    213c:	b0 93 69 02 	sts	0x0269, r27
			current_position.Y = dda->endpoint.Y -
			                     move_state.y_steps * 1000 / ((STEPS_PER_M_Y + 500) / 1000);
		else
			current_position.Y = dda->endpoint.Y +
			                     move_state.y_steps * 1000 / ((STEPS_PER_M_Y + 500) / 1000);
			current_position.Y = _YEncoderTicks;
    2140:	80 91 b4 04 	lds	r24, 0x04B4
    2144:	90 91 b5 04 	lds	r25, 0x04B5
    2148:	a0 91 b6 04 	lds	r26, 0x04B6
    214c:	b0 91 b7 04 	lds	r27, 0x04B7
    2150:	80 93 6a 02 	sts	0x026A, r24
    2154:	90 93 6b 02 	sts	0x026B, r25
    2158:	a0 93 6c 02 	sts	0x026C, r26
    215c:	b0 93 6d 02 	sts	0x026D, r27

		if (dda->z_direction)
    2160:	15 ff       	sbrs	r17, 5
    2162:	23 c0       	rjmp	.+70     	; 0x21aa <update_current_position+0x130>
			current_position.Z = dda->endpoint.Z -
			                     move_state.z_steps * 1000 / ((STEPS_PER_M_Z + 500) / 1000);
    2164:	20 91 4c 02 	lds	r18, 0x024C
    2168:	30 91 4d 02 	lds	r19, 0x024D
    216c:	40 91 4e 02 	lds	r20, 0x024E
    2170:	50 91 4f 02 	lds	r21, 0x024F
    2174:	a8 ee       	ldi	r26, 0xE8	; 232
    2176:	b3 e0       	ldi	r27, 0x03	; 3
    2178:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    217c:	26 e0       	ldi	r18, 0x06	; 6
    217e:	3d e0       	ldi	r19, 0x0D	; 13
    2180:	40 e0       	ldi	r20, 0x00	; 0
    2182:	50 e0       	ldi	r21, 0x00	; 0
    2184:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
			current_position.Y = dda->endpoint.Y +
			                     move_state.y_steps * 1000 / ((STEPS_PER_M_Y + 500) / 1000);
			current_position.Y = _YEncoderTicks;

		if (dda->z_direction)
			current_position.Z = dda->endpoint.Z -
    2188:	88 85       	ldd	r24, Y+8	; 0x08
    218a:	99 85       	ldd	r25, Y+9	; 0x09
    218c:	aa 85       	ldd	r26, Y+10	; 0x0a
    218e:	bb 85       	ldd	r27, Y+11	; 0x0b
    2190:	82 1b       	sub	r24, r18
    2192:	93 0b       	sbc	r25, r19
    2194:	a4 0b       	sbc	r26, r20
    2196:	b5 0b       	sbc	r27, r21
    2198:	80 93 6e 02 	sts	0x026E, r24
    219c:	90 93 6f 02 	sts	0x026F, r25
    21a0:	a0 93 70 02 	sts	0x0270, r26
    21a4:	b0 93 71 02 	sts	0x0271, r27
    21a8:	22 c0       	rjmp	.+68     	; 0x21ee <update_current_position+0x174>
			                     move_state.z_steps * 1000 / ((STEPS_PER_M_Z + 500) / 1000);
		else
			current_position.Z = dda->endpoint.Z +
			                     move_state.z_steps * 1000 / ((STEPS_PER_M_Z + 500) / 1000);
    21aa:	20 91 4c 02 	lds	r18, 0x024C
    21ae:	30 91 4d 02 	lds	r19, 0x024D
    21b2:	40 91 4e 02 	lds	r20, 0x024E
    21b6:	50 91 4f 02 	lds	r21, 0x024F
    21ba:	a8 ee       	ldi	r26, 0xE8	; 232
    21bc:	b3 e0       	ldi	r27, 0x03	; 3
    21be:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    21c2:	26 e0       	ldi	r18, 0x06	; 6
    21c4:	3d e0       	ldi	r19, 0x0D	; 13
    21c6:	40 e0       	ldi	r20, 0x00	; 0
    21c8:	50 e0       	ldi	r21, 0x00	; 0
    21ca:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>

		if (dda->z_direction)
			current_position.Z = dda->endpoint.Z -
			                     move_state.z_steps * 1000 / ((STEPS_PER_M_Z + 500) / 1000);
		else
			current_position.Z = dda->endpoint.Z +
    21ce:	88 85       	ldd	r24, Y+8	; 0x08
    21d0:	99 85       	ldd	r25, Y+9	; 0x09
    21d2:	aa 85       	ldd	r26, Y+10	; 0x0a
    21d4:	bb 85       	ldd	r27, Y+11	; 0x0b
    21d6:	82 0f       	add	r24, r18
    21d8:	93 1f       	adc	r25, r19
    21da:	a4 1f       	adc	r26, r20
    21dc:	b5 1f       	adc	r27, r21
    21de:	80 93 6e 02 	sts	0x026E, r24
    21e2:	90 93 6f 02 	sts	0x026F, r25
    21e6:	a0 93 70 02 	sts	0x0270, r26
    21ea:	b0 93 71 02 	sts	0x0271, r27
			                     move_state.z_steps * 1000 / ((STEPS_PER_M_Z + 500) / 1000);

		if (dda->endpoint.e_relative) {
    21ee:	8c 89       	ldd	r24, Y+20	; 0x14
    21f0:	80 ff       	sbrs	r24, 0
    21f2:	1b c0       	rjmp	.+54     	; 0x222a <__stack+0x2b>
			current_position.E = move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
    21f4:	20 91 50 02 	lds	r18, 0x0250
    21f8:	30 91 51 02 	lds	r19, 0x0251
    21fc:	40 91 52 02 	lds	r20, 0x0252
    2200:	50 91 53 02 	lds	r21, 0x0253
    2204:	a8 ee       	ldi	r26, 0xE8	; 232
    2206:	b3 e0       	ldi	r27, 0x03	; 3
    2208:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    220c:	2b e0       	ldi	r18, 0x0B	; 11
    220e:	30 e0       	ldi	r19, 0x00	; 0
    2210:	40 e0       	ldi	r20, 0x00	; 0
    2212:	50 e0       	ldi	r21, 0x00	; 0
    2214:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    2218:	20 93 72 02 	sts	0x0272, r18
    221c:	30 93 73 02 	sts	0x0273, r19
    2220:	40 93 74 02 	sts	0x0274, r20
    2224:	50 93 75 02 	sts	0x0275, r21
    2228:	47 c0       	rjmp	.+142    	; 0x22b8 <__stack+0xb9>
		}
		else {
			if (dda->e_direction)
    222a:	16 ff       	sbrs	r17, 6
    222c:	23 c0       	rjmp	.+70     	; 0x2274 <__stack+0x75>
				current_position.E = dda->endpoint.E -
				                     move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
    222e:	20 91 50 02 	lds	r18, 0x0250
    2232:	30 91 51 02 	lds	r19, 0x0251
    2236:	40 91 52 02 	lds	r20, 0x0252
    223a:	50 91 53 02 	lds	r21, 0x0253
    223e:	a8 ee       	ldi	r26, 0xE8	; 232
    2240:	b3 e0       	ldi	r27, 0x03	; 3
    2242:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    2246:	2b e0       	ldi	r18, 0x0B	; 11
    2248:	30 e0       	ldi	r19, 0x00	; 0
    224a:	40 e0       	ldi	r20, 0x00	; 0
    224c:	50 e0       	ldi	r21, 0x00	; 0
    224e:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
		if (dda->endpoint.e_relative) {
			current_position.E = move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
		}
		else {
			if (dda->e_direction)
				current_position.E = dda->endpoint.E -
    2252:	8c 85       	ldd	r24, Y+12	; 0x0c
    2254:	9d 85       	ldd	r25, Y+13	; 0x0d
    2256:	ae 85       	ldd	r26, Y+14	; 0x0e
    2258:	bf 85       	ldd	r27, Y+15	; 0x0f
    225a:	82 1b       	sub	r24, r18
    225c:	93 0b       	sbc	r25, r19
    225e:	a4 0b       	sbc	r26, r20
    2260:	b5 0b       	sbc	r27, r21
    2262:	80 93 72 02 	sts	0x0272, r24
    2266:	90 93 73 02 	sts	0x0273, r25
    226a:	a0 93 74 02 	sts	0x0274, r26
    226e:	b0 93 75 02 	sts	0x0275, r27
    2272:	22 c0       	rjmp	.+68     	; 0x22b8 <__stack+0xb9>
				                     move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
			else
				current_position.E = dda->endpoint.E +
				                     move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
    2274:	20 91 50 02 	lds	r18, 0x0250
    2278:	30 91 51 02 	lds	r19, 0x0251
    227c:	40 91 52 02 	lds	r20, 0x0252
    2280:	50 91 53 02 	lds	r21, 0x0253
    2284:	a8 ee       	ldi	r26, 0xE8	; 232
    2286:	b3 e0       	ldi	r27, 0x03	; 3
    2288:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    228c:	2b e0       	ldi	r18, 0x0B	; 11
    228e:	30 e0       	ldi	r19, 0x00	; 0
    2290:	40 e0       	ldi	r20, 0x00	; 0
    2292:	50 e0       	ldi	r21, 0x00	; 0
    2294:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
		else {
			if (dda->e_direction)
				current_position.E = dda->endpoint.E -
				                     move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
			else
				current_position.E = dda->endpoint.E +
    2298:	8c 85       	ldd	r24, Y+12	; 0x0c
    229a:	9d 85       	ldd	r25, Y+13	; 0x0d
    229c:	ae 85       	ldd	r26, Y+14	; 0x0e
    229e:	bf 85       	ldd	r27, Y+15	; 0x0f
    22a0:	82 0f       	add	r24, r18
    22a2:	93 1f       	adc	r25, r19
    22a4:	a4 1f       	adc	r26, r20
    22a6:	b5 1f       	adc	r27, r21
    22a8:	80 93 72 02 	sts	0x0272, r24
    22ac:	90 93 73 02 	sts	0x0273, r25
    22b0:	a0 93 74 02 	sts	0x0274, r26
    22b4:	b0 93 75 02 	sts	0x0275, r27
				                     move_state.e_steps * 1000 / ((STEPS_PER_M_E + 500) / 1000);
		}

		// current_position.F is updated in dda_start()
	}
}
    22b8:	df 91       	pop	r29
    22ba:	cf 91       	pop	r28
    22bc:	1f 91       	pop	r17
    22be:	08 95       	ret

000022c0 <__vector_3>:

ISR(INT2_vect) 
{
    22c0:	1f 92       	push	r1
    22c2:	0f 92       	push	r0
    22c4:	0f b6       	in	r0, 0x3f	; 63
    22c6:	0f 92       	push	r0
    22c8:	11 24       	eor	r1, r1
    22ca:	0b b6       	in	r0, 0x3b	; 59
    22cc:	0f 92       	push	r0
    22ce:	4f 93       	push	r20
    22d0:	5f 93       	push	r21
    22d2:	6f 93       	push	r22
    22d4:	7f 93       	push	r23
    22d6:	8f 93       	push	r24
    22d8:	9f 93       	push	r25
    22da:	af 93       	push	r26
    22dc:	bf 93       	push	r27
    22de:	ef 93       	push	r30
    22e0:	ff 93       	push	r31
	// Test transition; since the interrupt will only fire on 'rising' we don't need to read pin A
	//_XCsens=analogRead(A0);
	_XEncoderBSet = x_EncB();   // read the input pin 
    22e2:	e9 e0       	ldi	r30, 0x09	; 9
    22e4:	f1 e0       	ldi	r31, 0x01	; 1
    22e6:	80 81       	ld	r24, Z
    22e8:	82 95       	swap	r24
    22ea:	81 70       	andi	r24, 0x01	; 1
    22ec:	80 93 cb 04 	sts	0x04CB, r24
	_XEncoderISet = x_EncI();
    22f0:	80 81       	ld	r24, Z
    22f2:	82 fb       	bst	r24, 2
    22f4:	88 27       	eor	r24, r24
    22f6:	80 f9       	bld	r24, 0
    22f8:	80 93 ce 04 	sts	0x04CE, r24
	#ifdef LeftEncoderIsReversed
	_XEncoderTicks -= _XEncoderBSet ? -1 : +1;
	if (_XEncoderISet == 0)
	_XEncoderIndex -= _XEncoderBSet ? -1 : +1;
	#else
	_XEncoderTicks += _XEncoderBSet ? -1 : +1;
    22fc:	80 91 cb 04 	lds	r24, 0x04CB
    2300:	88 23       	and	r24, r24
    2302:	21 f0       	breq	.+8      	; 0x230c <__vector_3+0x4c>
    2304:	4f ef       	ldi	r20, 0xFF	; 255
    2306:	5f ef       	ldi	r21, 0xFF	; 255
    2308:	ba 01       	movw	r22, r20
    230a:	04 c0       	rjmp	.+8      	; 0x2314 <__vector_3+0x54>
    230c:	41 e0       	ldi	r20, 0x01	; 1
    230e:	50 e0       	ldi	r21, 0x00	; 0
    2310:	60 e0       	ldi	r22, 0x00	; 0
    2312:	70 e0       	ldi	r23, 0x00	; 0
    2314:	80 91 b8 04 	lds	r24, 0x04B8
    2318:	90 91 b9 04 	lds	r25, 0x04B9
    231c:	a0 91 ba 04 	lds	r26, 0x04BA
    2320:	b0 91 bb 04 	lds	r27, 0x04BB
    2324:	84 0f       	add	r24, r20
    2326:	95 1f       	adc	r25, r21
    2328:	a6 1f       	adc	r26, r22
    232a:	b7 1f       	adc	r27, r23
    232c:	80 93 b8 04 	sts	0x04B8, r24
    2330:	90 93 b9 04 	sts	0x04B9, r25
    2334:	a0 93 ba 04 	sts	0x04BA, r26
    2338:	b0 93 bb 04 	sts	0x04BB, r27
	#endif
}
    233c:	ff 91       	pop	r31
    233e:	ef 91       	pop	r30
    2340:	bf 91       	pop	r27
    2342:	af 91       	pop	r26
    2344:	9f 91       	pop	r25
    2346:	8f 91       	pop	r24
    2348:	7f 91       	pop	r23
    234a:	6f 91       	pop	r22
    234c:	5f 91       	pop	r21
    234e:	4f 91       	pop	r20
    2350:	0f 90       	pop	r0
    2352:	0b be       	out	0x3b, r0	; 59
    2354:	0f 90       	pop	r0
    2356:	0f be       	out	0x3f, r0	; 63
    2358:	0f 90       	pop	r0
    235a:	1f 90       	pop	r1
    235c:	18 95       	reti

0000235e <__vector_4>:

// Interrupt service routines for the right motor's quadrature encoder
ISR(INT3_vect) 
{
    235e:	1f 92       	push	r1
    2360:	0f 92       	push	r0
    2362:	0f b6       	in	r0, 0x3f	; 63
    2364:	0f 92       	push	r0
    2366:	11 24       	eor	r1, r1
    2368:	4f 93       	push	r20
    236a:	5f 93       	push	r21
    236c:	6f 93       	push	r22
    236e:	7f 93       	push	r23
    2370:	8f 93       	push	r24
    2372:	9f 93       	push	r25
    2374:	af 93       	push	r26
    2376:	bf 93       	push	r27
	// Test transition; since the interrupt will only fire on 'rising' we don't need to read pin A
	_YEncoderBSet = y_EncB();    // read the input pin
    2378:	82 b3       	in	r24, 0x12	; 18
    237a:	81 70       	andi	r24, 0x01	; 1
    237c:	80 93 cc 04 	sts	0x04CC, r24
	_YEncoderISet = y_EncI();
    2380:	80 91 09 01 	lds	r24, 0x0109
    2384:	86 fb       	bst	r24, 6
    2386:	88 27       	eor	r24, r24
    2388:	80 f9       	bld	r24, 0
    238a:	80 93 cd 04 	sts	0x04CD, r24
	#ifdef RightEncoderIsReversed
	_YEncoderTicks -= _YEncoderBSet ? -1 : +1;
	if (_YEncoderISet == 0)
	_YEncoderIndex -= _YEncoderBSet ? -1 : +1;
	#else
	_YEncoderTicks += _YEncoderBSet ? -1 : +1;
    238e:	80 91 cc 04 	lds	r24, 0x04CC
    2392:	88 23       	and	r24, r24
    2394:	21 f0       	breq	.+8      	; 0x239e <__vector_4+0x40>
    2396:	4f ef       	ldi	r20, 0xFF	; 255
    2398:	5f ef       	ldi	r21, 0xFF	; 255
    239a:	ba 01       	movw	r22, r20
    239c:	04 c0       	rjmp	.+8      	; 0x23a6 <__vector_4+0x48>
    239e:	41 e0       	ldi	r20, 0x01	; 1
    23a0:	50 e0       	ldi	r21, 0x00	; 0
    23a2:	60 e0       	ldi	r22, 0x00	; 0
    23a4:	70 e0       	ldi	r23, 0x00	; 0
    23a6:	80 91 b4 04 	lds	r24, 0x04B4
    23aa:	90 91 b5 04 	lds	r25, 0x04B5
    23ae:	a0 91 b6 04 	lds	r26, 0x04B6
    23b2:	b0 91 b7 04 	lds	r27, 0x04B7
    23b6:	84 0f       	add	r24, r20
    23b8:	95 1f       	adc	r25, r21
    23ba:	a6 1f       	adc	r26, r22
    23bc:	b7 1f       	adc	r27, r23
    23be:	80 93 b4 04 	sts	0x04B4, r24
    23c2:	90 93 b5 04 	sts	0x04B5, r25
    23c6:	a0 93 b6 04 	sts	0x04B6, r26
    23ca:	b0 93 b7 04 	sts	0x04B7, r27
	#endif
    23ce:	bf 91       	pop	r27
    23d0:	af 91       	pop	r26
    23d2:	9f 91       	pop	r25
    23d4:	8f 91       	pop	r24
    23d6:	7f 91       	pop	r23
    23d8:	6f 91       	pop	r22
    23da:	5f 91       	pop	r21
    23dc:	4f 91       	pop	r20
    23de:	0f 90       	pop	r0
    23e0:	0f be       	out	0x3f, r0	; 63
    23e2:	0f 90       	pop	r0
    23e4:	1f 90       	pop	r1
    23e6:	18 95       	reti

000023e8 <muldivQR>:

  Found on  http://stackoverflow.com/questions/4144232/
  how-to-calculate-a-times-b-divided-by-c-only-using-32-bit-integer-types-even-i
*/
const int32_t muldivQR(int32_t multiplicand, uint32_t qn, uint32_t rn,
                       uint32_t divisor) {
    23e8:	2f 92       	push	r2
    23ea:	3f 92       	push	r3
    23ec:	4f 92       	push	r4
    23ee:	5f 92       	push	r5
    23f0:	6f 92       	push	r6
    23f2:	7f 92       	push	r7
    23f4:	8f 92       	push	r8
    23f6:	9f 92       	push	r9
    23f8:	af 92       	push	r10
    23fa:	bf 92       	push	r11
    23fc:	cf 92       	push	r12
    23fe:	df 92       	push	r13
    2400:	ef 92       	push	r14
    2402:	ff 92       	push	r15
    2404:	0f 93       	push	r16
    2406:	1f 93       	push	r17
    2408:	cf 93       	push	r28
    240a:	df 93       	push	r29
    240c:	cd b7       	in	r28, 0x3d	; 61
    240e:	de b7       	in	r29, 0x3e	; 62
    2410:	28 97       	sbiw	r28, 0x08	; 8
    2412:	0f b6       	in	r0, 0x3f	; 63
    2414:	f8 94       	cli
    2416:	de bf       	out	0x3e, r29	; 62
    2418:	0f be       	out	0x3f, r0	; 63
    241a:	cd bf       	out	0x3d, r28	; 61
    241c:	1b 01       	movw	r2, r22
    241e:	2c 01       	movw	r4, r24
  uint32_t quotient = 0;
  uint32_t remainder = 0;
  uint8_t negative_flag = 0;

  if (multiplicand < 0) {
    2420:	99 23       	and	r25, r25
    2422:	54 f4       	brge	.+20     	; 0x2438 <muldivQR+0x50>
    negative_flag = 1;
    multiplicand = -multiplicand;
    2424:	50 94       	com	r5
    2426:	40 94       	com	r4
    2428:	30 94       	com	r3
    242a:	20 94       	com	r2
    242c:	21 1c       	adc	r2, r1
    242e:	31 1c       	adc	r3, r1
    2430:	41 1c       	adc	r4, r1
    2432:	51 1c       	adc	r5, r1
  uint32_t quotient = 0;
  uint32_t remainder = 0;
  uint8_t negative_flag = 0;

  if (multiplicand < 0) {
    negative_flag = 1;
    2434:	61 e0       	ldi	r22, 0x01	; 1
    2436:	01 c0       	rjmp	.+2      	; 0x243a <muldivQR+0x52>
*/
const int32_t muldivQR(int32_t multiplicand, uint32_t qn, uint32_t rn,
                       uint32_t divisor) {
  uint32_t quotient = 0;
  uint32_t remainder = 0;
  uint8_t negative_flag = 0;
    2438:	60 e0       	ldi	r22, 0x00	; 0
  if (multiplicand < 0) {
    negative_flag = 1;
    multiplicand = -multiplicand;
  }

  while(multiplicand) {
    243a:	21 14       	cp	r2, r1
    243c:	31 04       	cpc	r3, r1
    243e:	41 04       	cpc	r4, r1
    2440:	51 04       	cpc	r5, r1
    2442:	09 f4       	brne	.+2      	; 0x2446 <muldivQR+0x5e>
    2444:	76 c0       	rjmp	.+236    	; 0x2532 <muldivQR+0x14a>
    2446:	1d 82       	std	Y+5, r1	; 0x05
    2448:	1e 82       	std	Y+6, r1	; 0x06
    244a:	1f 82       	std	Y+7, r1	; 0x07
    244c:	18 86       	std	Y+8, r1	; 0x08
    244e:	19 82       	std	Y+1, r1	; 0x01
    2450:	1a 82       	std	Y+2, r1	; 0x02
    2452:	1b 82       	std	Y+3, r1	; 0x03
    2454:	1c 82       	std	Y+4, r1	; 0x04
    if (multiplicand & 1) {
    2456:	20 fe       	sbrs	r2, 0
    2458:	32 c0       	rjmp	.+100    	; 0x24be <muldivQR+0xd6>
      quotient += qn;
    245a:	69 80       	ldd	r6, Y+1	; 0x01
    245c:	7a 80       	ldd	r7, Y+2	; 0x02
    245e:	8b 80       	ldd	r8, Y+3	; 0x03
    2460:	9c 80       	ldd	r9, Y+4	; 0x04
    2462:	62 0e       	add	r6, r18
    2464:	73 1e       	adc	r7, r19
    2466:	84 1e       	adc	r8, r20
    2468:	95 1e       	adc	r9, r21
    246a:	69 82       	std	Y+1, r6	; 0x01
    246c:	7a 82       	std	Y+2, r7	; 0x02
    246e:	8b 82       	std	Y+3, r8	; 0x03
    2470:	9c 82       	std	Y+4, r9	; 0x04
      remainder += rn;
    2472:	8d 81       	ldd	r24, Y+5	; 0x05
    2474:	9e 81       	ldd	r25, Y+6	; 0x06
    2476:	af 81       	ldd	r26, Y+7	; 0x07
    2478:	b8 85       	ldd	r27, Y+8	; 0x08
    247a:	8e 0d       	add	r24, r14
    247c:	9f 1d       	adc	r25, r15
    247e:	a0 1f       	adc	r26, r16
    2480:	b1 1f       	adc	r27, r17
    2482:	8d 83       	std	Y+5, r24	; 0x05
    2484:	9e 83       	std	Y+6, r25	; 0x06
    2486:	af 83       	std	Y+7, r26	; 0x07
    2488:	b8 87       	std	Y+8, r27	; 0x08
      if (remainder >= divisor) {
    248a:	8a 15       	cp	r24, r10
    248c:	9b 05       	cpc	r25, r11
    248e:	ac 05       	cpc	r26, r12
    2490:	bd 05       	cpc	r27, r13
    2492:	a8 f0       	brcs	.+42     	; 0x24be <muldivQR+0xd6>
        quotient++;
    2494:	d4 01       	movw	r26, r8
    2496:	c3 01       	movw	r24, r6
    2498:	01 96       	adiw	r24, 0x01	; 1
    249a:	a1 1d       	adc	r26, r1
    249c:	b1 1d       	adc	r27, r1
    249e:	89 83       	std	Y+1, r24	; 0x01
    24a0:	9a 83       	std	Y+2, r25	; 0x02
    24a2:	ab 83       	std	Y+3, r26	; 0x03
    24a4:	bc 83       	std	Y+4, r27	; 0x04
        remainder -= divisor;
    24a6:	6d 80       	ldd	r6, Y+5	; 0x05
    24a8:	7e 80       	ldd	r7, Y+6	; 0x06
    24aa:	8f 80       	ldd	r8, Y+7	; 0x07
    24ac:	98 84       	ldd	r9, Y+8	; 0x08
    24ae:	6a 18       	sub	r6, r10
    24b0:	7b 08       	sbc	r7, r11
    24b2:	8c 08       	sbc	r8, r12
    24b4:	9d 08       	sbc	r9, r13
    24b6:	6d 82       	std	Y+5, r6	; 0x05
    24b8:	7e 82       	std	Y+6, r7	; 0x06
    24ba:	8f 82       	std	Y+7, r8	; 0x07
    24bc:	98 86       	std	Y+8, r9	; 0x08
      }
    }
    multiplicand  >>= 1;
    24be:	55 94       	asr	r5
    24c0:	47 94       	ror	r4
    24c2:	37 94       	ror	r3
    24c4:	27 94       	ror	r2
    qn <<= 1;
    24c6:	22 0f       	add	r18, r18
    24c8:	33 1f       	adc	r19, r19
    24ca:	44 1f       	adc	r20, r20
    24cc:	55 1f       	adc	r21, r21
    rn <<= 1;
    24ce:	ee 0c       	add	r14, r14
    24d0:	ff 1c       	adc	r15, r15
    24d2:	00 1f       	adc	r16, r16
    24d4:	11 1f       	adc	r17, r17
    if (rn >= divisor) {
    24d6:	ea 14       	cp	r14, r10
    24d8:	fb 04       	cpc	r15, r11
    24da:	0c 05       	cpc	r16, r12
    24dc:	1d 05       	cpc	r17, r13
    24de:	40 f0       	brcs	.+16     	; 0x24f0 <muldivQR+0x108>
      qn++; 
    24e0:	2f 5f       	subi	r18, 0xFF	; 255
    24e2:	3f 4f       	sbci	r19, 0xFF	; 255
    24e4:	4f 4f       	sbci	r20, 0xFF	; 255
    24e6:	5f 4f       	sbci	r21, 0xFF	; 255
      rn -= divisor;
    24e8:	ea 18       	sub	r14, r10
    24ea:	fb 08       	sbc	r15, r11
    24ec:	0c 09       	sbc	r16, r12
    24ee:	1d 09       	sbc	r17, r13
  if (multiplicand < 0) {
    negative_flag = 1;
    multiplicand = -multiplicand;
  }

  while(multiplicand) {
    24f0:	21 14       	cp	r2, r1
    24f2:	31 04       	cpc	r3, r1
    24f4:	41 04       	cpc	r4, r1
    24f6:	51 04       	cpc	r5, r1
    24f8:	09 f0       	breq	.+2      	; 0x24fc <muldivQR+0x114>
    24fa:	ad cf       	rjmp	.-166    	; 0x2456 <muldivQR+0x6e>
      rn -= divisor;
    }
  }

  // rounding
  if (remainder > divisor / 2)
    24fc:	d6 01       	movw	r26, r12
    24fe:	c5 01       	movw	r24, r10
    2500:	b6 95       	lsr	r27
    2502:	a7 95       	ror	r26
    2504:	97 95       	ror	r25
    2506:	87 95       	ror	r24
    2508:	2d 81       	ldd	r18, Y+5	; 0x05
    250a:	3e 81       	ldd	r19, Y+6	; 0x06
    250c:	4f 81       	ldd	r20, Y+7	; 0x07
    250e:	58 85       	ldd	r21, Y+8	; 0x08
    2510:	82 17       	cp	r24, r18
    2512:	93 07       	cpc	r25, r19
    2514:	a4 07       	cpc	r26, r20
    2516:	b5 07       	cpc	r27, r21
    2518:	80 f4       	brcc	.+32     	; 0x253a <muldivQR+0x152>
    quotient++;
    251a:	89 81       	ldd	r24, Y+1	; 0x01
    251c:	9a 81       	ldd	r25, Y+2	; 0x02
    251e:	ab 81       	ldd	r26, Y+3	; 0x03
    2520:	bc 81       	ldd	r27, Y+4	; 0x04
    2522:	01 96       	adiw	r24, 0x01	; 1
    2524:	a1 1d       	adc	r26, r1
    2526:	b1 1d       	adc	r27, r1
    2528:	89 83       	std	Y+1, r24	; 0x01
    252a:	9a 83       	std	Y+2, r25	; 0x02
    252c:	ab 83       	std	Y+3, r26	; 0x03
    252e:	bc 83       	std	Y+4, r27	; 0x04
    2530:	04 c0       	rjmp	.+8      	; 0x253a <muldivQR+0x152>
  if (multiplicand < 0) {
    negative_flag = 1;
    multiplicand = -multiplicand;
  }

  while(multiplicand) {
    2532:	19 82       	std	Y+1, r1	; 0x01
    2534:	1a 82       	std	Y+2, r1	; 0x02
    2536:	1b 82       	std	Y+3, r1	; 0x03
    2538:	1c 82       	std	Y+4, r1	; 0x04
  // rounding
  if (remainder > divisor / 2)
    quotient++;

  // remainder is valid here, but not returned
  return negative_flag ? -((int32_t)quotient) : (int32_t)quotient;
    253a:	66 23       	and	r22, r22
    253c:	61 f0       	breq	.+24     	; 0x2556 <muldivQR+0x16e>
    253e:	09 81       	ldd	r16, Y+1	; 0x01
    2540:	1a 81       	ldd	r17, Y+2	; 0x02
    2542:	2b 81       	ldd	r18, Y+3	; 0x03
    2544:	3c 81       	ldd	r19, Y+4	; 0x04
    2546:	30 95       	com	r19
    2548:	20 95       	com	r18
    254a:	10 95       	com	r17
    254c:	01 95       	neg	r16
    254e:	1f 4f       	sbci	r17, 0xFF	; 255
    2550:	2f 4f       	sbci	r18, 0xFF	; 255
    2552:	3f 4f       	sbci	r19, 0xFF	; 255
    2554:	04 c0       	rjmp	.+8      	; 0x255e <muldivQR+0x176>
    2556:	09 81       	ldd	r16, Y+1	; 0x01
    2558:	1a 81       	ldd	r17, Y+2	; 0x02
    255a:	2b 81       	ldd	r18, Y+3	; 0x03
    255c:	3c 81       	ldd	r19, Y+4	; 0x04
}
    255e:	60 2f       	mov	r22, r16
    2560:	71 2f       	mov	r23, r17
    2562:	82 2f       	mov	r24, r18
    2564:	93 2f       	mov	r25, r19
    2566:	28 96       	adiw	r28, 0x08	; 8
    2568:	0f b6       	in	r0, 0x3f	; 63
    256a:	f8 94       	cli
    256c:	de bf       	out	0x3e, r29	; 62
    256e:	0f be       	out	0x3f, r0	; 63
    2570:	cd bf       	out	0x3d, r28	; 61
    2572:	df 91       	pop	r29
    2574:	cf 91       	pop	r28
    2576:	1f 91       	pop	r17
    2578:	0f 91       	pop	r16
    257a:	ff 90       	pop	r15
    257c:	ef 90       	pop	r14
    257e:	df 90       	pop	r13
    2580:	cf 90       	pop	r12
    2582:	bf 90       	pop	r11
    2584:	af 90       	pop	r10
    2586:	9f 90       	pop	r9
    2588:	8f 90       	pop	r8
    258a:	7f 90       	pop	r7
    258c:	6f 90       	pop	r6
    258e:	5f 90       	pop	r5
    2590:	4f 90       	pop	r4
    2592:	3f 90       	pop	r3
    2594:	2f 90       	pop	r2
    2596:	08 95       	ret

00002598 <approx_distance>:
  \param dy distance in Y plane
  \return 3-part linear approximation of \f$\sqrt{\Delta x^2 + \Delta y^2}\f$

  see http://www.flipcode.com/archives/Fast_Approximate_Distance_Functions.shtml
*/
uint32_t approx_distance(uint32_t dx, uint32_t dy) {
    2598:	4f 92       	push	r4
    259a:	5f 92       	push	r5
    259c:	6f 92       	push	r6
    259e:	7f 92       	push	r7
    25a0:	8f 92       	push	r8
    25a2:	9f 92       	push	r9
    25a4:	af 92       	push	r10
    25a6:	bf 92       	push	r11
    25a8:	cf 92       	push	r12
    25aa:	df 92       	push	r13
    25ac:	ef 92       	push	r14
    25ae:	ff 92       	push	r15
    25b0:	0f 93       	push	r16
    25b2:	1f 93       	push	r17
  uint32_t min, max, approx;

  if ( dx < dy ) {
    25b4:	62 17       	cp	r22, r18
    25b6:	73 07       	cpc	r23, r19
    25b8:	84 07       	cpc	r24, r20
    25ba:	95 07       	cpc	r25, r21
    25bc:	28 f4       	brcc	.+10     	; 0x25c8 <approx_distance+0x30>
    min = dx;
    max = dy;
    25be:	69 01       	movw	r12, r18
    25c0:	7a 01       	movw	r14, r20
*/
uint32_t approx_distance(uint32_t dx, uint32_t dy) {
  uint32_t min, max, approx;

  if ( dx < dy ) {
    min = dx;
    25c2:	4b 01       	movw	r8, r22
    25c4:	5c 01       	movw	r10, r24
    25c6:	04 c0       	rjmp	.+8      	; 0x25d0 <approx_distance+0x38>
    max = dy;
  } else {
    min = dy;
    max = dx;
    25c8:	6b 01       	movw	r12, r22
    25ca:	7c 01       	movw	r14, r24

  if ( dx < dy ) {
    min = dx;
    max = dy;
  } else {
    min = dy;
    25cc:	49 01       	movw	r8, r18
    25ce:	5a 01       	movw	r10, r20
    max = dx;
  }

  approx = ( max * 1007 ) + ( min * 441 );
    25d0:	a9 eb       	ldi	r26, 0xB9	; 185
    25d2:	b1 e0       	ldi	r27, 0x01	; 1
    25d4:	a5 01       	movw	r20, r10
    25d6:	94 01       	movw	r18, r8
    25d8:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    25dc:	2b 01       	movw	r4, r22
    25de:	3c 01       	movw	r6, r24
    25e0:	af ee       	ldi	r26, 0xEF	; 239
    25e2:	b3 e0       	ldi	r27, 0x03	; 3
    25e4:	a7 01       	movw	r20, r14
    25e6:	96 01       	movw	r18, r12
    25e8:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    25ec:	93 01       	movw	r18, r6
    25ee:	82 01       	movw	r16, r4
    25f0:	06 0f       	add	r16, r22
    25f2:	17 1f       	adc	r17, r23
    25f4:	28 1f       	adc	r18, r24
    25f6:	39 1f       	adc	r19, r25
  if ( max < ( min << 4 ))
    25f8:	68 94       	set
    25fa:	13 f8       	bld	r1, 3
    25fc:	88 0c       	add	r8, r8
    25fe:	99 1c       	adc	r9, r9
    2600:	aa 1c       	adc	r10, r10
    2602:	bb 1c       	adc	r11, r11
    2604:	16 94       	lsr	r1
    2606:	d1 f7       	brne	.-12     	; 0x25fc <approx_distance+0x64>
    2608:	c8 14       	cp	r12, r8
    260a:	d9 04       	cpc	r13, r9
    260c:	ea 04       	cpc	r14, r10
    260e:	fb 04       	cpc	r15, r11
    2610:	f0 f4       	brcc	.+60     	; 0x264e <approx_distance+0xb6>
    approx -= ( max * 40 );
    2612:	cc 0c       	add	r12, r12
    2614:	dd 1c       	adc	r13, r13
    2616:	ee 1c       	adc	r14, r14
    2618:	ff 1c       	adc	r15, r15
    261a:	cc 0c       	add	r12, r12
    261c:	dd 1c       	adc	r13, r13
    261e:	ee 1c       	adc	r14, r14
    2620:	ff 1c       	adc	r15, r15
    2622:	cc 0c       	add	r12, r12
    2624:	dd 1c       	adc	r13, r13
    2626:	ee 1c       	adc	r14, r14
    2628:	ff 1c       	adc	r15, r15
    262a:	d7 01       	movw	r26, r14
    262c:	c6 01       	movw	r24, r12
    262e:	88 0f       	add	r24, r24
    2630:	99 1f       	adc	r25, r25
    2632:	aa 1f       	adc	r26, r26
    2634:	bb 1f       	adc	r27, r27
    2636:	88 0f       	add	r24, r24
    2638:	99 1f       	adc	r25, r25
    263a:	aa 1f       	adc	r26, r26
    263c:	bb 1f       	adc	r27, r27
    263e:	c8 0e       	add	r12, r24
    2640:	d9 1e       	adc	r13, r25
    2642:	ea 1e       	adc	r14, r26
    2644:	fb 1e       	adc	r15, r27
    2646:	0c 19       	sub	r16, r12
    2648:	1d 09       	sbc	r17, r13
    264a:	2e 09       	sbc	r18, r14
    264c:	3f 09       	sbc	r19, r15

  // add 512 for proper rounding
  return (( approx + 512 ) >> 10 );
    264e:	1e 5f       	subi	r17, 0xFE	; 254
    2650:	2f 4f       	sbci	r18, 0xFF	; 255
    2652:	3f 4f       	sbci	r19, 0xFF	; 255
    2654:	0f 2e       	mov	r0, r31
    2656:	fa e0       	ldi	r31, 0x0A	; 10
    2658:	36 95       	lsr	r19
    265a:	27 95       	ror	r18
    265c:	17 95       	ror	r17
    265e:	07 95       	ror	r16
    2660:	fa 95       	dec	r31
    2662:	d1 f7       	brne	.-12     	; 0x2658 <approx_distance+0xc0>
    2664:	f0 2d       	mov	r31, r0
}
    2666:	60 2f       	mov	r22, r16
    2668:	71 2f       	mov	r23, r17
    266a:	82 2f       	mov	r24, r18
    266c:	93 2f       	mov	r25, r19
    266e:	1f 91       	pop	r17
    2670:	0f 91       	pop	r16
    2672:	ff 90       	pop	r15
    2674:	ef 90       	pop	r14
    2676:	df 90       	pop	r13
    2678:	cf 90       	pop	r12
    267a:	bf 90       	pop	r11
    267c:	af 90       	pop	r10
    267e:	9f 90       	pop	r9
    2680:	8f 90       	pop	r8
    2682:	7f 90       	pop	r7
    2684:	6f 90       	pop	r6
    2686:	5f 90       	pop	r5
    2688:	4f 90       	pop	r4
    268a:	08 95       	ret

0000268c <approx_distance_3>:
  \param dz distance in Z plane
  \return 3-part linear approximation of \f$\sqrt{\Delta x^2 + \Delta y^2 + \Delta z^2}\f$

  see http://www.oroboro.com/rafael/docserv.php/index/programming/article/distance
*/
uint32_t approx_distance_3(uint32_t dx, uint32_t dy, uint32_t dz) {
    268c:	4f 92       	push	r4
    268e:	5f 92       	push	r5
    2690:	6f 92       	push	r6
    2692:	7f 92       	push	r7
    2694:	8f 92       	push	r8
    2696:	9f 92       	push	r9
    2698:	af 92       	push	r10
    269a:	bf 92       	push	r11
    269c:	cf 92       	push	r12
    269e:	df 92       	push	r13
    26a0:	ef 92       	push	r14
    26a2:	ff 92       	push	r15
    26a4:	0f 93       	push	r16
    26a6:	1f 93       	push	r17
    26a8:	cf 93       	push	r28
    26aa:	df 93       	push	r29
    26ac:	cd b7       	in	r28, 0x3d	; 61
    26ae:	de b7       	in	r29, 0x3e	; 62
    26b0:	28 97       	sbiw	r28, 0x08	; 8
    26b2:	0f b6       	in	r0, 0x3f	; 63
    26b4:	f8 94       	cli
    26b6:	de bf       	out	0x3e, r29	; 62
    26b8:	0f be       	out	0x3f, r0	; 63
    26ba:	cd bf       	out	0x3d, r28	; 61
  uint32_t min, med, max, approx;

  if ( dx < dy ) {
    26bc:	62 17       	cp	r22, r18
    26be:	73 07       	cpc	r23, r19
    26c0:	84 07       	cpc	r24, r20
    26c2:	95 07       	cpc	r25, r21
    26c4:	48 f4       	brcc	.+18     	; 0x26d8 <approx_distance_3+0x4c>
    min = dy;
    med = dx;
    26c6:	6d 83       	std	Y+5, r22	; 0x05
    26c8:	7e 83       	std	Y+6, r23	; 0x06
    26ca:	8f 83       	std	Y+7, r24	; 0x07
    26cc:	98 87       	std	Y+8, r25	; 0x08
*/
uint32_t approx_distance_3(uint32_t dx, uint32_t dy, uint32_t dz) {
  uint32_t min, med, max, approx;

  if ( dx < dy ) {
    min = dy;
    26ce:	29 83       	std	Y+1, r18	; 0x01
    26d0:	3a 83       	std	Y+2, r19	; 0x02
    26d2:	4b 83       	std	Y+3, r20	; 0x03
    26d4:	5c 83       	std	Y+4, r21	; 0x04
    26d6:	08 c0       	rjmp	.+16     	; 0x26e8 <approx_distance_3+0x5c>
    med = dx;
  } else {
    min = dx;
    med = dy;
    26d8:	2d 83       	std	Y+5, r18	; 0x05
    26da:	3e 83       	std	Y+6, r19	; 0x06
    26dc:	4f 83       	std	Y+7, r20	; 0x07
    26de:	58 87       	std	Y+8, r21	; 0x08

  if ( dx < dy ) {
    min = dy;
    med = dx;
  } else {
    min = dx;
    26e0:	69 83       	std	Y+1, r22	; 0x01
    26e2:	7a 83       	std	Y+2, r23	; 0x02
    26e4:	8b 83       	std	Y+3, r24	; 0x03
    26e6:	9c 83       	std	Y+4, r25	; 0x04
    med = dy;
  }

  if ( dz < min ) {
    26e8:	29 81       	ldd	r18, Y+1	; 0x01
    26ea:	3a 81       	ldd	r19, Y+2	; 0x02
    26ec:	4b 81       	ldd	r20, Y+3	; 0x03
    26ee:	5c 81       	ldd	r21, Y+4	; 0x04
    26f0:	e2 16       	cp	r14, r18
    26f2:	f3 06       	cpc	r15, r19
    26f4:	04 07       	cpc	r16, r20
    26f6:	15 07       	cpc	r17, r21
    26f8:	80 f0       	brcs	.+32     	; 0x271a <approx_distance_3+0x8e>
    max = med;
    med = min;
    min = dz;
  } else if ( dz < med ) {
    26fa:	8d 81       	ldd	r24, Y+5	; 0x05
    26fc:	9e 81       	ldd	r25, Y+6	; 0x06
    26fe:	af 81       	ldd	r26, Y+7	; 0x07
    2700:	b8 85       	ldd	r27, Y+8	; 0x08
    2702:	e8 16       	cp	r14, r24
    2704:	f9 06       	cpc	r15, r25
    2706:	0a 07       	cpc	r16, r26
    2708:	1b 07       	cpc	r17, r27
    270a:	c0 f4       	brcc	.+48     	; 0x273c <approx_distance_3+0xb0>
    max = med;
    270c:	2c 01       	movw	r4, r24
    270e:	3d 01       	movw	r6, r26
    med = dz;
    2710:	ed 82       	std	Y+5, r14	; 0x05
    2712:	fe 82       	std	Y+6, r15	; 0x06
    2714:	0f 83       	std	Y+7, r16	; 0x07
    2716:	18 87       	std	Y+8, r17	; 0x08
    2718:	13 c0       	rjmp	.+38     	; 0x2740 <approx_distance_3+0xb4>
    min = dx;
    med = dy;
  }

  if ( dz < min ) {
    max = med;
    271a:	4d 80       	ldd	r4, Y+5	; 0x05
    271c:	5e 80       	ldd	r5, Y+6	; 0x06
    271e:	6f 80       	ldd	r6, Y+7	; 0x07
    2720:	78 84       	ldd	r7, Y+8	; 0x08
    med = min;
    2722:	29 81       	ldd	r18, Y+1	; 0x01
    2724:	3a 81       	ldd	r19, Y+2	; 0x02
    2726:	4b 81       	ldd	r20, Y+3	; 0x03
    2728:	5c 81       	ldd	r21, Y+4	; 0x04
    272a:	2d 83       	std	Y+5, r18	; 0x05
    272c:	3e 83       	std	Y+6, r19	; 0x06
    272e:	4f 83       	std	Y+7, r20	; 0x07
    2730:	58 87       	std	Y+8, r21	; 0x08
    min = dz;
    2732:	e9 82       	std	Y+1, r14	; 0x01
    2734:	fa 82       	std	Y+2, r15	; 0x02
    2736:	0b 83       	std	Y+3, r16	; 0x03
    2738:	1c 83       	std	Y+4, r17	; 0x04
    273a:	02 c0       	rjmp	.+4      	; 0x2740 <approx_distance_3+0xb4>
  } else if ( dz < med ) {
    max = med;
    med = dz;
  } else {
    max = dz;
    273c:	27 01       	movw	r4, r14
    273e:	38 01       	movw	r6, r16
  }

  approx = ( max * 860 ) + ( med * 851 ) + ( min * 520 );
    2740:	a3 e5       	ldi	r26, 0x53	; 83
    2742:	b3 e0       	ldi	r27, 0x03	; 3
    2744:	2d 81       	ldd	r18, Y+5	; 0x05
    2746:	3e 81       	ldd	r19, Y+6	; 0x06
    2748:	4f 81       	ldd	r20, Y+7	; 0x07
    274a:	58 85       	ldd	r21, Y+8	; 0x08
    274c:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    2750:	4b 01       	movw	r8, r22
    2752:	5c 01       	movw	r10, r24
    2754:	ac e5       	ldi	r26, 0x5C	; 92
    2756:	b3 e0       	ldi	r27, 0x03	; 3
    2758:	a3 01       	movw	r20, r6
    275a:	92 01       	movw	r18, r4
    275c:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    2760:	86 0e       	add	r8, r22
    2762:	97 1e       	adc	r9, r23
    2764:	a8 1e       	adc	r10, r24
    2766:	b9 1e       	adc	r11, r25
    2768:	a8 e0       	ldi	r26, 0x08	; 8
    276a:	b2 e0       	ldi	r27, 0x02	; 2
    276c:	29 81       	ldd	r18, Y+1	; 0x01
    276e:	3a 81       	ldd	r19, Y+2	; 0x02
    2770:	4b 81       	ldd	r20, Y+3	; 0x03
    2772:	5c 81       	ldd	r21, Y+4	; 0x04
    2774:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    2778:	86 0e       	add	r8, r22
    277a:	97 1e       	adc	r9, r23
    277c:	a8 1e       	adc	r10, r24
    277e:	b9 1e       	adc	r11, r25
  if ( max < ( med << 1 )) approx -= ( max * 294 );
    2780:	8d 81       	ldd	r24, Y+5	; 0x05
    2782:	9e 81       	ldd	r25, Y+6	; 0x06
    2784:	af 81       	ldd	r26, Y+7	; 0x07
    2786:	b8 85       	ldd	r27, Y+8	; 0x08
    2788:	88 0f       	add	r24, r24
    278a:	99 1f       	adc	r25, r25
    278c:	aa 1f       	adc	r26, r26
    278e:	bb 1f       	adc	r27, r27
    2790:	48 16       	cp	r4, r24
    2792:	59 06       	cpc	r5, r25
    2794:	6a 06       	cpc	r6, r26
    2796:	7b 06       	cpc	r7, r27
    2798:	50 f4       	brcc	.+20     	; 0x27ae <approx_distance_3+0x122>
    279a:	a6 e2       	ldi	r26, 0x26	; 38
    279c:	b1 e0       	ldi	r27, 0x01	; 1
    279e:	a3 01       	movw	r20, r6
    27a0:	92 01       	movw	r18, r4
    27a2:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    27a6:	86 1a       	sub	r8, r22
    27a8:	97 0a       	sbc	r9, r23
    27aa:	a8 0a       	sbc	r10, r24
    27ac:	b9 0a       	sbc	r11, r25
  if ( max < ( min << 2 )) approx -= ( max * 113 );
    27ae:	89 81       	ldd	r24, Y+1	; 0x01
    27b0:	9a 81       	ldd	r25, Y+2	; 0x02
    27b2:	ab 81       	ldd	r26, Y+3	; 0x03
    27b4:	bc 81       	ldd	r27, Y+4	; 0x04
    27b6:	88 0f       	add	r24, r24
    27b8:	99 1f       	adc	r25, r25
    27ba:	aa 1f       	adc	r26, r26
    27bc:	bb 1f       	adc	r27, r27
    27be:	88 0f       	add	r24, r24
    27c0:	99 1f       	adc	r25, r25
    27c2:	aa 1f       	adc	r26, r26
    27c4:	bb 1f       	adc	r27, r27
    27c6:	89 83       	std	Y+1, r24	; 0x01
    27c8:	9a 83       	std	Y+2, r25	; 0x02
    27ca:	ab 83       	std	Y+3, r26	; 0x03
    27cc:	bc 83       	std	Y+4, r27	; 0x04
    27ce:	48 16       	cp	r4, r24
    27d0:	59 06       	cpc	r5, r25
    27d2:	6a 06       	cpc	r6, r26
    27d4:	7b 06       	cpc	r7, r27
    27d6:	50 f4       	brcc	.+20     	; 0x27ec <approx_distance_3+0x160>
    27d8:	a1 e7       	ldi	r26, 0x71	; 113
    27da:	b0 e0       	ldi	r27, 0x00	; 0
    27dc:	a3 01       	movw	r20, r6
    27de:	92 01       	movw	r18, r4
    27e0:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    27e4:	86 1a       	sub	r8, r22
    27e6:	97 0a       	sbc	r9, r23
    27e8:	a8 0a       	sbc	r10, r24
    27ea:	b9 0a       	sbc	r11, r25
  if ( med < ( min << 2 )) approx -= ( med *  40 );
    27ec:	2d 81       	ldd	r18, Y+5	; 0x05
    27ee:	3e 81       	ldd	r19, Y+6	; 0x06
    27f0:	4f 81       	ldd	r20, Y+7	; 0x07
    27f2:	58 85       	ldd	r21, Y+8	; 0x08
    27f4:	89 81       	ldd	r24, Y+1	; 0x01
    27f6:	9a 81       	ldd	r25, Y+2	; 0x02
    27f8:	ab 81       	ldd	r26, Y+3	; 0x03
    27fa:	bc 81       	ldd	r27, Y+4	; 0x04
    27fc:	28 17       	cp	r18, r24
    27fe:	39 07       	cpc	r19, r25
    2800:	4a 07       	cpc	r20, r26
    2802:	5b 07       	cpc	r21, r27
    2804:	00 f5       	brcc	.+64     	; 0x2846 <approx_distance_3+0x1ba>
    2806:	69 01       	movw	r12, r18
    2808:	7a 01       	movw	r14, r20
    280a:	cc 0c       	add	r12, r12
    280c:	dd 1c       	adc	r13, r13
    280e:	ee 1c       	adc	r14, r14
    2810:	ff 1c       	adc	r15, r15
    2812:	cc 0c       	add	r12, r12
    2814:	dd 1c       	adc	r13, r13
    2816:	ee 1c       	adc	r14, r14
    2818:	ff 1c       	adc	r15, r15
    281a:	cc 0c       	add	r12, r12
    281c:	dd 1c       	adc	r13, r13
    281e:	ee 1c       	adc	r14, r14
    2820:	ff 1c       	adc	r15, r15
    2822:	d7 01       	movw	r26, r14
    2824:	c6 01       	movw	r24, r12
    2826:	88 0f       	add	r24, r24
    2828:	99 1f       	adc	r25, r25
    282a:	aa 1f       	adc	r26, r26
    282c:	bb 1f       	adc	r27, r27
    282e:	88 0f       	add	r24, r24
    2830:	99 1f       	adc	r25, r25
    2832:	aa 1f       	adc	r26, r26
    2834:	bb 1f       	adc	r27, r27
    2836:	c8 0e       	add	r12, r24
    2838:	d9 1e       	adc	r13, r25
    283a:	ea 1e       	adc	r14, r26
    283c:	fb 1e       	adc	r15, r27
    283e:	8c 18       	sub	r8, r12
    2840:	9d 08       	sbc	r9, r13
    2842:	ae 08       	sbc	r10, r14
    2844:	bf 08       	sbc	r11, r15

  // add 512 for proper rounding
  return (( approx + 512 ) >> 10 );
    2846:	92 e0       	ldi	r25, 0x02	; 2
    2848:	99 0e       	add	r9, r25
    284a:	a1 1c       	adc	r10, r1
    284c:	b1 1c       	adc	r11, r1
    284e:	07 2e       	mov	r0, r23
    2850:	7a e0       	ldi	r23, 0x0A	; 10
    2852:	b6 94       	lsr	r11
    2854:	a7 94       	ror	r10
    2856:	97 94       	ror	r9
    2858:	87 94       	ror	r8
    285a:	7a 95       	dec	r23
    285c:	d1 f7       	brne	.-12     	; 0x2852 <approx_distance_3+0x1c6>
    285e:	70 2d       	mov	r23, r0
}
    2860:	68 2d       	mov	r22, r8
    2862:	79 2d       	mov	r23, r9
    2864:	8a 2d       	mov	r24, r10
    2866:	9b 2d       	mov	r25, r11
    2868:	28 96       	adiw	r28, 0x08	; 8
    286a:	0f b6       	in	r0, 0x3f	; 63
    286c:	f8 94       	cli
    286e:	de bf       	out	0x3e, r29	; 62
    2870:	0f be       	out	0x3f, r0	; 63
    2872:	cd bf       	out	0x3d, r28	; 61
    2874:	df 91       	pop	r29
    2876:	cf 91       	pop	r28
    2878:	1f 91       	pop	r17
    287a:	0f 91       	pop	r16
    287c:	ff 90       	pop	r15
    287e:	ef 90       	pop	r14
    2880:	df 90       	pop	r13
    2882:	cf 90       	pop	r12
    2884:	bf 90       	pop	r11
    2886:	af 90       	pop	r10
    2888:	9f 90       	pop	r9
    288a:	8f 90       	pop	r8
    288c:	7f 90       	pop	r7
    288e:	6f 90       	pop	r6
    2890:	5f 90       	pop	r5
    2892:	4f 90       	pop	r4
    2894:	08 95       	ret

00002896 <queue_full>:
DDA movebuffer[MOVEBUFFER_SIZE] __attribute__ ((__section__ (".bss")));

/// check if the queue is completely full
uint8_t queue_full() {
	MEMORY_BARRIER();
	if (mb_tail > mb_head) {
    2896:	80 91 bc 04 	lds	r24, 0x04BC
    289a:	20 91 bd 04 	lds	r18, 0x04BD
    289e:	28 17       	cp	r18, r24
    28a0:	38 f4       	brcc	.+14     	; 0x28b0 <queue_full+0x1a>
		return ((mb_tail - mb_head - 1) == 0) ? 255 : 0;
    28a2:	90 e0       	ldi	r25, 0x00	; 0
    28a4:	82 1b       	sub	r24, r18
    28a6:	91 09       	sbc	r25, r1
    28a8:	01 97       	sbiw	r24, 0x01	; 1
    28aa:	51 f4       	brne	.+20     	; 0x28c0 <queue_full+0x2a>
    28ac:	8f ef       	ldi	r24, 0xFF	; 255
    28ae:	08 95       	ret
	} else {
		return ((mb_tail + MOVEBUFFER_SIZE - mb_head - 1) == 0) ? 255 : 0;
    28b0:	90 e0       	ldi	r25, 0x00	; 0
    28b2:	08 96       	adiw	r24, 0x08	; 8
    28b4:	82 1b       	sub	r24, r18
    28b6:	91 09       	sbc	r25, r1
    28b8:	01 97       	sbiw	r24, 0x01	; 1
    28ba:	21 f4       	brne	.+8      	; 0x28c4 <queue_full+0x2e>
    28bc:	8f ef       	ldi	r24, 0xFF	; 255
    28be:	08 95       	ret

/// check if the queue is completely full
uint8_t queue_full() {
	MEMORY_BARRIER();
	if (mb_tail > mb_head) {
		return ((mb_tail - mb_head - 1) == 0) ? 255 : 0;
    28c0:	80 e0       	ldi	r24, 0x00	; 0
    28c2:	08 95       	ret
	} else {
		return ((mb_tail + MOVEBUFFER_SIZE - mb_head - 1) == 0) ? 255 : 0;
    28c4:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    28c6:	08 95       	ret

000028c8 <queue_empty>:

/// check if the queue is completely empty
uint8_t queue_empty() {
  uint8_t result;

  ATOMIC_START
    28c8:	9f b7       	in	r25, 0x3f	; 63
    28ca:	f8 94       	cli
    result = ((mb_tail == mb_head) && (movebuffer[mb_tail].live == 0))?255:0;
    28cc:	e0 91 bc 04 	lds	r30, 0x04BC
    28d0:	80 91 bd 04 	lds	r24, 0x04BD
    28d4:	e8 13       	cpse	r30, r24
    28d6:	0b c0       	rjmp	.+22     	; 0x28ee <queue_empty+0x26>
    28d8:	8c e3       	ldi	r24, 0x3C	; 60
    28da:	e8 9f       	mul	r30, r24
    28dc:	f0 01       	movw	r30, r0
    28de:	11 24       	eor	r1, r1
    28e0:	e6 54       	subi	r30, 0x46	; 70
    28e2:	fd 4f       	sbci	r31, 0xFD	; 253
    28e4:	80 81       	ld	r24, Z
    28e6:	81 ff       	sbrs	r24, 1
    28e8:	04 c0       	rjmp	.+8      	; 0x28f2 <queue_empty+0x2a>
    28ea:	80 e0       	ldi	r24, 0x00	; 0
    28ec:	03 c0       	rjmp	.+6      	; 0x28f4 <queue_empty+0x2c>
    28ee:	80 e0       	ldi	r24, 0x00	; 0
    28f0:	01 c0       	rjmp	.+2      	; 0x28f4 <queue_empty+0x2c>
    28f2:	8f ef       	ldi	r24, 0xFF	; 255
  ATOMIC_END
    28f4:	9f bf       	out	0x3f, r25	; 63

	return result;
}
    28f6:	08 95       	ret

000028f8 <next_move>:
/// be interrupted such that it can be re-entered from within an interrupt.
/// The timer interrupt MUST be disabled on entry. This is ensured because
/// the timer was disabled at the start of the ISR or else because the current
/// move buffer was dead in the non-interrupt case (which indicates that the 
/// timer interrupt is disabled).
void next_move() {
    28f8:	1f 93       	push	r17
    28fa:	cf 93       	push	r28
    28fc:	df 93       	push	r29
	while ((queue_empty() == 0) && (movebuffer[mb_tail].live == 0)) {
    28fe:	1c e3       	ldi	r17, 0x3C	; 60
    2900:	1c c0       	rjmp	.+56     	; 0x293a <next_move+0x42>
		// next item
		uint8_t t = mb_tail + 1;
    2902:	8f 5f       	subi	r24, 0xFF	; 255
		t &= (MOVEBUFFER_SIZE - 1);
    2904:	87 70       	andi	r24, 0x07	; 7
		DDA* current_movebuffer = &movebuffer[t];
    2906:	18 9f       	mul	r17, r24
    2908:	e0 01       	movw	r28, r0
    290a:	11 24       	eor	r1, r1
    290c:	cb 55       	subi	r28, 0x5B	; 91
    290e:	dd 4f       	sbci	r29, 0xFD	; 253
		// tail must be set before setTimer call as setTimer
		// reenables the timer interrupt, potentially exposing
		// mb_tail to the timer interrupt routine. 
		mb_tail = t;
    2910:	80 93 bc 04 	sts	0x04BC, r24
		if (current_movebuffer->waitfor_temp) {
    2914:	8d 89       	ldd	r24, Y+21	; 0x15
    2916:	82 ff       	sbrs	r24, 2
    2918:	0e c0       	rjmp	.+28     	; 0x2936 <next_move+0x3e>
			serial_writestr_P(PSTR("Waiting for target temp\n"));
    291a:	86 ee       	ldi	r24, 0xE6	; 230
    291c:	93 e0       	ldi	r25, 0x03	; 3
    291e:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <serial_writestr_P>
			current_movebuffer->live = 1;
    2922:	8d 89       	ldd	r24, Y+21	; 0x15
    2924:	82 60       	ori	r24, 0x02	; 2
    2926:	8d 8b       	std	Y+21, r24	; 0x15
			setTimer(HEATER_WAIT_TIMEOUT);
    2928:	60 e0       	ldi	r22, 0x00	; 0
    292a:	74 e2       	ldi	r23, 0x24	; 36
    292c:	84 ef       	ldi	r24, 0xF4	; 244
    292e:	90 e0       	ldi	r25, 0x00	; 0
    2930:	0e 94 20 2b 	call	0x5640	; 0x5640 <setTimer>
    2934:	02 c0       	rjmp	.+4      	; 0x293a <next_move+0x42>
		}
		else {
			dda_start(current_movebuffer);
    2936:	ce 01       	movw	r24, r28
    2938:	2e d8       	rcall	.-4004   	; 0x1996 <dda_start>
/// The timer interrupt MUST be disabled on entry. This is ensured because
/// the timer was disabled at the start of the ISR or else because the current
/// move buffer was dead in the non-interrupt case (which indicates that the 
/// timer interrupt is disabled).
void next_move() {
	while ((queue_empty() == 0) && (movebuffer[mb_tail].live == 0)) {
    293a:	c6 df       	rcall	.-116    	; 0x28c8 <queue_empty>
    293c:	81 11       	cpse	r24, r1
    293e:	0a c0       	rjmp	.+20     	; 0x2954 <next_move+0x5c>
    2940:	80 91 bc 04 	lds	r24, 0x04BC
    2944:	18 9f       	mul	r17, r24
    2946:	f0 01       	movw	r30, r0
    2948:	11 24       	eor	r1, r1
    294a:	e6 54       	subi	r30, 0x46	; 70
    294c:	fd 4f       	sbci	r31, 0xFD	; 253
    294e:	90 81       	ld	r25, Z
    2950:	91 ff       	sbrs	r25, 1
    2952:	d7 cf       	rjmp	.-82     	; 0x2902 <next_move+0xa>
		}
		else {
			dda_start(current_movebuffer);
		}
	} 
}
    2954:	df 91       	pop	r29
    2956:	cf 91       	pop	r28
    2958:	1f 91       	pop	r17
    295a:	08 95       	ret

0000295c <enqueue_home>:
}

/// add a move to the movebuffer
/// \note this function waits for space to be available if necessary, check queue_full() first if waiting is a problem
/// This is the only function that modifies mb_head and it always called from outside an interrupt.
void enqueue_home(TARGET *t, uint8_t endstop_check, uint8_t endstop_stop_cond) {
    295c:	df 92       	push	r13
    295e:	ef 92       	push	r14
    2960:	ff 92       	push	r15
    2962:	0f 93       	push	r16
    2964:	1f 93       	push	r17
    2966:	cf 93       	push	r28
    2968:	df 93       	push	r29
    296a:	8c 01       	movw	r16, r24
    296c:	d6 2e       	mov	r13, r22
    296e:	e4 2e       	mov	r14, r20
	// don't call this function when the queue is full, but just in case, wait for a move to complete and free up the space for the passed target
	while (queue_full())
    2970:	03 c0       	rjmp	.+6      	; 0x2978 <enqueue_home+0x1c>
		delay_us(100);
    2972:	84 e6       	ldi	r24, 0x64	; 100
    2974:	90 e0       	ldi	r25, 0x00	; 0
    2976:	b1 d0       	rcall	.+354    	; 0x2ada <delay_us>
/// add a move to the movebuffer
/// \note this function waits for space to be available if necessary, check queue_full() first if waiting is a problem
/// This is the only function that modifies mb_head and it always called from outside an interrupt.
void enqueue_home(TARGET *t, uint8_t endstop_check, uint8_t endstop_stop_cond) {
	// don't call this function when the queue is full, but just in case, wait for a move to complete and free up the space for the passed target
	while (queue_full())
    2978:	8e df       	rcall	.-228    	; 0x2896 <queue_full>
    297a:	81 11       	cpse	r24, r1
    297c:	fa cf       	rjmp	.-12     	; 0x2972 <enqueue_home+0x16>
		delay_us(100);

	uint8_t h = mb_head + 1;
    297e:	f0 90 bd 04 	lds	r15, 0x04BD
    2982:	8f 2d       	mov	r24, r15
    2984:	8f 5f       	subi	r24, 0xFF	; 255
	h &= (MOVEBUFFER_SIZE - 1);
    2986:	0f 2e       	mov	r0, r31
    2988:	f7 e0       	ldi	r31, 0x07	; 7
    298a:	ff 2e       	mov	r15, r31
    298c:	f0 2d       	mov	r31, r0
    298e:	f8 22       	and	r15, r24

	DDA* new_movebuffer = &(movebuffer[h]);
    2990:	2c e3       	ldi	r18, 0x3C	; 60
    2992:	f2 9e       	mul	r15, r18
    2994:	e0 01       	movw	r28, r0
    2996:	11 24       	eor	r1, r1
    2998:	cb 55       	subi	r28, 0x5B	; 91
    299a:	dd 4f       	sbci	r29, 0xFD	; 253
  DDA* prev_movebuffer = (queue_empty() != 0) ? NULL : &movebuffer[mb_head];
    299c:	95 df       	rcall	.-214    	; 0x28c8 <queue_empty>
    299e:	81 11       	cpse	r24, r1
    29a0:	0a c0       	rjmp	.+20     	; 0x29b6 <enqueue_home+0x5a>
    29a2:	80 91 bd 04 	lds	r24, 0x04BD
    29a6:	2c e3       	ldi	r18, 0x3C	; 60
    29a8:	82 9f       	mul	r24, r18
    29aa:	c0 01       	movw	r24, r0
    29ac:	11 24       	eor	r1, r1
    29ae:	ac 01       	movw	r20, r24
    29b0:	4b 55       	subi	r20, 0x5B	; 91
    29b2:	5d 4f       	sbci	r21, 0xFD	; 253
    29b4:	02 c0       	rjmp	.+4      	; 0x29ba <enqueue_home+0x5e>
    29b6:	40 e0       	ldi	r20, 0x00	; 0
    29b8:	50 e0       	ldi	r21, 0x00	; 0

  if (t != NULL) {
    29ba:	01 15       	cp	r16, r1
    29bc:	11 05       	cpc	r17, r1
    29be:	39 f0       	breq	.+14     	; 0x29ce <enqueue_home+0x72>
    dda_create(new_movebuffer, t, prev_movebuffer);
    29c0:	b8 01       	movw	r22, r16
    29c2:	ce 01       	movw	r24, r28
    29c4:	0e 94 ad 07 	call	0xf5a	; 0xf5a <dda_create>
		new_movebuffer->endstop_check = endstop_check;
    29c8:	da ae       	std	Y+58, r13	; 0x3a
		new_movebuffer->endstop_stop_cond = endstop_stop_cond;
    29ca:	eb ae       	std	Y+59, r14	; 0x3b
    29cc:	04 c0       	rjmp	.+8      	; 0x29d6 <enqueue_home+0x7a>
	}
	else {
		// it's a wait for temp
		new_movebuffer->waitfor_temp = 1;
    29ce:	8d 89       	ldd	r24, Y+21	; 0x15
		new_movebuffer->nullmove = 0;
    29d0:	84 60       	ori	r24, 0x04	; 4
    29d2:	8e 7f       	andi	r24, 0xFE	; 254
    29d4:	8d 8b       	std	Y+21, r24	; 0x15

	// make certain all writes to global memory
	// are flushed before modifying mb_head.
	MEMORY_BARRIER();

	mb_head = h;
    29d6:	f0 92 bd 04 	sts	0x04BD, r15

  uint8_t isdead;

  ATOMIC_START
    29da:	9f b7       	in	r25, 0x3f	; 63
    29dc:	f8 94       	cli
    isdead = (movebuffer[mb_tail].live == 0);
    29de:	e0 91 bc 04 	lds	r30, 0x04BC
    29e2:	8c e3       	ldi	r24, 0x3C	; 60
    29e4:	e8 9f       	mul	r30, r24
    29e6:	f0 01       	movw	r30, r0
    29e8:	11 24       	eor	r1, r1
    29ea:	e6 54       	subi	r30, 0x46	; 70
    29ec:	fd 4f       	sbci	r31, 0xFD	; 253
    29ee:	80 81       	ld	r24, Z
    29f0:	86 95       	lsr	r24
    29f2:	81 70       	andi	r24, 0x01	; 1
  ATOMIC_END
    29f4:	9f bf       	out	0x3f, r25	; 63

	if (isdead) {
    29f6:	81 11       	cpse	r24, r1
    29f8:	02 c0       	rjmp	.+4      	; 0x29fe <enqueue_home+0xa2>
		next_move();
    29fa:	7e df       	rcall	.-260    	; 0x28f8 <next_move>
		// Compensate for the cli() in setTimer().
		sei();
    29fc:	78 94       	sei
	}
}
    29fe:	df 91       	pop	r29
    2a00:	cf 91       	pop	r28
    2a02:	1f 91       	pop	r17
    2a04:	0f 91       	pop	r16
    2a06:	ff 90       	pop	r15
    2a08:	ef 90       	pop	r14
    2a0a:	df 90       	pop	r13
    2a0c:	08 95       	ret

00002a0e <queue_step>:
// -------------------------------------------------------
// This is the one function called by the timer interrupt.
// It calls a few other functions, though.
// -------------------------------------------------------
/// Take a step or go to the next move.
void queue_step() {
    2a0e:	cf 93       	push	r28
    2a10:	df 93       	push	r29
	// do our next step
	DDA* current_movebuffer = &movebuffer[mb_tail];
    2a12:	c0 91 bc 04 	lds	r28, 0x04BC
    2a16:	8c e3       	ldi	r24, 0x3C	; 60
    2a18:	c8 9f       	mul	r28, r24
    2a1a:	e0 01       	movw	r28, r0
    2a1c:	11 24       	eor	r1, r1
    2a1e:	cb 55       	subi	r28, 0x5B	; 91
    2a20:	dd 4f       	sbci	r29, 0xFD	; 253
	if (current_movebuffer->live) {
    2a22:	8d 89       	ldd	r24, Y+21	; 0x15
    2a24:	81 ff       	sbrs	r24, 1
    2a26:	19 c0       	rjmp	.+50     	; 0x2a5a <queue_step+0x4c>
		if (current_movebuffer->waitfor_temp) {
    2a28:	82 ff       	sbrs	r24, 2
    2a2a:	13 c0       	rjmp	.+38     	; 0x2a52 <queue_step+0x44>
			setTimer(HEATER_WAIT_TIMEOUT);
    2a2c:	60 e0       	ldi	r22, 0x00	; 0
    2a2e:	74 e2       	ldi	r23, 0x24	; 36
    2a30:	84 ef       	ldi	r24, 0xF4	; 244
    2a32:	90 e0       	ldi	r25, 0x00	; 0
    2a34:	0e 94 20 2b 	call	0x5640	; 0x5640 <setTimer>
			if (temp_achieved()) {
    2a38:	0e 94 10 2a 	call	0x5420	; 0x5420 <temp_achieved>
    2a3c:	88 23       	and	r24, r24
    2a3e:	59 f0       	breq	.+22     	; 0x2a56 <queue_step+0x48>
				current_movebuffer->live = current_movebuffer->waitfor_temp = 0;
    2a40:	8d 89       	ldd	r24, Y+21	; 0x15
    2a42:	8b 7f       	andi	r24, 0xFB	; 251
    2a44:	8d 7f       	andi	r24, 0xFD	; 253
    2a46:	8d 8b       	std	Y+21, r24	; 0x15
				serial_writestr_P(PSTR("Temp achieved\n"));
    2a48:	87 ed       	ldi	r24, 0xD7	; 215
    2a4a:	93 e0       	ldi	r25, 0x03	; 3
    2a4c:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <serial_writestr_P>
    2a50:	02 c0       	rjmp	.+4      	; 0x2a56 <queue_step+0x48>
			}
		}
		else {
			// NOTE: dda_step makes this interrupt interruptible for some time,
			//       see STEP_INTERRUPT_INTERRUPTIBLE.
			dda_step(current_movebuffer);
    2a52:	ce 01       	movw	r24, r28
    2a54:	37 d8       	rcall	.-3986   	; 0x1ac4 <dda_step>
		}
	}

	// fall directly into dda_start instead of waiting for another step
	// the dda dies not directly after its last step, but when the timer fires and there's no steps to do
	if (current_movebuffer->live == 0)
    2a56:	8d 89       	ldd	r24, Y+21	; 0x15
    2a58:	81 ff       	sbrs	r24, 1
		next_move();
    2a5a:	4e df       	rcall	.-356    	; 0x28f8 <next_move>
}
    2a5c:	df 91       	pop	r29
    2a5e:	cf 91       	pop	r28
    2a60:	08 95       	ret

00002a62 <print_queue>:
}

/// DEBUG - print queue.
/// Qt/hs format, t is tail, h is head, s is F/full, E/empty or neither
void print_queue() {
	sersendf_P(PSTR("Q%d/%d%c"), mb_tail, mb_head, (queue_full()?'F':(queue_empty()?'E':' ')));
    2a62:	19 df       	rcall	.-462    	; 0x2896 <queue_full>
    2a64:	81 11       	cpse	r24, r1
    2a66:	06 c0       	rjmp	.+12     	; 0x2a74 <print_queue+0x12>
    2a68:	2f df       	rcall	.-418    	; 0x28c8 <queue_empty>
    2a6a:	88 23       	and	r24, r24
    2a6c:	31 f0       	breq	.+12     	; 0x2a7a <print_queue+0x18>
    2a6e:	85 e4       	ldi	r24, 0x45	; 69
    2a70:	90 e0       	ldi	r25, 0x00	; 0
    2a72:	05 c0       	rjmp	.+10     	; 0x2a7e <print_queue+0x1c>
    2a74:	86 e4       	ldi	r24, 0x46	; 70
    2a76:	90 e0       	ldi	r25, 0x00	; 0
    2a78:	02 c0       	rjmp	.+4      	; 0x2a7e <print_queue+0x1c>
    2a7a:	80 e2       	ldi	r24, 0x20	; 32
    2a7c:	90 e0       	ldi	r25, 0x00	; 0
    2a7e:	9f 93       	push	r25
    2a80:	8f 93       	push	r24
    2a82:	80 91 bd 04 	lds	r24, 0x04BD
    2a86:	1f 92       	push	r1
    2a88:	8f 93       	push	r24
    2a8a:	80 91 bc 04 	lds	r24, 0x04BC
    2a8e:	1f 92       	push	r1
    2a90:	8f 93       	push	r24
    2a92:	8f ef       	ldi	r24, 0xFF	; 255
    2a94:	93 e0       	ldi	r25, 0x03	; 3
    2a96:	9f 93       	push	r25
    2a98:	8f 93       	push	r24
    2a9a:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
    2a9e:	8d b7       	in	r24, 0x3d	; 61
    2aa0:	9e b7       	in	r25, 0x3e	; 62
    2aa2:	08 96       	adiw	r24, 0x08	; 8
    2aa4:	0f b6       	in	r0, 0x3f	; 63
    2aa6:	f8 94       	cli
    2aa8:	9e bf       	out	0x3e, r25	; 62
    2aaa:	0f be       	out	0x3f, r0	; 63
    2aac:	8d bf       	out	0x3d, r24	; 61
    2aae:	08 95       	ret

00002ab0 <queue_flush>:
/// \todo effect on startpoint is undefined!
void queue_flush() {

  // if the timer were running, this would require
  // wrapping in ATOMIC_START ... ATOMIC_END.
  mb_tail = mb_head;
    2ab0:	e0 91 bd 04 	lds	r30, 0x04BD
    2ab4:	e0 93 bc 04 	sts	0x04BC, r30
  movebuffer[mb_head].live = 0;
    2ab8:	8c e3       	ldi	r24, 0x3C	; 60
    2aba:	e8 9f       	mul	r30, r24
    2abc:	f0 01       	movw	r30, r0
    2abe:	11 24       	eor	r1, r1
    2ac0:	e6 54       	subi	r30, 0x46	; 70
    2ac2:	fd 4f       	sbci	r31, 0xFD	; 253
    2ac4:	80 81       	ld	r24, Z
    2ac6:	8d 7f       	andi	r24, 0xFD	; 253
    2ac8:	80 83       	st	Z, r24
    2aca:	08 95       	ret

00002acc <queue_wait>:
}

/// wait for queue to empty
void queue_wait() {
	while (queue_empty() == 0)
    2acc:	02 c0       	rjmp	.+4      	; 0x2ad2 <queue_wait+0x6>
		clock();
    2ace:	0e 94 62 05 	call	0xac4	; 0xac4 <clock>
  movebuffer[mb_head].live = 0;
}

/// wait for queue to empty
void queue_wait() {
	while (queue_empty() == 0)
    2ad2:	fa de       	rcall	.-524    	; 0x28c8 <queue_empty>
    2ad4:	88 23       	and	r24, r24
    2ad6:	d9 f3       	breq	.-10     	; 0x2ace <queue_wait+0x2>
		clock();
}
    2ad8:	08 95       	ret

00002ada <delay_us>:

/// delay microseconds
/// \param delay time to wait in microseconds
void delay_us(uint16_t delay) {
	wd_reset();
	while (delay > (65536L / (F_CPU / 4000000L))) {
    2ada:	81 30       	cpi	r24, 0x01	; 1
    2adc:	20 e4       	ldi	r18, 0x40	; 64
    2ade:	92 07       	cpc	r25, r18
    2ae0:	f8 f0       	brcs	.+62     	; 0x2b20 <delay_us+0x46>
    2ae2:	9c 01       	movw	r18, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2ae4:	4e ef       	ldi	r20, 0xFE	; 254
    2ae6:	5f ef       	ldi	r21, 0xFF	; 255
    2ae8:	fa 01       	movw	r30, r20
    2aea:	31 97       	sbiw	r30, 0x01	; 1
    2aec:	f1 f7       	brne	.-4      	; 0x2aea <delay_us+0x10>
		_delay_loop_2(65534); // we use 65534 here to compensate for the time that the surrounding loop takes. TODO: exact figure needs tuning
		delay -= (65536L / (F_CPU / 4000000L));
    2aee:	30 54       	subi	r19, 0x40	; 64

/// delay microseconds
/// \param delay time to wait in microseconds
void delay_us(uint16_t delay) {
	wd_reset();
	while (delay > (65536L / (F_CPU / 4000000L))) {
    2af0:	21 30       	cpi	r18, 0x01	; 1
    2af2:	60 e4       	ldi	r22, 0x40	; 64
    2af4:	36 07       	cpc	r19, r22
    2af6:	c0 f7       	brcc	.-16     	; 0x2ae8 <delay_us+0xe>
#error Delay functions only work with F_CPU >= 4000000UL 
#endif

/// delay microseconds
/// \param delay time to wait in microseconds
void delay_us(uint16_t delay) {
    2af8:	bc 01       	movw	r22, r24
    2afa:	61 50       	subi	r22, 0x01	; 1
    2afc:	70 44       	sbci	r23, 0x40	; 64
    2afe:	64 e0       	ldi	r22, 0x04	; 4
    2b00:	76 9f       	mul	r23, r22
    2b02:	61 2d       	mov	r22, r1
    2b04:	77 27       	eor	r23, r23
    2b06:	11 24       	eor	r1, r1
    2b08:	40 e0       	ldi	r20, 0x00	; 0
    2b0a:	50 ec       	ldi	r21, 0xC0	; 192
    2b0c:	64 9f       	mul	r22, r20
    2b0e:	90 01       	movw	r18, r0
    2b10:	65 9f       	mul	r22, r21
    2b12:	30 0d       	add	r19, r0
    2b14:	74 9f       	mul	r23, r20
    2b16:	30 0d       	add	r19, r0
    2b18:	11 24       	eor	r1, r1
    2b1a:	90 54       	subi	r25, 0x40	; 64
    2b1c:	82 0f       	add	r24, r18
    2b1e:	93 1f       	adc	r25, r19
	while (delay > (65536L / (F_CPU / 4000000L))) {
		_delay_loop_2(65534); // we use 65534 here to compensate for the time that the surrounding loop takes. TODO: exact figure needs tuning
		delay -= (65536L / (F_CPU / 4000000L));
		wd_reset();
	}
	_delay_loop_2(delay * (F_CPU / 4000000L));
    2b20:	88 0f       	add	r24, r24
    2b22:	99 1f       	adc	r25, r25
    2b24:	88 0f       	add	r24, r24
    2b26:	99 1f       	adc	r25, r25
    2b28:	01 97       	sbiw	r24, 0x01	; 1
    2b2a:	f1 f7       	brne	.-4      	; 0x2b28 <delay_us+0x4e>
    2b2c:	08 95       	ret

00002b2e <delay_ms>:
	wd_reset();
}

/// delay milliseconds
/// \param delay time to wait in milliseconds
void delay_ms(uint32_t delay) {
    2b2e:	cf 92       	push	r12
    2b30:	df 92       	push	r13
    2b32:	ef 92       	push	r14
    2b34:	ff 92       	push	r15
    2b36:	6b 01       	movw	r12, r22
    2b38:	7c 01       	movw	r14, r24
	wd_reset();
	while (delay > 65) {
    2b3a:	82 e4       	ldi	r24, 0x42	; 66
    2b3c:	c8 16       	cp	r12, r24
    2b3e:	d1 04       	cpc	r13, r1
    2b40:	e1 04       	cpc	r14, r1
    2b42:	f1 04       	cpc	r15, r1
    2b44:	70 f0       	brcs	.+28     	; 0x2b62 <delay_ms+0x34>
		delay_us(64999);
    2b46:	87 ee       	ldi	r24, 0xE7	; 231
    2b48:	9d ef       	ldi	r25, 0xFD	; 253
    2b4a:	c7 df       	rcall	.-114    	; 0x2ada <delay_us>
		delay -= 65;
    2b4c:	81 e4       	ldi	r24, 0x41	; 65
    2b4e:	c8 1a       	sub	r12, r24
    2b50:	d1 08       	sbc	r13, r1
    2b52:	e1 08       	sbc	r14, r1
    2b54:	f1 08       	sbc	r15, r1

/// delay milliseconds
/// \param delay time to wait in milliseconds
void delay_ms(uint32_t delay) {
	wd_reset();
	while (delay > 65) {
    2b56:	82 e4       	ldi	r24, 0x42	; 66
    2b58:	c8 16       	cp	r12, r24
    2b5a:	d1 04       	cpc	r13, r1
    2b5c:	e1 04       	cpc	r14, r1
    2b5e:	f1 04       	cpc	r15, r1
    2b60:	90 f7       	brcc	.-28     	; 0x2b46 <delay_ms+0x18>
		delay_us(64999);
		delay -= 65;
		wd_reset();
	}
	delay_us(delay * 1000);
    2b62:	28 ee       	ldi	r18, 0xE8	; 232
    2b64:	33 e0       	ldi	r19, 0x03	; 3
    2b66:	c2 9e       	mul	r12, r18
    2b68:	c0 01       	movw	r24, r0
    2b6a:	c3 9e       	mul	r12, r19
    2b6c:	90 0d       	add	r25, r0
    2b6e:	d2 9e       	mul	r13, r18
    2b70:	90 0d       	add	r25, r0
    2b72:	11 24       	eor	r1, r1
    2b74:	b2 df       	rcall	.-156    	; 0x2ada <delay_us>
	wd_reset();
}
    2b76:	ff 90       	pop	r15
    2b78:	ef 90       	pop	r14
    2b7a:	df 90       	pop	r13
    2b7c:	cf 90       	pop	r12
    2b7e:	08 95       	ret

00002b80 <decfloat_to_int>:
/// \param *df pointer to floating point structure that holds fp value to convert
/// \param multiplicand multiply by this amount during conversion to integer
///
/// Tested for up to 42'000 mm (accurate), 420'000 mm (precision 10 um) and
/// 4'200'000 mm (precision 100 um).
static int32_t decfloat_to_int(decfloat *df, uint16_t multiplicand) {
    2b80:	4f 92       	push	r4
    2b82:	5f 92       	push	r5
    2b84:	6f 92       	push	r6
    2b86:	7f 92       	push	r7
    2b88:	8f 92       	push	r8
    2b8a:	9f 92       	push	r9
    2b8c:	af 92       	push	r10
    2b8e:	bf 92       	push	r11
    2b90:	cf 92       	push	r12
    2b92:	df 92       	push	r13
    2b94:	ef 92       	push	r14
    2b96:	ff 92       	push	r15
    2b98:	cf 93       	push	r28
    2b9a:	df 93       	push	r29
    2b9c:	ec 01       	movw	r28, r24
    2b9e:	ab 01       	movw	r20, r22
	uint32_t	r = df->mantissa;
    2ba0:	c8 80       	ld	r12, Y
    2ba2:	d9 80       	ldd	r13, Y+1	; 0x01
    2ba4:	ea 80       	ldd	r14, Y+2	; 0x02
    2ba6:	fb 80       	ldd	r15, Y+3	; 0x03
	uint8_t	e = df->exponent;
    2ba8:	ec 81       	ldd	r30, Y+4	; 0x04
    2baa:	ef 77       	andi	r30, 0x7F	; 127

	// e=1 means we've seen a decimal point but no digits after it, and e=2 means we've seen a decimal point with one digit so it's too high by one if not zero
	if (e)
    2bac:	09 f4       	brne	.+2      	; 0x2bb0 <decfloat_to_int+0x30>
    2bae:	70 c0       	rjmp	.+224    	; 0x2c90 <decfloat_to_int+0x110>
		e--;
    2bb0:	e1 50       	subi	r30, 0x01	; 1

	// This raises range for mm by factor 1000 and for inches by factor 100.
	// It's a bit expensive, but we should have the time while parsing.
	while (e && multiplicand % 10 == 0) {
    2bb2:	09 f4       	brne	.+2      	; 0x2bb6 <decfloat_to_int+0x36>
    2bb4:	6d c0       	rjmp	.+218    	; 0x2c90 <decfloat_to_int+0x110>
    2bb6:	9b 01       	movw	r18, r22
    2bb8:	ad ec       	ldi	r26, 0xCD	; 205
    2bba:	bc ec       	ldi	r27, 0xCC	; 204
    2bbc:	0e 94 3b 2c 	call	0x5876	; 0x5876 <__umulhisi3>
    2bc0:	96 95       	lsr	r25
    2bc2:	87 95       	ror	r24
    2bc4:	96 95       	lsr	r25
    2bc6:	87 95       	ror	r24
    2bc8:	96 95       	lsr	r25
    2bca:	87 95       	ror	r24
    2bcc:	9c 01       	movw	r18, r24
    2bce:	22 0f       	add	r18, r18
    2bd0:	33 1f       	adc	r19, r19
    2bd2:	88 0f       	add	r24, r24
    2bd4:	99 1f       	adc	r25, r25
    2bd6:	88 0f       	add	r24, r24
    2bd8:	99 1f       	adc	r25, r25
    2bda:	88 0f       	add	r24, r24
    2bdc:	99 1f       	adc	r25, r25
    2bde:	82 0f       	add	r24, r18
    2be0:	93 1f       	adc	r25, r19
    2be2:	48 17       	cp	r20, r24
    2be4:	59 07       	cpc	r21, r25
    2be6:	a9 f5       	brne	.+106    	; 0x2c52 <decfloat_to_int+0xd2>
		multiplicand /= 10;
    2be8:	9a 01       	movw	r18, r20
    2bea:	ad ec       	ldi	r26, 0xCD	; 205
    2bec:	bc ec       	ldi	r27, 0xCC	; 204
    2bee:	0e 94 3b 2c 	call	0x5876	; 0x5876 <__umulhisi3>
    2bf2:	ac 01       	movw	r20, r24
    2bf4:	56 95       	lsr	r21
    2bf6:	47 95       	ror	r20
    2bf8:	56 95       	lsr	r21
    2bfa:	47 95       	ror	r20
    2bfc:	56 95       	lsr	r21
    2bfe:	47 95       	ror	r20
		e--;
    2c00:	e1 50       	subi	r30, 0x01	; 1
	if (e)
		e--;

	// This raises range for mm by factor 1000 and for inches by factor 100.
	// It's a bit expensive, but we should have the time while parsing.
	while (e && multiplicand % 10 == 0) {
    2c02:	09 f4       	brne	.+2      	; 0x2c06 <decfloat_to_int+0x86>
    2c04:	45 c0       	rjmp	.+138    	; 0x2c90 <decfloat_to_int+0x110>
    2c06:	9a 01       	movw	r18, r20
    2c08:	0e 94 3b 2c 	call	0x5876	; 0x5876 <__umulhisi3>
    2c0c:	96 95       	lsr	r25
    2c0e:	87 95       	ror	r24
    2c10:	96 95       	lsr	r25
    2c12:	87 95       	ror	r24
    2c14:	96 95       	lsr	r25
    2c16:	87 95       	ror	r24
    2c18:	9c 01       	movw	r18, r24
    2c1a:	22 0f       	add	r18, r18
    2c1c:	33 1f       	adc	r19, r19
    2c1e:	88 0f       	add	r24, r24
    2c20:	99 1f       	adc	r25, r25
    2c22:	88 0f       	add	r24, r24
    2c24:	99 1f       	adc	r25, r25
    2c26:	88 0f       	add	r24, r24
    2c28:	99 1f       	adc	r25, r25
    2c2a:	82 0f       	add	r24, r18
    2c2c:	93 1f       	adc	r25, r19
    2c2e:	48 17       	cp	r20, r24
    2c30:	59 07       	cpc	r21, r25
    2c32:	d1 f2       	breq	.-76     	; 0x2be8 <decfloat_to_int+0x68>
    2c34:	0e c0       	rjmp	.+28     	; 0x2c52 <decfloat_to_int+0xd2>

	r *= multiplicand;
	if (e)
		r = (r + powers[e] / 2) / powers[e];

	return df->sign ? -(int32_t)r : (int32_t)r;
    2c36:	8c 81       	ldd	r24, Y+4	; 0x04
    2c38:	88 23       	and	r24, r24
    2c3a:	44 f4       	brge	.+16     	; 0x2c4c <decfloat_to_int+0xcc>
    2c3c:	88 27       	eor	r24, r24
    2c3e:	99 27       	eor	r25, r25
    2c40:	dc 01       	movw	r26, r24
    2c42:	82 1b       	sub	r24, r18
    2c44:	93 0b       	sbc	r25, r19
    2c46:	a4 0b       	sbc	r26, r20
    2c48:	b5 0b       	sbc	r27, r21
    2c4a:	2a c0       	rjmp	.+84     	; 0x2ca0 <decfloat_to_int+0x120>
    2c4c:	da 01       	movw	r26, r20
    2c4e:	c9 01       	movw	r24, r18
    2c50:	27 c0       	rjmp	.+78     	; 0x2ca0 <decfloat_to_int+0x120>
		e--;
	}

	r *= multiplicand;
	if (e)
		r = (r + powers[e] / 2) / powers[e];
    2c52:	f0 e0       	ldi	r31, 0x00	; 0
    2c54:	ee 0f       	add	r30, r30
    2c56:	ff 1f       	adc	r31, r31
    2c58:	ee 0f       	add	r30, r30
    2c5a:	ff 1f       	adc	r31, r31
    2c5c:	e6 5f       	subi	r30, 0xF6	; 246
    2c5e:	fd 4f       	sbci	r31, 0xFD	; 253
    2c60:	80 80       	ld	r8, Z
    2c62:	91 80       	ldd	r9, Z+1	; 0x01
    2c64:	a2 80       	ldd	r10, Z+2	; 0x02
    2c66:	b3 80       	ldd	r11, Z+3	; 0x03
    2c68:	24 01       	movw	r4, r8
    2c6a:	35 01       	movw	r6, r10
    2c6c:	76 94       	lsr	r7
    2c6e:	67 94       	ror	r6
    2c70:	57 94       	ror	r5
    2c72:	47 94       	ror	r4
	while (e && multiplicand % 10 == 0) {
		multiplicand /= 10;
		e--;
	}

	r *= multiplicand;
    2c74:	da 01       	movw	r26, r20
    2c76:	a7 01       	movw	r20, r14
    2c78:	96 01       	movw	r18, r12
    2c7a:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
	if (e)
		r = (r + powers[e] / 2) / powers[e];
    2c7e:	64 0d       	add	r22, r4
    2c80:	75 1d       	adc	r23, r5
    2c82:	86 1d       	adc	r24, r6
    2c84:	97 1d       	adc	r25, r7
    2c86:	a5 01       	movw	r20, r10
    2c88:	94 01       	movw	r18, r8
    2c8a:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <__udivmodsi4>
    2c8e:	d3 cf       	rjmp	.-90     	; 0x2c36 <decfloat_to_int+0xb6>
	while (e && multiplicand % 10 == 0) {
		multiplicand /= 10;
		e--;
	}

	r *= multiplicand;
    2c90:	da 01       	movw	r26, r20
    2c92:	a7 01       	movw	r20, r14
    2c94:	96 01       	movw	r18, r12
    2c96:	0e 94 47 2c 	call	0x588e	; 0x588e <__muluhisi3>
    2c9a:	9b 01       	movw	r18, r22
    2c9c:	ac 01       	movw	r20, r24
    2c9e:	cb cf       	rjmp	.-106    	; 0x2c36 <decfloat_to_int+0xb6>
	if (e)
		r = (r + powers[e] / 2) / powers[e];

	return df->sign ? -(int32_t)r : (int32_t)r;
    2ca0:	39 2f       	mov	r19, r25
    2ca2:	9b 2f       	mov	r25, r27
}
    2ca4:	68 2f       	mov	r22, r24
    2ca6:	73 2f       	mov	r23, r19
    2ca8:	8a 2f       	mov	r24, r26
    2caa:	df 91       	pop	r29
    2cac:	cf 91       	pop	r28
    2cae:	ff 90       	pop	r15
    2cb0:	ef 90       	pop	r14
    2cb2:	df 90       	pop	r13
    2cb4:	cf 90       	pop	r12
    2cb6:	bf 90       	pop	r11
    2cb8:	af 90       	pop	r10
    2cba:	9f 90       	pop	r9
    2cbc:	8f 90       	pop	r8
    2cbe:	7f 90       	pop	r7
    2cc0:	6f 90       	pop	r6
    2cc2:	5f 90       	pop	r5
    2cc4:	4f 90       	pop	r4
    2cc6:	08 95       	ret

00002cc8 <gcode_init>:

void gcode_init(void) {
	// gcc guarantees us all variables are initialised to 0.

	// assume a G1 by default
	next_target.seen_G = 1;
    2cc8:	e5 e8       	ldi	r30, 0x85	; 133
    2cca:	f4 e0       	ldi	r31, 0x04	; 4
    2ccc:	80 81       	ld	r24, Z
    2cce:	81 60       	ori	r24, 0x01	; 1
    2cd0:	80 83       	st	Z, r24
	next_target.G = 1;
    2cd2:	81 e0       	ldi	r24, 0x01	; 1
    2cd4:	80 93 88 04 	sts	0x0488, r24

	#ifndef E_ABSOLUTE
		next_target.option_e_relative = 1;
    2cd8:	e6 e8       	ldi	r30, 0x86	; 134
    2cda:	f4 e0       	ldi	r31, 0x04	; 4
    2cdc:	80 81       	ld	r24, Z
    2cde:	80 68       	ori	r24, 0x80	; 128
    2ce0:	80 83       	st	Z, r24
    2ce2:	08 95       	ret

00002ce4 <gcode_parse_char>:
	#endif
}

/// Character Received - add it to our command
/// \param c the next character to process
void gcode_parse_char(uint8_t c) {
    2ce4:	cf 93       	push	r28
    2ce6:	df 93       	push	r29
    2ce8:	d8 2f       	mov	r29, r24
	uint8_t checksum_char = c;

	// uppercase
	if (c >= 'a' && c <= 'z')
    2cea:	81 56       	subi	r24, 0x61	; 97
    2cec:	8a 31       	cpi	r24, 0x1A	; 26
    2cee:	18 f4       	brcc	.+6      	; 0x2cf6 <gcode_parse_char+0x12>
		c &= ~32;
    2cf0:	cd 2f       	mov	r28, r29
    2cf2:	cf 7d       	andi	r28, 0xDF	; 223
    2cf4:	01 c0       	rjmp	.+2      	; 0x2cf8 <gcode_parse_char+0x14>
/// \param c the next character to process
void gcode_parse_char(uint8_t c) {
	uint8_t checksum_char = c;

	// uppercase
	if (c >= 'a' && c <= 'z')
    2cf6:	cd 2f       	mov	r28, r29
		c &= ~32;

	// process previous field
	if (last_field) {
    2cf8:	80 91 be 04 	lds	r24, 0x04BE
    2cfc:	88 23       	and	r24, r24
    2cfe:	09 f4       	brne	.+2      	; 0x2d02 <gcode_parse_char+0x1e>
    2d00:	da c1       	rjmp	.+948    	; 0x30b6 <gcode_parse_char+0x3d2>
		// check if we're seeing a new field or end of line
		// any character will start a new field, even invalid/unknown ones
		if ((c >= 'A' && c <= 'Z') || c == '*' || (c == 10) || (c == 13)) {
    2d02:	9c 2f       	mov	r25, r28
    2d04:	91 54       	subi	r25, 0x41	; 65
    2d06:	9a 31       	cpi	r25, 0x1A	; 26
    2d08:	38 f0       	brcs	.+14     	; 0x2d18 <gcode_parse_char+0x34>
    2d0a:	ca 32       	cpi	r28, 0x2A	; 42
    2d0c:	29 f0       	breq	.+10     	; 0x2d18 <gcode_parse_char+0x34>
    2d0e:	ca 30       	cpi	r28, 0x0A	; 10
    2d10:	19 f0       	breq	.+6      	; 0x2d18 <gcode_parse_char+0x34>
    2d12:	cd 30       	cpi	r28, 0x0D	; 13
    2d14:	09 f0       	breq	.+2      	; 0x2d18 <gcode_parse_char+0x34>
    2d16:	cf c1       	rjmp	.+926    	; 0x30b6 <gcode_parse_char+0x3d2>
			switch (last_field) {
    2d18:	80 35       	cpi	r24, 0x50	; 80
    2d1a:	09 f4       	brne	.+2      	; 0x2d1e <gcode_parse_char+0x3a>
    2d1c:	75 c1       	rjmp	.+746    	; 0x3008 <gcode_parse_char+0x324>
    2d1e:	90 f4       	brcc	.+36     	; 0x2d44 <gcode_parse_char+0x60>
    2d20:	87 34       	cpi	r24, 0x47	; 71
    2d22:	09 f1       	breq	.+66     	; 0x2d66 <gcode_parse_char+0x82>
    2d24:	48 f4       	brcc	.+18     	; 0x2d38 <gcode_parse_char+0x54>
    2d26:	85 34       	cpi	r24, 0x45	; 69
    2d28:	09 f4       	brne	.+2      	; 0x2d2c <gcode_parse_char+0x48>
    2d2a:	d8 c0       	rjmp	.+432    	; 0x2edc <gcode_parse_char+0x1f8>
    2d2c:	08 f0       	brcs	.+2      	; 0x2d30 <gcode_parse_char+0x4c>
    2d2e:	05 c1       	rjmp	.+522    	; 0x2f3a <gcode_parse_char+0x256>
    2d30:	8a 32       	cpi	r24, 0x2A	; 42
    2d32:	09 f0       	breq	.+2      	; 0x2d36 <gcode_parse_char+0x52>
    2d34:	b4 c1       	rjmp	.+872    	; 0x309e <gcode_parse_char+0x3ba>
    2d36:	a3 c1       	rjmp	.+838    	; 0x307e <gcode_parse_char+0x39a>
    2d38:	8d 34       	cpi	r24, 0x4D	; 77
    2d3a:	61 f1       	breq	.+88     	; 0x2d94 <gcode_parse_char+0xb0>
    2d3c:	8e 34       	cpi	r24, 0x4E	; 78
    2d3e:	09 f0       	breq	.+2      	; 0x2d42 <gcode_parse_char+0x5e>
    2d40:	ae c1       	rjmp	.+860    	; 0x309e <gcode_parse_char+0x3ba>
    2d42:	8b c1       	rjmp	.+790    	; 0x305a <gcode_parse_char+0x376>
    2d44:	88 35       	cpi	r24, 0x58	; 88
    2d46:	e9 f1       	breq	.+122    	; 0x2dc2 <gcode_parse_char+0xde>
    2d48:	38 f4       	brcc	.+14     	; 0x2d58 <gcode_parse_char+0x74>
    2d4a:	83 35       	cpi	r24, 0x53	; 83
    2d4c:	09 f4       	brne	.+2      	; 0x2d50 <gcode_parse_char+0x6c>
    2d4e:	24 c1       	rjmp	.+584    	; 0x2f98 <gcode_parse_char+0x2b4>
    2d50:	84 35       	cpi	r24, 0x54	; 84
    2d52:	09 f0       	breq	.+2      	; 0x2d56 <gcode_parse_char+0x72>
    2d54:	a4 c1       	rjmp	.+840    	; 0x309e <gcode_parse_char+0x3ba>
    2d56:	6b c1       	rjmp	.+726    	; 0x302e <gcode_parse_char+0x34a>
    2d58:	89 35       	cpi	r24, 0x59	; 89
    2d5a:	09 f4       	brne	.+2      	; 0x2d5e <gcode_parse_char+0x7a>
    2d5c:	61 c0       	rjmp	.+194    	; 0x2e20 <gcode_parse_char+0x13c>
    2d5e:	8a 35       	cpi	r24, 0x5A	; 90
    2d60:	09 f0       	breq	.+2      	; 0x2d64 <gcode_parse_char+0x80>
    2d62:	9d c1       	rjmp	.+826    	; 0x309e <gcode_parse_char+0x3ba>
    2d64:	8c c0       	rjmp	.+280    	; 0x2e7e <gcode_parse_char+0x19a>
				case 'G':
					next_target.G = read_digit.mantissa;
    2d66:	80 91 ae 04 	lds	r24, 0x04AE
    2d6a:	90 91 af 04 	lds	r25, 0x04AF
    2d6e:	a0 91 b0 04 	lds	r26, 0x04B0
    2d72:	b0 91 b1 04 	lds	r27, 0x04B1
    2d76:	80 93 88 04 	sts	0x0488, r24
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2d7a:	20 91 cf 04 	lds	r18, 0x04CF
    2d7e:	22 23       	and	r18, r18
    2d80:	0c f0       	brlt	.+2      	; 0x2d84 <gcode_parse_char+0xa0>
    2d82:	8d c1       	rjmp	.+794    	; 0x309e <gcode_parse_char+0x3ba>
						serwrite_uint8(next_target.G);
    2d84:	bc 01       	movw	r22, r24
    2d86:	cd 01       	movw	r24, r26
    2d88:	77 27       	eor	r23, r23
    2d8a:	88 27       	eor	r24, r24
    2d8c:	99 27       	eor	r25, r25
    2d8e:	0e 94 b9 26 	call	0x4d72	; 0x4d72 <serwrite_uint32>
    2d92:	85 c1       	rjmp	.+778    	; 0x309e <gcode_parse_char+0x3ba>
					break;
				case 'M':
					next_target.M = read_digit.mantissa;
    2d94:	80 91 ae 04 	lds	r24, 0x04AE
    2d98:	90 91 af 04 	lds	r25, 0x04AF
    2d9c:	a0 91 b0 04 	lds	r26, 0x04B0
    2da0:	b0 91 b1 04 	lds	r27, 0x04B1
    2da4:	80 93 89 04 	sts	0x0489, r24
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2da8:	20 91 cf 04 	lds	r18, 0x04CF
    2dac:	22 23       	and	r18, r18
    2dae:	0c f0       	brlt	.+2      	; 0x2db2 <gcode_parse_char+0xce>
    2db0:	76 c1       	rjmp	.+748    	; 0x309e <gcode_parse_char+0x3ba>
						serwrite_uint8(next_target.M);
    2db2:	bc 01       	movw	r22, r24
    2db4:	cd 01       	movw	r24, r26
    2db6:	77 27       	eor	r23, r23
    2db8:	88 27       	eor	r24, r24
    2dba:	99 27       	eor	r25, r25
    2dbc:	0e 94 b9 26 	call	0x4d72	; 0x4d72 <serwrite_uint32>
    2dc0:	6e c1       	rjmp	.+732    	; 0x309e <gcode_parse_char+0x3ba>
					break;
				case 'X':
					if (next_target.option_inches)
    2dc2:	80 91 87 04 	lds	r24, 0x0487
    2dc6:	80 ff       	sbrs	r24, 0
    2dc8:	0e c0       	rjmp	.+28     	; 0x2de6 <gcode_parse_char+0x102>
						next_target.target.X = decfloat_to_int(&read_digit, 25400);
    2dca:	68 e3       	ldi	r22, 0x38	; 56
    2dcc:	73 e6       	ldi	r23, 0x63	; 99
    2dce:	8e ea       	ldi	r24, 0xAE	; 174
    2dd0:	94 e0       	ldi	r25, 0x04	; 4
    2dd2:	d6 de       	rcall	.-596    	; 0x2b80 <decfloat_to_int>
    2dd4:	60 93 8a 04 	sts	0x048A, r22
    2dd8:	70 93 8b 04 	sts	0x048B, r23
    2ddc:	80 93 8c 04 	sts	0x048C, r24
    2de0:	90 93 8d 04 	sts	0x048D, r25
    2de4:	0d c0       	rjmp	.+26     	; 0x2e00 <gcode_parse_char+0x11c>
					else
						next_target.target.X = decfloat_to_int(&read_digit, 1000);
    2de6:	68 ee       	ldi	r22, 0xE8	; 232
    2de8:	73 e0       	ldi	r23, 0x03	; 3
    2dea:	8e ea       	ldi	r24, 0xAE	; 174
    2dec:	94 e0       	ldi	r25, 0x04	; 4
    2dee:	c8 de       	rcall	.-624    	; 0x2b80 <decfloat_to_int>
    2df0:	60 93 8a 04 	sts	0x048A, r22
    2df4:	70 93 8b 04 	sts	0x048B, r23
    2df8:	80 93 8c 04 	sts	0x048C, r24
    2dfc:	90 93 8d 04 	sts	0x048D, r25
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2e00:	80 91 cf 04 	lds	r24, 0x04CF
    2e04:	88 23       	and	r24, r24
    2e06:	0c f0       	brlt	.+2      	; 0x2e0a <gcode_parse_char+0x126>
    2e08:	4a c1       	rjmp	.+660    	; 0x309e <gcode_parse_char+0x3ba>
						serwrite_int32(next_target.target.X);
    2e0a:	60 91 8a 04 	lds	r22, 0x048A
    2e0e:	70 91 8b 04 	lds	r23, 0x048B
    2e12:	80 91 8c 04 	lds	r24, 0x048C
    2e16:	90 91 8d 04 	lds	r25, 0x048D
    2e1a:	0e 94 08 27 	call	0x4e10	; 0x4e10 <serwrite_int32>
    2e1e:	3f c1       	rjmp	.+638    	; 0x309e <gcode_parse_char+0x3ba>
					break;
				case 'Y':
					if (next_target.option_inches)
    2e20:	80 91 87 04 	lds	r24, 0x0487
    2e24:	80 ff       	sbrs	r24, 0
    2e26:	0e c0       	rjmp	.+28     	; 0x2e44 <gcode_parse_char+0x160>
						next_target.target.Y = decfloat_to_int(&read_digit, 25400);
    2e28:	68 e3       	ldi	r22, 0x38	; 56
    2e2a:	73 e6       	ldi	r23, 0x63	; 99
    2e2c:	8e ea       	ldi	r24, 0xAE	; 174
    2e2e:	94 e0       	ldi	r25, 0x04	; 4
    2e30:	a7 de       	rcall	.-690    	; 0x2b80 <decfloat_to_int>
    2e32:	60 93 8e 04 	sts	0x048E, r22
    2e36:	70 93 8f 04 	sts	0x048F, r23
    2e3a:	80 93 90 04 	sts	0x0490, r24
    2e3e:	90 93 91 04 	sts	0x0491, r25
    2e42:	0d c0       	rjmp	.+26     	; 0x2e5e <gcode_parse_char+0x17a>
					else
						next_target.target.Y = decfloat_to_int(&read_digit, 1000);
    2e44:	68 ee       	ldi	r22, 0xE8	; 232
    2e46:	73 e0       	ldi	r23, 0x03	; 3
    2e48:	8e ea       	ldi	r24, 0xAE	; 174
    2e4a:	94 e0       	ldi	r25, 0x04	; 4
    2e4c:	99 de       	rcall	.-718    	; 0x2b80 <decfloat_to_int>
    2e4e:	60 93 8e 04 	sts	0x048E, r22
    2e52:	70 93 8f 04 	sts	0x048F, r23
    2e56:	80 93 90 04 	sts	0x0490, r24
    2e5a:	90 93 91 04 	sts	0x0491, r25
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2e5e:	80 91 cf 04 	lds	r24, 0x04CF
    2e62:	88 23       	and	r24, r24
    2e64:	0c f0       	brlt	.+2      	; 0x2e68 <gcode_parse_char+0x184>
    2e66:	1b c1       	rjmp	.+566    	; 0x309e <gcode_parse_char+0x3ba>
						serwrite_int32(next_target.target.Y);
    2e68:	60 91 8e 04 	lds	r22, 0x048E
    2e6c:	70 91 8f 04 	lds	r23, 0x048F
    2e70:	80 91 90 04 	lds	r24, 0x0490
    2e74:	90 91 91 04 	lds	r25, 0x0491
    2e78:	0e 94 08 27 	call	0x4e10	; 0x4e10 <serwrite_int32>
    2e7c:	10 c1       	rjmp	.+544    	; 0x309e <gcode_parse_char+0x3ba>
					break;
				case 'Z':
					if (next_target.option_inches)
    2e7e:	80 91 87 04 	lds	r24, 0x0487
    2e82:	80 ff       	sbrs	r24, 0
    2e84:	0e c0       	rjmp	.+28     	; 0x2ea2 <gcode_parse_char+0x1be>
						next_target.target.Z = decfloat_to_int(&read_digit, 25400);
    2e86:	68 e3       	ldi	r22, 0x38	; 56
    2e88:	73 e6       	ldi	r23, 0x63	; 99
    2e8a:	8e ea       	ldi	r24, 0xAE	; 174
    2e8c:	94 e0       	ldi	r25, 0x04	; 4
    2e8e:	78 de       	rcall	.-784    	; 0x2b80 <decfloat_to_int>
    2e90:	60 93 92 04 	sts	0x0492, r22
    2e94:	70 93 93 04 	sts	0x0493, r23
    2e98:	80 93 94 04 	sts	0x0494, r24
    2e9c:	90 93 95 04 	sts	0x0495, r25
    2ea0:	0d c0       	rjmp	.+26     	; 0x2ebc <gcode_parse_char+0x1d8>
					else
						next_target.target.Z = decfloat_to_int(&read_digit, 1000);
    2ea2:	68 ee       	ldi	r22, 0xE8	; 232
    2ea4:	73 e0       	ldi	r23, 0x03	; 3
    2ea6:	8e ea       	ldi	r24, 0xAE	; 174
    2ea8:	94 e0       	ldi	r25, 0x04	; 4
    2eaa:	6a de       	rcall	.-812    	; 0x2b80 <decfloat_to_int>
    2eac:	60 93 92 04 	sts	0x0492, r22
    2eb0:	70 93 93 04 	sts	0x0493, r23
    2eb4:	80 93 94 04 	sts	0x0494, r24
    2eb8:	90 93 95 04 	sts	0x0495, r25
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2ebc:	80 91 cf 04 	lds	r24, 0x04CF
    2ec0:	88 23       	and	r24, r24
    2ec2:	0c f0       	brlt	.+2      	; 0x2ec6 <gcode_parse_char+0x1e2>
    2ec4:	ec c0       	rjmp	.+472    	; 0x309e <gcode_parse_char+0x3ba>
						serwrite_int32(next_target.target.Z);
    2ec6:	60 91 92 04 	lds	r22, 0x0492
    2eca:	70 91 93 04 	lds	r23, 0x0493
    2ece:	80 91 94 04 	lds	r24, 0x0494
    2ed2:	90 91 95 04 	lds	r25, 0x0495
    2ed6:	0e 94 08 27 	call	0x4e10	; 0x4e10 <serwrite_int32>
    2eda:	e1 c0       	rjmp	.+450    	; 0x309e <gcode_parse_char+0x3ba>
					break;
				case 'E':
					if (next_target.option_inches)
    2edc:	80 91 87 04 	lds	r24, 0x0487
    2ee0:	80 ff       	sbrs	r24, 0
    2ee2:	0e c0       	rjmp	.+28     	; 0x2f00 <gcode_parse_char+0x21c>
						next_target.target.E = decfloat_to_int(&read_digit, 25400);
    2ee4:	68 e3       	ldi	r22, 0x38	; 56
    2ee6:	73 e6       	ldi	r23, 0x63	; 99
    2ee8:	8e ea       	ldi	r24, 0xAE	; 174
    2eea:	94 e0       	ldi	r25, 0x04	; 4
    2eec:	49 de       	rcall	.-878    	; 0x2b80 <decfloat_to_int>
    2eee:	60 93 96 04 	sts	0x0496, r22
    2ef2:	70 93 97 04 	sts	0x0497, r23
    2ef6:	80 93 98 04 	sts	0x0498, r24
    2efa:	90 93 99 04 	sts	0x0499, r25
    2efe:	0d c0       	rjmp	.+26     	; 0x2f1a <gcode_parse_char+0x236>
					else
						next_target.target.E = decfloat_to_int(&read_digit, 1000);
    2f00:	68 ee       	ldi	r22, 0xE8	; 232
    2f02:	73 e0       	ldi	r23, 0x03	; 3
    2f04:	8e ea       	ldi	r24, 0xAE	; 174
    2f06:	94 e0       	ldi	r25, 0x04	; 4
    2f08:	3b de       	rcall	.-906    	; 0x2b80 <decfloat_to_int>
    2f0a:	60 93 96 04 	sts	0x0496, r22
    2f0e:	70 93 97 04 	sts	0x0497, r23
    2f12:	80 93 98 04 	sts	0x0498, r24
    2f16:	90 93 99 04 	sts	0x0499, r25
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2f1a:	80 91 cf 04 	lds	r24, 0x04CF
    2f1e:	88 23       	and	r24, r24
    2f20:	0c f0       	brlt	.+2      	; 0x2f24 <gcode_parse_char+0x240>
    2f22:	bd c0       	rjmp	.+378    	; 0x309e <gcode_parse_char+0x3ba>
						serwrite_uint32(next_target.target.E);
    2f24:	60 91 96 04 	lds	r22, 0x0496
    2f28:	70 91 97 04 	lds	r23, 0x0497
    2f2c:	80 91 98 04 	lds	r24, 0x0498
    2f30:	90 91 99 04 	lds	r25, 0x0499
    2f34:	0e 94 b9 26 	call	0x4d72	; 0x4d72 <serwrite_uint32>
    2f38:	b2 c0       	rjmp	.+356    	; 0x309e <gcode_parse_char+0x3ba>
					break;
				case 'F':
					// just use raw integer, we need move distance and n_steps to convert it to a useful value, so wait until we have those to convert it
					if (next_target.option_inches)
    2f3a:	80 91 87 04 	lds	r24, 0x0487
    2f3e:	80 ff       	sbrs	r24, 0
    2f40:	0e c0       	rjmp	.+28     	; 0x2f5e <gcode_parse_char+0x27a>
						next_target.target.F = decfloat_to_int(&read_digit, 25400);
    2f42:	68 e3       	ldi	r22, 0x38	; 56
    2f44:	73 e6       	ldi	r23, 0x63	; 99
    2f46:	8e ea       	ldi	r24, 0xAE	; 174
    2f48:	94 e0       	ldi	r25, 0x04	; 4
    2f4a:	1a de       	rcall	.-972    	; 0x2b80 <decfloat_to_int>
    2f4c:	60 93 9a 04 	sts	0x049A, r22
    2f50:	70 93 9b 04 	sts	0x049B, r23
    2f54:	80 93 9c 04 	sts	0x049C, r24
    2f58:	90 93 9d 04 	sts	0x049D, r25
    2f5c:	0d c0       	rjmp	.+26     	; 0x2f78 <gcode_parse_char+0x294>
					else
						next_target.target.F = decfloat_to_int(&read_digit, 1);
    2f5e:	61 e0       	ldi	r22, 0x01	; 1
    2f60:	70 e0       	ldi	r23, 0x00	; 0
    2f62:	8e ea       	ldi	r24, 0xAE	; 174
    2f64:	94 e0       	ldi	r25, 0x04	; 4
    2f66:	0c de       	rcall	.-1000   	; 0x2b80 <decfloat_to_int>
    2f68:	60 93 9a 04 	sts	0x049A, r22
    2f6c:	70 93 9b 04 	sts	0x049B, r23
    2f70:	80 93 9c 04 	sts	0x049C, r24
    2f74:	90 93 9d 04 	sts	0x049D, r25
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2f78:	80 91 cf 04 	lds	r24, 0x04CF
    2f7c:	88 23       	and	r24, r24
    2f7e:	0c f0       	brlt	.+2      	; 0x2f82 <gcode_parse_char+0x29e>
    2f80:	8e c0       	rjmp	.+284    	; 0x309e <gcode_parse_char+0x3ba>
						serwrite_uint32(next_target.target.F);
    2f82:	60 91 9a 04 	lds	r22, 0x049A
    2f86:	70 91 9b 04 	lds	r23, 0x049B
    2f8a:	80 91 9c 04 	lds	r24, 0x049C
    2f8e:	90 91 9d 04 	lds	r25, 0x049D
    2f92:	0e 94 b9 26 	call	0x4d72	; 0x4d72 <serwrite_uint32>
    2f96:	83 c0       	rjmp	.+262    	; 0x309e <gcode_parse_char+0x3ba>
					break;
				case 'S':
					// if this is temperature, multiply by 4 to convert to quarter-degree units
					// cosmetically this should be done in the temperature section,
					// but it takes less code, less memory and loses no precision if we do it here instead
					if ((next_target.M == 104) || (next_target.M == 109) || (next_target.M == 140))
    2f98:	80 91 89 04 	lds	r24, 0x0489
    2f9c:	88 36       	cpi	r24, 0x68	; 104
    2f9e:	21 f0       	breq	.+8      	; 0x2fa8 <gcode_parse_char+0x2c4>
    2fa0:	8d 36       	cpi	r24, 0x6D	; 109
    2fa2:	11 f0       	breq	.+4      	; 0x2fa8 <gcode_parse_char+0x2c4>
    2fa4:	8c 38       	cpi	r24, 0x8C	; 140
    2fa6:	51 f4       	brne	.+20     	; 0x2fbc <gcode_parse_char+0x2d8>
						next_target.S = decfloat_to_int(&read_digit, 4);
    2fa8:	64 e0       	ldi	r22, 0x04	; 4
    2faa:	70 e0       	ldi	r23, 0x00	; 0
    2fac:	8e ea       	ldi	r24, 0xAE	; 174
    2fae:	94 e0       	ldi	r25, 0x04	; 4
    2fb0:	e7 dd       	rcall	.-1074   	; 0x2b80 <decfloat_to_int>
    2fb2:	70 93 a0 04 	sts	0x04A0, r23
    2fb6:	60 93 9f 04 	sts	0x049F, r22
    2fba:	16 c0       	rjmp	.+44     	; 0x2fe8 <gcode_parse_char+0x304>
					// if this is heater PID stuff, multiply by PID_SCALE because we divide by PID_SCALE later on
					else if ((next_target.M >= 130) && (next_target.M <= 132))
    2fbc:	82 58       	subi	r24, 0x82	; 130
    2fbe:	83 30       	cpi	r24, 0x03	; 3
    2fc0:	50 f4       	brcc	.+20     	; 0x2fd6 <gcode_parse_char+0x2f2>
						next_target.S = decfloat_to_int(&read_digit, PID_SCALE);
    2fc2:	60 e0       	ldi	r22, 0x00	; 0
    2fc4:	74 e0       	ldi	r23, 0x04	; 4
    2fc6:	8e ea       	ldi	r24, 0xAE	; 174
    2fc8:	94 e0       	ldi	r25, 0x04	; 4
    2fca:	da dd       	rcall	.-1100   	; 0x2b80 <decfloat_to_int>
    2fcc:	70 93 a0 04 	sts	0x04A0, r23
    2fd0:	60 93 9f 04 	sts	0x049F, r22
    2fd4:	09 c0       	rjmp	.+18     	; 0x2fe8 <gcode_parse_char+0x304>
					else
						next_target.S = decfloat_to_int(&read_digit, 1);
    2fd6:	61 e0       	ldi	r22, 0x01	; 1
    2fd8:	70 e0       	ldi	r23, 0x00	; 0
    2fda:	8e ea       	ldi	r24, 0xAE	; 174
    2fdc:	94 e0       	ldi	r25, 0x04	; 4
    2fde:	d0 dd       	rcall	.-1120   	; 0x2b80 <decfloat_to_int>
    2fe0:	70 93 a0 04 	sts	0x04A0, r23
    2fe4:	60 93 9f 04 	sts	0x049F, r22
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    2fe8:	80 91 cf 04 	lds	r24, 0x04CF
    2fec:	88 23       	and	r24, r24
    2fee:	0c f0       	brlt	.+2      	; 0x2ff2 <gcode_parse_char+0x30e>
    2ff0:	56 c0       	rjmp	.+172    	; 0x309e <gcode_parse_char+0x3ba>
						serwrite_uint16(next_target.S);
    2ff2:	60 91 9f 04 	lds	r22, 0x049F
    2ff6:	70 91 a0 04 	lds	r23, 0x04A0
    2ffa:	88 27       	eor	r24, r24
    2ffc:	77 fd       	sbrc	r23, 7
    2ffe:	80 95       	com	r24
    3000:	98 2f       	mov	r25, r24
    3002:	0e 94 b9 26 	call	0x4d72	; 0x4d72 <serwrite_uint32>
    3006:	4b c0       	rjmp	.+150    	; 0x309e <gcode_parse_char+0x3ba>
					break;
				case 'P':
					next_target.P = decfloat_to_int(&read_digit, 1);
    3008:	61 e0       	ldi	r22, 0x01	; 1
    300a:	70 e0       	ldi	r23, 0x00	; 0
    300c:	8e ea       	ldi	r24, 0xAE	; 174
    300e:	94 e0       	ldi	r25, 0x04	; 4
    3010:	b7 dd       	rcall	.-1170   	; 0x2b80 <decfloat_to_int>
    3012:	70 93 a2 04 	sts	0x04A2, r23
    3016:	60 93 a1 04 	sts	0x04A1, r22
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    301a:	20 91 cf 04 	lds	r18, 0x04CF
    301e:	22 23       	and	r18, r18
    3020:	0c f0       	brlt	.+2      	; 0x3024 <gcode_parse_char+0x340>
    3022:	3d c0       	rjmp	.+122    	; 0x309e <gcode_parse_char+0x3ba>
	#endif
}

/// Character Received - add it to our command
/// \param c the next character to process
void gcode_parse_char(uint8_t c) {
    3024:	88 27       	eor	r24, r24
    3026:	99 27       	eor	r25, r25
						serwrite_uint16(next_target.S);
					break;
				case 'P':
					next_target.P = decfloat_to_int(&read_digit, 1);
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
						serwrite_uint16(next_target.P);
    3028:	0e 94 b9 26 	call	0x4d72	; 0x4d72 <serwrite_uint32>
    302c:	38 c0       	rjmp	.+112    	; 0x309e <gcode_parse_char+0x3ba>
					break;
				case 'T':
					next_target.T = read_digit.mantissa;
    302e:	80 91 ae 04 	lds	r24, 0x04AE
    3032:	90 91 af 04 	lds	r25, 0x04AF
    3036:	a0 91 b0 04 	lds	r26, 0x04B0
    303a:	b0 91 b1 04 	lds	r27, 0x04B1
    303e:	80 93 a3 04 	sts	0x04A3, r24
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    3042:	20 91 cf 04 	lds	r18, 0x04CF
    3046:	22 23       	and	r18, r18
    3048:	54 f5       	brge	.+84     	; 0x309e <gcode_parse_char+0x3ba>
						serwrite_uint8(next_target.T);
    304a:	bc 01       	movw	r22, r24
    304c:	cd 01       	movw	r24, r26
    304e:	77 27       	eor	r23, r23
    3050:	88 27       	eor	r24, r24
    3052:	99 27       	eor	r25, r25
    3054:	0e 94 b9 26 	call	0x4d72	; 0x4d72 <serwrite_uint32>
    3058:	22 c0       	rjmp	.+68     	; 0x309e <gcode_parse_char+0x3ba>
					break;
				case 'N':
					next_target.N = decfloat_to_int(&read_digit, 1);
    305a:	61 e0       	ldi	r22, 0x01	; 1
    305c:	70 e0       	ldi	r23, 0x00	; 0
    305e:	8e ea       	ldi	r24, 0xAE	; 174
    3060:	94 e0       	ldi	r25, 0x04	; 4
    3062:	8e dd       	rcall	.-1252   	; 0x2b80 <decfloat_to_int>
    3064:	e4 ea       	ldi	r30, 0xA4	; 164
    3066:	f4 e0       	ldi	r31, 0x04	; 4
    3068:	60 83       	st	Z, r22
    306a:	71 83       	std	Z+1, r23	; 0x01
    306c:	82 83       	std	Z+2, r24	; 0x02
    306e:	93 83       	std	Z+3, r25	; 0x03
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    3070:	20 91 cf 04 	lds	r18, 0x04CF
    3074:	22 23       	and	r18, r18
    3076:	9c f4       	brge	.+38     	; 0x309e <gcode_parse_char+0x3ba>
						serwrite_uint32(next_target.N);
    3078:	0e 94 b9 26 	call	0x4d72	; 0x4d72 <serwrite_uint32>
    307c:	10 c0       	rjmp	.+32     	; 0x309e <gcode_parse_char+0x3ba>
					break;
				case '*':
					next_target.checksum_read = decfloat_to_int(&read_digit, 1);
    307e:	61 e0       	ldi	r22, 0x01	; 1
    3080:	70 e0       	ldi	r23, 0x00	; 0
    3082:	8e ea       	ldi	r24, 0xAE	; 174
    3084:	94 e0       	ldi	r25, 0x04	; 4
    3086:	7c dd       	rcall	.-1288   	; 0x2b80 <decfloat_to_int>
    3088:	60 93 ac 04 	sts	0x04AC, r22
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    308c:	20 91 cf 04 	lds	r18, 0x04CF
    3090:	22 23       	and	r18, r18
    3092:	2c f4       	brge	.+10     	; 0x309e <gcode_parse_char+0x3ba>
	#endif
}

/// Character Received - add it to our command
/// \param c the next character to process
void gcode_parse_char(uint8_t c) {
    3094:	77 27       	eor	r23, r23
    3096:	88 27       	eor	r24, r24
    3098:	99 27       	eor	r25, r25
						serwrite_uint32(next_target.N);
					break;
				case '*':
					next_target.checksum_read = decfloat_to_int(&read_digit, 1);
					if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
						serwrite_uint8(next_target.checksum_read);
    309a:	0e 94 b9 26 	call	0x4d72	; 0x4d72 <serwrite_uint32>
					break;
			}
			// reset for next field
			last_field = 0;
    309e:	10 92 be 04 	sts	0x04BE, r1
			read_digit.sign = read_digit.mantissa = read_digit.exponent = 0;
    30a2:	10 92 ae 04 	sts	0x04AE, r1
    30a6:	10 92 af 04 	sts	0x04AF, r1
    30aa:	10 92 b0 04 	sts	0x04B0, r1
    30ae:	10 92 b1 04 	sts	0x04B1, r1
    30b2:	10 92 b2 04 	sts	0x04B2, r1
		}
	}

	// skip comments
	if (next_target.seen_semi_comment == 0 && next_target.seen_parens_comment == 0) {
    30b6:	80 91 86 04 	lds	r24, 0x0486
    30ba:	98 2f       	mov	r25, r24
    30bc:	90 73       	andi	r25, 0x30	; 48
    30be:	09 f0       	breq	.+2      	; 0x30c2 <gcode_parse_char+0x3de>
    30c0:	f8 c0       	rjmp	.+496    	; 0x32b2 <gcode_parse_char+0x5ce>
		// new field?
		if ((c >= 'A' && c <= 'Z') || c == '*') {
    30c2:	8c 2f       	mov	r24, r28
    30c4:	81 54       	subi	r24, 0x41	; 65
    30c6:	8a 31       	cpi	r24, 0x1A	; 26
    30c8:	10 f0       	brcs	.+4      	; 0x30ce <gcode_parse_char+0x3ea>
    30ca:	ca 32       	cpi	r28, 0x2A	; 42
    30cc:	49 f4       	brne	.+18     	; 0x30e0 <gcode_parse_char+0x3fc>
			last_field = c;
    30ce:	c0 93 be 04 	sts	0x04BE, r28
			if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    30d2:	80 91 cf 04 	lds	r24, 0x04CF
    30d6:	88 23       	and	r24, r24
    30d8:	1c f4       	brge	.+6      	; 0x30e0 <gcode_parse_char+0x3fc>
				serial_writechar(c);
    30da:	8c 2f       	mov	r24, r28
    30dc:	0e 94 40 26 	call	0x4c80	; 0x4c80 <serial_writechar>
		}

		// process character
    // Can't do ranges in switch..case, so process actual digits here.
    // Do it early, as there are many more digits than characters expected.
    if (c >= '0' && c <= '9') {
    30e0:	8c 2f       	mov	r24, r28
    30e2:	80 53       	subi	r24, 0x30	; 48
    30e4:	8a 30       	cpi	r24, 0x0A	; 10
    30e6:	08 f0       	brcs	.+2      	; 0x30ea <gcode_parse_char+0x406>
    30e8:	5d c0       	rjmp	.+186    	; 0x31a4 <gcode_parse_char+0x4c0>
      if (read_digit.exponent < DECFLOAT_EXP_MAX + 1 &&
    30ea:	20 91 b2 04 	lds	r18, 0x04B2
    30ee:	2f 77       	andi	r18, 0x7F	; 127
    30f0:	82 2f       	mov	r24, r18
    30f2:	90 e0       	ldi	r25, 0x00	; 0
    30f4:	04 97       	sbiw	r24, 0x04	; 4
    30f6:	0c f0       	brlt	.+2      	; 0x30fa <gcode_parse_char+0x416>
    30f8:	e5 c0       	rjmp	.+458    	; 0x32c4 <gcode_parse_char+0x5e0>
          ((next_target.option_inches == 0 &&
    30fa:	80 91 87 04 	lds	r24, 0x0487

		// process character
    // Can't do ranges in switch..case, so process actual digits here.
    // Do it early, as there are many more digits than characters expected.
    if (c >= '0' && c <= '9') {
      if (read_digit.exponent < DECFLOAT_EXP_MAX + 1 &&
    30fe:	80 fd       	sbrc	r24, 0
    3100:	0e c0       	rjmp	.+28     	; 0x311e <gcode_parse_char+0x43a>
          ((next_target.option_inches == 0 &&
    3102:	40 91 ae 04 	lds	r20, 0x04AE
    3106:	50 91 af 04 	lds	r21, 0x04AF
    310a:	60 91 b0 04 	lds	r22, 0x04B0
    310e:	70 91 b1 04 	lds	r23, 0x04B1
    3112:	4f 3a       	cpi	r20, 0xAF	; 175
    3114:	55 47       	sbci	r21, 0x75	; 117
    3116:	61 44       	sbci	r22, 0x41	; 65
    3118:	71 05       	cpc	r23, r1
    311a:	78 f0       	brcs	.+30     	; 0x313a <gcode_parse_char+0x456>
    311c:	d3 c0       	rjmp	.+422    	; 0x32c4 <gcode_parse_char+0x5e0>
          read_digit.mantissa < DECFLOAT_MANT_MM_MAX) ||
          (next_target.option_inches &&
    311e:	80 91 ae 04 	lds	r24, 0x04AE
    3122:	90 91 af 04 	lds	r25, 0x04AF
    3126:	a0 91 b0 04 	lds	r26, 0x04B0
    312a:	b0 91 b1 04 	lds	r27, 0x04B1
    312e:	8d 3f       	cpi	r24, 0xFD	; 253
    3130:	90 48       	sbci	r25, 0x80	; 128
    3132:	a2 40       	sbci	r26, 0x02	; 2
    3134:	b1 05       	cpc	r27, r1
    3136:	08 f0       	brcs	.+2      	; 0x313a <gcode_parse_char+0x456>
    3138:	c5 c0       	rjmp	.+394    	; 0x32c4 <gcode_parse_char+0x5e0>
          read_digit.mantissa < DECFLOAT_MANT_IN_MAX))) {
        // this is simply mantissa = (mantissa * 10) + atoi(c) in different clothes
        read_digit.mantissa = (read_digit.mantissa << 3) +
    313a:	ee ea       	ldi	r30, 0xAE	; 174
    313c:	f4 e0       	ldi	r31, 0x04	; 4
    313e:	40 81       	ld	r20, Z
    3140:	51 81       	ldd	r21, Z+1	; 0x01
    3142:	62 81       	ldd	r22, Z+2	; 0x02
    3144:	73 81       	ldd	r23, Z+3	; 0x03
                              (read_digit.mantissa << 1) + (c - '0');
    3146:	44 0f       	add	r20, r20
    3148:	55 1f       	adc	r21, r21
    314a:	66 1f       	adc	r22, r22
    314c:	77 1f       	adc	r23, r23
          ((next_target.option_inches == 0 &&
          read_digit.mantissa < DECFLOAT_MANT_MM_MAX) ||
          (next_target.option_inches &&
          read_digit.mantissa < DECFLOAT_MANT_IN_MAX))) {
        // this is simply mantissa = (mantissa * 10) + atoi(c) in different clothes
        read_digit.mantissa = (read_digit.mantissa << 3) +
    314e:	db 01       	movw	r26, r22
    3150:	ca 01       	movw	r24, r20
    3152:	88 0f       	add	r24, r24
    3154:	99 1f       	adc	r25, r25
    3156:	aa 1f       	adc	r26, r26
    3158:	bb 1f       	adc	r27, r27
    315a:	88 0f       	add	r24, r24
    315c:	99 1f       	adc	r25, r25
    315e:	aa 1f       	adc	r26, r26
    3160:	bb 1f       	adc	r27, r27
    3162:	48 0f       	add	r20, r24
    3164:	59 1f       	adc	r21, r25
    3166:	6a 1f       	adc	r22, r26
    3168:	7b 1f       	adc	r23, r27
                              (read_digit.mantissa << 1) + (c - '0');
    316a:	8c 2f       	mov	r24, r28
    316c:	90 e0       	ldi	r25, 0x00	; 0
    316e:	c0 97       	sbiw	r24, 0x30	; 48
    3170:	aa 27       	eor	r26, r26
    3172:	97 fd       	sbrc	r25, 7
    3174:	a0 95       	com	r26
    3176:	ba 2f       	mov	r27, r26
    3178:	48 0f       	add	r20, r24
    317a:	59 1f       	adc	r21, r25
    317c:	6a 1f       	adc	r22, r26
    317e:	7b 1f       	adc	r23, r27
          ((next_target.option_inches == 0 &&
          read_digit.mantissa < DECFLOAT_MANT_MM_MAX) ||
          (next_target.option_inches &&
          read_digit.mantissa < DECFLOAT_MANT_IN_MAX))) {
        // this is simply mantissa = (mantissa * 10) + atoi(c) in different clothes
        read_digit.mantissa = (read_digit.mantissa << 3) +
    3180:	40 83       	st	Z, r20
    3182:	51 83       	std	Z+1, r21	; 0x01
    3184:	62 83       	std	Z+2, r22	; 0x02
    3186:	73 83       	std	Z+3, r23	; 0x03
                              (read_digit.mantissa << 1) + (c - '0');
        if (read_digit.exponent)
    3188:	80 91 b2 04 	lds	r24, 0x04B2
    318c:	8f 77       	andi	r24, 0x7F	; 127
    318e:	09 f4       	brne	.+2      	; 0x3192 <gcode_parse_char+0x4ae>
    3190:	99 c0       	rjmp	.+306    	; 0x32c4 <gcode_parse_char+0x5e0>
          read_digit.exponent++;
    3192:	2f 5f       	subi	r18, 0xFF	; 255
    3194:	2f 77       	andi	r18, 0x7F	; 127
    3196:	e2 eb       	ldi	r30, 0xB2	; 178
    3198:	f4 e0       	ldi	r31, 0x04	; 4
    319a:	80 81       	ld	r24, Z
    319c:	80 78       	andi	r24, 0x80	; 128
    319e:	28 2b       	or	r18, r24
    31a0:	20 83       	st	Z, r18
    31a2:	90 c0       	rjmp	.+288    	; 0x32c4 <gcode_parse_char+0x5e0>
      }
    }
    else {
      switch (c) {
    31a4:	4c 2f       	mov	r20, r28
    31a6:	50 e0       	ldi	r21, 0x00	; 0
    31a8:	fa 01       	movw	r30, r20
    31aa:	39 97       	sbiw	r30, 0x09	; 9
    31ac:	e2 35       	cpi	r30, 0x52	; 82
    31ae:	f1 05       	cpc	r31, r1
    31b0:	08 f0       	brcs	.+2      	; 0x31b4 <gcode_parse_char+0x4d0>
    31b2:	75 c0       	rjmp	.+234    	; 0x329e <gcode_parse_char+0x5ba>
    31b4:	ee 58       	subi	r30, 0x8E	; 142
    31b6:	ff 4f       	sbci	r31, 0xFF	; 255
    31b8:	0c 94 35 2c 	jmp	0x586a	; 0x586a <__tablejump2__>
        // Each currently known command is either G or M, so preserve
        // previous G/M unless a new one has appeared.
        // FIXME: same for T command
        case 'G':
          next_target.seen_G = 1;
    31bc:	e5 e8       	ldi	r30, 0x85	; 133
    31be:	f4 e0       	ldi	r31, 0x04	; 4
    31c0:	80 81       	ld	r24, Z
          next_target.seen_M = 0;
    31c2:	81 60       	ori	r24, 0x01	; 1
    31c4:	8d 7f       	andi	r24, 0xFD	; 253
    31c6:	80 83       	st	Z, r24
          next_target.M = 0;
    31c8:	10 92 89 04 	sts	0x0489, r1
          break;
    31cc:	7b c0       	rjmp	.+246    	; 0x32c4 <gcode_parse_char+0x5e0>
        case 'M':
          next_target.seen_M = 1;
    31ce:	e5 e8       	ldi	r30, 0x85	; 133
    31d0:	f4 e0       	ldi	r31, 0x04	; 4
    31d2:	80 81       	ld	r24, Z
          next_target.seen_G = 0;
    31d4:	82 60       	ori	r24, 0x02	; 2
    31d6:	8e 7f       	andi	r24, 0xFE	; 254
    31d8:	80 83       	st	Z, r24
          next_target.G = 0;
    31da:	10 92 88 04 	sts	0x0488, r1
          break;
    31de:	72 c0       	rjmp	.+228    	; 0x32c4 <gcode_parse_char+0x5e0>
        case 'X':
          next_target.seen_X = 1;
    31e0:	e5 e8       	ldi	r30, 0x85	; 133
    31e2:	f4 e0       	ldi	r31, 0x04	; 4
    31e4:	80 81       	ld	r24, Z
    31e6:	84 60       	ori	r24, 0x04	; 4
    31e8:	80 83       	st	Z, r24
          break;
    31ea:	6c c0       	rjmp	.+216    	; 0x32c4 <gcode_parse_char+0x5e0>
        case 'Y':
          next_target.seen_Y = 1;
    31ec:	e5 e8       	ldi	r30, 0x85	; 133
    31ee:	f4 e0       	ldi	r31, 0x04	; 4
    31f0:	80 81       	ld	r24, Z
    31f2:	88 60       	ori	r24, 0x08	; 8
    31f4:	80 83       	st	Z, r24
          break;
    31f6:	66 c0       	rjmp	.+204    	; 0x32c4 <gcode_parse_char+0x5e0>
        case 'Z':
          next_target.seen_Z = 1;
    31f8:	e5 e8       	ldi	r30, 0x85	; 133
    31fa:	f4 e0       	ldi	r31, 0x04	; 4
    31fc:	80 81       	ld	r24, Z
    31fe:	80 61       	ori	r24, 0x10	; 16
    3200:	80 83       	st	Z, r24
          break;
    3202:	60 c0       	rjmp	.+192    	; 0x32c4 <gcode_parse_char+0x5e0>
        case 'E':
          next_target.seen_E = 1;
    3204:	e5 e8       	ldi	r30, 0x85	; 133
    3206:	f4 e0       	ldi	r31, 0x04	; 4
    3208:	80 81       	ld	r24, Z
    320a:	80 62       	ori	r24, 0x20	; 32
    320c:	80 83       	st	Z, r24
          break;
    320e:	5a c0       	rjmp	.+180    	; 0x32c4 <gcode_parse_char+0x5e0>
        case 'F':
          next_target.seen_F = 1;
    3210:	e5 e8       	ldi	r30, 0x85	; 133
    3212:	f4 e0       	ldi	r31, 0x04	; 4
    3214:	80 81       	ld	r24, Z
    3216:	80 64       	ori	r24, 0x40	; 64
    3218:	80 83       	st	Z, r24
          break;
    321a:	54 c0       	rjmp	.+168    	; 0x32c4 <gcode_parse_char+0x5e0>
        case 'S':
          next_target.seen_S = 1;
    321c:	e5 e8       	ldi	r30, 0x85	; 133
    321e:	f4 e0       	ldi	r31, 0x04	; 4
    3220:	80 81       	ld	r24, Z
    3222:	80 68       	ori	r24, 0x80	; 128
    3224:	80 83       	st	Z, r24
          break;
    3226:	4e c0       	rjmp	.+156    	; 0x32c4 <gcode_parse_char+0x5e0>
        case 'P':
          next_target.seen_P = 1;
    3228:	e6 e8       	ldi	r30, 0x86	; 134
    322a:	f4 e0       	ldi	r31, 0x04	; 4
    322c:	80 81       	ld	r24, Z
    322e:	81 60       	ori	r24, 0x01	; 1
    3230:	80 83       	st	Z, r24
          break;
    3232:	48 c0       	rjmp	.+144    	; 0x32c4 <gcode_parse_char+0x5e0>
        case 'T':
          next_target.seen_T = 1;
    3234:	e6 e8       	ldi	r30, 0x86	; 134
    3236:	f4 e0       	ldi	r31, 0x04	; 4
    3238:	80 81       	ld	r24, Z
    323a:	82 60       	ori	r24, 0x02	; 2
    323c:	80 83       	st	Z, r24
          break;
    323e:	42 c0       	rjmp	.+132    	; 0x32c4 <gcode_parse_char+0x5e0>
        case 'N':
          next_target.seen_N = 1;
    3240:	e6 e8       	ldi	r30, 0x86	; 134
    3242:	f4 e0       	ldi	r31, 0x04	; 4
    3244:	80 81       	ld	r24, Z
    3246:	84 60       	ori	r24, 0x04	; 4
    3248:	80 83       	st	Z, r24
          break;
    324a:	3c c0       	rjmp	.+120    	; 0x32c4 <gcode_parse_char+0x5e0>
        case '*':
          next_target.seen_checksum = 1;
    324c:	e6 e8       	ldi	r30, 0x86	; 134
    324e:	f4 e0       	ldi	r31, 0x04	; 4
    3250:	80 81       	ld	r24, Z
    3252:	88 60       	ori	r24, 0x08	; 8
    3254:	80 83       	st	Z, r24
          break;
    3256:	36 c0       	rjmp	.+108    	; 0x32c4 <gcode_parse_char+0x5e0>

        // comments
        case ';':
          next_target.seen_semi_comment = 1;
    3258:	e6 e8       	ldi	r30, 0x86	; 134
    325a:	f4 e0       	ldi	r31, 0x04	; 4
    325c:	80 81       	ld	r24, Z
    325e:	80 61       	ori	r24, 0x10	; 16
    3260:	80 83       	st	Z, r24
          break;
    3262:	30 c0       	rjmp	.+96     	; 0x32c4 <gcode_parse_char+0x5e0>
        case '(':
          next_target.seen_parens_comment = 1;
    3264:	e6 e8       	ldi	r30, 0x86	; 134
    3266:	f4 e0       	ldi	r31, 0x04	; 4
    3268:	80 81       	ld	r24, Z
    326a:	80 62       	ori	r24, 0x20	; 32
    326c:	80 83       	st	Z, r24
          break;
    326e:	2a c0       	rjmp	.+84     	; 0x32c4 <gcode_parse_char+0x5e0>

        // now for some numeracy
        case '-':
          read_digit.sign = 1;
          // force sign to be at start of number, so 1-2 = -2 instead of -12
          read_digit.exponent = 0;
    3270:	80 e8       	ldi	r24, 0x80	; 128
    3272:	80 93 b2 04 	sts	0x04B2, r24
          read_digit.mantissa = 0;
    3276:	10 92 ae 04 	sts	0x04AE, r1
    327a:	10 92 af 04 	sts	0x04AF, r1
    327e:	10 92 b0 04 	sts	0x04B0, r1
    3282:	10 92 b1 04 	sts	0x04B1, r1
          break;
    3286:	1e c0       	rjmp	.+60     	; 0x32c4 <gcode_parse_char+0x5e0>
        case '.':
          if (read_digit.exponent == 0)
    3288:	80 91 b2 04 	lds	r24, 0x04B2
    328c:	8f 77       	andi	r24, 0x7F	; 127
    328e:	d1 f4       	brne	.+52     	; 0x32c4 <gcode_parse_char+0x5e0>
            read_digit.exponent = 1;
    3290:	e2 eb       	ldi	r30, 0xB2	; 178
    3292:	f4 e0       	ldi	r31, 0x04	; 4
    3294:	80 81       	ld	r24, Z
    3296:	80 78       	andi	r24, 0x80	; 128
    3298:	81 60       	ori	r24, 0x01	; 1
    329a:	80 83       	st	Z, r24
    329c:	13 c0       	rjmp	.+38     	; 0x32c4 <gcode_parse_char+0x5e0>
        #endif

        default:
          #ifdef	DEBUG
            // invalid
            serial_writechar('?');
    329e:	8f e3       	ldi	r24, 0x3F	; 63
    32a0:	0e 94 40 26 	call	0x4c80	; 0x4c80 <serial_writechar>
            serial_writechar(c);
    32a4:	8c 2f       	mov	r24, r28
    32a6:	0e 94 40 26 	call	0x4c80	; 0x4c80 <serial_writechar>
            serial_writechar('?');
    32aa:	8f e3       	ldi	r24, 0x3F	; 63
    32ac:	0e 94 40 26 	call	0x4c80	; 0x4c80 <serial_writechar>
          #endif
          break;
    32b0:	09 c0       	rjmp	.+18     	; 0x32c4 <gcode_parse_char+0x5e0>
      }
		}
	} else if ( next_target.seen_parens_comment == 1 && c == ')')
    32b2:	85 ff       	sbrs	r24, 5
    32b4:	07 c0       	rjmp	.+14     	; 0x32c4 <gcode_parse_char+0x5e0>
    32b6:	c9 32       	cpi	r28, 0x29	; 41
    32b8:	29 f4       	brne	.+10     	; 0x32c4 <gcode_parse_char+0x5e0>
		next_target.seen_parens_comment = 0; // recognize stuff after a (comment)
    32ba:	e6 e8       	ldi	r30, 0x86	; 134
    32bc:	f4 e0       	ldi	r31, 0x04	; 4
    32be:	80 81       	ld	r24, Z
    32c0:	8f 7d       	andi	r24, 0xDF	; 223
    32c2:	80 83       	st	Z, r24

	if (next_target.seen_checksum == 0)
    32c4:	80 91 86 04 	lds	r24, 0x0486
    32c8:	83 fd       	sbrc	r24, 3
    32ca:	05 c0       	rjmp	.+10     	; 0x32d6 <gcode_parse_char+0x5f2>
		next_target.checksum_calculated =
    32cc:	ed ea       	ldi	r30, 0xAD	; 173
    32ce:	f4 e0       	ldi	r31, 0x04	; 4
    32d0:	80 81       	ld	r24, Z
    32d2:	d8 27       	eor	r29, r24
    32d4:	d0 83       	st	Z, r29
			crc(next_target.checksum_calculated, checksum_char);

	// end of line
	if ((c == 10) || (c == 13)) {
    32d6:	ca 30       	cpi	r28, 0x0A	; 10
    32d8:	19 f0       	breq	.+6      	; 0x32e0 <gcode_parse_char+0x5fc>
    32da:	cd 30       	cpi	r28, 0x0D	; 13
    32dc:	09 f0       	breq	.+2      	; 0x32e0 <gcode_parse_char+0x5fc>
    32de:	84 c0       	rjmp	.+264    	; 0x33e8 <gcode_parse_char+0x704>
		if (DEBUG_ECHO && (debug_flags & DEBUG_ECHO))
    32e0:	80 91 cf 04 	lds	r24, 0x04CF
    32e4:	88 23       	and	r24, r24
    32e6:	1c f4       	brge	.+6      	; 0x32ee <gcode_parse_char+0x60a>
			serial_writechar(c);
    32e8:	8c 2f       	mov	r24, r28
    32ea:	0e 94 40 26 	call	0x4c80	; 0x4c80 <serial_writechar>
			) {
			if (
				#ifdef	REQUIRE_CHECKSUM
				((next_target.checksum_calculated == next_target.checksum_read) && (next_target.seen_checksum == 1))
				#else
				((next_target.checksum_calculated == next_target.checksum_read) || (next_target.seen_checksum == 0))
    32ee:	80 91 ad 04 	lds	r24, 0x04AD
			(next_target.seen_M && (next_target.M == 110))
		#else
			1
		#endif
			) {
			if (
    32f2:	90 91 ac 04 	lds	r25, 0x04AC
    32f6:	89 17       	cp	r24, r25
    32f8:	21 f0       	breq	.+8      	; 0x3302 <gcode_parse_char+0x61e>
				#ifdef	REQUIRE_CHECKSUM
				((next_target.checksum_calculated == next_target.checksum_read) && (next_target.seen_checksum == 1))
				#else
				((next_target.checksum_calculated == next_target.checksum_read) || (next_target.seen_checksum == 0))
    32fa:	90 91 86 04 	lds	r25, 0x0486
    32fe:	93 fd       	sbrc	r25, 3
    3300:	20 c0       	rjmp	.+64     	; 0x3342 <gcode_parse_char+0x65e>
				#endif
				) {
				// process
				serial_writestr_P(PSTR("ok "));
    3302:	88 e0       	ldi	r24, 0x08	; 8
    3304:	94 e0       	ldi	r25, 0x04	; 4
    3306:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <serial_writestr_P>
				process_gcode_command();
    330a:	71 d0       	rcall	.+226    	; 0x33ee <process_gcode_command>
				serial_writechar('\n');
    330c:	8a e0       	ldi	r24, 0x0A	; 10
    330e:	0e 94 40 26 	call	0x4c80	; 0x4c80 <serial_writechar>

				// expect next line number
				if (next_target.seen_N == 1)
    3312:	80 91 86 04 	lds	r24, 0x0486
    3316:	82 ff       	sbrs	r24, 2
    3318:	2e c0       	rjmp	.+92     	; 0x3376 <gcode_parse_char+0x692>
					next_target.N_expected = next_target.N + 1;
    331a:	80 91 a4 04 	lds	r24, 0x04A4
    331e:	90 91 a5 04 	lds	r25, 0x04A5
    3322:	a0 91 a6 04 	lds	r26, 0x04A6
    3326:	b0 91 a7 04 	lds	r27, 0x04A7
    332a:	01 96       	adiw	r24, 0x01	; 1
    332c:	a1 1d       	adc	r26, r1
    332e:	b1 1d       	adc	r27, r1
    3330:	80 93 a8 04 	sts	0x04A8, r24
    3334:	90 93 a9 04 	sts	0x04A9, r25
    3338:	a0 93 aa 04 	sts	0x04AA, r26
    333c:	b0 93 ab 04 	sts	0x04AB, r27
    3340:	1a c0       	rjmp	.+52     	; 0x3376 <gcode_parse_char+0x692>
			}
			else {
				sersendf_P(PSTR("rs N%ld Expected checksum %d\n"), next_target.N_expected, next_target.checksum_calculated);
    3342:	1f 92       	push	r1
    3344:	8f 93       	push	r24
    3346:	e8 ea       	ldi	r30, 0xA8	; 168
    3348:	f4 e0       	ldi	r31, 0x04	; 4
    334a:	83 81       	ldd	r24, Z+3	; 0x03
    334c:	8f 93       	push	r24
    334e:	82 81       	ldd	r24, Z+2	; 0x02
    3350:	8f 93       	push	r24
    3352:	81 81       	ldd	r24, Z+1	; 0x01
    3354:	8f 93       	push	r24
    3356:	80 81       	ld	r24, Z
    3358:	8f 93       	push	r24
    335a:	8c e0       	ldi	r24, 0x0C	; 12
    335c:	94 e0       	ldi	r25, 0x04	; 4
    335e:	9f 93       	push	r25
    3360:	8f 93       	push	r24
    3362:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
    3366:	8d b7       	in	r24, 0x3d	; 61
    3368:	9e b7       	in	r25, 0x3e	; 62
    336a:	08 96       	adiw	r24, 0x08	; 8
    336c:	0f b6       	in	r0, 0x3f	; 63
    336e:	f8 94       	cli
    3370:	9e bf       	out	0x3e, r25	; 62
    3372:	0f be       	out	0x3f, r0	; 63
    3374:	8d bf       	out	0x3d, r24	; 61
		next_target.seen_X = next_target.seen_Y = next_target.seen_Z = \
			next_target.seen_E = next_target.seen_F = next_target.seen_S = \
			next_target.seen_P = next_target.seen_T = next_target.seen_N = \
			next_target.seen_M = next_target.seen_checksum = next_target.seen_semi_comment = \
			next_target.seen_parens_comment = next_target.checksum_read = \
			next_target.checksum_calculated = 0;
    3376:	10 92 ad 04 	sts	0x04AD, r1
		// reset variables
		next_target.seen_X = next_target.seen_Y = next_target.seen_Z = \
			next_target.seen_E = next_target.seen_F = next_target.seen_S = \
			next_target.seen_P = next_target.seen_T = next_target.seen_N = \
			next_target.seen_M = next_target.seen_checksum = next_target.seen_semi_comment = \
			next_target.seen_parens_comment = next_target.checksum_read = \
    337a:	10 92 ac 04 	sts	0x04AC, r1
    337e:	a6 e8       	ldi	r26, 0x86	; 134
    3380:	b4 e0       	ldi	r27, 0x04	; 4
    3382:	8c 91       	ld	r24, X

		// reset variables
		next_target.seen_X = next_target.seen_Y = next_target.seen_Z = \
			next_target.seen_E = next_target.seen_F = next_target.seen_S = \
			next_target.seen_P = next_target.seen_T = next_target.seen_N = \
			next_target.seen_M = next_target.seen_checksum = next_target.seen_semi_comment = \
    3384:	e5 e8       	ldi	r30, 0x85	; 133
    3386:	f4 e0       	ldi	r31, 0x04	; 4
    3388:	90 81       	ld	r25, Z
		}

		// reset variables
		next_target.seen_X = next_target.seen_Y = next_target.seen_Z = \
			next_target.seen_E = next_target.seen_F = next_target.seen_S = \
			next_target.seen_P = next_target.seen_T = next_target.seen_N = \
    338a:	81 7c       	andi	r24, 0xC1	; 193
    338c:	8e 7f       	andi	r24, 0xFE	; 254
    338e:	8c 93       	st	X, r24
			next_target.seen_parens_comment = next_target.checksum_read = \
			next_target.checksum_calculated = 0;
		// last_field and read_digit are reset above already

		// assume a G1 by default
		next_target.seen_G = 1;
    3390:	91 70       	andi	r25, 0x01	; 1
    3392:	91 60       	ori	r25, 0x01	; 1
    3394:	90 83       	st	Z, r25
		next_target.G = 1;
    3396:	91 e0       	ldi	r25, 0x01	; 1
    3398:	90 93 88 04 	sts	0x0488, r25

		if (next_target.option_all_relative) {
    339c:	98 2f       	mov	r25, r24
    339e:	86 ff       	sbrs	r24, 6
    33a0:	18 c0       	rjmp	.+48     	; 0x33d2 <gcode_parse_char+0x6ee>
			next_target.target.X = next_target.target.Y = next_target.target.Z = 0;
    33a2:	10 92 92 04 	sts	0x0492, r1
    33a6:	10 92 93 04 	sts	0x0493, r1
    33aa:	10 92 94 04 	sts	0x0494, r1
    33ae:	10 92 95 04 	sts	0x0495, r1
    33b2:	10 92 8e 04 	sts	0x048E, r1
    33b6:	10 92 8f 04 	sts	0x048F, r1
    33ba:	10 92 90 04 	sts	0x0490, r1
    33be:	10 92 91 04 	sts	0x0491, r1
    33c2:	10 92 8a 04 	sts	0x048A, r1
    33c6:	10 92 8b 04 	sts	0x048B, r1
    33ca:	10 92 8c 04 	sts	0x048C, r1
    33ce:	10 92 8d 04 	sts	0x048D, r1
		}
		if (next_target.option_all_relative || next_target.option_e_relative) {
    33d2:	89 2f       	mov	r24, r25
    33d4:	80 7c       	andi	r24, 0xC0	; 192
    33d6:	41 f0       	breq	.+16     	; 0x33e8 <gcode_parse_char+0x704>
			next_target.target.E = 0;
    33d8:	10 92 96 04 	sts	0x0496, r1
    33dc:	10 92 97 04 	sts	0x0497, r1
    33e0:	10 92 98 04 	sts	0x0498, r1
    33e4:	10 92 99 04 	sts	0x0499, r1
		}
	}
}
    33e8:	df 91       	pop	r29
    33ea:	cf 91       	pop	r28
    33ec:	08 95       	ret

000033ee <process_gcode_command>:
    If you want to add support for a new G or M code, this is the place.


*//*************************************************************************/

void process_gcode_command() {
    33ee:	cf 92       	push	r12
    33f0:	df 92       	push	r13
    33f2:	ef 92       	push	r14
    33f4:	ff 92       	push	r15
    33f6:	cf 93       	push	r28
    33f8:	df 93       	push	r29
	uint32_t	backup_f;

	// convert relative to absolute
	if (next_target.option_all_relative) {
    33fa:	c0 91 86 04 	lds	r28, 0x0486
    33fe:	c6 ff       	sbrs	r28, 6
    3400:	42 c0       	rjmp	.+132    	; 0x3486 <process_gcode_command+0x98>
		next_target.target.X += startpoint.X;
    3402:	ea e8       	ldi	r30, 0x8A	; 138
    3404:	f4 e0       	ldi	r31, 0x04	; 4
    3406:	40 81       	ld	r20, Z
    3408:	51 81       	ldd	r21, Z+1	; 0x01
    340a:	62 81       	ldd	r22, Z+2	; 0x02
    340c:	73 81       	ldd	r23, Z+3	; 0x03
    340e:	80 91 90 02 	lds	r24, 0x0290
    3412:	90 91 91 02 	lds	r25, 0x0291
    3416:	a0 91 92 02 	lds	r26, 0x0292
    341a:	b0 91 93 02 	lds	r27, 0x0293
    341e:	84 0f       	add	r24, r20
    3420:	95 1f       	adc	r25, r21
    3422:	a6 1f       	adc	r26, r22
    3424:	b7 1f       	adc	r27, r23
    3426:	80 83       	st	Z, r24
    3428:	91 83       	std	Z+1, r25	; 0x01
    342a:	a2 83       	std	Z+2, r26	; 0x02
    342c:	b3 83       	std	Z+3, r27	; 0x03
		next_target.target.Y += startpoint.Y;
    342e:	ee e8       	ldi	r30, 0x8E	; 142
    3430:	f4 e0       	ldi	r31, 0x04	; 4
    3432:	40 81       	ld	r20, Z
    3434:	51 81       	ldd	r21, Z+1	; 0x01
    3436:	62 81       	ldd	r22, Z+2	; 0x02
    3438:	73 81       	ldd	r23, Z+3	; 0x03
    343a:	80 91 94 02 	lds	r24, 0x0294
    343e:	90 91 95 02 	lds	r25, 0x0295
    3442:	a0 91 96 02 	lds	r26, 0x0296
    3446:	b0 91 97 02 	lds	r27, 0x0297
    344a:	84 0f       	add	r24, r20
    344c:	95 1f       	adc	r25, r21
    344e:	a6 1f       	adc	r26, r22
    3450:	b7 1f       	adc	r27, r23
    3452:	80 83       	st	Z, r24
    3454:	91 83       	std	Z+1, r25	; 0x01
    3456:	a2 83       	std	Z+2, r26	; 0x02
    3458:	b3 83       	std	Z+3, r27	; 0x03
		next_target.target.Z += startpoint.Z;
    345a:	e2 e9       	ldi	r30, 0x92	; 146
    345c:	f4 e0       	ldi	r31, 0x04	; 4
    345e:	40 81       	ld	r20, Z
    3460:	51 81       	ldd	r21, Z+1	; 0x01
    3462:	62 81       	ldd	r22, Z+2	; 0x02
    3464:	73 81       	ldd	r23, Z+3	; 0x03
    3466:	80 91 98 02 	lds	r24, 0x0298
    346a:	90 91 99 02 	lds	r25, 0x0299
    346e:	a0 91 9a 02 	lds	r26, 0x029A
    3472:	b0 91 9b 02 	lds	r27, 0x029B
    3476:	84 0f       	add	r24, r20
    3478:	95 1f       	adc	r25, r21
    347a:	a6 1f       	adc	r26, r22
    347c:	b7 1f       	adc	r27, r23
    347e:	80 83       	st	Z, r24
    3480:	91 83       	std	Z+1, r25	; 0x01
    3482:	a2 83       	std	Z+2, r26	; 0x02
    3484:	b3 83       	std	Z+3, r27	; 0x03
	}

	// E relative movement.
	// Matches Sprinter's behaviour as of March 2012.
	if (next_target.option_all_relative || next_target.option_e_relative)
    3486:	8c 2f       	mov	r24, r28
    3488:	80 7c       	andi	r24, 0xC0	; 192
    348a:	31 f0       	breq	.+12     	; 0x3498 <process_gcode_command+0xaa>
		next_target.target.e_relative = 1;
    348c:	ee e9       	ldi	r30, 0x9E	; 158
    348e:	f4 e0       	ldi	r31, 0x04	; 4
    3490:	80 81       	ld	r24, Z
    3492:	81 60       	ori	r24, 0x01	; 1
    3494:	80 83       	st	Z, r24
    3496:	05 c0       	rjmp	.+10     	; 0x34a2 <process_gcode_command+0xb4>
	else
		next_target.target.e_relative = 0;
    3498:	ee e9       	ldi	r30, 0x9E	; 158
    349a:	f4 e0       	ldi	r31, 0x04	; 4
    349c:	80 81       	ld	r24, Z
    349e:	8e 7f       	andi	r24, 0xFE	; 254
    34a0:	80 83       	st	Z, r24

	// implement axis limits
	#ifdef	X_MIN
		if (next_target.target.X < X_MIN * 1000.)
    34a2:	60 91 8a 04 	lds	r22, 0x048A
    34a6:	70 91 8b 04 	lds	r23, 0x048B
    34aa:	80 91 8c 04 	lds	r24, 0x048C
    34ae:	90 91 8d 04 	lds	r25, 0x048D
    34b2:	0e 94 86 2b 	call	0x570c	; 0x570c <__floatsisf>
    34b6:	6b 01       	movw	r12, r22
    34b8:	7c 01       	movw	r14, r24
    34ba:	20 e0       	ldi	r18, 0x00	; 0
    34bc:	30 e0       	ldi	r19, 0x00	; 0
    34be:	a9 01       	movw	r20, r18
    34c0:	0e 94 80 2b 	call	0x5700	; 0x5700 <__cmpsf2>
    34c4:	88 23       	and	r24, r24
    34c6:	4c f4       	brge	.+18     	; 0x34da <process_gcode_command+0xec>
			next_target.target.X = X_MIN * 1000.;
    34c8:	10 92 8a 04 	sts	0x048A, r1
    34cc:	10 92 8b 04 	sts	0x048B, r1
    34d0:	10 92 8c 04 	sts	0x048C, r1
    34d4:	10 92 8d 04 	sts	0x048D, r1
    34d8:	16 c0       	rjmp	.+44     	; 0x3506 <process_gcode_command+0x118>
	#endif
	#ifdef	X_MAX
		if (next_target.target.X > X_MAX * 1000.)
    34da:	20 e0       	ldi	r18, 0x00	; 0
    34dc:	30 e5       	ldi	r19, 0x50	; 80
    34de:	43 e4       	ldi	r20, 0x43	; 67
    34e0:	58 e4       	ldi	r21, 0x48	; 72
    34e2:	c7 01       	movw	r24, r14
    34e4:	b6 01       	movw	r22, r12
    34e6:	0e 94 e5 2b 	call	0x57ca	; 0x57ca <__gesf2>
    34ea:	18 16       	cp	r1, r24
    34ec:	64 f4       	brge	.+24     	; 0x3506 <process_gcode_command+0x118>
			next_target.target.X = X_MAX * 1000.;
    34ee:	80 e4       	ldi	r24, 0x40	; 64
    34f0:	9d e0       	ldi	r25, 0x0D	; 13
    34f2:	a3 e0       	ldi	r26, 0x03	; 3
    34f4:	b0 e0       	ldi	r27, 0x00	; 0
    34f6:	80 93 8a 04 	sts	0x048A, r24
    34fa:	90 93 8b 04 	sts	0x048B, r25
    34fe:	a0 93 8c 04 	sts	0x048C, r26
    3502:	b0 93 8d 04 	sts	0x048D, r27
	#endif
	#ifdef	Y_MIN
		if (next_target.target.Y < Y_MIN * 1000.)
    3506:	60 91 8e 04 	lds	r22, 0x048E
    350a:	70 91 8f 04 	lds	r23, 0x048F
    350e:	80 91 90 04 	lds	r24, 0x0490
    3512:	90 91 91 04 	lds	r25, 0x0491
    3516:	0e 94 86 2b 	call	0x570c	; 0x570c <__floatsisf>
    351a:	6b 01       	movw	r12, r22
    351c:	7c 01       	movw	r14, r24
    351e:	20 e0       	ldi	r18, 0x00	; 0
    3520:	30 e0       	ldi	r19, 0x00	; 0
    3522:	a9 01       	movw	r20, r18
    3524:	0e 94 80 2b 	call	0x5700	; 0x5700 <__cmpsf2>
    3528:	88 23       	and	r24, r24
    352a:	4c f4       	brge	.+18     	; 0x353e <process_gcode_command+0x150>
			next_target.target.Y = Y_MIN * 1000.;
    352c:	10 92 8e 04 	sts	0x048E, r1
    3530:	10 92 8f 04 	sts	0x048F, r1
    3534:	10 92 90 04 	sts	0x0490, r1
    3538:	10 92 91 04 	sts	0x0491, r1
    353c:	16 c0       	rjmp	.+44     	; 0x356a <process_gcode_command+0x17c>
	#endif
	#ifdef	Y_MAX
		if (next_target.target.Y > Y_MAX * 1000.)
    353e:	20 e0       	ldi	r18, 0x00	; 0
    3540:	30 e5       	ldi	r19, 0x50	; 80
    3542:	43 e4       	ldi	r20, 0x43	; 67
    3544:	58 e4       	ldi	r21, 0x48	; 72
    3546:	c7 01       	movw	r24, r14
    3548:	b6 01       	movw	r22, r12
    354a:	0e 94 e5 2b 	call	0x57ca	; 0x57ca <__gesf2>
    354e:	18 16       	cp	r1, r24
    3550:	64 f4       	brge	.+24     	; 0x356a <process_gcode_command+0x17c>
			next_target.target.Y = Y_MAX * 1000.;
    3552:	80 e4       	ldi	r24, 0x40	; 64
    3554:	9d e0       	ldi	r25, 0x0D	; 13
    3556:	a3 e0       	ldi	r26, 0x03	; 3
    3558:	b0 e0       	ldi	r27, 0x00	; 0
    355a:	80 93 8e 04 	sts	0x048E, r24
    355e:	90 93 8f 04 	sts	0x048F, r25
    3562:	a0 93 90 04 	sts	0x0490, r26
    3566:	b0 93 91 04 	sts	0x0491, r27
	#endif
	#ifdef	Z_MIN
		if (next_target.target.Z < Z_MIN * 1000.)
    356a:	60 91 92 04 	lds	r22, 0x0492
    356e:	70 91 93 04 	lds	r23, 0x0493
    3572:	80 91 94 04 	lds	r24, 0x0494
    3576:	90 91 95 04 	lds	r25, 0x0495
    357a:	0e 94 86 2b 	call	0x570c	; 0x570c <__floatsisf>
    357e:	6b 01       	movw	r12, r22
    3580:	7c 01       	movw	r14, r24
    3582:	20 e0       	ldi	r18, 0x00	; 0
    3584:	30 e0       	ldi	r19, 0x00	; 0
    3586:	a9 01       	movw	r20, r18
    3588:	0e 94 80 2b 	call	0x5700	; 0x5700 <__cmpsf2>
    358c:	88 23       	and	r24, r24
    358e:	4c f4       	brge	.+18     	; 0x35a2 <process_gcode_command+0x1b4>
			next_target.target.Z = Z_MIN * 1000.;
    3590:	10 92 92 04 	sts	0x0492, r1
    3594:	10 92 93 04 	sts	0x0493, r1
    3598:	10 92 94 04 	sts	0x0494, r1
    359c:	10 92 95 04 	sts	0x0495, r1
    35a0:	16 c0       	rjmp	.+44     	; 0x35ce <process_gcode_command+0x1e0>
	#endif
	#ifdef	Z_MAX
		if (next_target.target.Z > Z_MAX * 1000.)
    35a2:	20 e0       	ldi	r18, 0x00	; 0
    35a4:	38 eb       	ldi	r19, 0xB8	; 184
    35a6:	48 e0       	ldi	r20, 0x08	; 8
    35a8:	58 e4       	ldi	r21, 0x48	; 72
    35aa:	c7 01       	movw	r24, r14
    35ac:	b6 01       	movw	r22, r12
    35ae:	0e 94 e5 2b 	call	0x57ca	; 0x57ca <__gesf2>
    35b2:	18 16       	cp	r1, r24
    35b4:	64 f4       	brge	.+24     	; 0x35ce <process_gcode_command+0x1e0>
			next_target.target.Z = Z_MAX * 1000.;
    35b6:	80 ee       	ldi	r24, 0xE0	; 224
    35b8:	92 e2       	ldi	r25, 0x22	; 34
    35ba:	a2 e0       	ldi	r26, 0x02	; 2
    35bc:	b0 e0       	ldi	r27, 0x00	; 0
    35be:	80 93 92 04 	sts	0x0492, r24
    35c2:	90 93 93 04 	sts	0x0493, r25
    35c6:	a0 93 94 04 	sts	0x0494, r26
    35ca:	b0 93 95 04 	sts	0x0495, r27
	#endif


	// The GCode documentation was taken from http://reprap.org/wiki/Gcode .

	if (next_target.seen_T) {
    35ce:	c1 ff       	sbrs	r28, 1
    35d0:	04 c0       	rjmp	.+8      	; 0x35da <process_gcode_command+0x1ec>
	    //?
	    //? Example: T1
	    //?
	    //? Select extruder number 1 to build with.  Extruder numbering starts at 0.

	    next_tool = next_target.T;
    35d2:	80 91 a3 04 	lds	r24, 0x04A3
    35d6:	80 93 d0 04 	sts	0x04D0, r24
	}

	if (next_target.seen_G) {
    35da:	80 91 85 04 	lds	r24, 0x0485
    35de:	80 ff       	sbrs	r24, 0
    35e0:	64 c1       	rjmp	.+712    	; 0x38aa <process_gcode_command+0x4bc>
		uint8_t axisSelected = 0;
		switch (next_target.G) {
    35e2:	90 91 88 04 	lds	r25, 0x0488
    35e6:	9c 31       	cpi	r25, 0x1C	; 28
    35e8:	09 f4       	brne	.+2      	; 0x35ec <process_gcode_command+0x1fe>
    35ea:	73 c0       	rjmp	.+230    	; 0x36d2 <process_gcode_command+0x2e4>
    35ec:	88 f4       	brcc	.+34     	; 0x3610 <process_gcode_command+0x222>
    35ee:	94 30       	cpi	r25, 0x04	; 4
    35f0:	09 f4       	brne	.+2      	; 0x35f4 <process_gcode_command+0x206>
    35f2:	41 c0       	rjmp	.+130    	; 0x3676 <process_gcode_command+0x288>
    35f4:	30 f4       	brcc	.+12     	; 0x3602 <process_gcode_command+0x214>
    35f6:	99 23       	and	r25, r25
    35f8:	01 f1       	breq	.+64     	; 0x363a <process_gcode_command+0x24c>
    35fa:	91 30       	cpi	r25, 0x01	; 1
    35fc:	09 f0       	breq	.+2      	; 0x3600 <process_gcode_command+0x212>
    35fe:	48 c1       	rjmp	.+656    	; 0x3890 <process_gcode_command+0x4a2>
    3600:	34 c0       	rjmp	.+104    	; 0x366a <process_gcode_command+0x27c>
    3602:	94 31       	cpi	r25, 0x14	; 20
    3604:	09 f4       	brne	.+2      	; 0x3608 <process_gcode_command+0x21a>
    3606:	54 c0       	rjmp	.+168    	; 0x36b0 <process_gcode_command+0x2c2>
    3608:	95 31       	cpi	r25, 0x15	; 21
    360a:	09 f0       	breq	.+2      	; 0x360e <process_gcode_command+0x220>
    360c:	41 c1       	rjmp	.+642    	; 0x3890 <process_gcode_command+0x4a2>
    360e:	56 c0       	rjmp	.+172    	; 0x36bc <process_gcode_command+0x2ce>
    3610:	9b 35       	cpi	r25, 0x5B	; 91
    3612:	09 f4       	brne	.+2      	; 0x3616 <process_gcode_command+0x228>
    3614:	84 c0       	rjmp	.+264    	; 0x371e <process_gcode_command+0x330>
    3616:	38 f4       	brcc	.+14     	; 0x3626 <process_gcode_command+0x238>
    3618:	9e 31       	cpi	r25, 0x1E	; 30
    361a:	09 f4       	brne	.+2      	; 0x361e <process_gcode_command+0x230>
    361c:	55 c0       	rjmp	.+170    	; 0x36c8 <process_gcode_command+0x2da>
    361e:	9a 35       	cpi	r25, 0x5A	; 90
    3620:	09 f0       	breq	.+2      	; 0x3624 <process_gcode_command+0x236>
    3622:	36 c1       	rjmp	.+620    	; 0x3890 <process_gcode_command+0x4a2>
    3624:	76 c0       	rjmp	.+236    	; 0x3712 <process_gcode_command+0x324>
    3626:	91 3a       	cpi	r25, 0xA1	; 161
    3628:	09 f4       	brne	.+2      	; 0x362c <process_gcode_command+0x23e>
    362a:	17 c1       	rjmp	.+558    	; 0x385a <process_gcode_command+0x46c>
    362c:	92 3a       	cpi	r25, 0xA2	; 162
    362e:	09 f4       	brne	.+2      	; 0x3632 <process_gcode_command+0x244>
    3630:	21 c1       	rjmp	.+578    	; 0x3874 <process_gcode_command+0x486>
    3632:	9c 35       	cpi	r25, 0x5C	; 92
    3634:	09 f0       	breq	.+2      	; 0x3638 <process_gcode_command+0x24a>
    3636:	2c c1       	rjmp	.+600    	; 0x3890 <process_gcode_command+0x4a2>
    3638:	78 c0       	rjmp	.+240    	; 0x372a <process_gcode_command+0x33c>
				//?
				//? Example: G0 X12
				//?
				//? In this case move rapidly to X = 12 mm.  In fact, the RepRap firmware uses exactly the same code for rapid as it uses for controlled moves (see G1 below), as - for the RepRap machine - this is just as efficient as not doing so.  (The distinction comes from some old machine tools that used to move faster if the axes were not driven in a straight line.  For them G0 allowed any movement in space to get to the destination as fast as possible.)
				//?
				backup_f = next_target.target.F;
    363a:	ca e9       	ldi	r28, 0x9A	; 154
    363c:	d4 e0       	ldi	r29, 0x04	; 4
    363e:	c8 80       	ld	r12, Y
    3640:	d9 80       	ldd	r13, Y+1	; 0x01
    3642:	ea 80       	ldd	r14, Y+2	; 0x02
    3644:	fb 80       	ldd	r15, Y+3	; 0x03
				next_target.target.F = MAXIMUM_FEEDRATE_X * 2L;
    3646:	80 e9       	ldi	r24, 0x90	; 144
    3648:	91 e0       	ldi	r25, 0x01	; 1
    364a:	a0 e0       	ldi	r26, 0x00	; 0
    364c:	b0 e0       	ldi	r27, 0x00	; 0
    364e:	88 83       	st	Y, r24
    3650:	99 83       	std	Y+1, r25	; 0x01
    3652:	aa 83       	std	Y+2, r26	; 0x02
    3654:	bb 83       	std	Y+3, r27	; 0x03
// t == NULL means add a wait for target temp to the queue
void enqueue_home(TARGET *t, uint8_t endstop_check, uint8_t endstop_stop_cond);

static void enqueue(TARGET *) __attribute__ ((always_inline));
inline void enqueue(TARGET *t) {
  enqueue_home(t, 0, 0);
    3656:	40 e0       	ldi	r20, 0x00	; 0
    3658:	60 e0       	ldi	r22, 0x00	; 0
    365a:	8a e8       	ldi	r24, 0x8A	; 138
    365c:	94 e0       	ldi	r25, 0x04	; 4
    365e:	7e d9       	rcall	.-3332   	; 0x295c <enqueue_home>
				enqueue(&next_target.target);
				next_target.target.F = backup_f;
    3660:	c8 82       	st	Y, r12
    3662:	d9 82       	std	Y+1, r13	; 0x01
    3664:	ea 82       	std	Y+2, r14	; 0x02
    3666:	fb 82       	std	Y+3, r15	; 0x03
				break;
    3668:	3a c3       	rjmp	.+1652   	; 0x3cde <process_gcode_command+0x8f0>
    366a:	40 e0       	ldi	r20, 0x00	; 0
    366c:	60 e0       	ldi	r22, 0x00	; 0
    366e:	8a e8       	ldi	r24, 0x8A	; 138
    3670:	94 e0       	ldi	r25, 0x04	; 4
    3672:	74 d9       	rcall	.-3352   	; 0x295c <enqueue_home>
    3674:	34 c3       	rjmp	.+1640   	; 0x3cde <process_gcode_command+0x8f0>
				//?
				//? Example: G4 P200
				//?
				//? In this case sit still doing nothing for 200 milliseconds.  During delays the state of the machine (for example the temperatures of its extruders) will still be preserved and controlled.
				//?
				queue_wait();
    3676:	2a da       	rcall	.-2988   	; 0x2acc <queue_wait>
				// delay
				if (next_target.seen_P) {
    3678:	80 91 86 04 	lds	r24, 0x0486
    367c:	80 ff       	sbrs	r24, 0
    367e:	2f c3       	rjmp	.+1630   	; 0x3cde <process_gcode_command+0x8f0>
					for (;next_target.P > 0;next_target.P--) {
    3680:	80 91 a1 04 	lds	r24, 0x04A1
    3684:	90 91 a2 04 	lds	r25, 0x04A2
    3688:	89 2b       	or	r24, r25
    368a:	09 f4       	brne	.+2      	; 0x368e <process_gcode_command+0x2a0>
    368c:	28 c3       	rjmp	.+1616   	; 0x3cde <process_gcode_command+0x8f0>
    368e:	c1 ea       	ldi	r28, 0xA1	; 161
    3690:	d4 e0       	ldi	r29, 0x04	; 4
						clock();
    3692:	0e 94 62 05 	call	0xac4	; 0xac4 <clock>
						delay_ms(1);
    3696:	61 e0       	ldi	r22, 0x01	; 1
    3698:	70 e0       	ldi	r23, 0x00	; 0
    369a:	80 e0       	ldi	r24, 0x00	; 0
    369c:	90 e0       	ldi	r25, 0x00	; 0
    369e:	47 da       	rcall	.-2930   	; 0x2b2e <delay_ms>
				//? In this case sit still doing nothing for 200 milliseconds.  During delays the state of the machine (for example the temperatures of its extruders) will still be preserved and controlled.
				//?
				queue_wait();
				// delay
				if (next_target.seen_P) {
					for (;next_target.P > 0;next_target.P--) {
    36a0:	88 81       	ld	r24, Y
    36a2:	99 81       	ldd	r25, Y+1	; 0x01
    36a4:	01 97       	sbiw	r24, 0x01	; 1
    36a6:	99 83       	std	Y+1, r25	; 0x01
    36a8:	88 83       	st	Y, r24
    36aa:	89 2b       	or	r24, r25
    36ac:	91 f7       	brne	.-28     	; 0x3692 <process_gcode_command+0x2a4>
    36ae:	17 c3       	rjmp	.+1582   	; 0x3cde <process_gcode_command+0x8f0>
				//?
				//? Example: G20
				//?
				//? Units from now on are in inches.
				//?
				next_target.option_inches = 1;
    36b0:	e7 e8       	ldi	r30, 0x87	; 135
    36b2:	f4 e0       	ldi	r31, 0x04	; 4
    36b4:	80 81       	ld	r24, Z
    36b6:	81 60       	ori	r24, 0x01	; 1
    36b8:	80 83       	st	Z, r24
				break;
    36ba:	11 c3       	rjmp	.+1570   	; 0x3cde <process_gcode_command+0x8f0>
				//?
				//? Example: G21
				//?
				//? Units from now on are in millimeters.  (This is the RepRap default.)
				//?
				next_target.option_inches = 0;
    36bc:	e7 e8       	ldi	r30, 0x87	; 135
    36be:	f4 e0       	ldi	r31, 0x04	; 4
    36c0:	80 81       	ld	r24, Z
    36c2:	8e 7f       	andi	r24, 0xFE	; 254
    36c4:	80 83       	st	Z, r24
				break;
    36c6:	0b c3       	rjmp	.+1558   	; 0x3cde <process_gcode_command+0x8f0>
    36c8:	40 e0       	ldi	r20, 0x00	; 0
    36ca:	60 e0       	ldi	r22, 0x00	; 0
    36cc:	8a e8       	ldi	r24, 0x8A	; 138
    36ce:	94 e0       	ldi	r25, 0x04	; 4
    36d0:	45 d9       	rcall	.-3446   	; 0x295c <enqueue_home>
				//? G28 X0 Y72.3
				//?
				//? will zero the X and Y axes, but not Z.  The actual coordinate values are ignored.
				//?

				queue_wait();
    36d2:	fc d9       	rcall	.-3080   	; 0x2acc <queue_wait>

				if (next_target.seen_X) {
    36d4:	80 91 85 04 	lds	r24, 0x0485
    36d8:	82 ff       	sbrs	r24, 2
    36da:	03 c0       	rjmp	.+6      	; 0x36e2 <process_gcode_command+0x2f4>
					#if defined	X_MIN_PIN
						home_x_negative();
    36dc:	b0 d7       	rcall	.+3936   	; 0x463e <home_x_negative>
					#elif defined X_MAX_PIN
						home_x_positive();
					#endif
					axisSelected = 1;
    36de:	81 e0       	ldi	r24, 0x01	; 1
    36e0:	01 c0       	rjmp	.+2      	; 0x36e4 <process_gcode_command+0x2f6>

	    next_tool = next_target.T;
	}

	if (next_target.seen_G) {
		uint8_t axisSelected = 0;
    36e2:	80 e0       	ldi	r24, 0x00	; 0
					#elif defined X_MAX_PIN
						home_x_positive();
					#endif
					axisSelected = 1;
				}
				if (next_target.seen_Y) {
    36e4:	90 91 85 04 	lds	r25, 0x0485
    36e8:	93 ff       	sbrs	r25, 3
    36ea:	07 c0       	rjmp	.+14     	; 0x36fa <process_gcode_command+0x30c>
					#if defined	Y_MIN_PIN
						home_y_negative();
    36ec:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <home_y_negative>
					#elif defined Y_MAX_PIN
						home_y_positive();
					#endif
					axisSelected = 1;
				}
				if (next_target.seen_Z) {
    36f0:	80 91 85 04 	lds	r24, 0x0485
    36f4:	84 ff       	sbrs	r24, 4
    36f6:	f3 c2       	rjmp	.+1510   	; 0x3cde <process_gcode_command+0x8f0>
    36f8:	04 c0       	rjmp	.+8      	; 0x3702 <process_gcode_command+0x314>
    36fa:	90 91 85 04 	lds	r25, 0x0485
    36fe:	94 ff       	sbrs	r25, 4
    3700:	03 c0       	rjmp	.+6      	; 0x3708 <process_gcode_command+0x31a>
					#if defined Z_MAX_PIN
						home_z_positive();
					#elif defined	Z_MIN_PIN
						home_z_negative();
    3702:	0e 94 c9 24 	call	0x4992	; 0x4992 <home_z_negative>
    3706:	eb c2       	rjmp	.+1494   	; 0x3cde <process_gcode_command+0x8f0>
					#endif
					axisSelected = 1;
				}
				// there's no point in moving E, as E has no endstops

				if (!axisSelected) {
    3708:	81 11       	cpse	r24, r1
    370a:	e9 c2       	rjmp	.+1490   	; 0x3cde <process_gcode_command+0x8f0>
					home();
    370c:	0e 94 25 25 	call	0x4a4a	; 0x4a4a <home>
    3710:	e6 c2       	rjmp	.+1484   	; 0x3cde <process_gcode_command+0x8f0>
				//? coordinate system while E doesn't change it's position in the
				//? coordinate system on relative movements.
				//?

				// No wait_queue() needed.
				next_target.option_all_relative = 0;
    3712:	e6 e8       	ldi	r30, 0x86	; 134
    3714:	f4 e0       	ldi	r31, 0x04	; 4
    3716:	80 81       	ld	r24, Z
    3718:	8f 7b       	andi	r24, 0xBF	; 191
    371a:	80 83       	st	Z, r24
				break;
    371c:	e0 c2       	rjmp	.+1472   	; 0x3cde <process_gcode_command+0x8f0>
				//?
				//? All coordinates from now on are relative to the last position.
				//?

				// No wait_queue() needed.
				next_target.option_all_relative = 1;
    371e:	e6 e8       	ldi	r30, 0x86	; 134
    3720:	f4 e0       	ldi	r31, 0x04	; 4
    3722:	80 81       	ld	r24, Z
    3724:	80 64       	ori	r24, 0x40	; 64
    3726:	80 83       	st	Z, r24
				break;
    3728:	da c2       	rjmp	.+1460   	; 0x3cde <process_gcode_command+0x8f0>
				//? Example: G92 X10 E90
				//?
				//? Allows programming of absolute zero point, by reseting the current position to the values specified.  This would set the machine's X coordinate to 10, and the extrude coordinate to 90. No physical motion will occur.
				//?

				queue_wait();
    372a:	d0 d9       	rcall	.-3168   	; 0x2acc <queue_wait>

				if (next_target.seen_X) {
    372c:	20 91 85 04 	lds	r18, 0x0485
    3730:	22 ff       	sbrs	r18, 2
    3732:	12 c0       	rjmp	.+36     	; 0x3758 <process_gcode_command+0x36a>
					startpoint.X = next_target.target.X;
    3734:	80 91 8a 04 	lds	r24, 0x048A
    3738:	90 91 8b 04 	lds	r25, 0x048B
    373c:	a0 91 8c 04 	lds	r26, 0x048C
    3740:	b0 91 8d 04 	lds	r27, 0x048D
    3744:	80 93 90 02 	sts	0x0290, r24
    3748:	90 93 91 02 	sts	0x0291, r25
    374c:	a0 93 92 02 	sts	0x0292, r26
    3750:	b0 93 93 02 	sts	0x0293, r27
					axisSelected = 1;
    3754:	81 e0       	ldi	r24, 0x01	; 1
    3756:	01 c0       	rjmp	.+2      	; 0x375a <process_gcode_command+0x36c>

	    next_tool = next_target.T;
	}

	if (next_target.seen_G) {
		uint8_t axisSelected = 0;
    3758:	80 e0       	ldi	r24, 0x00	; 0

				if (next_target.seen_X) {
					startpoint.X = next_target.target.X;
					axisSelected = 1;
				}
				if (next_target.seen_Y) {
    375a:	23 ff       	sbrs	r18, 3
    375c:	11 c0       	rjmp	.+34     	; 0x3780 <process_gcode_command+0x392>
					startpoint.Y = next_target.target.Y;
    375e:	80 91 8e 04 	lds	r24, 0x048E
    3762:	90 91 8f 04 	lds	r25, 0x048F
    3766:	a0 91 90 04 	lds	r26, 0x0490
    376a:	b0 91 91 04 	lds	r27, 0x0491
    376e:	80 93 94 02 	sts	0x0294, r24
    3772:	90 93 95 02 	sts	0x0295, r25
    3776:	a0 93 96 02 	sts	0x0296, r26
    377a:	b0 93 97 02 	sts	0x0297, r27
					axisSelected = 1;
    377e:	81 e0       	ldi	r24, 0x01	; 1
				}
				if (next_target.seen_Z) {
    3780:	24 ff       	sbrs	r18, 4
    3782:	13 c0       	rjmp	.+38     	; 0x37aa <process_gcode_command+0x3bc>
					startpoint.Z = next_target.target.Z;
    3784:	80 91 92 04 	lds	r24, 0x0492
    3788:	90 91 93 04 	lds	r25, 0x0493
    378c:	a0 91 94 04 	lds	r26, 0x0494
    3790:	b0 91 95 04 	lds	r27, 0x0495
    3794:	80 93 98 02 	sts	0x0298, r24
    3798:	90 93 99 02 	sts	0x0299, r25
    379c:	a0 93 9a 02 	sts	0x029A, r26
    37a0:	b0 93 9b 02 	sts	0x029B, r27
					axisSelected = 1;
				}
				if (next_target.seen_E) {
    37a4:	25 fd       	sbrc	r18, 5
    37a6:	03 c0       	rjmp	.+6      	; 0x37ae <process_gcode_command+0x3c0>
    37a8:	55 c0       	rjmp	.+170    	; 0x3854 <process_gcode_command+0x466>
    37aa:	25 ff       	sbrs	r18, 5
    37ac:	11 c0       	rjmp	.+34     	; 0x37d0 <process_gcode_command+0x3e2>
					startpoint.E = next_target.target.E;
    37ae:	80 91 96 04 	lds	r24, 0x0496
    37b2:	90 91 97 04 	lds	r25, 0x0497
    37b6:	a0 91 98 04 	lds	r26, 0x0498
    37ba:	b0 91 99 04 	lds	r27, 0x0499
    37be:	80 93 9c 02 	sts	0x029C, r24
    37c2:	90 93 9d 02 	sts	0x029D, r25
    37c6:	a0 93 9e 02 	sts	0x029E, r26
    37ca:	b0 93 9f 02 	sts	0x029F, r27
    37ce:	42 c0       	rjmp	.+132    	; 0x3854 <process_gcode_command+0x466>
					axisSelected = 1;
				}

				if (axisSelected == 0) {
    37d0:	81 11       	cpse	r24, r1
    37d2:	40 c0       	rjmp	.+128    	; 0x3854 <process_gcode_command+0x466>
					startpoint.X = next_target.target.X =
					startpoint.Y = next_target.target.Y =
					startpoint.Z = next_target.target.Z =
					startpoint.E = next_target.target.E = 0;
    37d4:	10 92 96 04 	sts	0x0496, r1
    37d8:	10 92 97 04 	sts	0x0497, r1
    37dc:	10 92 98 04 	sts	0x0498, r1
    37e0:	10 92 99 04 	sts	0x0499, r1
    37e4:	10 92 9c 02 	sts	0x029C, r1
    37e8:	10 92 9d 02 	sts	0x029D, r1
    37ec:	10 92 9e 02 	sts	0x029E, r1
    37f0:	10 92 9f 02 	sts	0x029F, r1
				}

				if (axisSelected == 0) {
					startpoint.X = next_target.target.X =
					startpoint.Y = next_target.target.Y =
					startpoint.Z = next_target.target.Z =
    37f4:	10 92 92 04 	sts	0x0492, r1
    37f8:	10 92 93 04 	sts	0x0493, r1
    37fc:	10 92 94 04 	sts	0x0494, r1
    3800:	10 92 95 04 	sts	0x0495, r1
    3804:	10 92 98 02 	sts	0x0298, r1
    3808:	10 92 99 02 	sts	0x0299, r1
    380c:	10 92 9a 02 	sts	0x029A, r1
    3810:	10 92 9b 02 	sts	0x029B, r1
					axisSelected = 1;
				}

				if (axisSelected == 0) {
					startpoint.X = next_target.target.X =
					startpoint.Y = next_target.target.Y =
    3814:	10 92 8e 04 	sts	0x048E, r1
    3818:	10 92 8f 04 	sts	0x048F, r1
    381c:	10 92 90 04 	sts	0x0490, r1
    3820:	10 92 91 04 	sts	0x0491, r1
    3824:	10 92 94 02 	sts	0x0294, r1
    3828:	10 92 95 02 	sts	0x0295, r1
    382c:	10 92 96 02 	sts	0x0296, r1
    3830:	10 92 97 02 	sts	0x0297, r1
					startpoint.E = next_target.target.E;
					axisSelected = 1;
				}

				if (axisSelected == 0) {
					startpoint.X = next_target.target.X =
    3834:	10 92 8a 04 	sts	0x048A, r1
    3838:	10 92 8b 04 	sts	0x048B, r1
    383c:	10 92 8c 04 	sts	0x048C, r1
    3840:	10 92 8d 04 	sts	0x048D, r1
    3844:	10 92 90 02 	sts	0x0290, r1
    3848:	10 92 91 02 	sts	0x0291, r1
    384c:	10 92 92 02 	sts	0x0292, r1
    3850:	10 92 93 02 	sts	0x0293, r1
					startpoint.Y = next_target.target.Y =
					startpoint.Z = next_target.target.Z =
					startpoint.E = next_target.target.E = 0;
				}

				dda_new_startpoint();
    3854:	0e 94 2c 07 	call	0xe58	; 0xe58 <dda_new_startpoint>
				break;
    3858:	42 c2       	rjmp	.+1156   	; 0x3cde <process_gcode_command+0x8f0>
			case 161:
				//? --- G161: Home negative ---
				//?
				//? Find the minimum limit of the specified axes by searching for the limit switch.
				//?
				if (next_target.seen_X)
    385a:	82 fd       	sbrc	r24, 2
					home_x_negative();
    385c:	f0 d6       	rcall	.+3552   	; 0x463e <home_x_negative>
				if (next_target.seen_Y)
    385e:	80 91 85 04 	lds	r24, 0x0485
    3862:	83 fd       	sbrc	r24, 3
					home_y_negative();
    3864:	c1 d7       	rcall	.+3970   	; 0x47e8 <home_y_negative>
				if (next_target.seen_Z)
    3866:	80 91 85 04 	lds	r24, 0x0485
    386a:	84 ff       	sbrs	r24, 4
    386c:	38 c2       	rjmp	.+1136   	; 0x3cde <process_gcode_command+0x8f0>
					home_z_negative();
    386e:	0e 94 c9 24 	call	0x4992	; 0x4992 <home_z_negative>
    3872:	35 c2       	rjmp	.+1130   	; 0x3cde <process_gcode_command+0x8f0>
			case 162:
				//? --- G162: Home positive ---
				//?
				//? Find the maximum limit of the specified axes by searching for the limit switch.
				//?
				if (next_target.seen_X)
    3874:	82 fd       	sbrc	r24, 2
					home_x_positive();
    3876:	3f d7       	rcall	.+3710   	; 0x46f6 <home_x_positive>
				if (next_target.seen_Y)
    3878:	80 91 85 04 	lds	r24, 0x0485
    387c:	83 fd       	sbrc	r24, 3
					home_y_positive();
    387e:	0e 94 50 24 	call	0x48a0	; 0x48a0 <home_y_positive>
				if (next_target.seen_Z)
    3882:	80 91 85 04 	lds	r24, 0x0485
    3886:	84 ff       	sbrs	r24, 4
    3888:	2a c2       	rjmp	.+1108   	; 0x3cde <process_gcode_command+0x8f0>
					home_z_positive();
    388a:	0e 94 28 25 	call	0x4a50	; 0x4a50 <home_z_positive>
    388e:	27 c2       	rjmp	.+1102   	; 0x3cde <process_gcode_command+0x8f0>
				break;

				// unknown gcode: spit an error
			default:
				sersendf_P(PSTR("E: Bad G-code %d"), next_target.G);
    3890:	1f 92       	push	r1
    3892:	9f 93       	push	r25
    3894:	8a e2       	ldi	r24, 0x2A	; 42
    3896:	94 e0       	ldi	r25, 0x04	; 4
    3898:	9f 93       	push	r25
    389a:	8f 93       	push	r24
    389c:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
				// newline is sent from gcode_parse after we return
				return;
    38a0:	0f 90       	pop	r0
    38a2:	0f 90       	pop	r0
    38a4:	0f 90       	pop	r0
    38a6:	0f 90       	pop	r0
    38a8:	1a c2       	rjmp	.+1076   	; 0x3cde <process_gcode_command+0x8f0>
		}
	}
	else if (next_target.seen_M) {
    38aa:	81 ff       	sbrs	r24, 1
    38ac:	18 c2       	rjmp	.+1072   	; 0x3cde <process_gcode_command+0x8f0>
		uint8_t i;

		switch (next_target.M) {
    38ae:	90 91 89 04 	lds	r25, 0x0489
    38b2:	e9 2f       	mov	r30, r25
    38b4:	f0 e0       	ldi	r31, 0x00	; 0
    38b6:	e2 3f       	cpi	r30, 0xF2	; 242
    38b8:	f1 05       	cpc	r31, r1
    38ba:	08 f0       	brcs	.+2      	; 0x38be <process_gcode_command+0x4d0>
    38bc:	04 c2       	rjmp	.+1032   	; 0x3cc6 <process_gcode_command+0x8d8>
    38be:	ec 53       	subi	r30, 0x3C	; 60
    38c0:	ff 4f       	sbci	r31, 0xFF	; 255
    38c2:	0c 94 35 2c 	jmp	0x586a	; 0x586a <__tablejump2__>
				//?
				//? Example: M2
				//?
				//? http://linuxcnc.org/handbook/RS274NGC_3/RS274NGC_33a.html#1002379
				//?
				queue_wait();
    38c6:	02 d9       	rcall	.-3580   	; 0x2acc <queue_wait>
				for (i = 0; i < NUM_HEATERS; i++)
					temp_set(i, 0);
    38c8:	60 e0       	ldi	r22, 0x00	; 0
    38ca:	70 e0       	ldi	r23, 0x00	; 0
    38cc:	80 e0       	ldi	r24, 0x00	; 0
    38ce:	0e 94 1b 2a 	call	0x5436	; 0x5436 <temp_set>
    38d2:	60 e0       	ldi	r22, 0x00	; 0
    38d4:	70 e0       	ldi	r23, 0x00	; 0
    38d6:	81 e0       	ldi	r24, 0x01	; 1
    38d8:	0e 94 1b 2a 	call	0x5436	; 0x5436 <temp_set>
				power_off();
    38dc:	0e 94 94 25 	call	0x4b28	; 0x4b28 <power_off>
				break;
    38e0:	fe c1       	rjmp	.+1020   	; 0x3cde <process_gcode_command+0x8f0>
				//?
				//? Any moves in progress are immediately terminated, then RepRap shuts down.  All motors and heaters are turned off.
				//? It can be started again by pressing the reset button on the master microcontroller.  See also M0.
				//?

				timer_stop();
    38e2:	0e 94 7d 2b 	call	0x56fa	; 0x56fa <timer_stop>
				queue_flush();
    38e6:	e4 d8       	rcall	.-3640   	; 0x2ab0 <queue_flush>
				power_off();
    38e8:	0e 94 94 25 	call	0x4b28	; 0x4b28 <power_off>
				cli();
    38ec:	f8 94       	cli
    38ee:	ff cf       	rjmp	.-2      	; 0x38ee <process_gcode_command+0x500>

			case 6:
				//? --- M6: tool change ---
				//?
				//? Undocumented.
				tool = next_tool;
    38f0:	80 91 d0 04 	lds	r24, 0x04D0
    38f4:	80 93 d1 04 	sts	0x04D1, r24
				break;
    38f8:	f2 c1       	rjmp	.+996    	; 0x3cde <process_gcode_command+0x8f0>
				//? While E does relative movements, it doesn't change its
				//? position in the coordinate system. See also comment on G90.
				//?

				// No wait_queue() needed.
				next_target.option_e_relative = 0;
    38fa:	e6 e8       	ldi	r30, 0x86	; 134
    38fc:	f4 e0       	ldi	r31, 0x04	; 4
    38fe:	80 81       	ld	r24, Z
    3900:	8f 77       	andi	r24, 0x7F	; 127
    3902:	80 83       	st	Z, r24
				break;
    3904:	ec c1       	rjmp	.+984    	; 0x3cde <process_gcode_command+0x8f0>
				//?
				//? Counterpart to M82.
				//?

				// No wait_queue() needed.
				next_target.option_e_relative = 1;
    3906:	e6 e8       	ldi	r30, 0x86	; 134
    3908:	f4 e0       	ldi	r31, 0x04	; 4
    390a:	80 81       	ld	r24, Z
    390c:	80 68       	ori	r24, 0x80	; 128
    390e:	80 83       	st	Z, r24
				break;
    3910:	e6 c1       	rjmp	.+972    	; 0x3cde <process_gcode_command+0x8f0>
			case 3:
			case 101:
				//? --- M101: extruder on ---
				//?
				//? Undocumented.
				if (temp_achieved() == 0) {
    3912:	0e 94 10 2a 	call	0x5420	; 0x5420 <temp_achieved>
    3916:	81 11       	cpse	r24, r1
    3918:	e2 c1       	rjmp	.+964    	; 0x3cde <process_gcode_command+0x8f0>
    391a:	40 e0       	ldi	r20, 0x00	; 0
    391c:	60 e0       	ldi	r22, 0x00	; 0
    391e:	80 e0       	ldi	r24, 0x00	; 0
    3920:	90 e0       	ldi	r25, 0x00	; 0
    3922:	1c d8       	rcall	.-4040   	; 0x295c <enqueue_home>
    3924:	dc c1       	rjmp	.+952    	; 0x3cde <process_gcode_command+0x8f0>
        //? Teacup supports an optional P parameter as a zero-based temperature
        //? sensor index to address (e.g. M104 P1 S100 will set the temperature
        //? of the heater connected to the second temperature sensor rather
        //? than the extruder temperature).
        //?
				if ( ! next_target.seen_S)
    3926:	88 23       	and	r24, r24
    3928:	0c f0       	brlt	.+2      	; 0x392c <process_gcode_command+0x53e>
    392a:	d9 c1       	rjmp	.+946    	; 0x3cde <process_gcode_command+0x8f0>
					break;
        #ifdef HEATER_EXTRUDER
          if ( ! next_target.seen_P)
    392c:	c0 fd       	sbrc	r28, 0
    392e:	04 c0       	rjmp	.+8      	; 0x3938 <process_gcode_command+0x54a>
            next_target.P = HEATER_EXTRUDER;
    3930:	10 92 a2 04 	sts	0x04A2, r1
    3934:	10 92 a1 04 	sts	0x04A1, r1
        // else use the first available device
        #endif
				temp_set(next_target.P, next_target.S);
    3938:	60 91 9f 04 	lds	r22, 0x049F
    393c:	70 91 a0 04 	lds	r23, 0x04A0
    3940:	80 91 a1 04 	lds	r24, 0x04A1
    3944:	0e 94 1b 2a 	call	0x5436	; 0x5436 <temp_set>
				break;
    3948:	ca c1       	rjmp	.+916    	; 0x3cde <process_gcode_command+0x8f0>
        //? sensor index to address.
				//?
				#ifdef ENFORCE_ORDER
					queue_wait();
				#endif
				if ( ! next_target.seen_P)
    394a:	c0 fd       	sbrc	r28, 0
    394c:	06 c0       	rjmp	.+12     	; 0x395a <process_gcode_command+0x56c>
					next_target.P = TEMP_SENSOR_none;
    394e:	82 e0       	ldi	r24, 0x02	; 2
    3950:	90 e0       	ldi	r25, 0x00	; 0
    3952:	90 93 a2 04 	sts	0x04A2, r25
    3956:	80 93 a1 04 	sts	0x04A1, r24
				temp_print(next_target.P);
    395a:	80 91 a1 04 	lds	r24, 0x04A1
    395e:	0e 94 2d 2a 	call	0x545a	; 0x545a <temp_print>
				break;
    3962:	bd c1       	rjmp	.+890    	; 0x3cde <process_gcode_command+0x8f0>
        #ifdef HEATER_FAN
          if ( ! next_target.seen_P)
            next_target.P = HEATER_FAN;
        // else use the first available device
        #endif
				if ( ! next_target.seen_S)
    3964:	88 23       	and	r24, r24
    3966:	0c f0       	brlt	.+2      	; 0x396a <process_gcode_command+0x57c>
    3968:	ba c1       	rjmp	.+884    	; 0x3cde <process_gcode_command+0x8f0>
					break;
        heater_set(next_target.P, next_target.S);
    396a:	60 91 9f 04 	lds	r22, 0x049F
    396e:	80 91 a1 04 	lds	r24, 0x04A1
    3972:	13 d3       	rcall	.+1574   	; 0x3f9a <heater_set>
				break;
    3974:	b4 c1       	rjmp	.+872    	; 0x3cde <process_gcode_command+0x8f0>
				//? #define         DEBUG_POSITION  4
				//? </pre>
				//?
				//? This command is only available in DEBUG builds of Teacup.

				if ( ! next_target.seen_S)
    3976:	88 23       	and	r24, r24
    3978:	0c f0       	brlt	.+2      	; 0x397c <process_gcode_command+0x58e>
    397a:	b1 c1       	rjmp	.+866    	; 0x3cde <process_gcode_command+0x8f0>
					break;
				debug_flags = next_target.S;
    397c:	80 91 9f 04 	lds	r24, 0x049F
    3980:	80 93 cf 04 	sts	0x04CF, r24
				break;
    3984:	ac c1       	rjmp	.+856    	; 0x3cde <process_gcode_command+0x8f0>
				//?
				#ifdef ENFORCE_ORDER
					// wait for all moves to complete
					queue_wait();
				#endif
				update_current_position();
    3986:	0e 94 3d 10 	call	0x207a	; 0x207a <update_current_position>
				sersendf_P(PSTR("X:%lq,Y:%lq,Z:%lq,E:%lq,F:%lu"),
    398a:	e6 e7       	ldi	r30, 0x76	; 118
    398c:	f2 e0       	ldi	r31, 0x02	; 2
    398e:	83 81       	ldd	r24, Z+3	; 0x03
    3990:	8f 93       	push	r24
    3992:	82 81       	ldd	r24, Z+2	; 0x02
    3994:	8f 93       	push	r24
    3996:	81 81       	ldd	r24, Z+1	; 0x01
    3998:	8f 93       	push	r24
    399a:	80 81       	ld	r24, Z
    399c:	8f 93       	push	r24
    399e:	e2 e7       	ldi	r30, 0x72	; 114
    39a0:	f2 e0       	ldi	r31, 0x02	; 2
    39a2:	83 81       	ldd	r24, Z+3	; 0x03
    39a4:	8f 93       	push	r24
    39a6:	82 81       	ldd	r24, Z+2	; 0x02
    39a8:	8f 93       	push	r24
    39aa:	81 81       	ldd	r24, Z+1	; 0x01
    39ac:	8f 93       	push	r24
    39ae:	80 81       	ld	r24, Z
    39b0:	8f 93       	push	r24
    39b2:	ee e6       	ldi	r30, 0x6E	; 110
    39b4:	f2 e0       	ldi	r31, 0x02	; 2
    39b6:	83 81       	ldd	r24, Z+3	; 0x03
    39b8:	8f 93       	push	r24
    39ba:	82 81       	ldd	r24, Z+2	; 0x02
    39bc:	8f 93       	push	r24
    39be:	81 81       	ldd	r24, Z+1	; 0x01
    39c0:	8f 93       	push	r24
    39c2:	80 81       	ld	r24, Z
    39c4:	8f 93       	push	r24
    39c6:	ea e6       	ldi	r30, 0x6A	; 106
    39c8:	f2 e0       	ldi	r31, 0x02	; 2
    39ca:	83 81       	ldd	r24, Z+3	; 0x03
    39cc:	8f 93       	push	r24
    39ce:	82 81       	ldd	r24, Z+2	; 0x02
    39d0:	8f 93       	push	r24
    39d2:	81 81       	ldd	r24, Z+1	; 0x01
    39d4:	8f 93       	push	r24
    39d6:	80 81       	ld	r24, Z
    39d8:	8f 93       	push	r24
    39da:	e6 e6       	ldi	r30, 0x66	; 102
    39dc:	f2 e0       	ldi	r31, 0x02	; 2
    39de:	83 81       	ldd	r24, Z+3	; 0x03
    39e0:	8f 93       	push	r24
    39e2:	82 81       	ldd	r24, Z+2	; 0x02
    39e4:	8f 93       	push	r24
    39e6:	81 81       	ldd	r24, Z+1	; 0x01
    39e8:	8f 93       	push	r24
    39ea:	80 81       	ld	r24, Z
    39ec:	8f 93       	push	r24
    39ee:	8b e3       	ldi	r24, 0x3B	; 59
    39f0:	94 e0       	ldi	r25, 0x04	; 4
    39f2:	9f 93       	push	r25
    39f4:	8f 93       	push	r24
    39f6:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
				                current_position.X, current_position.Y,
				                current_position.Z, current_position.E,
				                current_position.F);

				#ifdef	DEBUG
					if (DEBUG_POSITION && (debug_flags & DEBUG_POSITION)) {
    39fa:	80 91 cf 04 	lds	r24, 0x04CF
    39fe:	2d b7       	in	r18, 0x3d	; 61
    3a00:	3e b7       	in	r19, 0x3e	; 62
    3a02:	2a 5e       	subi	r18, 0xEA	; 234
    3a04:	3f 4f       	sbci	r19, 0xFF	; 255
    3a06:	0f b6       	in	r0, 0x3f	; 63
    3a08:	f8 94       	cli
    3a0a:	3e bf       	out	0x3e, r19	; 62
    3a0c:	0f be       	out	0x3f, r0	; 63
    3a0e:	2d bf       	out	0x3d, r18	; 61
    3a10:	82 ff       	sbrs	r24, 2
    3a12:	65 c1       	rjmp	.+714    	; 0x3cde <process_gcode_command+0x8f0>
						sersendf_P(PSTR(",c:%lu}\nEndpoint: X:%ld,Y:%ld,Z:%ld,E:%ld,F:%lu,c:%lu}"),
    3a14:	e0 91 bc 04 	lds	r30, 0x04BC
    3a18:	3c e3       	ldi	r19, 0x3C	; 60
    3a1a:	e3 9f       	mul	r30, r19
    3a1c:	f0 01       	movw	r30, r0
    3a1e:	11 24       	eor	r1, r1
    3a20:	eb 55       	subi	r30, 0x5B	; 91
    3a22:	fd 4f       	sbci	r31, 0xFD	; 253
    3a24:	df 01       	movw	r26, r30
    3a26:	9a 96       	adiw	r26, 0x2a	; 42
    3a28:	82 a5       	ldd	r24, Z+42	; 0x2a
    3a2a:	11 96       	adiw	r26, 0x01	; 1
    3a2c:	9c 91       	ld	r25, X
    3a2e:	11 97       	sbiw	r26, 0x01	; 1
    3a30:	12 96       	adiw	r26, 0x02	; 2
    3a32:	2c 91       	ld	r18, X
    3a34:	12 97       	sbiw	r26, 0x02	; 2
    3a36:	13 96       	adiw	r26, 0x03	; 3
    3a38:	3c 91       	ld	r19, X
    3a3a:	3f 93       	push	r19
    3a3c:	2f 93       	push	r18
    3a3e:	9f 93       	push	r25
    3a40:	8f 93       	push	r24
    3a42:	df 01       	movw	r26, r30
    3a44:	50 96       	adiw	r26, 0x10	; 16
    3a46:	13 96       	adiw	r26, 0x03	; 3
    3a48:	4c 91       	ld	r20, X
    3a4a:	13 97       	sbiw	r26, 0x03	; 3
    3a4c:	4f 93       	push	r20
    3a4e:	12 96       	adiw	r26, 0x02	; 2
    3a50:	4c 91       	ld	r20, X
    3a52:	12 97       	sbiw	r26, 0x02	; 2
    3a54:	4f 93       	push	r20
    3a56:	11 96       	adiw	r26, 0x01	; 1
    3a58:	4c 91       	ld	r20, X
    3a5a:	4f 93       	push	r20
    3a5c:	40 89       	ldd	r20, Z+16	; 0x10
    3a5e:	4f 93       	push	r20
    3a60:	df 01       	movw	r26, r30
    3a62:	1c 96       	adiw	r26, 0x0c	; 12
    3a64:	13 96       	adiw	r26, 0x03	; 3
    3a66:	4c 91       	ld	r20, X
    3a68:	13 97       	sbiw	r26, 0x03	; 3
    3a6a:	4f 93       	push	r20
    3a6c:	12 96       	adiw	r26, 0x02	; 2
    3a6e:	4c 91       	ld	r20, X
    3a70:	12 97       	sbiw	r26, 0x02	; 2
    3a72:	4f 93       	push	r20
    3a74:	11 96       	adiw	r26, 0x01	; 1
    3a76:	4c 91       	ld	r20, X
    3a78:	4f 93       	push	r20
    3a7a:	44 85       	ldd	r20, Z+12	; 0x0c
    3a7c:	4f 93       	push	r20
    3a7e:	df 01       	movw	r26, r30
    3a80:	18 96       	adiw	r26, 0x08	; 8
    3a82:	13 96       	adiw	r26, 0x03	; 3
    3a84:	4c 91       	ld	r20, X
    3a86:	13 97       	sbiw	r26, 0x03	; 3
    3a88:	4f 93       	push	r20
    3a8a:	12 96       	adiw	r26, 0x02	; 2
    3a8c:	4c 91       	ld	r20, X
    3a8e:	12 97       	sbiw	r26, 0x02	; 2
    3a90:	4f 93       	push	r20
    3a92:	11 96       	adiw	r26, 0x01	; 1
    3a94:	4c 91       	ld	r20, X
    3a96:	4f 93       	push	r20
    3a98:	40 85       	ldd	r20, Z+8	; 0x08
    3a9a:	4f 93       	push	r20
    3a9c:	df 01       	movw	r26, r30
    3a9e:	14 96       	adiw	r26, 0x04	; 4
    3aa0:	13 96       	adiw	r26, 0x03	; 3
    3aa2:	4c 91       	ld	r20, X
    3aa4:	13 97       	sbiw	r26, 0x03	; 3
    3aa6:	4f 93       	push	r20
    3aa8:	12 96       	adiw	r26, 0x02	; 2
    3aaa:	4c 91       	ld	r20, X
    3aac:	12 97       	sbiw	r26, 0x02	; 2
    3aae:	4f 93       	push	r20
    3ab0:	11 96       	adiw	r26, 0x01	; 1
    3ab2:	4c 91       	ld	r20, X
    3ab4:	4f 93       	push	r20
    3ab6:	44 81       	ldd	r20, Z+4	; 0x04
    3ab8:	4f 93       	push	r20
    3aba:	43 81       	ldd	r20, Z+3	; 0x03
    3abc:	4f 93       	push	r20
    3abe:	42 81       	ldd	r20, Z+2	; 0x02
    3ac0:	4f 93       	push	r20
    3ac2:	41 81       	ldd	r20, Z+1	; 0x01
    3ac4:	4f 93       	push	r20
    3ac6:	40 81       	ld	r20, Z
    3ac8:	4f 93       	push	r20
    3aca:	3f 93       	push	r19
    3acc:	2f 93       	push	r18
    3ace:	9f 93       	push	r25
    3ad0:	8f 93       	push	r24
    3ad2:	89 e5       	ldi	r24, 0x59	; 89
    3ad4:	94 e0       	ldi	r25, 0x04	; 4
    3ad6:	9f 93       	push	r25
    3ad8:	8f 93       	push	r24
    3ada:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
							movebuffer[mb_tail].end_c
						#else
							movebuffer[mb_tail].c
						#endif
						);
						print_queue();
    3ade:	0e 94 31 15 	call	0x2a62	; 0x2a62 <print_queue>
    3ae2:	8d b7       	in	r24, 0x3d	; 61
    3ae4:	9e b7       	in	r25, 0x3e	; 62
    3ae6:	4e 96       	adiw	r24, 0x1e	; 30
    3ae8:	0f b6       	in	r0, 0x3f	; 63
    3aea:	f8 94       	cli
    3aec:	9e bf       	out	0x3e, r25	; 62
    3aee:	0f be       	out	0x3f, r0	; 63
    3af0:	8d bf       	out	0x3d, r24	; 61
    3af2:	f5 c0       	rjmp	.+490    	; 0x3cde <process_gcode_command+0x8f0>
				//?
				//? sample data from firmware:
				//?  FIRMWARE_NAME:Teacup FIRMWARE_URL:http://github.com/triffid/Teacup_Firmware/ PROTOCOL_VERSION:1.0 MACHINE_TYPE:Mendel EXTRUDER_COUNT:1 TEMP_SENSOR_COUNT:1 HEATER_COUNT:1
				//?

				sersendf_P(PSTR("FIRMWARE_NAME:Teacup FIRMWARE_URL:http://github.com/triffid/Teacup_Firmware/ PROTOCOL_VERSION:1.0 MACHINE_TYPE:Mendel EXTRUDER_COUNT:%d TEMP_SENSOR_COUNT:%d HEATER_COUNT:%d"), 1, NUM_TEMP_SENSORS, NUM_HEATERS);
    3af4:	1f 92       	push	r1
    3af6:	82 e0       	ldi	r24, 0x02	; 2
    3af8:	8f 93       	push	r24
    3afa:	1f 92       	push	r1
    3afc:	81 e0       	ldi	r24, 0x01	; 1
    3afe:	8f 93       	push	r24
    3b00:	1f 92       	push	r1
    3b02:	8f 93       	push	r24
    3b04:	80 e9       	ldi	r24, 0x90	; 144
    3b06:	94 e0       	ldi	r25, 0x04	; 4
    3b08:	9f 93       	push	r25
    3b0a:	8f 93       	push	r24
    3b0c:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
				// newline is sent from gcode_parse after we return
				break;
    3b10:	2d b7       	in	r18, 0x3d	; 61
    3b12:	3e b7       	in	r19, 0x3e	; 62
    3b14:	28 5f       	subi	r18, 0xF8	; 248
    3b16:	3f 4f       	sbci	r19, 0xFF	; 255
    3b18:	0f b6       	in	r0, 0x3f	; 63
    3b1a:	f8 94       	cli
    3b1c:	3e bf       	out	0x3e, r19	; 62
    3b1e:	0f be       	out	0x3f, r0	; 63
    3b20:	2d bf       	out	0x3d, r18	; 61
    3b22:	dd c0       	rjmp	.+442    	; 0x3cde <process_gcode_command+0x8f0>
    3b24:	40 e0       	ldi	r20, 0x00	; 0
    3b26:	60 e0       	ldi	r22, 0x00	; 0
    3b28:	80 e0       	ldi	r24, 0x00	; 0
    3b2a:	90 e0       	ldi	r25, 0x00	; 0
    3b2c:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>
    3b30:	d6 c0       	rjmp	.+428    	; 0x3cde <process_gcode_command+0x8f0>

      case 119:
        //? --- M119: report endstop status ---
        //? Report the current status of the endstops configured in the
        //? firmware to the host.
        power_on();
    3b32:	f0 d7       	rcall	.+4064   	; 0x4b14 <power_on>
        endstops_on();
        delay_ms(10); // allow the signal to stabilize
    3b34:	6a e0       	ldi	r22, 0x0A	; 10
    3b36:	70 e0       	ldi	r23, 0x00	; 0
    3b38:	80 e0       	ldi	r24, 0x00	; 0
    3b3a:	90 e0       	ldi	r25, 0x00	; 0
    3b3c:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <delay_ms>
        #if defined(X_MIN_PIN)
          sersendf_P(PSTR("x_min:%d "), x_min());
    3b40:	c0 e0       	ldi	r28, 0x00	; 0
    3b42:	d1 e0       	ldi	r29, 0x01	; 1
    3b44:	88 81       	ld	r24, Y
    3b46:	86 95       	lsr	r24
    3b48:	81 70       	andi	r24, 0x01	; 1
    3b4a:	1f 92       	push	r1
    3b4c:	8f 93       	push	r24
    3b4e:	8d e3       	ldi	r24, 0x3D	; 61
    3b50:	95 e0       	ldi	r25, 0x05	; 5
    3b52:	9f 93       	push	r25
    3b54:	8f 93       	push	r24
    3b56:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
        #endif
        #if defined(X_MAX_PIN)
          sersendf_P(PSTR("x_max:%d "), x_max());
    3b5a:	88 81       	ld	r24, Y
    3b5c:	81 70       	andi	r24, 0x01	; 1
    3b5e:	1f 92       	push	r1
    3b60:	8f 93       	push	r24
    3b62:	87 e4       	ldi	r24, 0x47	; 71
    3b64:	95 e0       	ldi	r25, 0x05	; 5
    3b66:	9f 93       	push	r25
    3b68:	8f 93       	push	r24
    3b6a:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
        #endif
        #if defined(Y_MIN_PIN)
          sersendf_P(PSTR("y_min:%d "), y_min());
    3b6e:	c3 e0       	ldi	r28, 0x03	; 3
    3b70:	d1 e0       	ldi	r29, 0x01	; 1
    3b72:	88 81       	ld	r24, Y
    3b74:	86 95       	lsr	r24
    3b76:	81 70       	andi	r24, 0x01	; 1
    3b78:	1f 92       	push	r1
    3b7a:	8f 93       	push	r24
    3b7c:	81 e5       	ldi	r24, 0x51	; 81
    3b7e:	95 e0       	ldi	r25, 0x05	; 5
    3b80:	9f 93       	push	r25
    3b82:	8f 93       	push	r24
    3b84:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
        #endif
        #if defined(Y_MAX_PIN)
          sersendf_P(PSTR("y_max:%d "), y_max());
    3b88:	88 81       	ld	r24, Y
    3b8a:	81 70       	andi	r24, 0x01	; 1
    3b8c:	1f 92       	push	r1
    3b8e:	8f 93       	push	r24
    3b90:	8b e5       	ldi	r24, 0x5B	; 91
    3b92:	95 e0       	ldi	r25, 0x05	; 5
    3b94:	9f 93       	push	r25
    3b96:	8f 93       	push	r24
    3b98:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
        #endif
        #if defined(Z_MIN_PIN)
          sersendf_P(PSTR("z_min:%d "), z_min());
    3b9c:	89 b1       	in	r24, 0x09	; 9
    3b9e:	83 fb       	bst	r24, 3
    3ba0:	88 27       	eor	r24, r24
    3ba2:	80 f9       	bld	r24, 0
    3ba4:	1f 92       	push	r1
    3ba6:	8f 93       	push	r24
    3ba8:	85 e6       	ldi	r24, 0x65	; 101
    3baa:	95 e0       	ldi	r25, 0x05	; 5
    3bac:	9f 93       	push	r25
    3bae:	8f 93       	push	r24
    3bb0:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
    3bb4:	8d b7       	in	r24, 0x3d	; 61
    3bb6:	9e b7       	in	r25, 0x3e	; 62
    3bb8:	44 96       	adiw	r24, 0x14	; 20
    3bba:	0f b6       	in	r0, 0x3f	; 63
    3bbc:	f8 94       	cli
    3bbe:	9e bf       	out	0x3e, r25	; 62
    3bc0:	0f be       	out	0x3f, r0	; 63
    3bc2:	8d bf       	out	0x3d, r24	; 61
    3bc4:	8c c0       	rjmp	.+280    	; 0x3cde <process_gcode_command+0x8f0>
      #ifdef EECONFIG
			case 130:
				//? --- M130: heater P factor ---
				//? Undocumented.
        #ifdef HEATER_EXTRUDER
          if ( ! next_target.seen_P)
    3bc6:	c0 fd       	sbrc	r28, 0
    3bc8:	04 c0       	rjmp	.+8      	; 0x3bd2 <process_gcode_command+0x7e4>
            next_target.P = HEATER_EXTRUDER;
    3bca:	10 92 a2 04 	sts	0x04A2, r1
    3bce:	10 92 a1 04 	sts	0x04A1, r1
        // else use the first available device
        #endif
				if (next_target.seen_S)
    3bd2:	88 23       	and	r24, r24
    3bd4:	0c f0       	brlt	.+2      	; 0x3bd8 <process_gcode_command+0x7ea>
    3bd6:	83 c0       	rjmp	.+262    	; 0x3cde <process_gcode_command+0x8f0>
					pid_set_p(next_target.P, next_target.S);
    3bd8:	40 91 9f 04 	lds	r20, 0x049F
    3bdc:	50 91 a0 04 	lds	r21, 0x04A0
    3be0:	66 27       	eor	r22, r22
    3be2:	57 fd       	sbrc	r21, 7
    3be4:	60 95       	com	r22
    3be6:	76 2f       	mov	r23, r22
    3be8:	80 91 a1 04 	lds	r24, 0x04A1
    3bec:	f4 d3       	rcall	.+2024   	; 0x43d6 <pid_set_p>
    3bee:	77 c0       	rjmp	.+238    	; 0x3cde <process_gcode_command+0x8f0>

			case 131:
				//? --- M131: heater I factor ---
				//? Undocumented.
        #ifdef HEATER_EXTRUDER
          if ( ! next_target.seen_P)
    3bf0:	c0 fd       	sbrc	r28, 0
    3bf2:	04 c0       	rjmp	.+8      	; 0x3bfc <process_gcode_command+0x80e>
            next_target.P = HEATER_EXTRUDER;
    3bf4:	10 92 a2 04 	sts	0x04A2, r1
    3bf8:	10 92 a1 04 	sts	0x04A1, r1
        #endif
				if (next_target.seen_S)
    3bfc:	88 23       	and	r24, r24
    3bfe:	0c f0       	brlt	.+2      	; 0x3c02 <process_gcode_command+0x814>
    3c00:	6e c0       	rjmp	.+220    	; 0x3cde <process_gcode_command+0x8f0>
					pid_set_i(next_target.P, next_target.S);
    3c02:	40 91 9f 04 	lds	r20, 0x049F
    3c06:	50 91 a0 04 	lds	r21, 0x04A0
    3c0a:	66 27       	eor	r22, r22
    3c0c:	57 fd       	sbrc	r21, 7
    3c0e:	60 95       	com	r22
    3c10:	76 2f       	mov	r23, r22
    3c12:	80 91 a1 04 	lds	r24, 0x04A1
    3c16:	f5 d3       	rcall	.+2026   	; 0x4402 <pid_set_i>
    3c18:	62 c0       	rjmp	.+196    	; 0x3cde <process_gcode_command+0x8f0>

			case 132:
				//? --- M132: heater D factor ---
				//? Undocumented.
        #ifdef HEATER_EXTRUDER
          if ( ! next_target.seen_P)
    3c1a:	c0 fd       	sbrc	r28, 0
    3c1c:	04 c0       	rjmp	.+8      	; 0x3c26 <process_gcode_command+0x838>
            next_target.P = HEATER_EXTRUDER;
    3c1e:	10 92 a2 04 	sts	0x04A2, r1
    3c22:	10 92 a1 04 	sts	0x04A1, r1
        #endif
				if (next_target.seen_S)
    3c26:	88 23       	and	r24, r24
    3c28:	0c f0       	brlt	.+2      	; 0x3c2c <process_gcode_command+0x83e>
    3c2a:	59 c0       	rjmp	.+178    	; 0x3cde <process_gcode_command+0x8f0>
					pid_set_d(next_target.P, next_target.S);
    3c2c:	40 91 9f 04 	lds	r20, 0x049F
    3c30:	50 91 a0 04 	lds	r21, 0x04A0
    3c34:	66 27       	eor	r22, r22
    3c36:	57 fd       	sbrc	r21, 7
    3c38:	60 95       	com	r22
    3c3a:	76 2f       	mov	r23, r22
    3c3c:	80 91 a1 04 	lds	r24, 0x04A1
    3c40:	f6 d3       	rcall	.+2028   	; 0x442e <pid_set_d>
    3c42:	4d c0       	rjmp	.+154    	; 0x3cde <process_gcode_command+0x8f0>

			case 133:
				//? --- M133: heater I limit ---
				//? Undocumented.
        #ifdef HEATER_EXTRUDER
          if ( ! next_target.seen_P)
    3c44:	c0 fd       	sbrc	r28, 0
    3c46:	04 c0       	rjmp	.+8      	; 0x3c50 <process_gcode_command+0x862>
            next_target.P = HEATER_EXTRUDER;
    3c48:	10 92 a2 04 	sts	0x04A2, r1
    3c4c:	10 92 a1 04 	sts	0x04A1, r1
        #endif
				if (next_target.seen_S)
    3c50:	88 23       	and	r24, r24
    3c52:	0c f0       	brlt	.+2      	; 0x3c56 <process_gcode_command+0x868>
    3c54:	44 c0       	rjmp	.+136    	; 0x3cde <process_gcode_command+0x8f0>
					pid_set_i_limit(next_target.P, next_target.S);
    3c56:	40 91 9f 04 	lds	r20, 0x049F
    3c5a:	50 91 a0 04 	lds	r21, 0x04A0
    3c5e:	66 27       	eor	r22, r22
    3c60:	57 fd       	sbrc	r21, 7
    3c62:	60 95       	com	r22
    3c64:	76 2f       	mov	r23, r22
    3c66:	80 91 a1 04 	lds	r24, 0x04A1
    3c6a:	f7 d3       	rcall	.+2030   	; 0x445a <pid_set_i_limit>
    3c6c:	38 c0       	rjmp	.+112    	; 0x3cde <process_gcode_command+0x8f0>
				break;

			case 134:
				//? --- M134: save PID settings to eeprom ---
				//? Undocumented.
				heater_save_settings();
    3c6e:	09 d4       	rcall	.+2066   	; 0x4482 <heater_save_settings>
				break;
    3c70:	36 c0       	rjmp	.+108    	; 0x3cde <process_gcode_command+0x8f0>
			#ifdef	DEBUG
			case 136:
				//? --- M136: PRINT PID settings to host ---
				//? Undocumented.
				//? This comand is only available in DEBUG builds.
				if ( ! next_target.seen_P)
    3c72:	c0 fd       	sbrc	r28, 0
    3c74:	04 c0       	rjmp	.+8      	; 0x3c7e <process_gcode_command+0x890>
					next_target.P = HEATER_EXTRUDER;
    3c76:	10 92 a2 04 	sts	0x04A2, r1
    3c7a:	10 92 a1 04 	sts	0x04A1, r1
				heater_print(next_target.P);
    3c7e:	80 91 a1 04 	lds	r24, 0x04A1
    3c82:	90 91 a2 04 	lds	r25, 0x04A2
    3c86:	54 d4       	rcall	.+2216   	; 0x4530 <heater_print>
				break;
    3c88:	2a c0       	rjmp	.+84     	; 0x3cde <process_gcode_command+0x8f0>

			case 140:
				//? --- M140: Set heated bed temperature ---
				//? Undocumented.
				#ifdef	HEATER_BED
					if ( ! next_target.seen_S)
    3c8a:	88 23       	and	r24, r24
    3c8c:	44 f5       	brge	.+80     	; 0x3cde <process_gcode_command+0x8f0>
						break;
					temp_set(HEATER_BED, next_target.S);
    3c8e:	60 91 9f 04 	lds	r22, 0x049F
    3c92:	70 91 a0 04 	lds	r23, 0x04A0
    3c96:	81 e0       	ldi	r24, 0x01	; 1
    3c98:	0e 94 1b 2a 	call	0x5436	; 0x5436 <temp_set>
				#endif
				break;
    3c9c:	20 c0       	rjmp	.+64     	; 0x3cde <process_gcode_command+0x8f0>
			#ifdef	DEBUG
			case 240:
				//? --- M240: echo off ---
				//? Disable echo.
				//? This command is only available in DEBUG builds.
				debug_flags &= ~DEBUG_ECHO;
    3c9e:	80 91 cf 04 	lds	r24, 0x04CF
    3ca2:	8f 77       	andi	r24, 0x7F	; 127
    3ca4:	80 93 cf 04 	sts	0x04CF, r24
				serial_writestr_P(PSTR("Echo off"));
    3ca8:	8f e6       	ldi	r24, 0x6F	; 111
    3caa:	95 e0       	ldi	r25, 0x05	; 5
    3cac:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <serial_writestr_P>
				// newline is sent from gcode_parse after we return
				break;
    3cb0:	16 c0       	rjmp	.+44     	; 0x3cde <process_gcode_command+0x8f0>

			case 241:
				//? --- M241: echo on ---
				//? Enable echo.
				//? This command is only available in DEBUG builds.
				debug_flags |= DEBUG_ECHO;
    3cb2:	80 91 cf 04 	lds	r24, 0x04CF
    3cb6:	80 68       	ori	r24, 0x80	; 128
    3cb8:	80 93 cf 04 	sts	0x04CF, r24
				serial_writestr_P(PSTR("Echo on"));
    3cbc:	88 e7       	ldi	r24, 0x78	; 120
    3cbe:	95 e0       	ldi	r25, 0x05	; 5
    3cc0:	0e 94 7c 26 	call	0x4cf8	; 0x4cf8 <serial_writestr_P>
				// newline is sent from gcode_parse after we return
				break;
    3cc4:	0c c0       	rjmp	.+24     	; 0x3cde <process_gcode_command+0x8f0>

			#endif /* DEBUG */

				// unknown mcode: spit an error
			default:
				sersendf_P(PSTR("E: Bad M-code %d"), next_target.M);
    3cc6:	1f 92       	push	r1
    3cc8:	9f 93       	push	r25
    3cca:	80 e8       	ldi	r24, 0x80	; 128
    3ccc:	95 e0       	ldi	r25, 0x05	; 5
    3cce:	9f 93       	push	r25
    3cd0:	8f 93       	push	r24
    3cd2:	0e 94 9d 27 	call	0x4f3a	; 0x4f3a <sersendf_P>
    3cd6:	0f 90       	pop	r0
    3cd8:	0f 90       	pop	r0
    3cda:	0f 90       	pop	r0
    3cdc:	0f 90       	pop	r0
				// newline is sent from gcode_parse after we return
		} // switch (next_target.M)
	} // else if (next_target.seen_M)
} // process_gcode_command()
    3cde:	df 91       	pop	r29
    3ce0:	cf 91       	pop	r28
    3ce2:	ff 90       	pop	r15
    3ce4:	ef 90       	pop	r14
    3ce6:	df 90       	pop	r13
    3ce8:	cf 90       	pop	r12
    3cea:	08 95       	ret

00003cec <heater_init>:
		if (heaters_runtime[i].heater_output > 0)
			return 0;
	}

	return 255;
}
    3cec:	2f 92       	push	r2
    3cee:	3f 92       	push	r3
    3cf0:	4f 92       	push	r4
    3cf2:	5f 92       	push	r5
    3cf4:	6f 92       	push	r6
    3cf6:	7f 92       	push	r7
    3cf8:	9f 92       	push	r9
    3cfa:	af 92       	push	r10
    3cfc:	bf 92       	push	r11
    3cfe:	cf 92       	push	r12
    3d00:	df 92       	push	r13
    3d02:	ef 92       	push	r14
    3d04:	ff 92       	push	r15
    3d06:	0f 93       	push	r16
    3d08:	1f 93       	push	r17
    3d0a:	cf 93       	push	r28
    3d0c:	df 93       	push	r29
    3d0e:	93 e0       	ldi	r25, 0x03	; 3
    3d10:	94 bd       	out	0x24, r25	; 36
    3d12:	81 e0       	ldi	r24, 0x01	; 1
    3d14:	85 bd       	out	0x25, r24	; 37
    3d16:	25 e0       	ldi	r18, 0x05	; 5
    3d18:	25 bd       	out	0x25, r18	; 37
    3d1a:	10 92 6e 00 	sts	0x006E, r1
    3d1e:	17 bc       	out	0x27, r1	; 39
    3d20:	18 bc       	out	0x28, r1	; 40
    3d22:	90 93 b0 00 	sts	0x00B0, r25
    3d26:	e1 eb       	ldi	r30, 0xB1	; 177
    3d28:	f0 e0       	ldi	r31, 0x00	; 0
    3d2a:	80 83       	st	Z, r24
    3d2c:	97 e0       	ldi	r25, 0x07	; 7
    3d2e:	90 83       	st	Z, r25
    3d30:	10 92 70 00 	sts	0x0070, r1
    3d34:	10 92 b3 00 	sts	0x00B3, r1
    3d38:	10 92 b4 00 	sts	0x00B4, r1
    3d3c:	80 93 a0 00 	sts	0x00A0, r24
    3d40:	99 e0       	ldi	r25, 0x09	; 9
    3d42:	90 93 a1 00 	sts	0x00A1, r25
    3d46:	10 92 72 00 	sts	0x0072, r1
    3d4a:	10 92 a9 00 	sts	0x00A9, r1
    3d4e:	10 92 a8 00 	sts	0x00A8, r1
    3d52:	10 92 ab 00 	sts	0x00AB, r1
    3d56:	10 92 aa 00 	sts	0x00AA, r1
    3d5a:	80 93 20 01 	sts	0x0120, r24
    3d5e:	90 93 21 01 	sts	0x0121, r25
    3d62:	10 92 73 00 	sts	0x0073, r1
    3d66:	10 92 29 01 	sts	0x0129, r1
    3d6a:	10 92 28 01 	sts	0x0128, r1
    3d6e:	10 92 2b 01 	sts	0x012B, r1
    3d72:	10 92 2a 01 	sts	0x012A, r1
    3d76:	91 2c       	mov	r9, r1
    3d78:	c1 2c       	mov	r12, r1
    3d7a:	d1 2c       	mov	r13, r1
    3d7c:	76 01       	movw	r14, r12
    3d7e:	68 94       	set
    3d80:	d5 f8       	bld	r13, 5
    3d82:	41 2c       	mov	r4, r1
    3d84:	51 2c       	mov	r5, r1
    3d86:	32 01       	movw	r6, r4
    3d88:	68 94       	set
    3d8a:	51 f8       	bld	r5, 1
    3d8c:	68 94       	set
    3d8e:	22 24       	eor	r2, r2
    3d90:	27 f8       	bld	r2, 7
    3d92:	33 24       	eor	r3, r3
    3d94:	33 94       	inc	r3
    3d96:	a9 2c       	mov	r10, r9
    3d98:	b1 2c       	mov	r11, r1
    3d9a:	f5 01       	movw	r30, r10
    3d9c:	ee 0f       	add	r30, r30
    3d9e:	ff 1f       	adc	r31, r31
    3da0:	ee 0f       	add	r30, r30
    3da2:	ff 1f       	adc	r31, r31
    3da4:	ea 0d       	add	r30, r10
    3da6:	fb 1d       	adc	r31, r11
    3da8:	e0 50       	subi	r30, 0x00	; 0
    3daa:	fe 4f       	sbci	r31, 0xFE	; 254
    3dac:	03 80       	ldd	r0, Z+3	; 0x03
    3dae:	f4 81       	ldd	r31, Z+4	; 0x04
    3db0:	e0 2d       	mov	r30, r0
    3db2:	30 97       	sbiw	r30, 0x00	; 0
    3db4:	09 f4       	brne	.+2      	; 0x3db8 <heater_init+0xcc>
    3db6:	63 c0       	rjmp	.+198    	; 0x3e7e <heater_init+0x192>
    3db8:	10 82       	st	Z, r1
    3dba:	ec 3a       	cpi	r30, 0xAC	; 172
    3dbc:	f1 05       	cpc	r31, r1
    3dbe:	09 f4       	brne	.+2      	; 0x3dc2 <heater_init+0xd6>
    3dc0:	47 c0       	rjmp	.+142    	; 0x3e50 <heater_init+0x164>
    3dc2:	88 f4       	brcc	.+34     	; 0x3de6 <heater_init+0xfa>
    3dc4:	e8 34       	cpi	r30, 0x48	; 72
    3dc6:	f1 05       	cpc	r31, r1
    3dc8:	39 f1       	breq	.+78     	; 0x3e18 <heater_init+0x12c>
    3dca:	28 f4       	brcc	.+10     	; 0x3dd6 <heater_init+0xea>
    3dcc:	e7 34       	cpi	r30, 0x47	; 71
    3dce:	f1 05       	cpc	r31, r1
    3dd0:	09 f0       	breq	.+2      	; 0x3dd4 <heater_init+0xe8>
    3dd2:	55 c0       	rjmp	.+170    	; 0x3e7e <heater_init+0x192>
    3dd4:	1d c0       	rjmp	.+58     	; 0x3e10 <heater_init+0x124>
    3dd6:	e8 3a       	cpi	r30, 0xA8	; 168
    3dd8:	f1 05       	cpc	r31, r1
    3dda:	71 f1       	breq	.+92     	; 0x3e38 <heater_init+0x14c>
    3ddc:	ea 3a       	cpi	r30, 0xAA	; 170
    3dde:	f1 05       	cpc	r31, r1
    3de0:	09 f0       	breq	.+2      	; 0x3de4 <heater_init+0xf8>
    3de2:	4d c0       	rjmp	.+154    	; 0x3e7e <heater_init+0x192>
    3de4:	2f c0       	rjmp	.+94     	; 0x3e44 <heater_init+0x158>
    3de6:	e8 32       	cpi	r30, 0x28	; 40
    3de8:	81 e0       	ldi	r24, 0x01	; 1
    3dea:	f8 07       	cpc	r31, r24
    3dec:	b9 f1       	breq	.+110    	; 0x3e5c <heater_init+0x170>
    3dee:	40 f4       	brcc	.+16     	; 0x3e00 <heater_init+0x114>
    3df0:	e3 3b       	cpi	r30, 0xB3	; 179
    3df2:	f1 05       	cpc	r31, r1
    3df4:	a9 f0       	breq	.+42     	; 0x3e20 <heater_init+0x134>
    3df6:	e4 3b       	cpi	r30, 0xB4	; 180
    3df8:	f1 05       	cpc	r31, r1
    3dfa:	09 f0       	breq	.+2      	; 0x3dfe <heater_init+0x112>
    3dfc:	40 c0       	rjmp	.+128    	; 0x3e7e <heater_init+0x192>
    3dfe:	16 c0       	rjmp	.+44     	; 0x3e2c <heater_init+0x140>
    3e00:	ea 32       	cpi	r30, 0x2A	; 42
    3e02:	a1 e0       	ldi	r26, 0x01	; 1
    3e04:	fa 07       	cpc	r31, r26
    3e06:	81 f1       	breq	.+96     	; 0x3e68 <heater_init+0x17c>
    3e08:	ec 32       	cpi	r30, 0x2C	; 44
    3e0a:	f1 40       	sbci	r31, 0x01	; 1
    3e0c:	c1 f5       	brne	.+112    	; 0x3e7e <heater_init+0x192>
    3e0e:	32 c0       	rjmp	.+100    	; 0x3e74 <heater_init+0x188>
    3e10:	84 b5       	in	r24, 0x24	; 36
    3e12:	80 68       	ori	r24, 0x80	; 128
    3e14:	84 bd       	out	0x24, r24	; 36
    3e16:	33 c0       	rjmp	.+102    	; 0x3e7e <heater_init+0x192>
    3e18:	84 b5       	in	r24, 0x24	; 36
    3e1a:	80 62       	ori	r24, 0x20	; 32
    3e1c:	84 bd       	out	0x24, r24	; 36
    3e1e:	2f c0       	rjmp	.+94     	; 0x3e7e <heater_init+0x192>
    3e20:	e0 eb       	ldi	r30, 0xB0	; 176
    3e22:	f0 e0       	ldi	r31, 0x00	; 0
    3e24:	80 81       	ld	r24, Z
    3e26:	80 68       	ori	r24, 0x80	; 128
    3e28:	80 83       	st	Z, r24
    3e2a:	29 c0       	rjmp	.+82     	; 0x3e7e <heater_init+0x192>
    3e2c:	a0 eb       	ldi	r26, 0xB0	; 176
    3e2e:	b0 e0       	ldi	r27, 0x00	; 0
    3e30:	8c 91       	ld	r24, X
    3e32:	80 62       	ori	r24, 0x20	; 32
    3e34:	8c 93       	st	X, r24
    3e36:	23 c0       	rjmp	.+70     	; 0x3e7e <heater_init+0x192>
    3e38:	e0 ea       	ldi	r30, 0xA0	; 160
    3e3a:	f0 e0       	ldi	r31, 0x00	; 0
    3e3c:	80 81       	ld	r24, Z
    3e3e:	80 68       	ori	r24, 0x80	; 128
    3e40:	80 83       	st	Z, r24
    3e42:	1d c0       	rjmp	.+58     	; 0x3e7e <heater_init+0x192>
    3e44:	a0 ea       	ldi	r26, 0xA0	; 160
    3e46:	b0 e0       	ldi	r27, 0x00	; 0
    3e48:	8c 91       	ld	r24, X
    3e4a:	80 62       	ori	r24, 0x20	; 32
    3e4c:	8c 93       	st	X, r24
    3e4e:	17 c0       	rjmp	.+46     	; 0x3e7e <heater_init+0x192>
    3e50:	e0 ea       	ldi	r30, 0xA0	; 160
    3e52:	f0 e0       	ldi	r31, 0x00	; 0
    3e54:	80 81       	ld	r24, Z
    3e56:	88 60       	ori	r24, 0x08	; 8
    3e58:	80 83       	st	Z, r24
    3e5a:	11 c0       	rjmp	.+34     	; 0x3e7e <heater_init+0x192>
    3e5c:	a0 e2       	ldi	r26, 0x20	; 32
    3e5e:	b1 e0       	ldi	r27, 0x01	; 1
    3e60:	8c 91       	ld	r24, X
    3e62:	80 68       	ori	r24, 0x80	; 128
    3e64:	8c 93       	st	X, r24
    3e66:	0b c0       	rjmp	.+22     	; 0x3e7e <heater_init+0x192>
    3e68:	e0 e2       	ldi	r30, 0x20	; 32
    3e6a:	f1 e0       	ldi	r31, 0x01	; 1
    3e6c:	80 81       	ld	r24, Z
    3e6e:	80 62       	ori	r24, 0x20	; 32
    3e70:	80 83       	st	Z, r24
    3e72:	05 c0       	rjmp	.+10     	; 0x3e7e <heater_init+0x192>
    3e74:	a0 e2       	ldi	r26, 0x20	; 32
    3e76:	b1 e0       	ldi	r27, 0x01	; 1
    3e78:	8c 91       	ld	r24, X
    3e7a:	88 60       	ori	r24, 0x08	; 8
    3e7c:	8c 93       	st	X, r24
    3e7e:	e5 01       	movw	r28, r10
    3e80:	c2 95       	swap	r28
    3e82:	d2 95       	swap	r29
    3e84:	d0 7f       	andi	r29, 0xF0	; 240
    3e86:	dc 27       	eor	r29, r28
    3e88:	c0 7f       	andi	r28, 0xF0	; 240
    3e8a:	dc 27       	eor	r29, r28
    3e8c:	ce 01       	movw	r24, r28
    3e8e:	80 50       	subi	r24, 0x00	; 0
    3e90:	90 40       	sbci	r25, 0x00	; 0
    3e92:	0e 94 57 2c 	call	0x58ae	; 0x58ae <__eerd_dword_m2560>
    3e96:	95 01       	movw	r18, r10
    3e98:	22 0f       	add	r18, r18
    3e9a:	33 1f       	adc	r19, r19
    3e9c:	89 01       	movw	r16, r18
    3e9e:	00 0f       	add	r16, r16
    3ea0:	11 1f       	adc	r17, r17
    3ea2:	00 0f       	add	r16, r16
    3ea4:	11 1f       	adc	r17, r17
    3ea6:	00 0f       	add	r16, r16
    3ea8:	11 1f       	adc	r17, r17
    3eaa:	02 1b       	sub	r16, r18
    3eac:	13 0b       	sbc	r17, r19
    3eae:	06 50       	subi	r16, 0x06	; 6
    3eb0:	1b 4f       	sbci	r17, 0xFB	; 251
    3eb2:	f8 01       	movw	r30, r16
    3eb4:	60 83       	st	Z, r22
    3eb6:	71 83       	std	Z+1, r23	; 0x01
    3eb8:	82 83       	std	Z+2, r24	; 0x02
    3eba:	93 83       	std	Z+3, r25	; 0x03
    3ebc:	ce 01       	movw	r24, r28
    3ebe:	8c 5f       	subi	r24, 0xFC	; 252
    3ec0:	9f 4f       	sbci	r25, 0xFF	; 255
    3ec2:	0e 94 57 2c 	call	0x58ae	; 0x58ae <__eerd_dword_m2560>
    3ec6:	d8 01       	movw	r26, r16
    3ec8:	14 96       	adiw	r26, 0x04	; 4
    3eca:	6d 93       	st	X+, r22
    3ecc:	7d 93       	st	X+, r23
    3ece:	8d 93       	st	X+, r24
    3ed0:	9c 93       	st	X, r25
    3ed2:	17 97       	sbiw	r26, 0x07	; 7
    3ed4:	ce 01       	movw	r24, r28
    3ed6:	88 5f       	subi	r24, 0xF8	; 248
    3ed8:	9f 4f       	sbci	r25, 0xFF	; 255
    3eda:	0e 94 57 2c 	call	0x58ae	; 0x58ae <__eerd_dword_m2560>
    3ede:	f8 01       	movw	r30, r16
    3ee0:	60 87       	std	Z+8, r22	; 0x08
    3ee2:	71 87       	std	Z+9, r23	; 0x09
    3ee4:	82 87       	std	Z+10, r24	; 0x0a
    3ee6:	93 87       	std	Z+11, r25	; 0x0b
    3ee8:	ce 01       	movw	r24, r28
    3eea:	84 5f       	subi	r24, 0xF4	; 244
    3eec:	9f 4f       	sbci	r25, 0xFF	; 255
    3eee:	0e 94 5c 2c 	call	0x58b8	; 0x58b8 <__eerd_word_m2560>
    3ef2:	d8 01       	movw	r26, r16
    3ef4:	1d 96       	adiw	r26, 0x0d	; 13
    3ef6:	9c 93       	st	X, r25
    3ef8:	8e 93       	st	-X, r24
    3efa:	1c 97       	sbiw	r26, 0x0c	; 12
    3efc:	6e e0       	ldi	r22, 0x0E	; 14
    3efe:	70 e0       	ldi	r23, 0x00	; 0
    3f00:	c8 01       	movw	r24, r16
    3f02:	0e 94 6f 06 	call	0xcde	; 0xcde <crc_block>
    3f06:	8c 01       	movw	r16, r24
    3f08:	ce 01       	movw	r24, r28
    3f0a:	82 5f       	subi	r24, 0xF2	; 242
    3f0c:	9f 4f       	sbci	r25, 0xFF	; 255
    3f0e:	0e 94 5c 2c 	call	0x58b8	; 0x58b8 <__eerd_word_m2560>
    3f12:	08 17       	cp	r16, r24
    3f14:	19 07       	cpc	r17, r25
    3f16:	f9 f0       	breq	.+62     	; 0x3f56 <heater_init+0x26a>
    3f18:	aa 0c       	add	r10, r10
    3f1a:	bb 1c       	adc	r11, r11
    3f1c:	f5 01       	movw	r30, r10
    3f1e:	ee 0f       	add	r30, r30
    3f20:	ff 1f       	adc	r31, r31
    3f22:	ee 0f       	add	r30, r30
    3f24:	ff 1f       	adc	r31, r31
    3f26:	ee 0f       	add	r30, r30
    3f28:	ff 1f       	adc	r31, r31
    3f2a:	ea 19       	sub	r30, r10
    3f2c:	fb 09       	sbc	r31, r11
    3f2e:	e6 50       	subi	r30, 0x06	; 6
    3f30:	fb 4f       	sbci	r31, 0xFB	; 251
    3f32:	c0 82       	st	Z, r12
    3f34:	d1 82       	std	Z+1, r13	; 0x01
    3f36:	e2 82       	std	Z+2, r14	; 0x02
    3f38:	f3 82       	std	Z+3, r15	; 0x03
    3f3a:	44 82       	std	Z+4, r4	; 0x04
    3f3c:	55 82       	std	Z+5, r5	; 0x05
    3f3e:	66 82       	std	Z+6, r6	; 0x06
    3f40:	77 82       	std	Z+7, r7	; 0x07
    3f42:	80 e0       	ldi	r24, 0x00	; 0
    3f44:	90 e6       	ldi	r25, 0x60	; 96
    3f46:	a0 e0       	ldi	r26, 0x00	; 0
    3f48:	b0 e0       	ldi	r27, 0x00	; 0
    3f4a:	80 87       	std	Z+8, r24	; 0x08
    3f4c:	91 87       	std	Z+9, r25	; 0x09
    3f4e:	a2 87       	std	Z+10, r26	; 0x0a
    3f50:	b3 87       	std	Z+11, r27	; 0x0b
    3f52:	35 86       	std	Z+13, r3	; 0x0d
    3f54:	24 86       	std	Z+12, r2	; 0x0c
    3f56:	93 94       	inc	r9
    3f58:	92 e0       	ldi	r25, 0x02	; 2
    3f5a:	99 12       	cpse	r9, r25
    3f5c:	1c cf       	rjmp	.-456    	; 0x3d96 <heater_init+0xaa>
    3f5e:	2c 98       	cbi	0x05, 4	; 5
    3f60:	24 9a       	sbi	0x04, 4	; 4
    3f62:	e2 e0       	ldi	r30, 0x02	; 2
    3f64:	f1 e0       	ldi	r31, 0x01	; 1
    3f66:	80 81       	ld	r24, Z
    3f68:	8f 7d       	andi	r24, 0xDF	; 223
    3f6a:	80 83       	st	Z, r24
    3f6c:	e1 e0       	ldi	r30, 0x01	; 1
    3f6e:	f1 e0       	ldi	r31, 0x01	; 1
    3f70:	80 81       	ld	r24, Z
    3f72:	80 62       	ori	r24, 0x20	; 32
    3f74:	80 83       	st	Z, r24
    3f76:	df 91       	pop	r29
    3f78:	cf 91       	pop	r28
    3f7a:	1f 91       	pop	r17
    3f7c:	0f 91       	pop	r16
    3f7e:	ff 90       	pop	r15
    3f80:	ef 90       	pop	r14
    3f82:	df 90       	pop	r13
    3f84:	cf 90       	pop	r12
    3f86:	bf 90       	pop	r11
    3f88:	af 90       	pop	r10
    3f8a:	9f 90       	pop	r9
    3f8c:	7f 90       	pop	r7
    3f8e:	6f 90       	pop	r6
    3f90:	5f 90       	pop	r5
    3f92:	4f 90       	pop	r4
    3f94:	3f 90       	pop	r3
    3f96:	2f 90       	pop	r2
    3f98:	08 95       	ret

00003f9a <heater_set>:
    3f9a:	cf 93       	push	r28
    3f9c:	c6 2f       	mov	r28, r22
    3f9e:	82 30       	cpi	r24, 0x02	; 2
    3fa0:	08 f0       	brcs	.+2      	; 0x3fa4 <heater_set+0xa>
    3fa2:	66 c0       	rjmp	.+204    	; 0x4070 <heater_set+0xd6>
    3fa4:	28 2f       	mov	r18, r24
    3fa6:	30 e0       	ldi	r19, 0x00	; 0
    3fa8:	94 e1       	ldi	r25, 0x14	; 20
    3faa:	89 9f       	mul	r24, r25
    3fac:	f0 01       	movw	r30, r0
    3fae:	11 24       	eor	r1, r1
    3fb0:	ee 52       	subi	r30, 0x2E	; 46
    3fb2:	fb 4f       	sbci	r31, 0xFB	; 251
    3fb4:	63 8b       	std	Z+19, r22	; 0x13
    3fb6:	f9 01       	movw	r30, r18
    3fb8:	ee 0f       	add	r30, r30
    3fba:	ff 1f       	adc	r31, r31
    3fbc:	ee 0f       	add	r30, r30
    3fbe:	ff 1f       	adc	r31, r31
    3fc0:	e2 0f       	add	r30, r18
    3fc2:	f3 1f       	adc	r31, r19
    3fc4:	e0 50       	subi	r30, 0x00	; 0
    3fc6:	fe 4f       	sbci	r31, 0xFE	; 254
    3fc8:	03 80       	ldd	r0, Z+3	; 0x03
    3fca:	f4 81       	ldd	r31, Z+4	; 0x04
    3fcc:	e0 2d       	mov	r30, r0
    3fce:	30 97       	sbiw	r30, 0x00	; 0
    3fd0:	b1 f0       	breq	.+44     	; 0x3ffe <heater_set+0x64>
    3fd2:	60 83       	st	Z, r22
    3fd4:	90 91 cf 04 	lds	r25, 0x04CF
    3fd8:	90 ff       	sbrs	r25, 0
    3fda:	48 c0       	rjmp	.+144    	; 0x406c <heater_set+0xd2>
    3fdc:	90 81       	ld	r25, Z
    3fde:	1f 92       	push	r1
    3fe0:	9f 93       	push	r25
    3fe2:	1f 92       	push	r1
    3fe4:	8f 93       	push	r24
    3fe6:	80 ee       	ldi	r24, 0xE0	; 224
    3fe8:	95 e0       	ldi	r25, 0x05	; 5
    3fea:	9f 93       	push	r25
    3fec:	8f 93       	push	r24
    3fee:	a5 d7       	rcall	.+3914   	; 0x4f3a <sersendf_P>
    3ff0:	0f 90       	pop	r0
    3ff2:	0f 90       	pop	r0
    3ff4:	0f 90       	pop	r0
    3ff6:	0f 90       	pop	r0
    3ff8:	0f 90       	pop	r0
    3ffa:	0f 90       	pop	r0
    3ffc:	37 c0       	rjmp	.+110    	; 0x406c <heater_set+0xd2>
    3ffe:	68 30       	cpi	r22, 0x08	; 8
    4000:	d8 f0       	brcs	.+54     	; 0x4038 <heater_set+0x9e>
    4002:	d9 01       	movw	r26, r18
    4004:	aa 0f       	add	r26, r26
    4006:	bb 1f       	adc	r27, r27
    4008:	aa 0f       	add	r26, r26
    400a:	bb 1f       	adc	r27, r27
    400c:	2a 0f       	add	r18, r26
    400e:	3b 1f       	adc	r19, r27
    4010:	d9 01       	movw	r26, r18
    4012:	a0 50       	subi	r26, 0x00	; 0
    4014:	be 4f       	sbci	r27, 0xFE	; 254
    4016:	ed 91       	ld	r30, X+
    4018:	fc 91       	ld	r31, X
    401a:	11 97       	sbiw	r26, 0x01	; 1
    401c:	40 81       	ld	r20, Z
    401e:	21 e0       	ldi	r18, 0x01	; 1
    4020:	30 e0       	ldi	r19, 0x00	; 0
    4022:	c9 01       	movw	r24, r18
    4024:	12 96       	adiw	r26, 0x02	; 2
    4026:	0c 90       	ld	r0, X
    4028:	02 c0       	rjmp	.+4      	; 0x402e <heater_set+0x94>
    402a:	88 0f       	add	r24, r24
    402c:	99 1f       	adc	r25, r25
    402e:	0a 94       	dec	r0
    4030:	e2 f7       	brpl	.-8      	; 0x402a <heater_set+0x90>
    4032:	84 2b       	or	r24, r20
    4034:	80 83       	st	Z, r24
    4036:	1a c0       	rjmp	.+52     	; 0x406c <heater_set+0xd2>
    4038:	d9 01       	movw	r26, r18
    403a:	aa 0f       	add	r26, r26
    403c:	bb 1f       	adc	r27, r27
    403e:	aa 0f       	add	r26, r26
    4040:	bb 1f       	adc	r27, r27
    4042:	2a 0f       	add	r18, r26
    4044:	3b 1f       	adc	r19, r27
    4046:	d9 01       	movw	r26, r18
    4048:	a0 50       	subi	r26, 0x00	; 0
    404a:	be 4f       	sbci	r27, 0xFE	; 254
    404c:	ed 91       	ld	r30, X+
    404e:	fc 91       	ld	r31, X
    4050:	11 97       	sbiw	r26, 0x01	; 1
    4052:	20 81       	ld	r18, Z
    4054:	81 e0       	ldi	r24, 0x01	; 1
    4056:	90 e0       	ldi	r25, 0x00	; 0
    4058:	12 96       	adiw	r26, 0x02	; 2
    405a:	0c 90       	ld	r0, X
    405c:	02 c0       	rjmp	.+4      	; 0x4062 <heater_set+0xc8>
    405e:	88 0f       	add	r24, r24
    4060:	99 1f       	adc	r25, r25
    4062:	0a 94       	dec	r0
    4064:	e2 f7       	brpl	.-8      	; 0x405e <heater_set+0xc4>
    4066:	80 95       	com	r24
    4068:	82 23       	and	r24, r18
    406a:	80 83       	st	Z, r24
    406c:	c1 11       	cpse	r28, r1
    406e:	52 d5       	rcall	.+2724   	; 0x4b14 <power_on>
    4070:	cf 91       	pop	r28
    4072:	08 95       	ret

00004074 <heater_tick>:
    4074:	2f 92       	push	r2
    4076:	3f 92       	push	r3
    4078:	4f 92       	push	r4
    407a:	5f 92       	push	r5
    407c:	6f 92       	push	r6
    407e:	7f 92       	push	r7
    4080:	8f 92       	push	r8
    4082:	9f 92       	push	r9
    4084:	af 92       	push	r10
    4086:	bf 92       	push	r11
    4088:	cf 92       	push	r12
    408a:	df 92       	push	r13
    408c:	ef 92       	push	r14
    408e:	ff 92       	push	r15
    4090:	0f 93       	push	r16
    4092:	1f 93       	push	r17
    4094:	cf 93       	push	r28
    4096:	df 93       	push	r29
    4098:	cd b7       	in	r28, 0x3d	; 61
    409a:	de b7       	in	r29, 0x3e	; 62
    409c:	2f 97       	sbiw	r28, 0x0f	; 15
    409e:	0f b6       	in	r0, 0x3f	; 63
    40a0:	f8 94       	cli
    40a2:	de bf       	out	0x3e, r29	; 62
    40a4:	0f be       	out	0x3f, r0	; 63
    40a6:	cd bf       	out	0x3d, r28	; 61
    40a8:	8e 87       	std	Y+14, r24	; 0x0e
    40aa:	82 30       	cpi	r24, 0x02	; 2
    40ac:	08 f0       	brcs	.+2      	; 0x40b0 <heater_tick+0x3c>
    40ae:	6c c1       	rjmp	.+728    	; 0x4388 <heater_tick+0x314>
    40b0:	21 15       	cp	r18, r1
    40b2:	31 05       	cpc	r19, r1
    40b4:	19 f4       	brne	.+6      	; 0x40bc <heater_tick+0x48>
    40b6:	60 e0       	ldi	r22, 0x00	; 0
    40b8:	70 df       	rcall	.-288    	; 0x3f9a <heater_set>
    40ba:	66 c1       	rjmp	.+716    	; 0x4388 <heater_tick+0x314>
    40bc:	39 01       	movw	r6, r18
    40be:	64 1a       	sub	r6, r20
    40c0:	75 0a       	sbc	r7, r21
    40c2:	2e 85       	ldd	r18, Y+14	; 0x0e
    40c4:	82 2f       	mov	r24, r18
    40c6:	90 e0       	ldi	r25, 0x00	; 0
    40c8:	34 e1       	ldi	r19, 0x14	; 20
    40ca:	23 9f       	mul	r18, r19
    40cc:	f0 01       	movw	r30, r0
    40ce:	11 24       	eor	r1, r1
    40d0:	ee 52       	subi	r30, 0x2E	; 46
    40d2:	fb 4f       	sbci	r31, 0xFB	; 251
    40d4:	62 89       	ldd	r22, Z+18	; 0x12
    40d6:	9c 01       	movw	r18, r24
    40d8:	22 0f       	add	r18, r18
    40da:	33 1f       	adc	r19, r19
    40dc:	dc 01       	movw	r26, r24
    40de:	aa 0f       	add	r26, r26
    40e0:	bb 1f       	adc	r27, r27
    40e2:	aa 0f       	add	r26, r26
    40e4:	bb 1f       	adc	r27, r27
    40e6:	aa 0f       	add	r26, r26
    40e8:	bb 1f       	adc	r27, r27
    40ea:	a2 0f       	add	r26, r18
    40ec:	b3 1f       	adc	r27, r19
    40ee:	a6 0f       	add	r26, r22
    40f0:	b1 1d       	adc	r27, r1
    40f2:	aa 0f       	add	r26, r26
    40f4:	bb 1f       	adc	r27, r27
    40f6:	ac 52       	subi	r26, 0x2C	; 44
    40f8:	bb 4f       	sbci	r27, 0xFB	; 251
    40fa:	4d 93       	st	X+, r20
    40fc:	5c 93       	st	X, r21
    40fe:	6f 5f       	subi	r22, 0xFF	; 255
    4100:	67 70       	andi	r22, 0x07	; 7
    4102:	62 8b       	std	Z+18, r22	; 0x12
    4104:	60 81       	ld	r22, Z
    4106:	71 81       	ldd	r23, Z+1	; 0x01
    4108:	66 0d       	add	r22, r6
    410a:	77 1d       	adc	r23, r7
    410c:	71 83       	std	Z+1, r23	; 0x01
    410e:	60 83       	st	Z, r22
    4110:	f9 01       	movw	r30, r18
    4112:	ee 0f       	add	r30, r30
    4114:	ff 1f       	adc	r31, r31
    4116:	ee 0f       	add	r30, r30
    4118:	ff 1f       	adc	r31, r31
    411a:	ee 0f       	add	r30, r30
    411c:	ff 1f       	adc	r31, r31
    411e:	e2 1b       	sub	r30, r18
    4120:	f3 0b       	sbc	r31, r19
    4122:	e6 50       	subi	r30, 0x06	; 6
    4124:	fb 4f       	sbci	r31, 0xFB	; 251
    4126:	24 85       	ldd	r18, Z+12	; 0x0c
    4128:	35 85       	ldd	r19, Z+13	; 0x0d
    412a:	26 17       	cp	r18, r22
    412c:	37 07       	cpc	r19, r23
    412e:	5c f4       	brge	.+22     	; 0x4146 <heater_tick+0xd2>
    4130:	64 e1       	ldi	r22, 0x14	; 20
    4132:	68 9f       	mul	r22, r24
    4134:	f0 01       	movw	r30, r0
    4136:	69 9f       	mul	r22, r25
    4138:	f0 0d       	add	r31, r0
    413a:	11 24       	eor	r1, r1
    413c:	ee 52       	subi	r30, 0x2E	; 46
    413e:	fb 4f       	sbci	r31, 0xFB	; 251
    4140:	31 83       	std	Z+1, r19	; 0x01
    4142:	20 83       	st	Z, r18
    4144:	10 c0       	rjmp	.+32     	; 0x4166 <heater_tick+0xf2>
    4146:	31 95       	neg	r19
    4148:	21 95       	neg	r18
    414a:	31 09       	sbc	r19, r1
    414c:	62 17       	cp	r22, r18
    414e:	73 07       	cpc	r23, r19
    4150:	54 f4       	brge	.+20     	; 0x4166 <heater_tick+0xf2>
    4152:	64 e1       	ldi	r22, 0x14	; 20
    4154:	68 9f       	mul	r22, r24
    4156:	f0 01       	movw	r30, r0
    4158:	69 9f       	mul	r22, r25
    415a:	f0 0d       	add	r31, r0
    415c:	11 24       	eor	r1, r1
    415e:	ee 52       	subi	r30, 0x2E	; 46
    4160:	fb 4f       	sbci	r31, 0xFB	; 251
    4162:	31 83       	std	Z+1, r19	; 0x01
    4164:	20 83       	st	Z, r18
    4166:	24 e1       	ldi	r18, 0x14	; 20
    4168:	28 9f       	mul	r18, r24
    416a:	80 01       	movw	r16, r0
    416c:	29 9f       	mul	r18, r25
    416e:	10 0d       	add	r17, r0
    4170:	11 24       	eor	r1, r1
    4172:	0e 52       	subi	r16, 0x2E	; 46
    4174:	1b 4f       	sbci	r17, 0xFB	; 251
    4176:	d8 01       	movw	r26, r16
    4178:	52 96       	adiw	r26, 0x12	; 18
    417a:	6c 91       	ld	r22, X
    417c:	9c 01       	movw	r18, r24
    417e:	22 0f       	add	r18, r18
    4180:	33 1f       	adc	r19, r19
    4182:	fc 01       	movw	r30, r24
    4184:	ee 0f       	add	r30, r30
    4186:	ff 1f       	adc	r31, r31
    4188:	ee 0f       	add	r30, r30
    418a:	ff 1f       	adc	r31, r31
    418c:	ee 0f       	add	r30, r30
    418e:	ff 1f       	adc	r31, r31
    4190:	e2 0f       	add	r30, r18
    4192:	f3 1f       	adc	r31, r19
    4194:	e6 0f       	add	r30, r22
    4196:	f1 1d       	adc	r31, r1
    4198:	ee 0f       	add	r30, r30
    419a:	ff 1f       	adc	r31, r31
    419c:	ec 52       	subi	r30, 0x2C	; 44
    419e:	fb 4f       	sbci	r31, 0xFB	; 251
    41a0:	80 81       	ld	r24, Z
    41a2:	91 81       	ldd	r25, Z+1	; 0x01
    41a4:	fc 01       	movw	r30, r24
    41a6:	e4 1b       	sub	r30, r20
    41a8:	f5 0b       	sbc	r31, r21
    41aa:	fa 83       	std	Y+2, r31	; 0x02
    41ac:	e9 83       	std	Y+1, r30	; 0x01
    41ae:	f9 01       	movw	r30, r18
    41b0:	ee 0f       	add	r30, r30
    41b2:	ff 1f       	adc	r31, r31
    41b4:	ee 0f       	add	r30, r30
    41b6:	ff 1f       	adc	r31, r31
    41b8:	ee 0f       	add	r30, r30
    41ba:	ff 1f       	adc	r31, r31
    41bc:	e2 1b       	sub	r30, r18
    41be:	f3 0b       	sbc	r31, r19
    41c0:	9f 01       	movw	r18, r30
    41c2:	26 50       	subi	r18, 0x06	; 6
    41c4:	3b 4f       	sbci	r19, 0xFB	; 251
    41c6:	3b 87       	std	Y+11, r19	; 0x0b
    41c8:	2a 87       	std	Y+10, r18	; 0x0a
    41ca:	f9 01       	movw	r30, r18
    41cc:	f0 81       	ld	r31, Z
    41ce:	fb 83       	std	Y+3, r31	; 0x03
    41d0:	f9 01       	movw	r30, r18
    41d2:	f1 81       	ldd	r31, Z+1	; 0x01
    41d4:	fc 83       	std	Y+4, r31	; 0x04
    41d6:	f9 01       	movw	r30, r18
    41d8:	f2 81       	ldd	r31, Z+2	; 0x02
    41da:	fd 83       	std	Y+5, r31	; 0x05
    41dc:	f9 01       	movw	r30, r18
    41de:	f3 81       	ldd	r31, Z+3	; 0x03
    41e0:	fe 83       	std	Y+6, r31	; 0x06
    41e2:	d3 01       	movw	r26, r6
    41e4:	2b 81       	ldd	r18, Y+3	; 0x03
    41e6:	3c 81       	ldd	r19, Y+4	; 0x04
    41e8:	4d 81       	ldd	r20, Y+5	; 0x05
    41ea:	5f 2f       	mov	r21, r31
    41ec:	0e 94 51 2c 	call	0x58a2	; 0x58a2 <__mulshisi3>
    41f0:	6b 01       	movw	r12, r22
    41f2:	7c 01       	movw	r14, r24
    41f4:	d8 01       	movw	r26, r16
    41f6:	bc 91       	ld	r27, X
    41f8:	bf 83       	std	Y+7, r27	; 0x07
    41fa:	f8 01       	movw	r30, r16
    41fc:	11 81       	ldd	r17, Z+1	; 0x01
    41fe:	ea 85       	ldd	r30, Y+10	; 0x0a
    4200:	fb 85       	ldd	r31, Y+11	; 0x0b
    4202:	04 81       	ldd	r16, Z+4	; 0x04
    4204:	f5 81       	ldd	r31, Z+5	; 0x05
    4206:	f8 87       	std	Y+8, r31	; 0x08
    4208:	ea 85       	ldd	r30, Y+10	; 0x0a
    420a:	fb 85       	ldd	r31, Y+11	; 0x0b
    420c:	f6 81       	ldd	r31, Z+6	; 0x06
    420e:	f9 87       	std	Y+9, r31	; 0x09
    4210:	ea 85       	ldd	r30, Y+10	; 0x0a
    4212:	fb 85       	ldd	r31, Y+11	; 0x0b
    4214:	57 80       	ldd	r5, Z+7	; 0x07
    4216:	ab 2f       	mov	r26, r27
    4218:	b1 2f       	mov	r27, r17
    421a:	20 2f       	mov	r18, r16
    421c:	38 85       	ldd	r19, Y+8	; 0x08
    421e:	49 85       	ldd	r20, Y+9	; 0x09
    4220:	55 2d       	mov	r21, r5
    4222:	0e 94 51 2c 	call	0x58a2	; 0x58a2 <__mulshisi3>
    4226:	4b 01       	movw	r8, r22
    4228:	5c 01       	movw	r10, r24
    422a:	40 84       	ldd	r4, Z+8	; 0x08
    422c:	31 84       	ldd	r3, Z+9	; 0x09
    422e:	22 84       	ldd	r2, Z+10	; 0x0a
    4230:	f3 85       	ldd	r31, Z+11	; 0x0b
    4232:	ff 87       	std	Y+15, r31	; 0x0f
    4234:	a9 81       	ldd	r26, Y+1	; 0x01
    4236:	ba 81       	ldd	r27, Y+2	; 0x02
    4238:	24 2d       	mov	r18, r4
    423a:	33 2d       	mov	r19, r3
    423c:	42 2d       	mov	r20, r2
    423e:	5f 2f       	mov	r21, r31
    4240:	0e 94 51 2c 	call	0x58a2	; 0x58a2 <__mulshisi3>
    4244:	a7 01       	movw	r20, r14
    4246:	96 01       	movw	r18, r12
    4248:	28 0d       	add	r18, r8
    424a:	39 1d       	adc	r19, r9
    424c:	4a 1d       	adc	r20, r10
    424e:	5b 1d       	adc	r21, r11
    4250:	26 0f       	add	r18, r22
    4252:	37 1f       	adc	r19, r23
    4254:	48 1f       	adc	r20, r24
    4256:	59 1f       	adc	r21, r25
    4258:	2a 87       	std	Y+10, r18	; 0x0a
    425a:	3b 87       	std	Y+11, r19	; 0x0b
    425c:	4c 87       	std	Y+12, r20	; 0x0c
    425e:	5d 87       	std	Y+13, r21	; 0x0d
    4260:	55 23       	and	r21, r21
    4262:	24 f4       	brge	.+8      	; 0x426c <heater_tick+0x1f8>
    4264:	21 50       	subi	r18, 0x01	; 1
    4266:	3c 4f       	sbci	r19, 0xFC	; 252
    4268:	4f 4f       	sbci	r20, 0xFF	; 255
    426a:	5f 4f       	sbci	r21, 0xFF	; 255
    426c:	01 2e       	mov	r0, r17
    426e:	1a e0       	ldi	r17, 0x0A	; 10
    4270:	55 95       	asr	r21
    4272:	47 95       	ror	r20
    4274:	37 95       	ror	r19
    4276:	27 95       	ror	r18
    4278:	1a 95       	dec	r17
    427a:	d1 f7       	brne	.-12     	; 0x4270 <heater_tick+0x1fc>
    427c:	10 2d       	mov	r17, r0
    427e:	2f 3f       	cpi	r18, 0xFF	; 255
    4280:	31 05       	cpc	r19, r1
    4282:	41 05       	cpc	r20, r1
    4284:	51 05       	cpc	r21, r1
    4286:	09 f0       	breq	.+2      	; 0x428a <heater_tick+0x216>
    4288:	24 f4       	brge	.+8      	; 0x4292 <heater_tick+0x21e>
    428a:	55 23       	and	r21, r21
    428c:	2c f0       	brlt	.+10     	; 0x4298 <heater_tick+0x224>
    428e:	2a 87       	std	Y+10, r18	; 0x0a
    4290:	04 c0       	rjmp	.+8      	; 0x429a <heater_tick+0x226>
    4292:	af ef       	ldi	r26, 0xFF	; 255
    4294:	aa 87       	std	Y+10, r26	; 0x0a
    4296:	01 c0       	rjmp	.+2      	; 0x429a <heater_tick+0x226>
    4298:	1a 86       	std	Y+10, r1	; 0x0a
    429a:	f0 91 cf 04 	lds	r31, 0x04CF
    429e:	f0 ff       	sbrs	r31, 0
    42a0:	70 c0       	rjmp	.+224    	; 0x4382 <heater_tick+0x30e>
    42a2:	1f 92       	push	r1
    42a4:	ba 85       	ldd	r27, Y+10	; 0x0a
    42a6:	bf 93       	push	r27
    42a8:	5f 93       	push	r21
    42aa:	4f 93       	push	r20
    42ac:	3f 93       	push	r19
    42ae:	2f 93       	push	r18
    42b0:	9b 01       	movw	r18, r22
    42b2:	ac 01       	movw	r20, r24
    42b4:	99 23       	and	r25, r25
    42b6:	24 f4       	brge	.+8      	; 0x42c0 <heater_tick+0x24c>
    42b8:	21 50       	subi	r18, 0x01	; 1
    42ba:	3c 4f       	sbci	r19, 0xFC	; 252
    42bc:	4f 4f       	sbci	r20, 0xFF	; 255
    42be:	5f 4f       	sbci	r21, 0xFF	; 255
    42c0:	da 01       	movw	r26, r20
    42c2:	c9 01       	movw	r24, r18
    42c4:	07 2e       	mov	r0, r23
    42c6:	7a e0       	ldi	r23, 0x0A	; 10
    42c8:	b5 95       	asr	r27
    42ca:	a7 95       	ror	r26
    42cc:	97 95       	ror	r25
    42ce:	87 95       	ror	r24
    42d0:	7a 95       	dec	r23
    42d2:	d1 f7       	brne	.-12     	; 0x42c8 <heater_tick+0x254>
    42d4:	70 2d       	mov	r23, r0
    42d6:	bf 93       	push	r27
    42d8:	af 93       	push	r26
    42da:	9f 93       	push	r25
    42dc:	8f 93       	push	r24
    42de:	ef 85       	ldd	r30, Y+15	; 0x0f
    42e0:	ef 93       	push	r30
    42e2:	2f 92       	push	r2
    42e4:	3f 92       	push	r3
    42e6:	4f 92       	push	r4
    42e8:	fa 81       	ldd	r31, Y+2	; 0x02
    42ea:	ff 93       	push	r31
    42ec:	29 81       	ldd	r18, Y+1	; 0x01
    42ee:	2f 93       	push	r18
    42f0:	d5 01       	movw	r26, r10
    42f2:	c4 01       	movw	r24, r8
    42f4:	bb 20       	and	r11, r11
    42f6:	24 f4       	brge	.+8      	; 0x4300 <heater_tick+0x28c>
    42f8:	81 50       	subi	r24, 0x01	; 1
    42fa:	9c 4f       	sbci	r25, 0xFC	; 252
    42fc:	af 4f       	sbci	r26, 0xFF	; 255
    42fe:	bf 4f       	sbci	r27, 0xFF	; 255
    4300:	07 2e       	mov	r0, r23
    4302:	7a e0       	ldi	r23, 0x0A	; 10
    4304:	b5 95       	asr	r27
    4306:	a7 95       	ror	r26
    4308:	97 95       	ror	r25
    430a:	87 95       	ror	r24
    430c:	7a 95       	dec	r23
    430e:	d1 f7       	brne	.-12     	; 0x4304 <heater_tick+0x290>
    4310:	70 2d       	mov	r23, r0
    4312:	bf 93       	push	r27
    4314:	af 93       	push	r26
    4316:	9f 93       	push	r25
    4318:	8f 93       	push	r24
    431a:	5f 92       	push	r5
    431c:	e9 85       	ldd	r30, Y+9	; 0x09
    431e:	ef 93       	push	r30
    4320:	f8 85       	ldd	r31, Y+8	; 0x08
    4322:	ff 93       	push	r31
    4324:	0f 93       	push	r16
    4326:	1f 93       	push	r17
    4328:	ef 81       	ldd	r30, Y+7	; 0x07
    432a:	ef 93       	push	r30
    432c:	d7 01       	movw	r26, r14
    432e:	c6 01       	movw	r24, r12
    4330:	ff 20       	and	r15, r15
    4332:	24 f4       	brge	.+8      	; 0x433c <heater_tick+0x2c8>
    4334:	81 50       	subi	r24, 0x01	; 1
    4336:	9c 4f       	sbci	r25, 0xFC	; 252
    4338:	af 4f       	sbci	r26, 0xFF	; 255
    433a:	bf 4f       	sbci	r27, 0xFF	; 255
    433c:	07 2e       	mov	r0, r23
    433e:	7a e0       	ldi	r23, 0x0A	; 10
    4340:	b5 95       	asr	r27
    4342:	a7 95       	ror	r26
    4344:	97 95       	ror	r25
    4346:	87 95       	ror	r24
    4348:	7a 95       	dec	r23
    434a:	d1 f7       	brne	.-12     	; 0x4340 <heater_tick+0x2cc>
    434c:	70 2d       	mov	r23, r0
    434e:	bf 93       	push	r27
    4350:	af 93       	push	r26
    4352:	9f 93       	push	r25
    4354:	8f 93       	push	r24
    4356:	fe 81       	ldd	r31, Y+6	; 0x06
    4358:	ff 93       	push	r31
    435a:	ed 81       	ldd	r30, Y+5	; 0x05
    435c:	ef 93       	push	r30
    435e:	fc 81       	ldd	r31, Y+4	; 0x04
    4360:	ff 93       	push	r31
    4362:	eb 81       	ldd	r30, Y+3	; 0x03
    4364:	ef 93       	push	r30
    4366:	7f 92       	push	r7
    4368:	6f 92       	push	r6
    436a:	7f 92       	push	r7
    436c:	6f 92       	push	r6
    436e:	81 e9       	ldi	r24, 0x91	; 145
    4370:	95 e0       	ldi	r25, 0x05	; 5
    4372:	9f 93       	push	r25
    4374:	8f 93       	push	r24
    4376:	e1 d5       	rcall	.+3010   	; 0x4f3a <sersendf_P>
    4378:	0f b6       	in	r0, 0x3f	; 63
    437a:	f8 94       	cli
    437c:	de bf       	out	0x3e, r29	; 62
    437e:	0f be       	out	0x3f, r0	; 63
    4380:	cd bf       	out	0x3d, r28	; 61
    4382:	6a 85       	ldd	r22, Y+10	; 0x0a
    4384:	8e 85       	ldd	r24, Y+14	; 0x0e
    4386:	09 de       	rcall	.-1006   	; 0x3f9a <heater_set>
    4388:	2f 96       	adiw	r28, 0x0f	; 15
    438a:	0f b6       	in	r0, 0x3f	; 63
    438c:	f8 94       	cli
    438e:	de bf       	out	0x3e, r29	; 62
    4390:	0f be       	out	0x3f, r0	; 63
    4392:	cd bf       	out	0x3d, r28	; 61
    4394:	df 91       	pop	r29
    4396:	cf 91       	pop	r28
    4398:	1f 91       	pop	r17
    439a:	0f 91       	pop	r16
    439c:	ff 90       	pop	r15
    439e:	ef 90       	pop	r14
    43a0:	df 90       	pop	r13
    43a2:	cf 90       	pop	r12
    43a4:	bf 90       	pop	r11
    43a6:	af 90       	pop	r10
    43a8:	9f 90       	pop	r9
    43aa:	8f 90       	pop	r8
    43ac:	7f 90       	pop	r7
    43ae:	6f 90       	pop	r6
    43b0:	5f 90       	pop	r5
    43b2:	4f 90       	pop	r4
    43b4:	3f 90       	pop	r3
    43b6:	2f 90       	pop	r2
    43b8:	08 95       	ret

000043ba <heaters_all_zero>:
    43ba:	80 91 e5 04 	lds	r24, 0x04E5
    43be:	81 11       	cpse	r24, r1
    43c0:	06 c0       	rjmp	.+12     	; 0x43ce <heaters_all_zero+0x14>
    43c2:	80 91 f9 04 	lds	r24, 0x04F9
    43c6:	88 23       	and	r24, r24
    43c8:	21 f0       	breq	.+8      	; 0x43d2 <heaters_all_zero+0x18>
    43ca:	80 e0       	ldi	r24, 0x00	; 0
    43cc:	08 95       	ret
    43ce:	80 e0       	ldi	r24, 0x00	; 0
    43d0:	08 95       	ret
    43d2:	8f ef       	ldi	r24, 0xFF	; 255
    43d4:	08 95       	ret

000043d6 <pid_set_p>:
	\param index heater to change factor for
	\param p scaled P factor
*/
void pid_set_p(heater_t index, int32_t p) {
	#ifndef	BANG_BANG
		if (index >= NUM_HEATERS)
    43d6:	82 30       	cpi	r24, 0x02	; 2
    43d8:	98 f4       	brcc	.+38     	; 0x4400 <pid_set_p+0x2a>
			return;

		heaters_pid[index].p_factor = p;
    43da:	28 2f       	mov	r18, r24
    43dc:	30 e0       	ldi	r19, 0x00	; 0
    43de:	22 0f       	add	r18, r18
    43e0:	33 1f       	adc	r19, r19
    43e2:	f9 01       	movw	r30, r18
    43e4:	ee 0f       	add	r30, r30
    43e6:	ff 1f       	adc	r31, r31
    43e8:	ee 0f       	add	r30, r30
    43ea:	ff 1f       	adc	r31, r31
    43ec:	ee 0f       	add	r30, r30
    43ee:	ff 1f       	adc	r31, r31
    43f0:	e2 1b       	sub	r30, r18
    43f2:	f3 0b       	sbc	r31, r19
    43f4:	e6 50       	subi	r30, 0x06	; 6
    43f6:	fb 4f       	sbci	r31, 0xFB	; 251
    43f8:	40 83       	st	Z, r20
    43fa:	51 83       	std	Z+1, r21	; 0x01
    43fc:	62 83       	std	Z+2, r22	; 0x02
    43fe:	73 83       	std	Z+3, r23	; 0x03
    4400:	08 95       	ret

00004402 <pid_set_i>:
	\param index heater to change I factor for
	\param i scaled I factor
*/
void pid_set_i(heater_t index, int32_t i) {
	#ifndef	BANG_BANG
		if (index >= NUM_HEATERS)
    4402:	82 30       	cpi	r24, 0x02	; 2
    4404:	98 f4       	brcc	.+38     	; 0x442c <pid_set_i+0x2a>
			return;

		heaters_pid[index].i_factor = i;
    4406:	28 2f       	mov	r18, r24
    4408:	30 e0       	ldi	r19, 0x00	; 0
    440a:	22 0f       	add	r18, r18
    440c:	33 1f       	adc	r19, r19
    440e:	f9 01       	movw	r30, r18
    4410:	ee 0f       	add	r30, r30
    4412:	ff 1f       	adc	r31, r31
    4414:	ee 0f       	add	r30, r30
    4416:	ff 1f       	adc	r31, r31
    4418:	ee 0f       	add	r30, r30
    441a:	ff 1f       	adc	r31, r31
    441c:	e2 1b       	sub	r30, r18
    441e:	f3 0b       	sbc	r31, r19
    4420:	e6 50       	subi	r30, 0x06	; 6
    4422:	fb 4f       	sbci	r31, 0xFB	; 251
    4424:	44 83       	std	Z+4, r20	; 0x04
    4426:	55 83       	std	Z+5, r21	; 0x05
    4428:	66 83       	std	Z+6, r22	; 0x06
    442a:	77 83       	std	Z+7, r23	; 0x07
    442c:	08 95       	ret

0000442e <pid_set_d>:
	\param index heater to change D factor for
	\param d scaled D factor
*/
void pid_set_d(heater_t index, int32_t d) {
	#ifndef	BANG_BANG
		if (index >= NUM_HEATERS)
    442e:	82 30       	cpi	r24, 0x02	; 2
    4430:	98 f4       	brcc	.+38     	; 0x4458 <pid_set_d+0x2a>
			return;

		heaters_pid[index].d_factor = d;
    4432:	28 2f       	mov	r18, r24
    4434:	30 e0       	ldi	r19, 0x00	; 0
    4436:	22 0f       	add	r18, r18
    4438:	33 1f       	adc	r19, r19
    443a:	f9 01       	movw	r30, r18
    443c:	ee 0f       	add	r30, r30
    443e:	ff 1f       	adc	r31, r31
    4440:	ee 0f       	add	r30, r30
    4442:	ff 1f       	adc	r31, r31
    4444:	ee 0f       	add	r30, r30
    4446:	ff 1f       	adc	r31, r31
    4448:	e2 1b       	sub	r30, r18
    444a:	f3 0b       	sbc	r31, r19
    444c:	e6 50       	subi	r30, 0x06	; 6
    444e:	fb 4f       	sbci	r31, 0xFB	; 251
    4450:	40 87       	std	Z+8, r20	; 0x08
    4452:	51 87       	std	Z+9, r21	; 0x09
    4454:	62 87       	std	Z+10, r22	; 0x0a
    4456:	73 87       	std	Z+11, r23	; 0x0b
    4458:	08 95       	ret

0000445a <pid_set_i_limit>:
	\param index heater to set I limit for
	\param i_limit scaled I limit
*/
void pid_set_i_limit(heater_t index, int32_t i_limit) {
	#ifndef	BANG_BANG
		if (index >= NUM_HEATERS)
    445a:	82 30       	cpi	r24, 0x02	; 2
    445c:	88 f4       	brcc	.+34     	; 0x4480 <pid_set_i_limit+0x26>
			return;

		heaters_pid[index].i_limit = i_limit;
    445e:	28 2f       	mov	r18, r24
    4460:	30 e0       	ldi	r19, 0x00	; 0
    4462:	22 0f       	add	r18, r18
    4464:	33 1f       	adc	r19, r19
    4466:	f9 01       	movw	r30, r18
    4468:	ee 0f       	add	r30, r30
    446a:	ff 1f       	adc	r31, r31
    446c:	ee 0f       	add	r30, r30
    446e:	ff 1f       	adc	r31, r31
    4470:	ee 0f       	add	r30, r30
    4472:	ff 1f       	adc	r31, r31
    4474:	e2 1b       	sub	r30, r18
    4476:	f3 0b       	sbc	r31, r19
    4478:	e6 50       	subi	r30, 0x06	; 6
    447a:	fb 4f       	sbci	r31, 0xFB	; 251
    447c:	55 87       	std	Z+13, r21	; 0x0d
    447e:	44 87       	std	Z+12, r20	; 0x0c
    4480:	08 95       	ret

00004482 <heater_save_settings>:
	#endif /* BANG_BANG */
}

/// \brief Write PID factors to eeprom
void heater_save_settings() {
    4482:	ff 92       	push	r15
    4484:	0f 93       	push	r16
    4486:	1f 93       	push	r17
    4488:	cf 93       	push	r28
    448a:	df 93       	push	r29
  #ifndef BANG_BANG
    heater_t i;
    for (i = 0; i < NUM_HEATERS; i++) {
    448c:	f1 2c       	mov	r15, r1
      eeprom_write_dword((uint32_t *) &EE_factors[i].EE_p_factor, heaters_pid[i].p_factor);
    448e:	cf 2d       	mov	r28, r15
    4490:	d0 e0       	ldi	r29, 0x00	; 0
    4492:	ce 01       	movw	r24, r28
    4494:	88 0f       	add	r24, r24
    4496:	99 1f       	adc	r25, r25
    4498:	8c 01       	movw	r16, r24
    449a:	00 0f       	add	r16, r16
    449c:	11 1f       	adc	r17, r17
    449e:	00 0f       	add	r16, r16
    44a0:	11 1f       	adc	r17, r17
    44a2:	00 0f       	add	r16, r16
    44a4:	11 1f       	adc	r17, r17
    44a6:	08 1b       	sub	r16, r24
    44a8:	19 0b       	sbc	r17, r25
    44aa:	06 50       	subi	r16, 0x06	; 6
    44ac:	1b 4f       	sbci	r17, 0xFB	; 251
    44ae:	f8 01       	movw	r30, r16
    44b0:	40 81       	ld	r20, Z
    44b2:	51 81       	ldd	r21, Z+1	; 0x01
    44b4:	62 81       	ldd	r22, Z+2	; 0x02
    44b6:	73 81       	ldd	r23, Z+3	; 0x03
    44b8:	c2 95       	swap	r28
    44ba:	d2 95       	swap	r29
    44bc:	d0 7f       	andi	r29, 0xF0	; 240
    44be:	dc 27       	eor	r29, r28
    44c0:	c0 7f       	andi	r28, 0xF0	; 240
    44c2:	dc 27       	eor	r29, r28
    44c4:	ce 01       	movw	r24, r28
    44c6:	80 50       	subi	r24, 0x00	; 0
    44c8:	90 40       	sbci	r25, 0x00	; 0
    44ca:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <__eewr_dword_m2560>
      eeprom_write_dword((uint32_t *) &EE_factors[i].EE_i_factor, heaters_pid[i].i_factor);
    44ce:	f8 01       	movw	r30, r16
    44d0:	44 81       	ldd	r20, Z+4	; 0x04
    44d2:	55 81       	ldd	r21, Z+5	; 0x05
    44d4:	66 81       	ldd	r22, Z+6	; 0x06
    44d6:	77 81       	ldd	r23, Z+7	; 0x07
    44d8:	ce 01       	movw	r24, r28
    44da:	8c 5f       	subi	r24, 0xFC	; 252
    44dc:	9f 4f       	sbci	r25, 0xFF	; 255
    44de:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <__eewr_dword_m2560>
      eeprom_write_dword((uint32_t *) &EE_factors[i].EE_d_factor, heaters_pid[i].d_factor);
    44e2:	f8 01       	movw	r30, r16
    44e4:	40 85       	ldd	r20, Z+8	; 0x08
    44e6:	51 85       	ldd	r21, Z+9	; 0x09
    44e8:	62 85       	ldd	r22, Z+10	; 0x0a
    44ea:	73 85       	ldd	r23, Z+11	; 0x0b
    44ec:	ce 01       	movw	r24, r28
    44ee:	88 5f       	subi	r24, 0xF8	; 248
    44f0:	9f 4f       	sbci	r25, 0xFF	; 255
    44f2:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <__eewr_dword_m2560>
      eeprom_write_word((uint16_t *) &EE_factors[i].EE_i_limit, heaters_pid[i].i_limit);
    44f6:	f8 01       	movw	r30, r16
    44f8:	64 85       	ldd	r22, Z+12	; 0x0c
    44fa:	75 85       	ldd	r23, Z+13	; 0x0d
    44fc:	ce 01       	movw	r24, r28
    44fe:	84 5f       	subi	r24, 0xF4	; 244
    4500:	9f 4f       	sbci	r25, 0xFF	; 255
    4502:	0e 94 66 2c 	call	0x58cc	; 0x58cc <__eewr_word_m2560>
      eeprom_write_word((uint16_t *) &EE_factors[i].crc, crc_block(&heaters_pid[i].p_factor, 14));
    4506:	6e e0       	ldi	r22, 0x0E	; 14
    4508:	70 e0       	ldi	r23, 0x00	; 0
    450a:	c8 01       	movw	r24, r16
    450c:	0e 94 6f 06 	call	0xcde	; 0xcde <crc_block>
    4510:	bc 01       	movw	r22, r24
    4512:	ce 01       	movw	r24, r28
    4514:	82 5f       	subi	r24, 0xF2	; 242
    4516:	9f 4f       	sbci	r25, 0xFF	; 255
    4518:	0e 94 66 2c 	call	0x58cc	; 0x58cc <__eewr_word_m2560>

/// \brief Write PID factors to eeprom
void heater_save_settings() {
  #ifndef BANG_BANG
    heater_t i;
    for (i = 0; i < NUM_HEATERS; i++) {
    451c:	f3 94       	inc	r15
    451e:	f2 e0       	ldi	r31, 0x02	; 2
    4520:	ff 12       	cpse	r15, r31
    4522:	b5 cf       	rjmp	.-150    	; 0x448e <heater_save_settings+0xc>
      eeprom_write_dword((uint32_t *) &EE_factors[i].EE_d_factor, heaters_pid[i].d_factor);
      eeprom_write_word((uint16_t *) &EE_factors[i].EE_i_limit, heaters_pid[i].i_limit);
      eeprom_write_word((uint16_t *) &EE_factors[i].crc, crc_block(&heaters_pid[i].p_factor, 14));
    }
  #endif /* BANG_BANG */
}
    4524:	df 91       	pop	r29
    4526:	cf 91       	pop	r28
    4528:	1f 91       	pop	r17
    452a:	0f 91       	pop	r16
    452c:	ff 90       	pop	r15
    452e:	08 95       	ret

00004530 <heater_print>:

#ifndef	EXTRUDER
/** \brief send heater debug info to host
	\param i index of heater to send info for
*/
void heater_print(uint16_t i) {
    4530:	cf 93       	push	r28
    4532:	df 93       	push	r29
    4534:	d8 2f       	mov	r29, r24
    4536:	c9 2f       	mov	r28, r25
	sersendf_P(PSTR("P:%ld I:%ld D:%ld Ilim:%u crc:%u "), heaters_pid[i].p_factor, heaters_pid[i].i_factor, heaters_pid[i].d_factor, heaters_pid[i].i_limit, crc_block(&heaters_pid[i].p_factor, 14));
    4538:	28 2f       	mov	r18, r24
    453a:	39 2f       	mov	r19, r25
    453c:	22 0f       	add	r18, r18
    453e:	33 1f       	adc	r19, r19
    4540:	c9 01       	movw	r24, r18
    4542:	88 0f       	add	r24, r24
    4544:	99 1f       	adc	r25, r25
    4546:	88 0f       	add	r24, r24
    4548:	99 1f       	adc	r25, r25
    454a:	88 0f       	add	r24, r24
    454c:	99 1f       	adc	r25, r25
    454e:	82 1b       	sub	r24, r18
    4550:	93 0b       	sbc	r25, r19
    4552:	6e e0       	ldi	r22, 0x0E	; 14
    4554:	70 e0       	ldi	r23, 0x00	; 0
    4556:	86 50       	subi	r24, 0x06	; 6
    4558:	9b 4f       	sbci	r25, 0xFB	; 251
    455a:	0e 94 6f 06 	call	0xcde	; 0xcde <crc_block>
    455e:	9f 93       	push	r25
    4560:	8f 93       	push	r24
    4562:	2d 2f       	mov	r18, r29
    4564:	3c 2f       	mov	r19, r28
    4566:	22 0f       	add	r18, r18
    4568:	33 1f       	adc	r19, r19
    456a:	f9 01       	movw	r30, r18
    456c:	ee 0f       	add	r30, r30
    456e:	ff 1f       	adc	r31, r31
    4570:	ee 0f       	add	r30, r30
    4572:	ff 1f       	adc	r31, r31
    4574:	ee 0f       	add	r30, r30
    4576:	ff 1f       	adc	r31, r31
    4578:	e2 1b       	sub	r30, r18
    457a:	f3 0b       	sbc	r31, r19
    457c:	e6 50       	subi	r30, 0x06	; 6
    457e:	fb 4f       	sbci	r31, 0xFB	; 251
    4580:	85 85       	ldd	r24, Z+13	; 0x0d
    4582:	8f 93       	push	r24
    4584:	84 85       	ldd	r24, Z+12	; 0x0c
    4586:	8f 93       	push	r24
    4588:	2d 2f       	mov	r18, r29
    458a:	3c 2f       	mov	r19, r28
    458c:	22 0f       	add	r18, r18
    458e:	33 1f       	adc	r19, r19
    4590:	d9 01       	movw	r26, r18
    4592:	aa 0f       	add	r26, r26
    4594:	bb 1f       	adc	r27, r27
    4596:	aa 0f       	add	r26, r26
    4598:	bb 1f       	adc	r27, r27
    459a:	aa 0f       	add	r26, r26
    459c:	bb 1f       	adc	r27, r27
    459e:	a2 1b       	sub	r26, r18
    45a0:	b3 0b       	sbc	r27, r19
    45a2:	a6 50       	subi	r26, 0x06	; 6
    45a4:	bb 4f       	sbci	r27, 0xFB	; 251
    45a6:	fd 01       	movw	r30, r26
    45a8:	38 96       	adiw	r30, 0x08	; 8
    45aa:	83 81       	ldd	r24, Z+3	; 0x03
    45ac:	8f 93       	push	r24
    45ae:	82 81       	ldd	r24, Z+2	; 0x02
    45b0:	8f 93       	push	r24
    45b2:	81 81       	ldd	r24, Z+1	; 0x01
    45b4:	8f 93       	push	r24
    45b6:	18 96       	adiw	r26, 0x08	; 8
    45b8:	8c 91       	ld	r24, X
    45ba:	8f 93       	push	r24
    45bc:	2d 2f       	mov	r18, r29
    45be:	3c 2f       	mov	r19, r28
    45c0:	22 0f       	add	r18, r18
    45c2:	33 1f       	adc	r19, r19
    45c4:	d9 01       	movw	r26, r18
    45c6:	aa 0f       	add	r26, r26
    45c8:	bb 1f       	adc	r27, r27
    45ca:	aa 0f       	add	r26, r26
    45cc:	bb 1f       	adc	r27, r27
    45ce:	aa 0f       	add	r26, r26
    45d0:	bb 1f       	adc	r27, r27
    45d2:	a2 1b       	sub	r26, r18
    45d4:	b3 0b       	sbc	r27, r19
    45d6:	a6 50       	subi	r26, 0x06	; 6
    45d8:	bb 4f       	sbci	r27, 0xFB	; 251
    45da:	fd 01       	movw	r30, r26
    45dc:	34 96       	adiw	r30, 0x04	; 4
    45de:	83 81       	ldd	r24, Z+3	; 0x03
    45e0:	8f 93       	push	r24
    45e2:	82 81       	ldd	r24, Z+2	; 0x02
    45e4:	8f 93       	push	r24
    45e6:	81 81       	ldd	r24, Z+1	; 0x01
    45e8:	8f 93       	push	r24
    45ea:	14 96       	adiw	r26, 0x04	; 4
    45ec:	8c 91       	ld	r24, X
    45ee:	8f 93       	push	r24
    45f0:	2d 2f       	mov	r18, r29
    45f2:	3c 2f       	mov	r19, r28
    45f4:	22 0f       	add	r18, r18
    45f6:	33 1f       	adc	r19, r19
    45f8:	f9 01       	movw	r30, r18
    45fa:	ee 0f       	add	r30, r30
    45fc:	ff 1f       	adc	r31, r31
    45fe:	ee 0f       	add	r30, r30
    4600:	ff 1f       	adc	r31, r31
    4602:	ee 0f       	add	r30, r30
    4604:	ff 1f       	adc	r31, r31
    4606:	e2 1b       	sub	r30, r18
    4608:	f3 0b       	sbc	r31, r19
    460a:	e6 50       	subi	r30, 0x06	; 6
    460c:	fb 4f       	sbci	r31, 0xFB	; 251
    460e:	83 81       	ldd	r24, Z+3	; 0x03
    4610:	8f 93       	push	r24
    4612:	82 81       	ldd	r24, Z+2	; 0x02
    4614:	8f 93       	push	r24
    4616:	81 81       	ldd	r24, Z+1	; 0x01
    4618:	8f 93       	push	r24
    461a:	80 81       	ld	r24, Z
    461c:	8f 93       	push	r24
    461e:	8e ee       	ldi	r24, 0xEE	; 238
    4620:	95 e0       	ldi	r25, 0x05	; 5
    4622:	9f 93       	push	r25
    4624:	8f 93       	push	r24
    4626:	89 d4       	rcall	.+2322   	; 0x4f3a <sersendf_P>
    4628:	8d b7       	in	r24, 0x3d	; 61
    462a:	9e b7       	in	r25, 0x3e	; 62
    462c:	42 96       	adiw	r24, 0x12	; 18
    462e:	0f b6       	in	r0, 0x3f	; 63
    4630:	f8 94       	cli
    4632:	9e bf       	out	0x3e, r25	; 62
    4634:	0f be       	out	0x3f, r0	; 63
    4636:	8d bf       	out	0x3d, r24	; 61
}
    4638:	df 91       	pop	r29
    463a:	cf 91       	pop	r28
    463c:	08 95       	ret

0000463e <home_x_negative>:
		home_z_positive();
	#endif
}

/// find X MIN endstop
void home_x_negative() {
    463e:	cf 93       	push	r28
    4640:	df 93       	push	r29
    4642:	cd b7       	in	r28, 0x3d	; 61
    4644:	de b7       	in	r29, 0x3e	; 62
    4646:	65 97       	sbiw	r28, 0x15	; 21
    4648:	0f b6       	in	r0, 0x3f	; 63
    464a:	f8 94       	cli
    464c:	de bf       	out	0x3e, r29	; 62
    464e:	0f be       	out	0x3f, r0	; 63
    4650:	cd bf       	out	0x3d, r28	; 61
	#if defined X_MIN_PIN
		TARGET t = startpoint;
    4652:	85 e1       	ldi	r24, 0x15	; 21
    4654:	e0 e9       	ldi	r30, 0x90	; 144
    4656:	f2 e0       	ldi	r31, 0x02	; 2
    4658:	de 01       	movw	r26, r28
    465a:	11 96       	adiw	r26, 0x01	; 1
    465c:	01 90       	ld	r0, Z+
    465e:	0d 92       	st	X+, r0
    4660:	8a 95       	dec	r24
    4662:	e1 f7       	brne	.-8      	; 0x465c <home_x_negative+0x1e>

		t.X = -1000000;
    4664:	80 ec       	ldi	r24, 0xC0	; 192
    4666:	9d eb       	ldi	r25, 0xBD	; 189
    4668:	a0 ef       	ldi	r26, 0xF0	; 240
    466a:	bf ef       	ldi	r27, 0xFF	; 255
    466c:	89 83       	std	Y+1, r24	; 0x01
    466e:	9a 83       	std	Y+2, r25	; 0x02
    4670:	ab 83       	std	Y+3, r26	; 0x03
    4672:	bc 83       	std	Y+4, r27	; 0x04
		#ifdef SLOW_HOMING
			// hit home soft
			t.F = SEARCH_FEEDRATE_X;
		#else
			// hit home hard
			t.F = MAXIMUM_FEEDRATE_X;
    4674:	88 ec       	ldi	r24, 0xC8	; 200
    4676:	90 e0       	ldi	r25, 0x00	; 0
    4678:	a0 e0       	ldi	r26, 0x00	; 0
    467a:	b0 e0       	ldi	r27, 0x00	; 0
    467c:	89 8b       	std	Y+17, r24	; 0x11
    467e:	9a 8b       	std	Y+18, r25	; 0x12
    4680:	ab 8b       	std	Y+19, r26	; 0x13
    4682:	bc 8b       	std	Y+20, r27	; 0x14
		#endif
		enqueue_home(&t, 0x1, 1);
    4684:	41 e0       	ldi	r20, 0x01	; 1
    4686:	61 e0       	ldi	r22, 0x01	; 1
    4688:	ce 01       	movw	r24, r28
    468a:	01 96       	adiw	r24, 0x01	; 1
    468c:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>

		#ifndef SLOW_HOMING
			// back off slowly
			t.X = +1000000;
    4690:	80 e4       	ldi	r24, 0x40	; 64
    4692:	92 e4       	ldi	r25, 0x42	; 66
    4694:	af e0       	ldi	r26, 0x0F	; 15
    4696:	b0 e0       	ldi	r27, 0x00	; 0
    4698:	89 83       	std	Y+1, r24	; 0x01
    469a:	9a 83       	std	Y+2, r25	; 0x02
    469c:	ab 83       	std	Y+3, r26	; 0x03
    469e:	bc 83       	std	Y+4, r27	; 0x04
			t.F = SEARCH_FEEDRATE_X;
    46a0:	82 e3       	ldi	r24, 0x32	; 50
    46a2:	90 e0       	ldi	r25, 0x00	; 0
    46a4:	a0 e0       	ldi	r26, 0x00	; 0
    46a6:	b0 e0       	ldi	r27, 0x00	; 0
    46a8:	89 8b       	std	Y+17, r24	; 0x11
    46aa:	9a 8b       	std	Y+18, r25	; 0x12
    46ac:	ab 8b       	std	Y+19, r26	; 0x13
    46ae:	bc 8b       	std	Y+20, r27	; 0x14
			enqueue_home(&t, 0x1, 0);
    46b0:	40 e0       	ldi	r20, 0x00	; 0
    46b2:	61 e0       	ldi	r22, 0x01	; 1
    46b4:	ce 01       	movw	r24, r28
    46b6:	01 96       	adiw	r24, 0x01	; 1
    46b8:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>
		#endif

		// set X home
		queue_wait(); // we have to wait here, see G92
    46bc:	0e 94 66 15 	call	0x2acc	; 0x2acc <queue_wait>
		#ifdef X_MIN
			startpoint.X = next_target.target.X = (int32_t)(X_MIN * 1000.0);
    46c0:	10 92 8a 04 	sts	0x048A, r1
    46c4:	10 92 8b 04 	sts	0x048B, r1
    46c8:	10 92 8c 04 	sts	0x048C, r1
    46cc:	10 92 8d 04 	sts	0x048D, r1
    46d0:	10 92 90 02 	sts	0x0290, r1
    46d4:	10 92 91 02 	sts	0x0291, r1
    46d8:	10 92 92 02 	sts	0x0292, r1
    46dc:	10 92 93 02 	sts	0x0293, r1
		#else
			startpoint.X = next_target.target.X = 0;
		#endif
		dda_new_startpoint();
    46e0:	0e 94 2c 07 	call	0xe58	; 0xe58 <dda_new_startpoint>
	#endif
}
    46e4:	65 96       	adiw	r28, 0x15	; 21
    46e6:	0f b6       	in	r0, 0x3f	; 63
    46e8:	f8 94       	cli
    46ea:	de bf       	out	0x3e, r29	; 62
    46ec:	0f be       	out	0x3f, r0	; 63
    46ee:	cd bf       	out	0x3d, r28	; 61
    46f0:	df 91       	pop	r29
    46f2:	cf 91       	pop	r28
    46f4:	08 95       	ret

000046f6 <home_x_positive>:

/// find X_MAX endstop
void home_x_positive() {
    46f6:	cf 92       	push	r12
    46f8:	df 92       	push	r13
    46fa:	ef 92       	push	r14
    46fc:	ff 92       	push	r15
    46fe:	cf 93       	push	r28
    4700:	df 93       	push	r29
    4702:	cd b7       	in	r28, 0x3d	; 61
    4704:	de b7       	in	r29, 0x3e	; 62
    4706:	65 97       	sbiw	r28, 0x15	; 21
    4708:	0f b6       	in	r0, 0x3f	; 63
    470a:	f8 94       	cli
    470c:	de bf       	out	0x3e, r29	; 62
    470e:	0f be       	out	0x3f, r0	; 63
    4710:	cd bf       	out	0x3d, r28	; 61
	#if defined X_MAX_PIN && ! defined X_MAX
		#warning X_MAX_PIN defined, but not X_MAX. home_x_positive() disabled.
	#endif
	#if defined X_MAX_PIN && defined X_MAX
		TARGET t = startpoint;
    4712:	85 e1       	ldi	r24, 0x15	; 21
    4714:	e0 e9       	ldi	r30, 0x90	; 144
    4716:	f2 e0       	ldi	r31, 0x02	; 2
    4718:	de 01       	movw	r26, r28
    471a:	11 96       	adiw	r26, 0x01	; 1
    471c:	01 90       	ld	r0, Z+
    471e:	0d 92       	st	X+, r0
    4720:	8a 95       	dec	r24
    4722:	e1 f7       	brne	.-8      	; 0x471c <home_x_positive+0x26>

		t.X = +1000000;
    4724:	80 e4       	ldi	r24, 0x40	; 64
    4726:	92 e4       	ldi	r25, 0x42	; 66
    4728:	af e0       	ldi	r26, 0x0F	; 15
    472a:	b0 e0       	ldi	r27, 0x00	; 0
    472c:	89 83       	std	Y+1, r24	; 0x01
    472e:	9a 83       	std	Y+2, r25	; 0x02
    4730:	ab 83       	std	Y+3, r26	; 0x03
    4732:	bc 83       	std	Y+4, r27	; 0x04
		#ifdef SLOW_HOMING
			// hit home soft
			t.F = SEARCH_FEEDRATE_X;
		#else
			// hit home hard
			t.F = MAXIMUM_FEEDRATE_X;
    4734:	0f 2e       	mov	r0, r31
    4736:	f8 ec       	ldi	r31, 0xC8	; 200
    4738:	cf 2e       	mov	r12, r31
    473a:	d1 2c       	mov	r13, r1
    473c:	e1 2c       	mov	r14, r1
    473e:	f1 2c       	mov	r15, r1
    4740:	f0 2d       	mov	r31, r0
    4742:	c9 8a       	std	Y+17, r12	; 0x11
    4744:	da 8a       	std	Y+18, r13	; 0x12
    4746:	eb 8a       	std	Y+19, r14	; 0x13
    4748:	fc 8a       	std	Y+20, r15	; 0x14
		#endif
		enqueue_home(&t, 0x1, 1);
    474a:	41 e0       	ldi	r20, 0x01	; 1
    474c:	61 e0       	ldi	r22, 0x01	; 1
    474e:	ce 01       	movw	r24, r28
    4750:	01 96       	adiw	r24, 0x01	; 1
    4752:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>

		#ifndef SLOW_HOMING
			// back off slowly
			t.X = -1000000;
    4756:	80 ec       	ldi	r24, 0xC0	; 192
    4758:	9d eb       	ldi	r25, 0xBD	; 189
    475a:	a0 ef       	ldi	r26, 0xF0	; 240
    475c:	bf ef       	ldi	r27, 0xFF	; 255
    475e:	89 83       	std	Y+1, r24	; 0x01
    4760:	9a 83       	std	Y+2, r25	; 0x02
    4762:	ab 83       	std	Y+3, r26	; 0x03
    4764:	bc 83       	std	Y+4, r27	; 0x04
			t.F = SEARCH_FEEDRATE_X;
    4766:	82 e3       	ldi	r24, 0x32	; 50
    4768:	90 e0       	ldi	r25, 0x00	; 0
    476a:	a0 e0       	ldi	r26, 0x00	; 0
    476c:	b0 e0       	ldi	r27, 0x00	; 0
    476e:	89 8b       	std	Y+17, r24	; 0x11
    4770:	9a 8b       	std	Y+18, r25	; 0x12
    4772:	ab 8b       	std	Y+19, r26	; 0x13
    4774:	bc 8b       	std	Y+20, r27	; 0x14
			enqueue_home(&t, 0x1, 0);
    4776:	40 e0       	ldi	r20, 0x00	; 0
    4778:	61 e0       	ldi	r22, 0x01	; 1
    477a:	ce 01       	movw	r24, r28
    477c:	01 96       	adiw	r24, 0x01	; 1
    477e:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>
		#endif

		// set X home
		queue_wait();
    4782:	0e 94 66 15 	call	0x2acc	; 0x2acc <queue_wait>
		// set position to MAX
		startpoint.X = next_target.target.X = (int32_t)(X_MAX * 1000.);
    4786:	80 e4       	ldi	r24, 0x40	; 64
    4788:	9d e0       	ldi	r25, 0x0D	; 13
    478a:	a3 e0       	ldi	r26, 0x03	; 3
    478c:	b0 e0       	ldi	r27, 0x00	; 0
    478e:	80 93 8a 04 	sts	0x048A, r24
    4792:	90 93 8b 04 	sts	0x048B, r25
    4796:	a0 93 8c 04 	sts	0x048C, r26
    479a:	b0 93 8d 04 	sts	0x048D, r27
    479e:	80 93 90 02 	sts	0x0290, r24
    47a2:	90 93 91 02 	sts	0x0291, r25
    47a6:	a0 93 92 02 	sts	0x0292, r26
    47aa:	b0 93 93 02 	sts	0x0293, r27
		dda_new_startpoint();
    47ae:	0e 94 2c 07 	call	0xe58	; 0xe58 <dda_new_startpoint>
		// go to zero
		t.X = 0;
    47b2:	19 82       	std	Y+1, r1	; 0x01
    47b4:	1a 82       	std	Y+2, r1	; 0x02
    47b6:	1b 82       	std	Y+3, r1	; 0x03
    47b8:	1c 82       	std	Y+4, r1	; 0x04
		t.F = MAXIMUM_FEEDRATE_X;
    47ba:	c9 8a       	std	Y+17, r12	; 0x11
    47bc:	da 8a       	std	Y+18, r13	; 0x12
    47be:	eb 8a       	std	Y+19, r14	; 0x13
    47c0:	fc 8a       	std	Y+20, r15	; 0x14
    47c2:	40 e0       	ldi	r20, 0x00	; 0
    47c4:	60 e0       	ldi	r22, 0x00	; 0
    47c6:	ce 01       	movw	r24, r28
    47c8:	01 96       	adiw	r24, 0x01	; 1
    47ca:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>
		enqueue(&t);
	#endif
}
    47ce:	65 96       	adiw	r28, 0x15	; 21
    47d0:	0f b6       	in	r0, 0x3f	; 63
    47d2:	f8 94       	cli
    47d4:	de bf       	out	0x3e, r29	; 62
    47d6:	0f be       	out	0x3f, r0	; 63
    47d8:	cd bf       	out	0x3d, r28	; 61
    47da:	df 91       	pop	r29
    47dc:	cf 91       	pop	r28
    47de:	ff 90       	pop	r15
    47e0:	ef 90       	pop	r14
    47e2:	df 90       	pop	r13
    47e4:	cf 90       	pop	r12
    47e6:	08 95       	ret

000047e8 <home_y_negative>:

/// fund Y MIN endstop
void home_y_negative() {
    47e8:	cf 93       	push	r28
    47ea:	df 93       	push	r29
    47ec:	cd b7       	in	r28, 0x3d	; 61
    47ee:	de b7       	in	r29, 0x3e	; 62
    47f0:	65 97       	sbiw	r28, 0x15	; 21
    47f2:	0f b6       	in	r0, 0x3f	; 63
    47f4:	f8 94       	cli
    47f6:	de bf       	out	0x3e, r29	; 62
    47f8:	0f be       	out	0x3f, r0	; 63
    47fa:	cd bf       	out	0x3d, r28	; 61
	#if defined Y_MIN_PIN
		TARGET t = startpoint;
    47fc:	85 e1       	ldi	r24, 0x15	; 21
    47fe:	e0 e9       	ldi	r30, 0x90	; 144
    4800:	f2 e0       	ldi	r31, 0x02	; 2
    4802:	de 01       	movw	r26, r28
    4804:	11 96       	adiw	r26, 0x01	; 1
    4806:	01 90       	ld	r0, Z+
    4808:	0d 92       	st	X+, r0
    480a:	8a 95       	dec	r24
    480c:	e1 f7       	brne	.-8      	; 0x4806 <home_y_negative+0x1e>

		t.Y = -1000000;
    480e:	80 ec       	ldi	r24, 0xC0	; 192
    4810:	9d eb       	ldi	r25, 0xBD	; 189
    4812:	a0 ef       	ldi	r26, 0xF0	; 240
    4814:	bf ef       	ldi	r27, 0xFF	; 255
    4816:	8d 83       	std	Y+5, r24	; 0x05
    4818:	9e 83       	std	Y+6, r25	; 0x06
    481a:	af 83       	std	Y+7, r26	; 0x07
    481c:	b8 87       	std	Y+8, r27	; 0x08
		#ifdef SLOW_HOMING
			// hit home soft
			t.F = SEARCH_FEEDRATE_Y;
		#else
			// hit home hard
			t.F = MAXIMUM_FEEDRATE_Y;
    481e:	88 ec       	ldi	r24, 0xC8	; 200
    4820:	90 e0       	ldi	r25, 0x00	; 0
    4822:	a0 e0       	ldi	r26, 0x00	; 0
    4824:	b0 e0       	ldi	r27, 0x00	; 0
    4826:	89 8b       	std	Y+17, r24	; 0x11
    4828:	9a 8b       	std	Y+18, r25	; 0x12
    482a:	ab 8b       	std	Y+19, r26	; 0x13
    482c:	bc 8b       	std	Y+20, r27	; 0x14
		#endif
		enqueue_home(&t, 0x2, 1);
    482e:	41 e0       	ldi	r20, 0x01	; 1
    4830:	62 e0       	ldi	r22, 0x02	; 2
    4832:	ce 01       	movw	r24, r28
    4834:	01 96       	adiw	r24, 0x01	; 1
    4836:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>

		#ifndef SLOW_HOMING
			// back off slowly
			t.Y = +1000000;
    483a:	80 e4       	ldi	r24, 0x40	; 64
    483c:	92 e4       	ldi	r25, 0x42	; 66
    483e:	af e0       	ldi	r26, 0x0F	; 15
    4840:	b0 e0       	ldi	r27, 0x00	; 0
    4842:	8d 83       	std	Y+5, r24	; 0x05
    4844:	9e 83       	std	Y+6, r25	; 0x06
    4846:	af 83       	std	Y+7, r26	; 0x07
    4848:	b8 87       	std	Y+8, r27	; 0x08
			t.F = SEARCH_FEEDRATE_Y;
    484a:	82 e3       	ldi	r24, 0x32	; 50
    484c:	90 e0       	ldi	r25, 0x00	; 0
    484e:	a0 e0       	ldi	r26, 0x00	; 0
    4850:	b0 e0       	ldi	r27, 0x00	; 0
    4852:	89 8b       	std	Y+17, r24	; 0x11
    4854:	9a 8b       	std	Y+18, r25	; 0x12
    4856:	ab 8b       	std	Y+19, r26	; 0x13
    4858:	bc 8b       	std	Y+20, r27	; 0x14
			enqueue_home(&t, 0x2, 0);
    485a:	40 e0       	ldi	r20, 0x00	; 0
    485c:	62 e0       	ldi	r22, 0x02	; 2
    485e:	ce 01       	movw	r24, r28
    4860:	01 96       	adiw	r24, 0x01	; 1
    4862:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>
		#endif

		// set Y home
		queue_wait();
    4866:	0e 94 66 15 	call	0x2acc	; 0x2acc <queue_wait>
		#ifdef	Y_MIN
			startpoint.Y = next_target.target.Y = (int32_t)(Y_MIN * 1000.);
    486a:	10 92 8e 04 	sts	0x048E, r1
    486e:	10 92 8f 04 	sts	0x048F, r1
    4872:	10 92 90 04 	sts	0x0490, r1
    4876:	10 92 91 04 	sts	0x0491, r1
    487a:	10 92 94 02 	sts	0x0294, r1
    487e:	10 92 95 02 	sts	0x0295, r1
    4882:	10 92 96 02 	sts	0x0296, r1
    4886:	10 92 97 02 	sts	0x0297, r1
		#else
			startpoint.Y = next_target.target.Y = 0;
		#endif
		dda_new_startpoint();
    488a:	0e 94 2c 07 	call	0xe58	; 0xe58 <dda_new_startpoint>
	#endif
}
    488e:	65 96       	adiw	r28, 0x15	; 21
    4890:	0f b6       	in	r0, 0x3f	; 63
    4892:	f8 94       	cli
    4894:	de bf       	out	0x3e, r29	; 62
    4896:	0f be       	out	0x3f, r0	; 63
    4898:	cd bf       	out	0x3d, r28	; 61
    489a:	df 91       	pop	r29
    489c:	cf 91       	pop	r28
    489e:	08 95       	ret

000048a0 <home_y_positive>:

/// find Y MAX endstop
void home_y_positive() {
    48a0:	cf 92       	push	r12
    48a2:	df 92       	push	r13
    48a4:	ef 92       	push	r14
    48a6:	ff 92       	push	r15
    48a8:	cf 93       	push	r28
    48aa:	df 93       	push	r29
    48ac:	cd b7       	in	r28, 0x3d	; 61
    48ae:	de b7       	in	r29, 0x3e	; 62
    48b0:	65 97       	sbiw	r28, 0x15	; 21
    48b2:	0f b6       	in	r0, 0x3f	; 63
    48b4:	f8 94       	cli
    48b6:	de bf       	out	0x3e, r29	; 62
    48b8:	0f be       	out	0x3f, r0	; 63
    48ba:	cd bf       	out	0x3d, r28	; 61
	#if defined Y_MAX_PIN && ! defined Y_MAX
		#warning Y_MAX_PIN defined, but not Y_MAX. home_y_positive() disabled.
	#endif
	#if defined Y_MAX_PIN && defined Y_MAX
		TARGET t = startpoint;
    48bc:	85 e1       	ldi	r24, 0x15	; 21
    48be:	e0 e9       	ldi	r30, 0x90	; 144
    48c0:	f2 e0       	ldi	r31, 0x02	; 2
    48c2:	de 01       	movw	r26, r28
    48c4:	11 96       	adiw	r26, 0x01	; 1
    48c6:	01 90       	ld	r0, Z+
    48c8:	0d 92       	st	X+, r0
    48ca:	8a 95       	dec	r24
    48cc:	e1 f7       	brne	.-8      	; 0x48c6 <home_y_positive+0x26>

		t.Y = +1000000;
    48ce:	80 e4       	ldi	r24, 0x40	; 64
    48d0:	92 e4       	ldi	r25, 0x42	; 66
    48d2:	af e0       	ldi	r26, 0x0F	; 15
    48d4:	b0 e0       	ldi	r27, 0x00	; 0
    48d6:	8d 83       	std	Y+5, r24	; 0x05
    48d8:	9e 83       	std	Y+6, r25	; 0x06
    48da:	af 83       	std	Y+7, r26	; 0x07
    48dc:	b8 87       	std	Y+8, r27	; 0x08
		#ifdef SLOW_HOMING
			// hit home soft
			t.F = SEARCH_FEEDRATE_Y;
		#else
			// hit home hard
			t.F = MAXIMUM_FEEDRATE_Y;
    48de:	0f 2e       	mov	r0, r31
    48e0:	f8 ec       	ldi	r31, 0xC8	; 200
    48e2:	cf 2e       	mov	r12, r31
    48e4:	d1 2c       	mov	r13, r1
    48e6:	e1 2c       	mov	r14, r1
    48e8:	f1 2c       	mov	r15, r1
    48ea:	f0 2d       	mov	r31, r0
    48ec:	c9 8a       	std	Y+17, r12	; 0x11
    48ee:	da 8a       	std	Y+18, r13	; 0x12
    48f0:	eb 8a       	std	Y+19, r14	; 0x13
    48f2:	fc 8a       	std	Y+20, r15	; 0x14
		#endif
		enqueue_home(&t, 0x2, 1);
    48f4:	41 e0       	ldi	r20, 0x01	; 1
    48f6:	62 e0       	ldi	r22, 0x02	; 2
    48f8:	ce 01       	movw	r24, r28
    48fa:	01 96       	adiw	r24, 0x01	; 1
    48fc:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>

		#ifndef SLOW_HOMING
			// back off slowly
			t.Y = -1000000;
    4900:	80 ec       	ldi	r24, 0xC0	; 192
    4902:	9d eb       	ldi	r25, 0xBD	; 189
    4904:	a0 ef       	ldi	r26, 0xF0	; 240
    4906:	bf ef       	ldi	r27, 0xFF	; 255
    4908:	8d 83       	std	Y+5, r24	; 0x05
    490a:	9e 83       	std	Y+6, r25	; 0x06
    490c:	af 83       	std	Y+7, r26	; 0x07
    490e:	b8 87       	std	Y+8, r27	; 0x08
			t.F = SEARCH_FEEDRATE_Y;
    4910:	82 e3       	ldi	r24, 0x32	; 50
    4912:	90 e0       	ldi	r25, 0x00	; 0
    4914:	a0 e0       	ldi	r26, 0x00	; 0
    4916:	b0 e0       	ldi	r27, 0x00	; 0
    4918:	89 8b       	std	Y+17, r24	; 0x11
    491a:	9a 8b       	std	Y+18, r25	; 0x12
    491c:	ab 8b       	std	Y+19, r26	; 0x13
    491e:	bc 8b       	std	Y+20, r27	; 0x14
			enqueue_home(&t, 0x2, 0);
    4920:	40 e0       	ldi	r20, 0x00	; 0
    4922:	62 e0       	ldi	r22, 0x02	; 2
    4924:	ce 01       	movw	r24, r28
    4926:	01 96       	adiw	r24, 0x01	; 1
    4928:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>
		#endif

		// set Y home
		queue_wait();
    492c:	0e 94 66 15 	call	0x2acc	; 0x2acc <queue_wait>
		// set position to MAX
		startpoint.Y = next_target.target.Y = (int32_t)(Y_MAX * 1000.);
    4930:	80 e4       	ldi	r24, 0x40	; 64
    4932:	9d e0       	ldi	r25, 0x0D	; 13
    4934:	a3 e0       	ldi	r26, 0x03	; 3
    4936:	b0 e0       	ldi	r27, 0x00	; 0
    4938:	80 93 8e 04 	sts	0x048E, r24
    493c:	90 93 8f 04 	sts	0x048F, r25
    4940:	a0 93 90 04 	sts	0x0490, r26
    4944:	b0 93 91 04 	sts	0x0491, r27
    4948:	80 93 94 02 	sts	0x0294, r24
    494c:	90 93 95 02 	sts	0x0295, r25
    4950:	a0 93 96 02 	sts	0x0296, r26
    4954:	b0 93 97 02 	sts	0x0297, r27
		dda_new_startpoint();
    4958:	0e 94 2c 07 	call	0xe58	; 0xe58 <dda_new_startpoint>
		// go to zero
		t.Y = 0;
    495c:	1d 82       	std	Y+5, r1	; 0x05
    495e:	1e 82       	std	Y+6, r1	; 0x06
    4960:	1f 82       	std	Y+7, r1	; 0x07
    4962:	18 86       	std	Y+8, r1	; 0x08
		t.F = MAXIMUM_FEEDRATE_Y;
    4964:	c9 8a       	std	Y+17, r12	; 0x11
    4966:	da 8a       	std	Y+18, r13	; 0x12
    4968:	eb 8a       	std	Y+19, r14	; 0x13
    496a:	fc 8a       	std	Y+20, r15	; 0x14
    496c:	40 e0       	ldi	r20, 0x00	; 0
    496e:	60 e0       	ldi	r22, 0x00	; 0
    4970:	ce 01       	movw	r24, r28
    4972:	01 96       	adiw	r24, 0x01	; 1
    4974:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>
		enqueue(&t);
	#endif
}
    4978:	65 96       	adiw	r28, 0x15	; 21
    497a:	0f b6       	in	r0, 0x3f	; 63
    497c:	f8 94       	cli
    497e:	de bf       	out	0x3e, r29	; 62
    4980:	0f be       	out	0x3f, r0	; 63
    4982:	cd bf       	out	0x3d, r28	; 61
    4984:	df 91       	pop	r29
    4986:	cf 91       	pop	r28
    4988:	ff 90       	pop	r15
    498a:	ef 90       	pop	r14
    498c:	df 90       	pop	r13
    498e:	cf 90       	pop	r12
    4990:	08 95       	ret

00004992 <home_z_negative>:

/// find Z MIN endstop
void home_z_negative() {
    4992:	cf 93       	push	r28
    4994:	df 93       	push	r29
    4996:	cd b7       	in	r28, 0x3d	; 61
    4998:	de b7       	in	r29, 0x3e	; 62
    499a:	65 97       	sbiw	r28, 0x15	; 21
    499c:	0f b6       	in	r0, 0x3f	; 63
    499e:	f8 94       	cli
    49a0:	de bf       	out	0x3e, r29	; 62
    49a2:	0f be       	out	0x3f, r0	; 63
    49a4:	cd bf       	out	0x3d, r28	; 61
	#if defined Z_MIN_PIN
		TARGET t = startpoint;
    49a6:	85 e1       	ldi	r24, 0x15	; 21
    49a8:	e0 e9       	ldi	r30, 0x90	; 144
    49aa:	f2 e0       	ldi	r31, 0x02	; 2
    49ac:	de 01       	movw	r26, r28
    49ae:	11 96       	adiw	r26, 0x01	; 1
    49b0:	01 90       	ld	r0, Z+
    49b2:	0d 92       	st	X+, r0
    49b4:	8a 95       	dec	r24
    49b6:	e1 f7       	brne	.-8      	; 0x49b0 <home_z_negative+0x1e>

		t.Z = -1000000;
    49b8:	80 ec       	ldi	r24, 0xC0	; 192
    49ba:	9d eb       	ldi	r25, 0xBD	; 189
    49bc:	a0 ef       	ldi	r26, 0xF0	; 240
    49be:	bf ef       	ldi	r27, 0xFF	; 255
    49c0:	89 87       	std	Y+9, r24	; 0x09
    49c2:	9a 87       	std	Y+10, r25	; 0x0a
    49c4:	ab 87       	std	Y+11, r26	; 0x0b
    49c6:	bc 87       	std	Y+12, r27	; 0x0c
		#ifdef SLOW_HOMING
			// hit home soft
			t.F = SEARCH_FEEDRATE_Z;
		#else
			// hit home hard
			t.F = MAXIMUM_FEEDRATE_Z;
    49c8:	84 e6       	ldi	r24, 0x64	; 100
    49ca:	90 e0       	ldi	r25, 0x00	; 0
    49cc:	a0 e0       	ldi	r26, 0x00	; 0
    49ce:	b0 e0       	ldi	r27, 0x00	; 0
    49d0:	89 8b       	std	Y+17, r24	; 0x11
    49d2:	9a 8b       	std	Y+18, r25	; 0x12
    49d4:	ab 8b       	std	Y+19, r26	; 0x13
    49d6:	bc 8b       	std	Y+20, r27	; 0x14
		#endif
		enqueue_home(&t, 0x4, 1);
    49d8:	41 e0       	ldi	r20, 0x01	; 1
    49da:	64 e0       	ldi	r22, 0x04	; 4
    49dc:	ce 01       	movw	r24, r28
    49de:	01 96       	adiw	r24, 0x01	; 1
    49e0:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>

		#ifndef SLOW_HOMING
			// back off slowly
			t.Z = +1000000;
    49e4:	80 e4       	ldi	r24, 0x40	; 64
    49e6:	92 e4       	ldi	r25, 0x42	; 66
    49e8:	af e0       	ldi	r26, 0x0F	; 15
    49ea:	b0 e0       	ldi	r27, 0x00	; 0
    49ec:	89 87       	std	Y+9, r24	; 0x09
    49ee:	9a 87       	std	Y+10, r25	; 0x0a
    49f0:	ab 87       	std	Y+11, r26	; 0x0b
    49f2:	bc 87       	std	Y+12, r27	; 0x0c
			t.F = SEARCH_FEEDRATE_Z;
    49f4:	81 e0       	ldi	r24, 0x01	; 1
    49f6:	90 e0       	ldi	r25, 0x00	; 0
    49f8:	a0 e0       	ldi	r26, 0x00	; 0
    49fa:	b0 e0       	ldi	r27, 0x00	; 0
    49fc:	89 8b       	std	Y+17, r24	; 0x11
    49fe:	9a 8b       	std	Y+18, r25	; 0x12
    4a00:	ab 8b       	std	Y+19, r26	; 0x13
    4a02:	bc 8b       	std	Y+20, r27	; 0x14
			enqueue_home(&t, 0x4, 0);
    4a04:	40 e0       	ldi	r20, 0x00	; 0
    4a06:	64 e0       	ldi	r22, 0x04	; 4
    4a08:	ce 01       	movw	r24, r28
    4a0a:	01 96       	adiw	r24, 0x01	; 1
    4a0c:	0e 94 ae 14 	call	0x295c	; 0x295c <enqueue_home>
		#endif

		// set Z home
		queue_wait();
    4a10:	0e 94 66 15 	call	0x2acc	; 0x2acc <queue_wait>
		#ifdef Z_MIN
			startpoint.Z = next_target.target.Z = (int32_t)(Z_MIN * 1000.);
    4a14:	10 92 92 04 	sts	0x0492, r1
    4a18:	10 92 93 04 	sts	0x0493, r1
    4a1c:	10 92 94 04 	sts	0x0494, r1
    4a20:	10 92 95 04 	sts	0x0495, r1
    4a24:	10 92 98 02 	sts	0x0298, r1
    4a28:	10 92 99 02 	sts	0x0299, r1
    4a2c:	10 92 9a 02 	sts	0x029A, r1
    4a30:	10 92 9b 02 	sts	0x029B, r1
		#else
			startpoint.Z = next_target.target.Z = 0;
		#endif
		dda_new_startpoint();
    4a34:	0e 94 2c 07 	call	0xe58	; 0xe58 <dda_new_startpoint>
		z_disable();
	#endif
}
    4a38:	65 96       	adiw	r28, 0x15	; 21
    4a3a:	0f b6       	in	r0, 0x3f	; 63
    4a3c:	f8 94       	cli
    4a3e:	de bf       	out	0x3e, r29	; 62
    4a40:	0f be       	out	0x3f, r0	; 63
    4a42:	cd bf       	out	0x3d, r28	; 61
    4a44:	df 91       	pop	r29
    4a46:	cf 91       	pop	r28
    4a48:	08 95       	ret

00004a4a <home>:
#include	"gcode_parse.h"

/// home all 3 axes
void home() {
	#if defined	X_MIN_PIN
		home_x_negative();
    4a4a:	f9 dd       	rcall	.-1038   	; 0x463e <home_x_negative>
	#elif defined X_MAX_PIN
		home_x_positive();
	#endif

	#if defined	Y_MIN_PIN
		home_y_negative();
    4a4c:	cd de       	rcall	.-614    	; 0x47e8 <home_y_negative>
	#elif defined Y_MAX_PIN
		home_y_positive();
	#endif

	#if defined Z_MIN_PIN
		home_z_negative();
    4a4e:	a1 cf       	rjmp	.-190    	; 0x4992 <home_z_negative>

00004a50 <home_z_positive>:
		z_disable();
	#endif
}

/// find Z MAX endstop
void home_z_positive() {
    4a50:	08 95       	ret

00004a52 <io_init>:
void io_init(void) {
	// disable modules we don't use
	#ifdef PRR
		PRR = MASK(PRTWI) | MASK(PRADC) | MASK(PRSPI);
	#elif defined PRR0
		PRR0 = MASK(PRTWI) | MASK(PRADC) | MASK(PRSPI);
    4a52:	85 e8       	ldi	r24, 0x85	; 133
    4a54:	80 93 64 00 	sts	0x0064, r24
		#if defined(PRUSART3)
			// don't use USART2 or USART3- leave USART1 for GEN3 and derivatives
			PRR1 |= MASK(PRUSART3) | MASK(PRUSART2);
    4a58:	e5 e6       	ldi	r30, 0x65	; 101
    4a5a:	f0 e0       	ldi	r31, 0x00	; 0
    4a5c:	80 81       	ld	r24, Z
    4a5e:	86 60       	ori	r24, 0x06	; 6
    4a60:	80 83       	st	Z, r24
		#endif
		#if defined(PRUSART2)
			// don't use USART2 or USART3- leave USART1 for GEN3 and derivatives
			PRR1 |= MASK(PRUSART2);
    4a62:	80 81       	ld	r24, Z
    4a64:	82 60       	ori	r24, 0x02	; 2
    4a66:	80 83       	st	Z, r24
		#endif
	#endif
	ACSR = MASK(ACD);
    4a68:	80 e8       	ldi	r24, 0x80	; 128
    4a6a:	80 bf       	out	0x30, r24	; 48

	// X Stepper
	//WRITE(X_STEP_PIN, 0);	SET_OUTPUT(X_STEP_PIN);
	//WRITE(X_DIR_PIN,  0);	SET_OUTPUT(X_DIR_PIN);
	#ifdef X_MIN_PIN
		SET_INPUT(X_MIN_PIN);
    4a6c:	a1 e0       	ldi	r26, 0x01	; 1
    4a6e:	b1 e0       	ldi	r27, 0x01	; 1
    4a70:	8c 91       	ld	r24, X
    4a72:	8d 7f       	andi	r24, 0xFD	; 253
    4a74:	8c 93       	st	X, r24
		WRITE(X_MIN_PIN, 0); // pullup resistors off
    4a76:	e2 e0       	ldi	r30, 0x02	; 2
    4a78:	f1 e0       	ldi	r31, 0x01	; 1
    4a7a:	80 81       	ld	r24, Z
    4a7c:	8d 7f       	andi	r24, 0xFD	; 253
    4a7e:	80 83       	st	Z, r24
	#endif
	#ifdef X_MAX_PIN
		SET_INPUT(X_MAX_PIN);
    4a80:	8c 91       	ld	r24, X
    4a82:	8e 7f       	andi	r24, 0xFE	; 254
    4a84:	8c 93       	st	X, r24
		WRITE(X_MAX_PIN, 0); // pullup resistors off
    4a86:	80 81       	ld	r24, Z
    4a88:	8e 7f       	andi	r24, 0xFE	; 254
    4a8a:	80 83       	st	Z, r24

	// Y Stepper
	//WRITE(Y_STEP_PIN, 0);	SET_OUTPUT(Y_STEP_PIN);
	//WRITE(Y_DIR_PIN,  0);	SET_OUTPUT(Y_DIR_PIN);
	#ifdef Y_MIN_PIN
		SET_INPUT(Y_MIN_PIN);
    4a8c:	a4 e0       	ldi	r26, 0x04	; 4
    4a8e:	b1 e0       	ldi	r27, 0x01	; 1
    4a90:	8c 91       	ld	r24, X
    4a92:	8d 7f       	andi	r24, 0xFD	; 253
    4a94:	8c 93       	st	X, r24
		WRITE(Y_MIN_PIN, 0); // pullup resistors off
    4a96:	e5 e0       	ldi	r30, 0x05	; 5
    4a98:	f1 e0       	ldi	r31, 0x01	; 1
    4a9a:	80 81       	ld	r24, Z
    4a9c:	8d 7f       	andi	r24, 0xFD	; 253
    4a9e:	80 83       	st	Z, r24
	#endif
	#ifdef Y_MAX_PIN
		SET_INPUT(Y_MAX_PIN);
    4aa0:	8c 91       	ld	r24, X
    4aa2:	8e 7f       	andi	r24, 0xFE	; 254
    4aa4:	8c 93       	st	X, r24
		WRITE(Y_MAX_PIN, 0); // pullup resistors off
    4aa6:	80 81       	ld	r24, Z
    4aa8:	8e 7f       	andi	r24, 0xFE	; 254
    4aaa:	80 83       	st	Z, r24
	#endif

	// Z Stepper
	#if defined Z_STEP_PIN && defined Z_DIR_PIN
		WRITE(Z_STEP_PIN, 0);	SET_OUTPUT(Z_STEP_PIN);
    4aac:	ab e0       	ldi	r26, 0x0B	; 11
    4aae:	b1 e0       	ldi	r27, 0x01	; 1
    4ab0:	8c 91       	ld	r24, X
    4ab2:	87 7f       	andi	r24, 0xF7	; 247
    4ab4:	8c 93       	st	X, r24
    4ab6:	ea e0       	ldi	r30, 0x0A	; 10
    4ab8:	f1 e0       	ldi	r31, 0x01	; 1
    4aba:	80 81       	ld	r24, Z
    4abc:	88 60       	ori	r24, 0x08	; 8
    4abe:	80 83       	st	Z, r24
		WRITE(Z_DIR_PIN,  0);	SET_OUTPUT(Z_DIR_PIN);
    4ac0:	8c 91       	ld	r24, X
    4ac2:	8d 7f       	andi	r24, 0xFD	; 253
    4ac4:	8c 93       	st	X, r24
    4ac6:	80 81       	ld	r24, Z
    4ac8:	82 60       	ori	r24, 0x02	; 2
    4aca:	80 83       	st	Z, r24
	#endif
	#ifdef Z_MIN_PIN
		SET_INPUT(Z_MIN_PIN);
    4acc:	53 98       	cbi	0x0a, 3	; 10
		WRITE(Z_MIN_PIN, 0); // pullup resistors off
    4ace:	5b 98       	cbi	0x0b, 3	; 11
		SET_INPUT(Z_MAX_PIN);
		WRITE(Z_MAX_PIN, 0); // pullup resistors off
	#endif

	#if defined E_STEP_PIN && defined E_DIR_PIN
		WRITE(E_STEP_PIN, 0);	SET_OUTPUT(E_STEP_PIN);
    4ad0:	14 98       	cbi	0x02, 4	; 2
    4ad2:	0c 9a       	sbi	0x01, 4	; 1
		WRITE(E_DIR_PIN,  0);	SET_OUTPUT(E_DIR_PIN);
    4ad4:	16 98       	cbi	0x02, 6	; 2
    4ad6:	0e 9a       	sbi	0x01, 6	; 1
    4ad8:	08 95       	ret

00004ada <init>:
void init(void) {
	// set up watchdog
	wd_init();

	// set up serial
	serial_init();
    4ada:	29 d0       	rcall	.+82     	; 0x4b2e <serial_init>

	// set up G-code parsing
	gcode_init();
    4adc:	0e 94 64 16 	call	0x2cc8	; 0x2cc8 <gcode_init>

	// set up inputs and outputs
	io_init();
    4ae0:	b8 df       	rcall	.-144    	; 0x4a52 <io_init>

	// set up timers
	timer_init();
    4ae2:	9f d5       	rcall	.+2878   	; 0x5622 <timer_init>

	// read PID settings from EEPROM
	heater_init();
    4ae4:	03 d9       	rcall	.-3578   	; 0x3cec <heater_init>

	// set up dda
	dda_init();
    4ae6:	0e 94 98 06 	call	0xd30	; 0xd30 <dda_init>

	// start up analog read interrupt loop,
	// if any of the temp sensors in your config.h use analog interface
	analog_init();
    4aea:	0e 94 fd 04 	call	0x9fa	; 0x9fa <analog_init>

	// set up temperature inputs
	temp_init();
    4aee:	24 d3       	rcall	.+1608   	; 0x5138 <temp_init>

	// enable interrupts
	sei();
    4af0:	78 94       	sei

	// reset watchdog
	wd_reset();

	// say hi to host
	serial_writestr_P(PSTR("start\nok\n"));
    4af2:	80 e1       	ldi	r24, 0x10	; 16
    4af4:	96 e0       	ldi	r25, 0x06	; 6
    4af6:	00 c1       	rjmp	.+512    	; 0x4cf8 <serial_writestr_P>

00004af8 <main>:
/// this is where it all starts, and ends
///
/// just run init(), then run an endless loop where we pass characters from the serial RX buffer to gcode_parse_char() and check the clocks
int main (void)
{
	init();
    4af8:	f0 df       	rcall	.-32     	; 0x4ada <init>

	// main loop
	for (;;)
	{
		// if queue is full, no point in reading chars- host will just have to wait
		if ((serial_rxchars() != 0) && (queue_full() == 0)) {
    4afa:	a1 d0       	rcall	.+322    	; 0x4c3e <serial_rxchars>
    4afc:	88 23       	and	r24, r24
    4afe:	39 f0       	breq	.+14     	; 0x4b0e <main+0x16>
    4b00:	0e 94 4b 14 	call	0x2896	; 0x2896 <queue_full>
    4b04:	81 11       	cpse	r24, r1
    4b06:	03 c0       	rjmp	.+6      	; 0x4b0e <main+0x16>
			uint8_t c = serial_popchar();
    4b08:	a1 d0       	rcall	.+322    	; 0x4c4c <serial_popchar>
			gcode_parse_char(c);
    4b0a:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <gcode_parse_char>
		}

		clock();
    4b0e:	0e 94 62 05 	call	0xac4	; 0xac4 <clock>
		}
    4b12:	f3 cf       	rjmp	.-26     	; 0x4afa <main+0x2>

00004b14 <power_on>:
/// step/psu timeout
volatile uint8_t	psu_timeout = 0;

void power_on() {

	if (ps_is_on == 0) {
    4b14:	80 91 c0 04 	lds	r24, 0x04C0
    4b18:	81 11       	cpse	r24, r1
    4b1a:	03 c0       	rjmp	.+6      	; 0x4b22 <power_on+0xe>
		#ifdef	PS_ON_PIN
			WRITE(PS_ON_PIN, 0);
			SET_OUTPUT(PS_ON_PIN);
			delay_ms(500);
		#endif
		ps_is_on = 1;
    4b1c:	81 e0       	ldi	r24, 0x01	; 1
    4b1e:	80 93 c0 04 	sts	0x04C0, r24
	}

	psu_timeout = 0;
    4b22:	10 92 bf 04 	sts	0x04BF, r1
    4b26:	08 95       	ret

00004b28 <power_off>:

	#ifdef	PS_ON_PIN
		SET_INPUT(PS_ON_PIN);
	#endif

	ps_is_on = 0;
    4b28:	10 92 c0 04 	sts	0x04C0, r1
    4b2c:	08 95       	ret

00004b2e <serial_init>:
{
	int i;

	for (i = 0; i < datalen; i++)
		serial_writechar(pgm_read_byte(&data[i]));
}
    4b2e:	82 e0       	ldi	r24, 0x02	; 2
    4b30:	80 93 c0 00 	sts	0x00C0, r24
    4b34:	80 e1       	ldi	r24, 0x10	; 16
    4b36:	90 e0       	ldi	r25, 0x00	; 0
    4b38:	90 93 c5 00 	sts	0x00C5, r25
    4b3c:	80 93 c4 00 	sts	0x00C4, r24
    4b40:	e1 ec       	ldi	r30, 0xC1	; 193
    4b42:	f0 e0       	ldi	r31, 0x00	; 0
    4b44:	88 e1       	ldi	r24, 0x18	; 24
    4b46:	80 83       	st	Z, r24
    4b48:	86 e0       	ldi	r24, 0x06	; 6
    4b4a:	80 93 c2 00 	sts	0x00C2, r24
    4b4e:	80 81       	ld	r24, Z
    4b50:	80 6a       	ori	r24, 0xA0	; 160
    4b52:	80 83       	st	Z, r24
    4b54:	08 95       	ret

00004b56 <__vector_25>:
    4b56:	1f 92       	push	r1
    4b58:	0f 92       	push	r0
    4b5a:	0f b6       	in	r0, 0x3f	; 63
    4b5c:	0f 92       	push	r0
    4b5e:	11 24       	eor	r1, r1
    4b60:	0b b6       	in	r0, 0x3b	; 59
    4b62:	0f 92       	push	r0
    4b64:	2f 93       	push	r18
    4b66:	3f 93       	push	r19
    4b68:	8f 93       	push	r24
    4b6a:	9f 93       	push	r25
    4b6c:	ef 93       	push	r30
    4b6e:	ff 93       	push	r31
    4b70:	2f b7       	in	r18, 0x3f	; 63
    4b72:	80 91 c3 04 	lds	r24, 0x04C3
    4b76:	30 91 c4 04 	lds	r19, 0x04C4
    4b7a:	90 e0       	ldi	r25, 0x00	; 0
    4b7c:	83 1b       	sub	r24, r19
    4b7e:	91 09       	sbc	r25, r1
    4b80:	01 97       	sbiw	r24, 0x01	; 1
    4b82:	8f 73       	andi	r24, 0x3F	; 63
    4b84:	99 27       	eor	r25, r25
    4b86:	89 2b       	or	r24, r25
    4b88:	79 f0       	breq	.+30     	; 0x4ba8 <__vector_25+0x52>
    4b8a:	e0 91 c4 04 	lds	r30, 0x04C4
    4b8e:	f0 e0       	ldi	r31, 0x00	; 0
    4b90:	80 91 c6 00 	lds	r24, 0x00C6
    4b94:	ea 5e       	subi	r30, 0xEA	; 234
    4b96:	fa 4f       	sbci	r31, 0xFA	; 250
    4b98:	80 83       	st	Z, r24
    4b9a:	80 91 c4 04 	lds	r24, 0x04C4
    4b9e:	8f 5f       	subi	r24, 0xFF	; 255
    4ba0:	8f 73       	andi	r24, 0x3F	; 63
    4ba2:	80 93 c4 04 	sts	0x04C4, r24
    4ba6:	02 c0       	rjmp	.+4      	; 0x4bac <__vector_25+0x56>
    4ba8:	80 91 c6 00 	lds	r24, 0x00C6
    4bac:	2f bf       	out	0x3f, r18	; 63
    4bae:	ff 91       	pop	r31
    4bb0:	ef 91       	pop	r30
    4bb2:	9f 91       	pop	r25
    4bb4:	8f 91       	pop	r24
    4bb6:	3f 91       	pop	r19
    4bb8:	2f 91       	pop	r18
    4bba:	0f 90       	pop	r0
    4bbc:	0b be       	out	0x3b, r0	; 59
    4bbe:	0f 90       	pop	r0
    4bc0:	0f be       	out	0x3f, r0	; 63
    4bc2:	0f 90       	pop	r0
    4bc4:	1f 90       	pop	r1
    4bc6:	18 95       	reti

00004bc8 <__vector_26>:
    4bc8:	1f 92       	push	r1
    4bca:	0f 92       	push	r0
    4bcc:	0f b6       	in	r0, 0x3f	; 63
    4bce:	0f 92       	push	r0
    4bd0:	11 24       	eor	r1, r1
    4bd2:	0b b6       	in	r0, 0x3b	; 59
    4bd4:	0f 92       	push	r0
    4bd6:	2f 93       	push	r18
    4bd8:	3f 93       	push	r19
    4bda:	8f 93       	push	r24
    4bdc:	9f 93       	push	r25
    4bde:	ef 93       	push	r30
    4be0:	ff 93       	push	r31
    4be2:	2f b7       	in	r18, 0x3f	; 63
    4be4:	80 91 c2 04 	lds	r24, 0x04C2
    4be8:	30 91 c1 04 	lds	r19, 0x04C1
    4bec:	90 e0       	ldi	r25, 0x00	; 0
    4bee:	83 1b       	sub	r24, r19
    4bf0:	91 09       	sbc	r25, r1
    4bf2:	8f 73       	andi	r24, 0x3F	; 63
    4bf4:	99 27       	eor	r25, r25
    4bf6:	89 2b       	or	r24, r25
    4bf8:	79 f0       	breq	.+30     	; 0x4c18 <__vector_26+0x50>
    4bfa:	e0 91 c1 04 	lds	r30, 0x04C1
    4bfe:	f0 e0       	ldi	r31, 0x00	; 0
    4c00:	ea 5a       	subi	r30, 0xAA	; 170
    4c02:	fa 4f       	sbci	r31, 0xFA	; 250
    4c04:	80 81       	ld	r24, Z
    4c06:	80 93 c6 00 	sts	0x00C6, r24
    4c0a:	80 91 c1 04 	lds	r24, 0x04C1
    4c0e:	8f 5f       	subi	r24, 0xFF	; 255
    4c10:	8f 73       	andi	r24, 0x3F	; 63
    4c12:	80 93 c1 04 	sts	0x04C1, r24
    4c16:	05 c0       	rjmp	.+10     	; 0x4c22 <__vector_26+0x5a>
    4c18:	e1 ec       	ldi	r30, 0xC1	; 193
    4c1a:	f0 e0       	ldi	r31, 0x00	; 0
    4c1c:	80 81       	ld	r24, Z
    4c1e:	8f 7d       	andi	r24, 0xDF	; 223
    4c20:	80 83       	st	Z, r24
    4c22:	2f bf       	out	0x3f, r18	; 63
    4c24:	ff 91       	pop	r31
    4c26:	ef 91       	pop	r30
    4c28:	9f 91       	pop	r25
    4c2a:	8f 91       	pop	r24
    4c2c:	3f 91       	pop	r19
    4c2e:	2f 91       	pop	r18
    4c30:	0f 90       	pop	r0
    4c32:	0b be       	out	0x3b, r0	; 59
    4c34:	0f 90       	pop	r0
    4c36:	0f be       	out	0x3f, r0	; 63
    4c38:	0f 90       	pop	r0
    4c3a:	1f 90       	pop	r1
    4c3c:	18 95       	reti

00004c3e <serial_rxchars>:
    4c3e:	80 91 c4 04 	lds	r24, 0x04C4
    4c42:	90 91 c3 04 	lds	r25, 0x04C3
    4c46:	89 1b       	sub	r24, r25
    4c48:	8f 73       	andi	r24, 0x3F	; 63
    4c4a:	08 95       	ret

00004c4c <serial_popchar>:
    4c4c:	80 91 c4 04 	lds	r24, 0x04C4
    4c50:	20 91 c3 04 	lds	r18, 0x04C3
    4c54:	90 e0       	ldi	r25, 0x00	; 0
    4c56:	82 1b       	sub	r24, r18
    4c58:	91 09       	sbc	r25, r1
    4c5a:	8f 73       	andi	r24, 0x3F	; 63
    4c5c:	99 27       	eor	r25, r25
    4c5e:	89 2b       	or	r24, r25
    4c60:	69 f0       	breq	.+26     	; 0x4c7c <serial_popchar+0x30>
    4c62:	e0 91 c3 04 	lds	r30, 0x04C3
    4c66:	f0 e0       	ldi	r31, 0x00	; 0
    4c68:	ea 5e       	subi	r30, 0xEA	; 234
    4c6a:	fa 4f       	sbci	r31, 0xFA	; 250
    4c6c:	80 81       	ld	r24, Z
    4c6e:	90 91 c3 04 	lds	r25, 0x04C3
    4c72:	9f 5f       	subi	r25, 0xFF	; 255
    4c74:	9f 73       	andi	r25, 0x3F	; 63
    4c76:	90 93 c3 04 	sts	0x04C3, r25
    4c7a:	08 95       	ret
    4c7c:	80 e0       	ldi	r24, 0x00	; 0
    4c7e:	08 95       	ret

00004c80 <serial_writechar>:
    4c80:	0f b6       	in	r0, 0x3f	; 63
    4c82:	07 fe       	sbrs	r0, 7
    4c84:	1a c0       	rjmp	.+52     	; 0x4cba <serial_writechar+0x3a>
    4c86:	20 91 c1 04 	lds	r18, 0x04C1
    4c8a:	90 91 c2 04 	lds	r25, 0x04C2
    4c8e:	30 e0       	ldi	r19, 0x00	; 0
    4c90:	29 1b       	sub	r18, r25
    4c92:	31 09       	sbc	r19, r1
    4c94:	21 50       	subi	r18, 0x01	; 1
    4c96:	31 09       	sbc	r19, r1
    4c98:	2f 73       	andi	r18, 0x3F	; 63
    4c9a:	33 27       	eor	r19, r19
    4c9c:	23 2b       	or	r18, r19
    4c9e:	99 f3       	breq	.-26     	; 0x4c86 <serial_writechar+0x6>
    4ca0:	e0 91 c2 04 	lds	r30, 0x04C2
    4ca4:	f0 e0       	ldi	r31, 0x00	; 0
    4ca6:	ea 5a       	subi	r30, 0xAA	; 170
    4ca8:	fa 4f       	sbci	r31, 0xFA	; 250
    4caa:	80 83       	st	Z, r24
    4cac:	80 91 c2 04 	lds	r24, 0x04C2
    4cb0:	8f 5f       	subi	r24, 0xFF	; 255
    4cb2:	8f 73       	andi	r24, 0x3F	; 63
    4cb4:	80 93 c2 04 	sts	0x04C2, r24
    4cb8:	19 c0       	rjmp	.+50     	; 0x4cec <serial_writechar+0x6c>
    4cba:	20 91 c1 04 	lds	r18, 0x04C1
    4cbe:	90 91 c2 04 	lds	r25, 0x04C2
    4cc2:	30 e0       	ldi	r19, 0x00	; 0
    4cc4:	29 1b       	sub	r18, r25
    4cc6:	31 09       	sbc	r19, r1
    4cc8:	21 50       	subi	r18, 0x01	; 1
    4cca:	31 09       	sbc	r19, r1
    4ccc:	2f 73       	andi	r18, 0x3F	; 63
    4cce:	33 27       	eor	r19, r19
    4cd0:	23 2b       	or	r18, r19
    4cd2:	61 f0       	breq	.+24     	; 0x4cec <serial_writechar+0x6c>
    4cd4:	e0 91 c2 04 	lds	r30, 0x04C2
    4cd8:	f0 e0       	ldi	r31, 0x00	; 0
    4cda:	ea 5a       	subi	r30, 0xAA	; 170
    4cdc:	fa 4f       	sbci	r31, 0xFA	; 250
    4cde:	80 83       	st	Z, r24
    4ce0:	80 91 c2 04 	lds	r24, 0x04C2
    4ce4:	8f 5f       	subi	r24, 0xFF	; 255
    4ce6:	8f 73       	andi	r24, 0x3F	; 63
    4ce8:	80 93 c2 04 	sts	0x04C2, r24
    4cec:	e1 ec       	ldi	r30, 0xC1	; 193
    4cee:	f0 e0       	ldi	r31, 0x00	; 0
    4cf0:	80 81       	ld	r24, Z
    4cf2:	80 62       	ori	r24, 0x20	; 32
    4cf4:	80 83       	st	Z, r24
    4cf6:	08 95       	ret

00004cf8 <serial_writestr_P>:

/// Write string from FLASH
void serial_writestr_P(PGM_P data)
{
    4cf8:	1f 93       	push	r17
    4cfa:	cf 93       	push	r28
    4cfc:	df 93       	push	r29
    4cfe:	ec 01       	movw	r28, r24
	uint8_t r, i = 0;
	// yes, this is *supposed* to be assignment rather than comparison, so we break when r is assigned zero
	while ((r = pgm_read_byte(&data[i++])))
    4d00:	fc 01       	movw	r30, r24
    4d02:	84 91       	lpm	r24, Z
    4d04:	88 23       	and	r24, r24
    4d06:	49 f0       	breq	.+18     	; 0x4d1a <serial_writestr_P+0x22>
    4d08:	11 e0       	ldi	r17, 0x01	; 1
		serial_writechar(r);
    4d0a:	ba df       	rcall	.-140    	; 0x4c80 <serial_writechar>
/// Write string from FLASH
void serial_writestr_P(PGM_P data)
{
	uint8_t r, i = 0;
	// yes, this is *supposed* to be assignment rather than comparison, so we break when r is assigned zero
	while ((r = pgm_read_byte(&data[i++])))
    4d0c:	fe 01       	movw	r30, r28
    4d0e:	e1 0f       	add	r30, r17
    4d10:	f1 1d       	adc	r31, r1
    4d12:	1f 5f       	subi	r17, 0xFF	; 255
    4d14:	84 91       	lpm	r24, Z
    4d16:	81 11       	cpse	r24, r1
    4d18:	f8 cf       	rjmp	.-16     	; 0x4d0a <serial_writestr_P+0x12>
		serial_writechar(r);
}
    4d1a:	df 91       	pop	r29
    4d1c:	cf 91       	pop	r28
    4d1e:	1f 91       	pop	r17
    4d20:	08 95       	ret

00004d22 <serwrite_hex4>:

/** write a single hex digit
	\param v hex digit to write, higher nibble ignored
*/
void serwrite_hex4(uint8_t v) {
	v &= 0xF;
    4d22:	8f 70       	andi	r24, 0x0F	; 15
	if (v < 10)
    4d24:	8a 30       	cpi	r24, 0x0A	; 10
    4d26:	10 f4       	brcc	.+4      	; 0x4d2c <serwrite_hex4+0xa>
		serial_writechar('0' + v);
    4d28:	80 5d       	subi	r24, 0xD0	; 208
    4d2a:	aa cf       	rjmp	.-172    	; 0x4c80 <serial_writechar>
	else
		serial_writechar('A' - 10 + v);
    4d2c:	89 5c       	subi	r24, 0xC9	; 201
    4d2e:	a8 cf       	rjmp	.-176    	; 0x4c80 <serial_writechar>

00004d30 <serwrite_hex8>:
}

/** write a pair of hex digits
	\param v byte to write. One byte gives two hex digits
*/
void serwrite_hex8(uint8_t v) {
    4d30:	cf 93       	push	r28
    4d32:	c8 2f       	mov	r28, r24
	serwrite_hex4(v >> 4);
    4d34:	82 95       	swap	r24
    4d36:	8f 70       	andi	r24, 0x0F	; 15
    4d38:	f4 df       	rcall	.-24     	; 0x4d22 <serwrite_hex4>
	serwrite_hex4(v & 0x0F);
    4d3a:	8c 2f       	mov	r24, r28
    4d3c:	8f 70       	andi	r24, 0x0F	; 15
    4d3e:	f1 df       	rcall	.-30     	; 0x4d22 <serwrite_hex4>
}
    4d40:	cf 91       	pop	r28
    4d42:	08 95       	ret

00004d44 <serwrite_hex16>:

/** write four hex digits
	\param v word to write
*/
void serwrite_hex16(uint16_t v) {
    4d44:	cf 93       	push	r28
    4d46:	c8 2f       	mov	r28, r24
	serwrite_hex8(v >> 8);
    4d48:	89 2f       	mov	r24, r25
    4d4a:	f2 df       	rcall	.-28     	; 0x4d30 <serwrite_hex8>
	serwrite_hex8(v & 0xFF);
    4d4c:	8c 2f       	mov	r24, r28
    4d4e:	f0 df       	rcall	.-32     	; 0x4d30 <serwrite_hex8>
}
    4d50:	cf 91       	pop	r28
    4d52:	08 95       	ret

00004d54 <serwrite_hex32>:

/** write eight hex digits
	\param v long word to write
*/
void serwrite_hex32(uint32_t v) {
    4d54:	cf 92       	push	r12
    4d56:	df 92       	push	r13
    4d58:	ef 92       	push	r14
    4d5a:	ff 92       	push	r15
    4d5c:	6b 01       	movw	r12, r22
    4d5e:	7c 01       	movw	r14, r24
	serwrite_hex16(v >> 16);
    4d60:	c7 01       	movw	r24, r14
    4d62:	f0 df       	rcall	.-32     	; 0x4d44 <serwrite_hex16>
	serwrite_hex16(v & 0xFFFF);
    4d64:	c6 01       	movw	r24, r12
    4d66:	ee df       	rcall	.-36     	; 0x4d44 <serwrite_hex16>
}
    4d68:	ff 90       	pop	r15
    4d6a:	ef 90       	pop	r14
    4d6c:	df 90       	pop	r13
    4d6e:	cf 90       	pop	r12
    4d70:	08 95       	ret

00004d72 <serwrite_uint32>:
const uint32_t powers[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};

/** write decimal digits from a long unsigned int
	\param v number to send
*/
void serwrite_uint32(uint32_t v) {
    4d72:	cf 92       	push	r12
    4d74:	df 92       	push	r13
    4d76:	ef 92       	push	r14
    4d78:	ff 92       	push	r15
    4d7a:	cf 93       	push	r28
    4d7c:	df 93       	push	r29
    4d7e:	6b 01       	movw	r12, r22
    4d80:	7c 01       	movw	r14, r24
	uint8_t e, t;

	for (e = 9; e > 0; e--) {
		if (v >= powers[e])
    4d82:	c1 14       	cp	r12, r1
    4d84:	8a ec       	ldi	r24, 0xCA	; 202
    4d86:	d8 06       	cpc	r13, r24
    4d88:	8a e9       	ldi	r24, 0x9A	; 154
    4d8a:	e8 06       	cpc	r14, r24
    4d8c:	8b e3       	ldi	r24, 0x3B	; 59
    4d8e:	f8 06       	cpc	r15, r24
    4d90:	78 f4       	brcc	.+30     	; 0x4db0 <serwrite_uint32+0x3e>
    4d92:	ee e2       	ldi	r30, 0x2E	; 46
    4d94:	f2 e0       	ldi	r31, 0x02	; 2
	\param v number to send
*/
void serwrite_uint32(uint32_t v) {
	uint8_t e, t;

	for (e = 9; e > 0; e--) {
    4d96:	c8 e0       	ldi	r28, 0x08	; 8
		if (v >= powers[e])
    4d98:	b2 91       	ld	r27, -Z
    4d9a:	a2 91       	ld	r26, -Z
    4d9c:	92 91       	ld	r25, -Z
    4d9e:	82 91       	ld	r24, -Z
    4da0:	c8 16       	cp	r12, r24
    4da2:	d9 06       	cpc	r13, r25
    4da4:	ea 06       	cpc	r14, r26
    4da6:	fb 06       	cpc	r15, r27
    4da8:	38 f4       	brcc	.+14     	; 0x4db8 <serwrite_uint32+0x46>
	\param v number to send
*/
void serwrite_uint32(uint32_t v) {
	uint8_t e, t;

	for (e = 9; e > 0; e--) {
    4daa:	c1 50       	subi	r28, 0x01	; 1
    4dac:	a9 f7       	brne	.-22     	; 0x4d98 <serwrite_uint32+0x26>
    4dae:	04 c0       	rjmp	.+8      	; 0x4db8 <serwrite_uint32+0x46>
    4db0:	c9 e0       	ldi	r28, 0x09	; 9
    4db2:	02 c0       	rjmp	.+4      	; 0x4db8 <serwrite_uint32+0x46>
	do
	{
		for (t = 0; v >= powers[e]; v -= powers[e], t++);
		serial_writechar(t + '0');
	}
	while (e--);
    4db4:	c8 2f       	mov	r28, r24
    4db6:	01 c0       	rjmp	.+2      	; 0x4dba <serwrite_uint32+0x48>
			break;
	}

	do
	{
		for (t = 0; v >= powers[e]; v -= powers[e], t++);
    4db8:	d0 e0       	ldi	r29, 0x00	; 0
    4dba:	ec 2f       	mov	r30, r28
    4dbc:	f0 e0       	ldi	r31, 0x00	; 0
    4dbe:	ee 0f       	add	r30, r30
    4dc0:	ff 1f       	adc	r31, r31
    4dc2:	ee 0f       	add	r30, r30
    4dc4:	ff 1f       	adc	r31, r31
    4dc6:	e6 5f       	subi	r30, 0xF6	; 246
    4dc8:	fd 4f       	sbci	r31, 0xFD	; 253
    4dca:	40 81       	ld	r20, Z
    4dcc:	51 81       	ldd	r21, Z+1	; 0x01
    4dce:	62 81       	ldd	r22, Z+2	; 0x02
    4dd0:	73 81       	ldd	r23, Z+3	; 0x03
    4dd2:	c4 16       	cp	r12, r20
    4dd4:	d5 06       	cpc	r13, r21
    4dd6:	e6 06       	cpc	r14, r22
    4dd8:	f7 06       	cpc	r15, r23
    4dda:	60 f0       	brcs	.+24     	; 0x4df4 <serwrite_uint32+0x82>
    4ddc:	8d 2f       	mov	r24, r29
const uint32_t powers[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};

/** write decimal digits from a long unsigned int
	\param v number to send
*/
void serwrite_uint32(uint32_t v) {
    4dde:	c4 1a       	sub	r12, r20
    4de0:	d5 0a       	sbc	r13, r21
    4de2:	e6 0a       	sbc	r14, r22
    4de4:	f7 0a       	sbc	r15, r23
			break;
	}

	do
	{
		for (t = 0; v >= powers[e]; v -= powers[e], t++);
    4de6:	8f 5f       	subi	r24, 0xFF	; 255
    4de8:	c4 16       	cp	r12, r20
    4dea:	d5 06       	cpc	r13, r21
    4dec:	e6 06       	cpc	r14, r22
    4dee:	f7 06       	cpc	r15, r23
    4df0:	b0 f7       	brcc	.-20     	; 0x4dde <serwrite_uint32+0x6c>
    4df2:	01 c0       	rjmp	.+2      	; 0x4df6 <serwrite_uint32+0x84>
    4df4:	8d 2f       	mov	r24, r29
		serial_writechar(t + '0');
    4df6:	80 5d       	subi	r24, 0xD0	; 208
    4df8:	43 df       	rcall	.-378    	; 0x4c80 <serial_writechar>
	}
	while (e--);
    4dfa:	8c 2f       	mov	r24, r28
    4dfc:	81 50       	subi	r24, 0x01	; 1
    4dfe:	c1 11       	cpse	r28, r1
    4e00:	d9 cf       	rjmp	.-78     	; 0x4db4 <serwrite_uint32+0x42>
}
    4e02:	df 91       	pop	r29
    4e04:	cf 91       	pop	r28
    4e06:	ff 90       	pop	r15
    4e08:	ef 90       	pop	r14
    4e0a:	df 90       	pop	r13
    4e0c:	cf 90       	pop	r12
    4e0e:	08 95       	ret

00004e10 <serwrite_int32>:

/** write decimal digits from a long signed int
	\param v number to send
*/
void serwrite_int32(int32_t v) {
    4e10:	cf 92       	push	r12
    4e12:	df 92       	push	r13
    4e14:	ef 92       	push	r14
    4e16:	ff 92       	push	r15
    4e18:	6b 01       	movw	r12, r22
    4e1a:	7c 01       	movw	r14, r24
	if (v < 0) {
    4e1c:	99 23       	and	r25, r25
    4e1e:	54 f4       	brge	.+20     	; 0x4e34 <serwrite_int32+0x24>
		serial_writechar('-');
    4e20:	8d e2       	ldi	r24, 0x2D	; 45
    4e22:	2e df       	rcall	.-420    	; 0x4c80 <serial_writechar>
		v = -v;
    4e24:	f0 94       	com	r15
    4e26:	e0 94       	com	r14
    4e28:	d0 94       	com	r13
    4e2a:	c0 94       	com	r12
    4e2c:	c1 1c       	adc	r12, r1
    4e2e:	d1 1c       	adc	r13, r1
    4e30:	e1 1c       	adc	r14, r1
    4e32:	f1 1c       	adc	r15, r1
	}

	serwrite_uint32(v);
    4e34:	c7 01       	movw	r24, r14
    4e36:	b6 01       	movw	r22, r12
    4e38:	9c df       	rcall	.-200    	; 0x4d72 <serwrite_uint32>
}
    4e3a:	ff 90       	pop	r15
    4e3c:	ef 90       	pop	r14
    4e3e:	df 90       	pop	r13
    4e40:	cf 90       	pop	r12
    4e42:	08 95       	ret

00004e44 <serwrite_uint32_vf>:

/** write decimal digits from a long unsigned int
\param v number to send
*/
void serwrite_uint32_vf(uint32_t v, uint8_t fp) {
    4e44:	bf 92       	push	r11
    4e46:	cf 92       	push	r12
    4e48:	df 92       	push	r13
    4e4a:	ef 92       	push	r14
    4e4c:	ff 92       	push	r15
    4e4e:	0f 93       	push	r16
    4e50:	1f 93       	push	r17
    4e52:	cf 93       	push	r28
    4e54:	df 93       	push	r29
    4e56:	6b 01       	movw	r12, r22
    4e58:	7c 01       	movw	r14, r24
    4e5a:	c4 2f       	mov	r28, r20
	uint8_t e, t;

	for (e = 9; e > 0; e--) {
		if (v >= powers[e])
    4e5c:	c1 14       	cp	r12, r1
    4e5e:	8a ec       	ldi	r24, 0xCA	; 202
    4e60:	d8 06       	cpc	r13, r24
    4e62:	8a e9       	ldi	r24, 0x9A	; 154
    4e64:	e8 06       	cpc	r14, r24
    4e66:	8b e3       	ldi	r24, 0x3B	; 59
    4e68:	f8 06       	cpc	r15, r24
    4e6a:	78 f4       	brcc	.+30     	; 0x4e8a <serwrite_uint32_vf+0x46>
    4e6c:	ee e2       	ldi	r30, 0x2E	; 46
    4e6e:	f2 e0       	ldi	r31, 0x02	; 2
\param v number to send
*/
void serwrite_uint32_vf(uint32_t v, uint8_t fp) {
	uint8_t e, t;

	for (e = 9; e > 0; e--) {
    4e70:	d8 e0       	ldi	r29, 0x08	; 8
		if (v >= powers[e])
    4e72:	b2 91       	ld	r27, -Z
    4e74:	a2 91       	ld	r26, -Z
    4e76:	92 91       	ld	r25, -Z
    4e78:	82 91       	ld	r24, -Z
    4e7a:	c8 16       	cp	r12, r24
    4e7c:	d9 06       	cpc	r13, r25
    4e7e:	ea 06       	cpc	r14, r26
    4e80:	fb 06       	cpc	r15, r27
    4e82:	20 f4       	brcc	.+8      	; 0x4e8c <serwrite_uint32_vf+0x48>
\param v number to send
*/
void serwrite_uint32_vf(uint32_t v, uint8_t fp) {
	uint8_t e, t;

	for (e = 9; e > 0; e--) {
    4e84:	d1 50       	subi	r29, 0x01	; 1
    4e86:	a9 f7       	brne	.-22     	; 0x4e72 <serwrite_uint32_vf+0x2e>
    4e88:	01 c0       	rjmp	.+2      	; 0x4e8c <serwrite_uint32_vf+0x48>
    4e8a:	d9 e0       	ldi	r29, 0x09	; 9
    4e8c:	dc 17       	cp	r29, r28
    4e8e:	20 f4       	brcc	.+8      	; 0x4e98 <serwrite_uint32_vf+0x54>
    4e90:	dc 2f       	mov	r29, r28
    4e92:	02 c0       	rjmp	.+4      	; 0x4e98 <serwrite_uint32_vf+0x54>
		for (t = 0; v >= powers[e]; v -= powers[e], t++);
		serial_writechar(t + '0');
		if (e == fp)
			serial_writechar('.');
	}
	while (e--);
    4e94:	d8 2f       	mov	r29, r24
    4e96:	01 c0       	rjmp	.+2      	; 0x4e9a <serwrite_uint32_vf+0x56>
	if (e < fp)
		e = fp;

	do
	{
		for (t = 0; v >= powers[e]; v -= powers[e], t++);
    4e98:	b1 2c       	mov	r11, r1
    4e9a:	ed 2f       	mov	r30, r29
    4e9c:	f0 e0       	ldi	r31, 0x00	; 0
    4e9e:	ee 0f       	add	r30, r30
    4ea0:	ff 1f       	adc	r31, r31
    4ea2:	ee 0f       	add	r30, r30
    4ea4:	ff 1f       	adc	r31, r31
    4ea6:	e6 5f       	subi	r30, 0xF6	; 246
    4ea8:	fd 4f       	sbci	r31, 0xFD	; 253
    4eaa:	00 81       	ld	r16, Z
    4eac:	11 81       	ldd	r17, Z+1	; 0x01
    4eae:	22 81       	ldd	r18, Z+2	; 0x02
    4eb0:	33 81       	ldd	r19, Z+3	; 0x03
    4eb2:	c0 16       	cp	r12, r16
    4eb4:	d1 06       	cpc	r13, r17
    4eb6:	e2 06       	cpc	r14, r18
    4eb8:	f3 06       	cpc	r15, r19
    4eba:	60 f0       	brcs	.+24     	; 0x4ed4 <serwrite_uint32_vf+0x90>
    4ebc:	8b 2d       	mov	r24, r11
}

/** write decimal digits from a long unsigned int
\param v number to send
*/
void serwrite_uint32_vf(uint32_t v, uint8_t fp) {
    4ebe:	c0 1a       	sub	r12, r16
    4ec0:	d1 0a       	sbc	r13, r17
    4ec2:	e2 0a       	sbc	r14, r18
    4ec4:	f3 0a       	sbc	r15, r19
	if (e < fp)
		e = fp;

	do
	{
		for (t = 0; v >= powers[e]; v -= powers[e], t++);
    4ec6:	8f 5f       	subi	r24, 0xFF	; 255
    4ec8:	c0 16       	cp	r12, r16
    4eca:	d1 06       	cpc	r13, r17
    4ecc:	e2 06       	cpc	r14, r18
    4ece:	f3 06       	cpc	r15, r19
    4ed0:	b0 f7       	brcc	.-20     	; 0x4ebe <serwrite_uint32_vf+0x7a>
    4ed2:	01 c0       	rjmp	.+2      	; 0x4ed6 <serwrite_uint32_vf+0x92>
    4ed4:	8b 2d       	mov	r24, r11
		serial_writechar(t + '0');
    4ed6:	80 5d       	subi	r24, 0xD0	; 208
    4ed8:	d3 de       	rcall	.-602    	; 0x4c80 <serial_writechar>
		if (e == fp)
    4eda:	dc 13       	cpse	r29, r28
    4edc:	02 c0       	rjmp	.+4      	; 0x4ee2 <serwrite_uint32_vf+0x9e>
			serial_writechar('.');
    4ede:	8e e2       	ldi	r24, 0x2E	; 46
    4ee0:	cf de       	rcall	.-610    	; 0x4c80 <serial_writechar>
	}
	while (e--);
    4ee2:	8d 2f       	mov	r24, r29
    4ee4:	81 50       	subi	r24, 0x01	; 1
    4ee6:	d1 11       	cpse	r29, r1
    4ee8:	d5 cf       	rjmp	.-86     	; 0x4e94 <serwrite_uint32_vf+0x50>
}
    4eea:	df 91       	pop	r29
    4eec:	cf 91       	pop	r28
    4eee:	1f 91       	pop	r17
    4ef0:	0f 91       	pop	r16
    4ef2:	ff 90       	pop	r15
    4ef4:	ef 90       	pop	r14
    4ef6:	df 90       	pop	r13
    4ef8:	cf 90       	pop	r12
    4efa:	bf 90       	pop	r11
    4efc:	08 95       	ret

00004efe <serwrite_int32_vf>:

/** write decimal digits from a long signed int
\param v number to send
*/
void serwrite_int32_vf(int32_t v, uint8_t fp) {
    4efe:	cf 92       	push	r12
    4f00:	df 92       	push	r13
    4f02:	ef 92       	push	r14
    4f04:	ff 92       	push	r15
    4f06:	cf 93       	push	r28
    4f08:	6b 01       	movw	r12, r22
    4f0a:	7c 01       	movw	r14, r24
    4f0c:	c4 2f       	mov	r28, r20
	if (v < 0) {
    4f0e:	99 23       	and	r25, r25
    4f10:	54 f4       	brge	.+20     	; 0x4f26 <serwrite_int32_vf+0x28>
		serial_writechar('-');
    4f12:	8d e2       	ldi	r24, 0x2D	; 45
    4f14:	b5 de       	rcall	.-662    	; 0x4c80 <serial_writechar>
		v = -v;
    4f16:	f0 94       	com	r15
    4f18:	e0 94       	com	r14
    4f1a:	d0 94       	com	r13
    4f1c:	c0 94       	com	r12
    4f1e:	c1 1c       	adc	r12, r1
    4f20:	d1 1c       	adc	r13, r1
    4f22:	e1 1c       	adc	r14, r1
    4f24:	f1 1c       	adc	r15, r1
	}

	serwrite_uint32_vf(v, fp);
    4f26:	4c 2f       	mov	r20, r28
    4f28:	c7 01       	movw	r24, r14
    4f2a:	b6 01       	movw	r22, r12
    4f2c:	8b df       	rcall	.-234    	; 0x4e44 <serwrite_uint32_vf>
}
    4f2e:	cf 91       	pop	r28
    4f30:	ff 90       	pop	r15
    4f32:	ef 90       	pop	r14
    4f34:	df 90       	pop	r13
    4f36:	cf 90       	pop	r12
    4f38:	08 95       	ret

00004f3a <sersendf_P>:

	Example:

	\code sersendf_P(PSTR("X:%ld Y:%ld temp:%u.%d flags:%sx Q%su/%su%c\n"), target.X, target.Y, current_temp >> 2, (current_temp & 3) * 25, dda.allflags, mb_head, mb_tail, (queue_full()?'F':(queue_empty()?'E':' '))) \endcode
*/
void sersendf_P(PGM_P format, ...) {
    4f3a:	8f 92       	push	r8
    4f3c:	9f 92       	push	r9
    4f3e:	af 92       	push	r10
    4f40:	bf 92       	push	r11
    4f42:	cf 92       	push	r12
    4f44:	df 92       	push	r13
    4f46:	ef 92       	push	r14
    4f48:	ff 92       	push	r15
    4f4a:	0f 93       	push	r16
    4f4c:	1f 93       	push	r17
    4f4e:	cf 93       	push	r28
    4f50:	df 93       	push	r29
    4f52:	cd b7       	in	r28, 0x3d	; 61
    4f54:	de b7       	in	r29, 0x3e	; 62
	va_list args;
	va_start(args, format);
    4f56:	7e 01       	movw	r14, r28
    4f58:	82 e1       	ldi	r24, 0x12	; 18
    4f5a:	e8 0e       	add	r14, r24
    4f5c:	f1 1c       	adc	r15, r1
    4f5e:	08 89       	ldd	r16, Y+16	; 0x10
    4f60:	19 89       	ldd	r17, Y+17	; 0x11

	uint16_t i = 0;
	uint8_t c = 1, j = 0;
    4f62:	d1 2c       	mov	r13, r1
					break;
			}
		}
		else {
			if (c == '%') {
				j = 2;
    4f64:	68 94       	set
    4f66:	aa 24       	eor	r10, r10
    4f68:	a1 f8       	bld	r10, 1
					break;
/*				case 'p':
					serwrite_hex16(va_arg(args, uint16_t));*/
				case 'q':
					serwrite_int32_vf(va_arg(args, int32_t), 3);
					j = 0;
    4f6a:	b1 2c       	mov	r11, r1
	uint8_t c = 1, j = 0;
	while ((c = pgm_read_byte(&format[i++]))) {
		if (j) {
			switch(c) {
				case 's':
					j = 1;
    4f6c:	99 24       	eor	r9, r9
    4f6e:	93 94       	inc	r9
					break;
				case 'l':
					j = 4;
    4f70:	68 94       	set
    4f72:	88 24       	eor	r8, r8
    4f74:	82 f8       	bld	r8, 2
	va_list args;
	va_start(args, format);

	uint16_t i = 0;
	uint8_t c = 1, j = 0;
	while ((c = pgm_read_byte(&format[i++]))) {
    4f76:	a5 c0       	rjmp	.+330    	; 0x50c2 <sersendf_P+0x188>
		if (j) {
    4f78:	dd 20       	and	r13, r13
    4f7a:	09 f4       	brne	.+2      	; 0x4f7e <sersendf_P+0x44>
    4f7c:	99 c0       	rjmp	.+306    	; 0x50b0 <sersendf_P+0x176>
			switch(c) {
    4f7e:	81 37       	cpi	r24, 0x71	; 113
    4f80:	09 f4       	brne	.+2      	; 0x4f84 <sersendf_P+0x4a>
    4f82:	85 c0       	rjmp	.+266    	; 0x508e <sersendf_P+0x154>
    4f84:	48 f4       	brcc	.+18     	; 0x4f98 <sersendf_P+0x5e>
    4f86:	84 36       	cpi	r24, 0x64	; 100
    4f88:	71 f1       	breq	.+92     	; 0x4fe6 <sersendf_P+0xac>
    4f8a:	8c 36       	cpi	r24, 0x6C	; 108
    4f8c:	09 f4       	brne	.+2      	; 0x4f90 <sersendf_P+0x56>
    4f8e:	94 c0       	rjmp	.+296    	; 0x50b8 <sersendf_P+0x17e>
    4f90:	83 36       	cpi	r24, 0x63	; 99
    4f92:	09 f0       	breq	.+2      	; 0x4f96 <sersendf_P+0x5c>
    4f94:	8a c0       	rjmp	.+276    	; 0x50aa <sersendf_P+0x170>
    4f96:	46 c0       	rjmp	.+140    	; 0x5024 <sersendf_P+0xea>
    4f98:	85 37       	cpi	r24, 0x75	; 117
    4f9a:	41 f0       	breq	.+16     	; 0x4fac <sersendf_P+0x72>
    4f9c:	88 37       	cpi	r24, 0x78	; 120
    4f9e:	09 f4       	brne	.+2      	; 0x4fa2 <sersendf_P+0x68>
    4fa0:	4b c0       	rjmp	.+150    	; 0x5038 <sersendf_P+0xfe>
    4fa2:	83 37       	cpi	r24, 0x73	; 115
    4fa4:	09 f0       	breq	.+2      	; 0x4fa8 <sersendf_P+0x6e>
    4fa6:	81 c0       	rjmp	.+258    	; 0x50aa <sersendf_P+0x170>
				case 's':
					j = 1;
    4fa8:	d9 2c       	mov	r13, r9
    4faa:	89 c0       	rjmp	.+274    	; 0x50be <sersendf_P+0x184>
					break;
				case 'l':
					j = 4;
					break;
				case 'u':
					if (j == 4)
    4fac:	e4 e0       	ldi	r30, 0x04	; 4
    4fae:	de 12       	cpse	r13, r30
    4fb0:	0d c0       	rjmp	.+26     	; 0x4fcc <sersendf_P+0x92>
						serwrite_uint32(va_arg(args, uint32_t));
    4fb2:	67 01       	movw	r12, r14
    4fb4:	f4 e0       	ldi	r31, 0x04	; 4
    4fb6:	cf 0e       	add	r12, r31
    4fb8:	d1 1c       	adc	r13, r1
    4fba:	f7 01       	movw	r30, r14
    4fbc:	60 81       	ld	r22, Z
    4fbe:	71 81       	ldd	r23, Z+1	; 0x01
    4fc0:	82 81       	ldd	r24, Z+2	; 0x02
    4fc2:	93 81       	ldd	r25, Z+3	; 0x03
    4fc4:	d6 de       	rcall	.-596    	; 0x4d72 <serwrite_uint32>
    4fc6:	76 01       	movw	r14, r12
					else
						serwrite_uint16(va_arg(args, uint16_t));
					j = 0;
    4fc8:	db 2c       	mov	r13, r11
    4fca:	79 c0       	rjmp	.+242    	; 0x50be <sersendf_P+0x184>
					break;
				case 'u':
					if (j == 4)
						serwrite_uint32(va_arg(args, uint32_t));
					else
						serwrite_uint16(va_arg(args, uint16_t));
    4fcc:	67 01       	movw	r12, r14
    4fce:	f2 e0       	ldi	r31, 0x02	; 2
    4fd0:	cf 0e       	add	r12, r31
    4fd2:	d1 1c       	adc	r13, r1
    4fd4:	f7 01       	movw	r30, r14
    4fd6:	60 81       	ld	r22, Z
    4fd8:	71 81       	ldd	r23, Z+1	; 0x01
    4fda:	80 e0       	ldi	r24, 0x00	; 0
    4fdc:	90 e0       	ldi	r25, 0x00	; 0
    4fde:	c9 de       	rcall	.-622    	; 0x4d72 <serwrite_uint32>
    4fe0:	76 01       	movw	r14, r12
					j = 0;
    4fe2:	db 2c       	mov	r13, r11
    4fe4:	6c c0       	rjmp	.+216    	; 0x50be <sersendf_P+0x184>
					break;
				case 'd':
					if (j == 4)
    4fe6:	f4 e0       	ldi	r31, 0x04	; 4
    4fe8:	df 12       	cpse	r13, r31
    4fea:	0d c0       	rjmp	.+26     	; 0x5006 <sersendf_P+0xcc>
						serwrite_int32(va_arg(args, int32_t));
    4fec:	67 01       	movw	r12, r14
    4fee:	84 e0       	ldi	r24, 0x04	; 4
    4ff0:	c8 0e       	add	r12, r24
    4ff2:	d1 1c       	adc	r13, r1
    4ff4:	f7 01       	movw	r30, r14
    4ff6:	60 81       	ld	r22, Z
    4ff8:	71 81       	ldd	r23, Z+1	; 0x01
    4ffa:	82 81       	ldd	r24, Z+2	; 0x02
    4ffc:	93 81       	ldd	r25, Z+3	; 0x03
    4ffe:	08 df       	rcall	.-496    	; 0x4e10 <serwrite_int32>
    5000:	76 01       	movw	r14, r12
					else
						serwrite_int16(va_arg(args, int16_t));
					j = 0;
    5002:	db 2c       	mov	r13, r11
    5004:	5c c0       	rjmp	.+184    	; 0x50be <sersendf_P+0x184>
					break;
				case 'd':
					if (j == 4)
						serwrite_int32(va_arg(args, int32_t));
					else
						serwrite_int16(va_arg(args, int16_t));
    5006:	67 01       	movw	r12, r14
    5008:	f2 e0       	ldi	r31, 0x02	; 2
    500a:	cf 0e       	add	r12, r31
    500c:	d1 1c       	adc	r13, r1
    500e:	f7 01       	movw	r30, r14
    5010:	60 81       	ld	r22, Z
    5012:	71 81       	ldd	r23, Z+1	; 0x01
    5014:	88 27       	eor	r24, r24
    5016:	77 fd       	sbrc	r23, 7
    5018:	80 95       	com	r24
    501a:	98 2f       	mov	r25, r24
    501c:	f9 de       	rcall	.-526    	; 0x4e10 <serwrite_int32>
    501e:	76 01       	movw	r14, r12
					j = 0;
    5020:	db 2c       	mov	r13, r11
    5022:	4d c0       	rjmp	.+154    	; 0x50be <sersendf_P+0x184>
					break;
				case 'c':
					serial_writechar(va_arg(args, uint16_t));
    5024:	67 01       	movw	r12, r14
    5026:	f2 e0       	ldi	r31, 0x02	; 2
    5028:	cf 0e       	add	r12, r31
    502a:	d1 1c       	adc	r13, r1
    502c:	f7 01       	movw	r30, r14
    502e:	80 81       	ld	r24, Z
    5030:	27 de       	rcall	.-946    	; 0x4c80 <serial_writechar>
    5032:	76 01       	movw	r14, r12
					j = 0;
    5034:	db 2c       	mov	r13, r11
					break;
    5036:	43 c0       	rjmp	.+134    	; 0x50be <sersendf_P+0x184>
				case 'x':
					serial_writestr_P(PSTR("0x"));
    5038:	8a e1       	ldi	r24, 0x1A	; 26
    503a:	96 e0       	ldi	r25, 0x06	; 6
    503c:	5d de       	rcall	.-838    	; 0x4cf8 <serial_writestr_P>
					if (j == 4)
    503e:	f4 e0       	ldi	r31, 0x04	; 4
    5040:	df 12       	cpse	r13, r31
    5042:	0d c0       	rjmp	.+26     	; 0x505e <sersendf_P+0x124>
						serwrite_hex32(va_arg(args, uint32_t));
    5044:	67 01       	movw	r12, r14
    5046:	84 e0       	ldi	r24, 0x04	; 4
    5048:	c8 0e       	add	r12, r24
    504a:	d1 1c       	adc	r13, r1
    504c:	f7 01       	movw	r30, r14
    504e:	60 81       	ld	r22, Z
    5050:	71 81       	ldd	r23, Z+1	; 0x01
    5052:	82 81       	ldd	r24, Z+2	; 0x02
    5054:	93 81       	ldd	r25, Z+3	; 0x03
    5056:	7e de       	rcall	.-772    	; 0x4d54 <serwrite_hex32>
    5058:	76 01       	movw	r14, r12
					else if (j == 1)
						serwrite_hex8(va_arg(args, uint16_t));
					else
						serwrite_hex16(va_arg(args, uint16_t));
					j = 0;
    505a:	db 2c       	mov	r13, r11
    505c:	30 c0       	rjmp	.+96     	; 0x50be <sersendf_P+0x184>
					break;
				case 'x':
					serial_writestr_P(PSTR("0x"));
					if (j == 4)
						serwrite_hex32(va_arg(args, uint32_t));
					else if (j == 1)
    505e:	f1 e0       	ldi	r31, 0x01	; 1
    5060:	df 12       	cpse	r13, r31
    5062:	0a c0       	rjmp	.+20     	; 0x5078 <sersendf_P+0x13e>
						serwrite_hex8(va_arg(args, uint16_t));
    5064:	67 01       	movw	r12, r14
    5066:	82 e0       	ldi	r24, 0x02	; 2
    5068:	c8 0e       	add	r12, r24
    506a:	d1 1c       	adc	r13, r1
    506c:	f7 01       	movw	r30, r14
    506e:	80 81       	ld	r24, Z
    5070:	5f de       	rcall	.-834    	; 0x4d30 <serwrite_hex8>
    5072:	76 01       	movw	r14, r12
					else
						serwrite_hex16(va_arg(args, uint16_t));
					j = 0;
    5074:	db 2c       	mov	r13, r11
    5076:	23 c0       	rjmp	.+70     	; 0x50be <sersendf_P+0x184>
					if (j == 4)
						serwrite_hex32(va_arg(args, uint32_t));
					else if (j == 1)
						serwrite_hex8(va_arg(args, uint16_t));
					else
						serwrite_hex16(va_arg(args, uint16_t));
    5078:	67 01       	movw	r12, r14
    507a:	f2 e0       	ldi	r31, 0x02	; 2
    507c:	cf 0e       	add	r12, r31
    507e:	d1 1c       	adc	r13, r1
    5080:	f7 01       	movw	r30, r14
    5082:	80 81       	ld	r24, Z
    5084:	91 81       	ldd	r25, Z+1	; 0x01
    5086:	5e de       	rcall	.-836    	; 0x4d44 <serwrite_hex16>
    5088:	76 01       	movw	r14, r12
					j = 0;
    508a:	db 2c       	mov	r13, r11
    508c:	18 c0       	rjmp	.+48     	; 0x50be <sersendf_P+0x184>
					break;
/*				case 'p':
					serwrite_hex16(va_arg(args, uint16_t));*/
				case 'q':
					serwrite_int32_vf(va_arg(args, int32_t), 3);
    508e:	67 01       	movw	r12, r14
    5090:	f4 e0       	ldi	r31, 0x04	; 4
    5092:	cf 0e       	add	r12, r31
    5094:	d1 1c       	adc	r13, r1
    5096:	f7 01       	movw	r30, r14
    5098:	60 81       	ld	r22, Z
    509a:	71 81       	ldd	r23, Z+1	; 0x01
    509c:	82 81       	ldd	r24, Z+2	; 0x02
    509e:	93 81       	ldd	r25, Z+3	; 0x03
    50a0:	43 e0       	ldi	r20, 0x03	; 3
    50a2:	2d df       	rcall	.-422    	; 0x4efe <serwrite_int32_vf>
    50a4:	76 01       	movw	r14, r12
					j = 0;
    50a6:	db 2c       	mov	r13, r11
					break;
    50a8:	0a c0       	rjmp	.+20     	; 0x50be <sersendf_P+0x184>
				default:
					serial_writechar(c);
    50aa:	ea dd       	rcall	.-1068   	; 0x4c80 <serial_writechar>
					j = 0;
    50ac:	db 2c       	mov	r13, r11
					break;
    50ae:	07 c0       	rjmp	.+14     	; 0x50be <sersendf_P+0x184>
			}
		}
		else {
			if (c == '%') {
    50b0:	85 32       	cpi	r24, 0x25	; 37
    50b2:	21 f0       	breq	.+8      	; 0x50bc <sersendf_P+0x182>
				j = 2;
			}
			else {
				serial_writechar(c);
    50b4:	e5 dd       	rcall	.-1078   	; 0x4c80 <serial_writechar>
    50b6:	03 c0       	rjmp	.+6      	; 0x50be <sersendf_P+0x184>
			switch(c) {
				case 's':
					j = 1;
					break;
				case 'l':
					j = 4;
    50b8:	d8 2c       	mov	r13, r8
    50ba:	01 c0       	rjmp	.+2      	; 0x50be <sersendf_P+0x184>
					break;
			}
		}
		else {
			if (c == '%') {
				j = 2;
    50bc:	da 2c       	mov	r13, r10
    50be:	0f 5f       	subi	r16, 0xFF	; 255
    50c0:	1f 4f       	sbci	r17, 0xFF	; 255
	va_list args;
	va_start(args, format);

	uint16_t i = 0;
	uint8_t c = 1, j = 0;
	while ((c = pgm_read_byte(&format[i++]))) {
    50c2:	f8 01       	movw	r30, r16
    50c4:	84 91       	lpm	r24, Z
    50c6:	81 11       	cpse	r24, r1
    50c8:	57 cf       	rjmp	.-338    	; 0x4f78 <sersendf_P+0x3e>
				serial_writechar(c);
			}
		}
	}
	va_end(args);
}
    50ca:	df 91       	pop	r29
    50cc:	cf 91       	pop	r28
    50ce:	1f 91       	pop	r17
    50d0:	0f 91       	pop	r16
    50d2:	ff 90       	pop	r15
    50d4:	ef 90       	pop	r14
    50d6:	df 90       	pop	r13
    50d8:	cf 90       	pop	r12
    50da:	bf 90       	pop	r11
    50dc:	af 90       	pop	r10
    50de:	9f 90       	pop	r9
    50e0:	8f 90       	pop	r8
    50e2:	08 95       	ret

000050e4 <single_temp_print>:
uint16_t temp_get(temp_sensor_t index) {
	if (index >= NUM_TEMP_SENSORS)
		return 0;

	return temp_sensors_runtime[index].last_read_temp;
}
    50e4:	90 e0       	ldi	r25, 0x00	; 0
    50e6:	fc 01       	movw	r30, r24
    50e8:	ee 0f       	add	r30, r30
    50ea:	ff 1f       	adc	r31, r31
    50ec:	ee 0f       	add	r30, r30
    50ee:	ff 1f       	adc	r31, r31
    50f0:	ee 0f       	add	r30, r30
    50f2:	ff 1f       	adc	r31, r31
    50f4:	8e 0f       	add	r24, r30
    50f6:	9f 1f       	adc	r25, r31
    50f8:	fc 01       	movw	r30, r24
    50fa:	ea 56       	subi	r30, 0x6A	; 106
    50fc:	fa 4f       	sbci	r31, 0xFA	; 250
    50fe:	81 81       	ldd	r24, Z+1	; 0x01
    5100:	92 81       	ldd	r25, Z+2	; 0x02
    5102:	9c 01       	movw	r18, r24
    5104:	23 70       	andi	r18, 0x03	; 3
    5106:	33 27       	eor	r19, r19
    5108:	39 e1       	ldi	r19, 0x19	; 25
    510a:	23 9f       	mul	r18, r19
    510c:	20 2d       	mov	r18, r0
    510e:	11 24       	eor	r1, r1
    5110:	1f 92       	push	r1
    5112:	2f 93       	push	r18
    5114:	96 95       	lsr	r25
    5116:	87 95       	ror	r24
    5118:	96 95       	lsr	r25
    511a:	87 95       	ror	r24
    511c:	9f 93       	push	r25
    511e:	8f 93       	push	r24
    5120:	8f ea       	ldi	r24, 0xAF	; 175
    5122:	99 e0       	ldi	r25, 0x09	; 9
    5124:	9f 93       	push	r25
    5126:	8f 93       	push	r24
    5128:	08 df       	rcall	.-496    	; 0x4f3a <sersendf_P>
    512a:	0f 90       	pop	r0
    512c:	0f 90       	pop	r0
    512e:	0f 90       	pop	r0
    5130:	0f 90       	pop	r0
    5132:	0f 90       	pop	r0
    5134:	0f 90       	pop	r0
    5136:	08 95       	ret

00005138 <temp_init>:
    5138:	08 95       	ret

0000513a <temp_sensor_tick>:
    513a:	4f 92       	push	r4
    513c:	5f 92       	push	r5
    513e:	6f 92       	push	r6
    5140:	7f 92       	push	r7
    5142:	9f 92       	push	r9
    5144:	af 92       	push	r10
    5146:	bf 92       	push	r11
    5148:	cf 92       	push	r12
    514a:	df 92       	push	r13
    514c:	ef 92       	push	r14
    514e:	ff 92       	push	r15
    5150:	0f 93       	push	r16
    5152:	1f 93       	push	r17
    5154:	cf 93       	push	r28
    5156:	df 93       	push	r29
    5158:	80 91 9d 05 	lds	r24, 0x059D
    515c:	90 91 9e 05 	lds	r25, 0x059E
    5160:	00 97       	sbiw	r24, 0x00	; 0
    5162:	31 f0       	breq	.+12     	; 0x5170 <temp_sensor_tick+0x36>
    5164:	01 97       	sbiw	r24, 0x01	; 1
    5166:	90 93 9e 05 	sts	0x059E, r25
    516a:	80 93 9d 05 	sts	0x059D, r24
    516e:	d7 c0       	rjmp	.+430    	; 0x531e <temp_sensor_tick+0x1e4>
    5170:	80 e0       	ldi	r24, 0x00	; 0
    5172:	0e 94 54 05 	call	0xaa8	; 0xaa8 <analog_read>
    5176:	6c 01       	movw	r12, r24
    5178:	c1 e2       	ldi	r28, 0x21	; 33
    517a:	d6 e0       	ldi	r29, 0x06	; 6
    517c:	fe 01       	movw	r30, r28
    517e:	85 91       	lpm	r24, Z+
    5180:	94 91       	lpm	r25, Z
    5182:	c8 16       	cp	r12, r24
    5184:	d9 06       	cpc	r13, r25
    5186:	98 f0       	brcs	.+38     	; 0x51ae <temp_sensor_tick+0x74>
    5188:	82 e0       	ldi	r24, 0x02	; 2
    518a:	90 e0       	ldi	r25, 0x00	; 0
    518c:	98 2e       	mov	r9, r24
    518e:	8c 01       	movw	r16, r24
    5190:	ec 01       	movw	r28, r24
    5192:	cc 0f       	add	r28, r28
    5194:	dd 1f       	adc	r29, r29
    5196:	cc 0f       	add	r28, r28
    5198:	dd 1f       	adc	r29, r29
    519a:	c3 5e       	subi	r28, 0xE3	; 227
    519c:	d9 4f       	sbci	r29, 0xF9	; 249
    519e:	fe 01       	movw	r30, r28
    51a0:	25 91       	lpm	r18, Z+
    51a2:	34 91       	lpm	r19, Z
    51a4:	c2 16       	cp	r12, r18
    51a6:	d3 06       	cpc	r13, r19
    51a8:	08 f0       	brcs	.+2      	; 0x51ac <temp_sensor_tick+0x72>
    51aa:	7f c0       	rjmp	.+254    	; 0x52aa <temp_sensor_tick+0x170>
    51ac:	04 c0       	rjmp	.+8      	; 0x51b6 <temp_sensor_tick+0x7c>
    51ae:	01 e0       	ldi	r16, 0x01	; 1
    51b0:	10 e0       	ldi	r17, 0x00	; 0
    51b2:	99 24       	eor	r9, r9
    51b4:	93 94       	inc	r9
    51b6:	80 91 cf 04 	lds	r24, 0x04CF
    51ba:	80 ff       	sbrs	r24, 0
    51bc:	14 c0       	rjmp	.+40     	; 0x51e6 <temp_sensor_tick+0xac>
    51be:	1f 93       	push	r17
    51c0:	0f 93       	push	r16
    51c2:	df 92       	push	r13
    51c4:	cf 92       	push	r12
    51c6:	1f 92       	push	r1
    51c8:	8d e0       	ldi	r24, 0x0D	; 13
    51ca:	8f 93       	push	r24
    51cc:	8d e4       	ldi	r24, 0x4D	; 77
    51ce:	99 e0       	ldi	r25, 0x09	; 9
    51d0:	9f 93       	push	r25
    51d2:	8f 93       	push	r24
    51d4:	b2 de       	rcall	.-668    	; 0x4f3a <sersendf_P>
    51d6:	8d b7       	in	r24, 0x3d	; 61
    51d8:	9e b7       	in	r25, 0x3e	; 62
    51da:	08 96       	adiw	r24, 0x08	; 8
    51dc:	0f b6       	in	r0, 0x3f	; 63
    51de:	f8 94       	cli
    51e0:	9e bf       	out	0x3e, r25	; 62
    51e2:	0f be       	out	0x3f, r0	; 63
    51e4:	8d bf       	out	0x3d, r24	; 61
    51e6:	e1 2c       	mov	r14, r1
    51e8:	f1 2c       	mov	r15, r1
    51ea:	c8 01       	movw	r24, r16
    51ec:	01 97       	sbiw	r24, 0x01	; 1
    51ee:	88 0f       	add	r24, r24
    51f0:	99 1f       	adc	r25, r25
    51f2:	88 0f       	add	r24, r24
    51f4:	99 1f       	adc	r25, r25
    51f6:	fc 01       	movw	r30, r24
    51f8:	e3 5e       	subi	r30, 0xE3	; 227
    51fa:	f9 4f       	sbci	r31, 0xF9	; 249
    51fc:	a5 90       	lpm	r10, Z+
    51fe:	b4 90       	lpm	r11, Z
    5200:	f8 01       	movw	r30, r16
    5202:	ee 0f       	add	r30, r30
    5204:	ff 1f       	adc	r31, r31
    5206:	ee 0f       	add	r30, r30
    5208:	ff 1f       	adc	r31, r31
    520a:	e1 5e       	subi	r30, 0xE1	; 225
    520c:	f9 4f       	sbci	r31, 0xF9	; 249
    520e:	a5 91       	lpm	r26, Z+
    5210:	b4 91       	lpm	r27, Z
    5212:	fe 01       	movw	r30, r28
    5214:	05 91       	lpm	r16, Z+
    5216:	14 91       	lpm	r17, Z
    5218:	fc 01       	movw	r30, r24
    521a:	e1 5e       	subi	r30, 0xE1	; 225
    521c:	f9 4f       	sbci	r31, 0xF9	; 249
    521e:	c5 91       	lpm	r28, Z+
    5220:	d4 91       	lpm	r29, Z
    5222:	a7 01       	movw	r20, r14
    5224:	96 01       	movw	r18, r12
    5226:	2a 19       	sub	r18, r10
    5228:	3b 09       	sbc	r19, r11
    522a:	41 09       	sbc	r20, r1
    522c:	51 09       	sbc	r21, r1
    522e:	2f d3       	rcall	.+1630   	; 0x588e <__muluhisi3>
    5230:	2b 01       	movw	r4, r22
    5232:	3c 01       	movw	r6, r24
    5234:	c8 01       	movw	r24, r16
    5236:	a0 e0       	ldi	r26, 0x00	; 0
    5238:	b0 e0       	ldi	r27, 0x00	; 0
    523a:	9c 01       	movw	r18, r24
    523c:	ad 01       	movw	r20, r26
    523e:	2c 19       	sub	r18, r12
    5240:	3d 09       	sbc	r19, r13
    5242:	4e 09       	sbc	r20, r14
    5244:	5f 09       	sbc	r21, r15
    5246:	de 01       	movw	r26, r28
    5248:	22 d3       	rcall	.+1604   	; 0x588e <__muluhisi3>
    524a:	64 0d       	add	r22, r4
    524c:	75 1d       	adc	r23, r5
    524e:	86 1d       	adc	r24, r6
    5250:	97 1d       	adc	r25, r7
    5252:	98 01       	movw	r18, r16
    5254:	2a 19       	sub	r18, r10
    5256:	3b 09       	sbc	r19, r11
    5258:	40 e0       	ldi	r20, 0x00	; 0
    525a:	50 e0       	ldi	r21, 0x00	; 0
    525c:	c9 d2       	rcall	.+1426   	; 0x57f0 <__udivmodsi4>
    525e:	69 01       	movw	r12, r18
    5260:	80 91 cf 04 	lds	r24, 0x04CF
    5264:	80 ff       	sbrs	r24, 0
    5266:	27 c0       	rjmp	.+78     	; 0x52b6 <temp_sensor_tick+0x17c>
    5268:	89 01       	movw	r16, r18
    526a:	9a 01       	movw	r18, r20
    526c:	03 70       	andi	r16, 0x03	; 3
    526e:	11 27       	eor	r17, r17
    5270:	22 27       	eor	r18, r18
    5272:	33 27       	eor	r19, r19
    5274:	69 e1       	ldi	r22, 0x19	; 25
    5276:	60 9f       	mul	r22, r16
    5278:	c0 01       	movw	r24, r0
    527a:	61 9f       	mul	r22, r17
    527c:	90 0d       	add	r25, r0
    527e:	11 24       	eor	r1, r1
    5280:	9f 93       	push	r25
    5282:	8f 93       	push	r24
    5284:	c6 01       	movw	r24, r12
    5286:	96 95       	lsr	r25
    5288:	87 95       	ror	r24
    528a:	96 95       	lsr	r25
    528c:	87 95       	ror	r24
    528e:	9f 93       	push	r25
    5290:	8f 93       	push	r24
    5292:	8f e6       	ldi	r24, 0x6F	; 111
    5294:	99 e0       	ldi	r25, 0x09	; 9
    5296:	9f 93       	push	r25
    5298:	8f 93       	push	r24
    529a:	4f de       	rcall	.-866    	; 0x4f3a <sersendf_P>
    529c:	0f 90       	pop	r0
    529e:	0f 90       	pop	r0
    52a0:	0f 90       	pop	r0
    52a2:	0f 90       	pop	r0
    52a4:	0f 90       	pop	r0
    52a6:	0f 90       	pop	r0
    52a8:	06 c0       	rjmp	.+12     	; 0x52b6 <temp_sensor_tick+0x17c>
    52aa:	93 94       	inc	r9
    52ac:	01 96       	adiw	r24, 0x01	; 1
    52ae:	86 36       	cpi	r24, 0x66	; 102
    52b0:	91 05       	cpc	r25, r1
    52b2:	09 f0       	breq	.+2      	; 0x52b6 <temp_sensor_tick+0x17c>
    52b4:	6b cf       	rjmp	.-298    	; 0x518c <temp_sensor_tick+0x52>
    52b6:	80 91 cf 04 	lds	r24, 0x04CF
    52ba:	80 ff       	sbrs	r24, 0
    52bc:	0b c0       	rjmp	.+22     	; 0x52d4 <temp_sensor_tick+0x19a>
    52be:	1f 92       	push	r1
    52c0:	1f 92       	push	r1
    52c2:	8b e7       	ldi	r24, 0x7B	; 123
    52c4:	99 e0       	ldi	r25, 0x09	; 9
    52c6:	9f 93       	push	r25
    52c8:	8f 93       	push	r24
    52ca:	37 de       	rcall	.-914    	; 0x4f3a <sersendf_P>
    52cc:	0f 90       	pop	r0
    52ce:	0f 90       	pop	r0
    52d0:	0f 90       	pop	r0
    52d2:	0f 90       	pop	r0
    52d4:	96 e6       	ldi	r25, 0x66	; 102
    52d6:	99 12       	cpse	r9, r25
    52d8:	02 c0       	rjmp	.+4      	; 0x52de <temp_sensor_tick+0x1a4>
    52da:	c1 2c       	mov	r12, r1
    52dc:	d1 2c       	mov	r13, r1
    52de:	10 92 9e 05 	sts	0x059E, r1
    52e2:	10 92 9d 05 	sts	0x059D, r1
    52e6:	e7 e9       	ldi	r30, 0x97	; 151
    52e8:	f5 e0       	ldi	r31, 0x05	; 5
    52ea:	96 01       	movw	r18, r12
    52ec:	a6 e6       	ldi	r26, 0x66	; 102
    52ee:	b0 e0       	ldi	r27, 0x00	; 0
    52f0:	c2 d2       	rcall	.+1412   	; 0x5876 <__umulhisi3>
    52f2:	6b 01       	movw	r12, r22
    52f4:	7c 01       	movw	r14, r24
    52f6:	20 81       	ld	r18, Z
    52f8:	31 81       	ldd	r19, Z+1	; 0x01
    52fa:	aa e9       	ldi	r26, 0x9A	; 154
    52fc:	b3 e0       	ldi	r27, 0x03	; 3
    52fe:	bb d2       	rcall	.+1398   	; 0x5876 <__umulhisi3>
    5300:	c6 0e       	add	r12, r22
    5302:	d7 1e       	adc	r13, r23
    5304:	e8 1e       	adc	r14, r24
    5306:	f9 1e       	adc	r15, r25
    5308:	0b 2e       	mov	r0, r27
    530a:	ba e0       	ldi	r27, 0x0A	; 10
    530c:	f5 94       	asr	r15
    530e:	e7 94       	ror	r14
    5310:	d7 94       	ror	r13
    5312:	c7 94       	ror	r12
    5314:	ba 95       	dec	r27
    5316:	d1 f7       	brne	.-12     	; 0x530c <temp_sensor_tick+0x1d2>
    5318:	b0 2d       	mov	r27, r0
    531a:	d1 82       	std	Z+1, r13	; 0x01
    531c:	c0 82       	st	Z, r12
    531e:	80 91 97 05 	lds	r24, 0x0597
    5322:	90 91 98 05 	lds	r25, 0x0598
    5326:	20 91 99 05 	lds	r18, 0x0599
    532a:	30 91 9a 05 	lds	r19, 0x059A
    532e:	82 1b       	sub	r24, r18
    5330:	93 0b       	sbc	r25, r19
    5332:	8d 3e       	cpi	r24, 0xED	; 237
    5334:	2f ef       	ldi	r18, 0xFF	; 255
    5336:	92 07       	cpc	r25, r18
    5338:	84 f0       	brlt	.+32     	; 0x535a <temp_sensor_tick+0x220>
    533a:	44 97       	sbiw	r24, 0x14	; 20
    533c:	74 f4       	brge	.+28     	; 0x535a <temp_sensor_tick+0x220>
    533e:	80 91 9b 05 	lds	r24, 0x059B
    5342:	90 91 9c 05 	lds	r25, 0x059C
    5346:	80 32       	cpi	r24, 0x20	; 32
    5348:	2c e1       	ldi	r18, 0x1C	; 28
    534a:	92 07       	cpc	r25, r18
    534c:	b8 f4       	brcc	.+46     	; 0x537c <temp_sensor_tick+0x242>
    534e:	01 96       	adiw	r24, 0x01	; 1
    5350:	90 93 9c 05 	sts	0x059C, r25
    5354:	80 93 9b 05 	sts	0x059B, r24
    5358:	11 c0       	rjmp	.+34     	; 0x537c <temp_sensor_tick+0x242>
    535a:	80 91 9b 05 	lds	r24, 0x059B
    535e:	90 91 9c 05 	lds	r25, 0x059C
    5362:	8b 30       	cpi	r24, 0x0B	; 11
    5364:	91 05       	cpc	r25, r1
    5366:	30 f0       	brcs	.+12     	; 0x5374 <temp_sensor_tick+0x23a>
    5368:	0a 97       	sbiw	r24, 0x0a	; 10
    536a:	90 93 9c 05 	sts	0x059C, r25
    536e:	80 93 9b 05 	sts	0x059B, r24
    5372:	04 c0       	rjmp	.+8      	; 0x537c <temp_sensor_tick+0x242>
    5374:	10 92 9c 05 	sts	0x059C, r1
    5378:	10 92 9b 05 	sts	0x059B, r1
    537c:	20 91 99 05 	lds	r18, 0x0599
    5380:	30 91 9a 05 	lds	r19, 0x059A
    5384:	40 91 97 05 	lds	r20, 0x0597
    5388:	50 91 98 05 	lds	r21, 0x0598
    538c:	60 e0       	ldi	r22, 0x00	; 0
    538e:	80 e0       	ldi	r24, 0x00	; 0
    5390:	0e 94 3a 20 	call	0x4074	; 0x4074 <heater_tick>
    5394:	80 91 cf 04 	lds	r24, 0x04CF
    5398:	80 ff       	sbrs	r24, 0
    539a:	27 c0       	rjmp	.+78     	; 0x53ea <temp_sensor_tick+0x2b0>
    539c:	80 91 97 05 	lds	r24, 0x0597
    53a0:	90 91 98 05 	lds	r25, 0x0598
    53a4:	ac 01       	movw	r20, r24
    53a6:	43 70       	andi	r20, 0x03	; 3
    53a8:	55 27       	eor	r21, r21
    53aa:	69 e1       	ldi	r22, 0x19	; 25
    53ac:	64 9f       	mul	r22, r20
    53ae:	90 01       	movw	r18, r0
    53b0:	65 9f       	mul	r22, r21
    53b2:	30 0d       	add	r19, r0
    53b4:	11 24       	eor	r1, r1
    53b6:	3f 93       	push	r19
    53b8:	2f 93       	push	r18
    53ba:	9c 01       	movw	r18, r24
    53bc:	36 95       	lsr	r19
    53be:	27 95       	ror	r18
    53c0:	36 95       	lsr	r19
    53c2:	27 95       	ror	r18
    53c4:	3f 93       	push	r19
    53c6:	2f 93       	push	r18
    53c8:	9f 93       	push	r25
    53ca:	8f 93       	push	r24
    53cc:	1f 92       	push	r1
    53ce:	1f 92       	push	r1
    53d0:	87 e8       	ldi	r24, 0x87	; 135
    53d2:	99 e0       	ldi	r25, 0x09	; 9
    53d4:	9f 93       	push	r25
    53d6:	8f 93       	push	r24
    53d8:	b0 dd       	rcall	.-1184   	; 0x4f3a <sersendf_P>
    53da:	8d b7       	in	r24, 0x3d	; 61
    53dc:	9e b7       	in	r25, 0x3e	; 62
    53de:	0a 96       	adiw	r24, 0x0a	; 10
    53e0:	0f b6       	in	r0, 0x3f	; 63
    53e2:	f8 94       	cli
    53e4:	9e bf       	out	0x3e, r25	; 62
    53e6:	0f be       	out	0x3f, r0	; 63
    53e8:	8d bf       	out	0x3d, r24	; 61
    53ea:	80 91 cf 04 	lds	r24, 0x04CF
    53ee:	80 ff       	sbrs	r24, 0
    53f0:	07 c0       	rjmp	.+14     	; 0x5400 <temp_sensor_tick+0x2c6>
    53f2:	8e e9       	ldi	r24, 0x9E	; 158
    53f4:	99 e0       	ldi	r25, 0x09	; 9
    53f6:	9f 93       	push	r25
    53f8:	8f 93       	push	r24
    53fa:	9f dd       	rcall	.-1218   	; 0x4f3a <sersendf_P>
    53fc:	0f 90       	pop	r0
    53fe:	0f 90       	pop	r0
    5400:	df 91       	pop	r29
    5402:	cf 91       	pop	r28
    5404:	1f 91       	pop	r17
    5406:	0f 91       	pop	r16
    5408:	ff 90       	pop	r15
    540a:	ef 90       	pop	r14
    540c:	df 90       	pop	r13
    540e:	cf 90       	pop	r12
    5410:	bf 90       	pop	r11
    5412:	af 90       	pop	r10
    5414:	9f 90       	pop	r9
    5416:	7f 90       	pop	r7
    5418:	6f 90       	pop	r6
    541a:	5f 90       	pop	r5
    541c:	4f 90       	pop	r4
    541e:	08 95       	ret

00005420 <temp_achieved>:
    5420:	80 91 9b 05 	lds	r24, 0x059B
    5424:	90 91 9c 05 	lds	r25, 0x059C
    5428:	80 37       	cpi	r24, 0x70	; 112
    542a:	97 41       	sbci	r25, 0x17	; 23
    542c:	10 f0       	brcs	.+4      	; 0x5432 <temp_achieved+0x12>
    542e:	8f ef       	ldi	r24, 0xFF	; 255
    5430:	08 95       	ret
    5432:	80 e0       	ldi	r24, 0x00	; 0
    5434:	08 95       	ret

00005436 <temp_set>:
    5436:	81 11       	cpse	r24, r1
    5438:	0f c0       	rjmp	.+30     	; 0x5458 <temp_set+0x22>
    543a:	80 91 99 05 	lds	r24, 0x0599
    543e:	90 91 9a 05 	lds	r25, 0x059A
    5442:	86 17       	cp	r24, r22
    5444:	97 07       	cpc	r25, r23
    5446:	41 f0       	breq	.+16     	; 0x5458 <temp_set+0x22>
    5448:	70 93 9a 05 	sts	0x059A, r23
    544c:	60 93 99 05 	sts	0x0599, r22
    5450:	10 92 9c 05 	sts	0x059C, r1
    5454:	10 92 9b 05 	sts	0x059B, r1
    5458:	08 95       	ret

0000545a <temp_print>:

/// send temperatures to host
/// \param index sensor value to send
void temp_print(temp_sensor_t index) {

	if (index == TEMP_SENSOR_none) { // standard behaviour
    545a:	82 30       	cpi	r24, 0x02	; 2
    545c:	99 f4       	brne	.+38     	; 0x5484 <temp_print+0x2a>
		#ifdef HEATER_EXTRUDER
			sersendf_P(PSTR("T:"));
    545e:	80 ea       	ldi	r24, 0xA0	; 160
    5460:	99 e0       	ldi	r25, 0x09	; 9
    5462:	9f 93       	push	r25
    5464:	8f 93       	push	r24
    5466:	69 dd       	rcall	.-1326   	; 0x4f3a <sersendf_P>
			single_temp_print(HEATER_EXTRUDER);
    5468:	80 e0       	ldi	r24, 0x00	; 0
    546a:	3c de       	rcall	.-904    	; 0x50e4 <single_temp_print>
		#endif
		#ifdef HEATER_BED
			sersendf_P(PSTR(" B:"));
    546c:	83 ea       	ldi	r24, 0xA3	; 163
    546e:	99 e0       	ldi	r25, 0x09	; 9
    5470:	9f 93       	push	r25
    5472:	8f 93       	push	r24
    5474:	62 dd       	rcall	.-1340   	; 0x4f3a <sersendf_P>
			single_temp_print(HEATER_BED);
    5476:	81 e0       	ldi	r24, 0x01	; 1
    5478:	35 de       	rcall	.-918    	; 0x50e4 <single_temp_print>
    547a:	0f 90       	pop	r0
    547c:	0f 90       	pop	r0
    547e:	0f 90       	pop	r0
    5480:	0f 90       	pop	r0
    5482:	08 95       	ret
		#endif
	}
	else {
		if (index >= NUM_TEMP_SENSORS)
    5484:	81 11       	cpse	r24, r1
    5486:	0d c0       	rjmp	.+26     	; 0x54a2 <temp_print+0x48>
			return;
		sersendf_P(PSTR("T[%su]:"), index);
    5488:	1f 92       	push	r1
    548a:	1f 92       	push	r1
    548c:	87 ea       	ldi	r24, 0xA7	; 167
    548e:	99 e0       	ldi	r25, 0x09	; 9
    5490:	9f 93       	push	r25
    5492:	8f 93       	push	r24
    5494:	52 dd       	rcall	.-1372   	; 0x4f3a <sersendf_P>
		single_temp_print(index);
    5496:	80 e0       	ldi	r24, 0x00	; 0
    5498:	25 de       	rcall	.-950    	; 0x50e4 <single_temp_print>
    549a:	0f 90       	pop	r0
    549c:	0f 90       	pop	r0
    549e:	0f 90       	pop	r0
    54a0:	0f 90       	pop	r0
    54a2:	08 95       	ret

000054a4 <__vector_43>:
volatile uint8_t	clock_flag_10ms = 0;
volatile uint8_t	clock_flag_250ms = 0;
volatile uint8_t	clock_flag_1s = 0;

/// comparator B is the system clock, happens every TICK_TIME
ISR(TIMER4_COMPB_vect) {
    54a4:	1f 92       	push	r1
    54a6:	0f 92       	push	r0
    54a8:	0f b6       	in	r0, 0x3f	; 63
    54aa:	0f 92       	push	r0
    54ac:	11 24       	eor	r1, r1
    54ae:	0b b6       	in	r0, 0x3b	; 59
    54b0:	0f 92       	push	r0
    54b2:	2f 93       	push	r18
    54b4:	8f 93       	push	r24
    54b6:	9f 93       	push	r25
    54b8:	ef 93       	push	r30
    54ba:	ff 93       	push	r31
	// save status register
	uint8_t sreg_save = SREG;
    54bc:	2f b7       	in	r18, 0x3f	; 63

	// set output compare register to the next clock tick
	OCR4B = (OCR4B + TICK_TIME) & 0xFFFF;
    54be:	ea ea       	ldi	r30, 0xAA	; 170
    54c0:	f0 e0       	ldi	r31, 0x00	; 0
    54c2:	80 81       	ld	r24, Z
    54c4:	91 81       	ldd	r25, Z+1	; 0x01
    54c6:	93 58       	subi	r25, 0x83	; 131
    54c8:	91 83       	std	Z+1, r25	; 0x01
    54ca:	80 83       	st	Z, r24

	/*
	clock stuff
	*/
	clock_counter_10ms += TICK_TIME_MS;
    54cc:	80 91 ca 04 	lds	r24, 0x04CA
    54d0:	98 2f       	mov	r25, r24
    54d2:	9e 5f       	subi	r25, 0xFE	; 254
	if (clock_counter_10ms >= 10) {
    54d4:	9a 30       	cpi	r25, 0x0A	; 10
    54d6:	18 f4       	brcc	.+6      	; 0x54de <__vector_43+0x3a>
	OCR4B = (OCR4B + TICK_TIME) & 0xFFFF;

	/*
	clock stuff
	*/
	clock_counter_10ms += TICK_TIME_MS;
    54d8:	90 93 ca 04 	sts	0x04CA, r25
    54dc:	20 c0       	rjmp	.+64     	; 0x551e <__vector_43+0x7a>
	if (clock_counter_10ms >= 10) {
		clock_counter_10ms -= 10;
    54de:	88 50       	subi	r24, 0x08	; 8
    54e0:	80 93 ca 04 	sts	0x04CA, r24
		clock_flag_10ms = 1;
    54e4:	81 e0       	ldi	r24, 0x01	; 1
    54e6:	80 93 c7 04 	sts	0x04C7, r24

		clock_counter_250ms++;
    54ea:	80 91 c9 04 	lds	r24, 0x04C9
    54ee:	8f 5f       	subi	r24, 0xFF	; 255
		if (clock_counter_250ms >= 25) {
    54f0:	89 31       	cpi	r24, 0x19	; 25
    54f2:	18 f4       	brcc	.+6      	; 0x54fa <__vector_43+0x56>
	clock_counter_10ms += TICK_TIME_MS;
	if (clock_counter_10ms >= 10) {
		clock_counter_10ms -= 10;
		clock_flag_10ms = 1;

		clock_counter_250ms++;
    54f4:	80 93 c9 04 	sts	0x04C9, r24
    54f8:	12 c0       	rjmp	.+36     	; 0x551e <__vector_43+0x7a>
		if (clock_counter_250ms >= 25) {
			clock_counter_250ms = 0;
    54fa:	10 92 c9 04 	sts	0x04C9, r1
			clock_flag_250ms = 1;
    54fe:	81 e0       	ldi	r24, 0x01	; 1
    5500:	80 93 c6 04 	sts	0x04C6, r24

			clock_counter_1s++;
    5504:	80 91 c8 04 	lds	r24, 0x04C8
    5508:	8f 5f       	subi	r24, 0xFF	; 255
			if (clock_counter_1s >= 4) {
    550a:	84 30       	cpi	r24, 0x04	; 4
    550c:	18 f4       	brcc	.+6      	; 0x5514 <__vector_43+0x70>
		clock_counter_250ms++;
		if (clock_counter_250ms >= 25) {
			clock_counter_250ms = 0;
			clock_flag_250ms = 1;

			clock_counter_1s++;
    550e:	80 93 c8 04 	sts	0x04C8, r24
    5512:	05 c0       	rjmp	.+10     	; 0x551e <__vector_43+0x7a>
			if (clock_counter_1s >= 4) {
				clock_counter_1s = 0;
    5514:	10 92 c8 04 	sts	0x04C8, r1
				clock_flag_1s = 1;
    5518:	81 e0       	ldi	r24, 0x01	; 1
    551a:	80 93 c5 04 	sts	0x04C5, r24
		}
	}

	// restore status register
	MEMORY_BARRIER();
	SREG = sreg_save;
    551e:	2f bf       	out	0x3f, r18	; 63
}
    5520:	ff 91       	pop	r31
    5522:	ef 91       	pop	r30
    5524:	9f 91       	pop	r25
    5526:	8f 91       	pop	r24
    5528:	2f 91       	pop	r18
    552a:	0f 90       	pop	r0
    552c:	0b be       	out	0x3b, r0	; 59
    552e:	0f 90       	pop	r0
    5530:	0f be       	out	0x3f, r0	; 63
    5532:	0f 90       	pop	r0
    5534:	1f 90       	pop	r1
    5536:	18 95       	reti

00005538 <__vector_42>:

#ifdef	MOTHERBOARD

/// comparator A is the step timer. It has higher priority then B.
ISR(TIMER4_COMPA_vect) {
    5538:	1f 92       	push	r1
    553a:	0f 92       	push	r0
    553c:	0f b6       	in	r0, 0x3f	; 63
    553e:	0f 92       	push	r0
    5540:	11 24       	eor	r1, r1
    5542:	0b b6       	in	r0, 0x3b	; 59
    5544:	0f 92       	push	r0
    5546:	2f 93       	push	r18
    5548:	3f 93       	push	r19
    554a:	4f 93       	push	r20
    554c:	5f 93       	push	r21
    554e:	6f 93       	push	r22
    5550:	7f 93       	push	r23
    5552:	8f 93       	push	r24
    5554:	9f 93       	push	r25
    5556:	af 93       	push	r26
    5558:	bf 93       	push	r27
    555a:	ef 93       	push	r30
    555c:	ff 93       	push	r31
	// save status register
	uint8_t sreg_save = SREG;
    555e:	4f b7       	in	r20, 0x3f	; 63

	// Check if this is a real step, or just a next_step_time "overflow"
	if (next_step_time < 65536) {
    5560:	80 91 9f 05 	lds	r24, 0x059F
    5564:	90 91 a0 05 	lds	r25, 0x05A0
    5568:	a0 91 a1 05 	lds	r26, 0x05A1
    556c:	b0 91 a2 05 	lds	r27, 0x05A2
    5570:	00 97       	sbiw	r24, 0x00	; 0
    5572:	21 e0       	ldi	r18, 0x01	; 1
    5574:	a2 07       	cpc	r26, r18
    5576:	b1 05       	cpc	r27, r1
    5578:	40 f4       	brcc	.+16     	; 0x558a <__vector_42+0x52>
		#ifdef DEBUG_LED_PIN
			WRITE(DEBUG_LED_PIN, 1);
		#endif

		// disable this interrupt. if we set a new timeout, it will be re-enabled when appropriate
		TIMSK4 &= ~MASK(OCIE4A);
    557a:	e2 e7       	ldi	r30, 0x72	; 114
    557c:	f0 e0       	ldi	r31, 0x00	; 0
    557e:	80 81       	ld	r24, Z
    5580:	8d 7f       	andi	r24, 0xFD	; 253
    5582:	80 83       	st	Z, r24
		
		// stepper tick
		queue_step();
    5584:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <queue_step>
		// led off
		#ifdef DEBUG_LED_PIN
			WRITE(DEBUG_LED_PIN, 0);
		#endif

		return;
    5588:	39 c0       	rjmp	.+114    	; 0x55fc <__vector_42+0xc4>
	}

	next_step_time -= 65536;
    558a:	11 97       	sbiw	r26, 0x01	; 1
    558c:	80 93 9f 05 	sts	0x059F, r24
    5590:	90 93 a0 05 	sts	0x05A0, r25
    5594:	a0 93 a1 05 	sts	0x05A1, r26
    5598:	b0 93 a2 05 	sts	0x05A2, r27

	// similar algorithm as described in setTimer below.
	if (next_step_time < 65536) {
    559c:	00 97       	sbiw	r24, 0x00	; 0
    559e:	21 e0       	ldi	r18, 0x01	; 1
    55a0:	a2 07       	cpc	r26, r18
    55a2:	b1 05       	cpc	r27, r1
    55a4:	48 f4       	brcc	.+18     	; 0x55b8 <__vector_42+0x80>
		OCR4A = (OCR4A + next_step_time) & 0xFFFF;
    55a6:	e8 ea       	ldi	r30, 0xA8	; 168
    55a8:	f0 e0       	ldi	r31, 0x00	; 0
    55aa:	20 81       	ld	r18, Z
    55ac:	31 81       	ldd	r19, Z+1	; 0x01
    55ae:	82 0f       	add	r24, r18
    55b0:	93 1f       	adc	r25, r19
    55b2:	91 83       	std	Z+1, r25	; 0x01
    55b4:	80 83       	st	Z, r24
    55b6:	21 c0       	rjmp	.+66     	; 0x55fa <__vector_42+0xc2>
	} else if(next_step_time < 75536){
    55b8:	80 31       	cpi	r24, 0x10	; 16
    55ba:	97 42       	sbci	r25, 0x27	; 39
    55bc:	a1 40       	sbci	r26, 0x01	; 1
    55be:	b1 05       	cpc	r27, r1
    55c0:	e0 f4       	brcc	.+56     	; 0x55fa <__vector_42+0xc2>
		OCR4A = (OCR4A - 10000) & 0xFFFF;
    55c2:	e8 ea       	ldi	r30, 0xA8	; 168
    55c4:	f0 e0       	ldi	r31, 0x00	; 0
    55c6:	80 81       	ld	r24, Z
    55c8:	91 81       	ldd	r25, Z+1	; 0x01
    55ca:	80 51       	subi	r24, 0x10	; 16
    55cc:	97 42       	sbci	r25, 0x27	; 39
    55ce:	91 83       	std	Z+1, r25	; 0x01
    55d0:	80 83       	st	Z, r24
		next_step_time += 10000;
    55d2:	80 91 9f 05 	lds	r24, 0x059F
    55d6:	90 91 a0 05 	lds	r25, 0x05A0
    55da:	a0 91 a1 05 	lds	r26, 0x05A1
    55de:	b0 91 a2 05 	lds	r27, 0x05A2
    55e2:	80 5f       	subi	r24, 0xF0	; 240
    55e4:	98 4d       	sbci	r25, 0xD8	; 216
    55e6:	af 4f       	sbci	r26, 0xFF	; 255
    55e8:	bf 4f       	sbci	r27, 0xFF	; 255
    55ea:	80 93 9f 05 	sts	0x059F, r24
    55ee:	90 93 a0 05 	sts	0x05A0, r25
    55f2:	a0 93 a1 05 	sts	0x05A1, r26
    55f6:	b0 93 a2 05 	sts	0x05A2, r27
	}
	// leave OCR4A as it was

	// restore status register
	MEMORY_BARRIER();
	SREG = sreg_save;
    55fa:	4f bf       	out	0x3f, r20	; 63
}
    55fc:	ff 91       	pop	r31
    55fe:	ef 91       	pop	r30
    5600:	bf 91       	pop	r27
    5602:	af 91       	pop	r26
    5604:	9f 91       	pop	r25
    5606:	8f 91       	pop	r24
    5608:	7f 91       	pop	r23
    560a:	6f 91       	pop	r22
    560c:	5f 91       	pop	r21
    560e:	4f 91       	pop	r20
    5610:	3f 91       	pop	r19
    5612:	2f 91       	pop	r18
    5614:	0f 90       	pop	r0
    5616:	0b be       	out	0x3b, r0	; 59
    5618:	0f 90       	pop	r0
    561a:	0f be       	out	0x3f, r0	; 63
    561c:	0f 90       	pop	r0
    561e:	1f 90       	pop	r1
    5620:	18 95       	reti

00005622 <timer_init>:
/// initialise timer and enable system clock interrupt.
/// step interrupt is enabled later when we start using it
void timer_init()
{
	// no outputs
	TCCR4A = 0;
    5622:	10 92 a0 00 	sts	0x00A0, r1
	// Normal Mode
	TCCR4B = MASK(CS40);
    5626:	81 e0       	ldi	r24, 0x01	; 1
    5628:	80 93 a1 00 	sts	0x00A1, r24
	// set up "clock" comparator for first tick
	OCR4B = TICK_TIME & 0xFFFF;
    562c:	80 e0       	ldi	r24, 0x00	; 0
    562e:	9d e7       	ldi	r25, 0x7D	; 125
    5630:	90 93 ab 00 	sts	0x00AB, r25
    5634:	80 93 aa 00 	sts	0x00AA, r24
	// enable interrupt
	TIMSK4 = MASK(OCIE4B);
    5638:	84 e0       	ldi	r24, 0x04	; 4
    563a:	80 93 72 00 	sts	0x0072, r24
    563e:	08 95       	ret

00005640 <setTimer>:
	So, if you use it from inside the step interrupt, make sure to do so
	as late as possible. If you use it from outside the step interrupt,
	do a sei() after it to make the interrupt actually fire.
*/
void setTimer(uint32_t delay)
{
    5640:	0f 93       	push	r16
    5642:	1f 93       	push	r17
	uint16_t current_time;
	uint32_t earliest_time, actual_time;
	#endif /* ACCELERATION_TEMPORAL */

	// re-enable clock interrupt in case we're recovering from emergency stop
	TIMSK4 |= MASK(OCIE4B);
    5644:	e2 e7       	ldi	r30, 0x72	; 114
    5646:	f0 e0       	ldi	r31, 0x00	; 0
    5648:	20 81       	ld	r18, Z
    564a:	24 60       	ori	r18, 0x04	; 4
    564c:	20 83       	st	Z, r18

	// An interrupt would make all our timing calculations invalid,
	// so stop that here.
	cli();
    564e:	f8 94       	cli

	// Assume all steps belong to one move. Within one move the delay is
	// from one step to the next one, which should be more or less the same
	// as from one step interrupt to the next one. The last step interrupt happend
	// at OCR1A, so start delay from there.
	step_start = OCR4A;
    5650:	40 91 a8 00 	lds	r20, 0x00A8
    5654:	50 91 a9 00 	lds	r21, 0x00A9
	if (next_step_time == 0) {
    5658:	00 91 9f 05 	lds	r16, 0x059F
    565c:	10 91 a0 05 	lds	r17, 0x05A0
    5660:	20 91 a1 05 	lds	r18, 0x05A1
    5664:	30 91 a2 05 	lds	r19, 0x05A2
    5668:	01 2b       	or	r16, r17
    566a:	02 2b       	or	r16, r18
    566c:	03 2b       	or	r16, r19
    566e:	21 f4       	brne	.+8      	; 0x5678 <setTimer+0x38>
		// new move, take current time as start value
		step_start = TCNT4;
    5670:	40 91 a4 00 	lds	r20, 0x00A4
    5674:	50 91 a5 00 	lds	r21, 0x00A5
	}
	next_step_time = delay;
    5678:	60 93 9f 05 	sts	0x059F, r22
    567c:	70 93 a0 05 	sts	0x05A0, r23
    5680:	80 93 a1 05 	sts	0x05A1, r24
    5684:	90 93 a2 05 	sts	0x05A2, r25
		}
	}
	#endif /* ACCELERATION_TEMPORAL */

	// Now we know how long we actually want to delay, so set the timer.
	if (next_step_time < 65536) {
    5688:	61 15       	cp	r22, r1
    568a:	71 05       	cpc	r23, r1
    568c:	21 e0       	ldi	r18, 0x01	; 1
    568e:	82 07       	cpc	r24, r18
    5690:	91 05       	cpc	r25, r1
    5692:	38 f4       	brcc	.+14     	; 0x56a2 <setTimer+0x62>
		// set the comparator directly to the next real step
		OCR4A = (next_step_time + step_start) & 0xFFFF;
    5694:	64 0f       	add	r22, r20
    5696:	75 1f       	adc	r23, r21
    5698:	70 93 a9 00 	sts	0x00A9, r23
    569c:	60 93 a8 00 	sts	0x00A8, r22
    56a0:	24 c0       	rjmp	.+72     	; 0x56ea <setTimer+0xaa>
	}
	else if (next_step_time < 75536) {
    56a2:	60 31       	cpi	r22, 0x10	; 16
    56a4:	77 42       	sbci	r23, 0x27	; 39
    56a6:	81 40       	sbci	r24, 0x01	; 1
    56a8:	91 05       	cpc	r25, r1
    56aa:	d8 f4       	brcc	.+54     	; 0x56e2 <setTimer+0xa2>
		// Next comparator interrupt would have to trigger another
		// interrupt within a short time (possibly within 1 cycle).
		// Avoid the impossible by firing the interrupt earlier.
		OCR4A = (step_start - 10000) & 0xFFFF;
    56ac:	40 51       	subi	r20, 0x10	; 16
    56ae:	57 42       	sbci	r21, 0x27	; 39
    56b0:	50 93 a9 00 	sts	0x00A9, r21
    56b4:	40 93 a8 00 	sts	0x00A8, r20
		next_step_time += 10000;
    56b8:	80 91 9f 05 	lds	r24, 0x059F
    56bc:	90 91 a0 05 	lds	r25, 0x05A0
    56c0:	a0 91 a1 05 	lds	r26, 0x05A1
    56c4:	b0 91 a2 05 	lds	r27, 0x05A2
    56c8:	80 5f       	subi	r24, 0xF0	; 240
    56ca:	98 4d       	sbci	r25, 0xD8	; 216
    56cc:	af 4f       	sbci	r26, 0xFF	; 255
    56ce:	bf 4f       	sbci	r27, 0xFF	; 255
    56d0:	80 93 9f 05 	sts	0x059F, r24
    56d4:	90 93 a0 05 	sts	0x05A0, r25
    56d8:	a0 93 a1 05 	sts	0x05A1, r26
    56dc:	b0 93 a2 05 	sts	0x05A2, r27
    56e0:	04 c0       	rjmp	.+8      	; 0x56ea <setTimer+0xaa>
	}
	else {
		OCR4A = step_start;
    56e2:	50 93 a9 00 	sts	0x00A9, r21
    56e6:	40 93 a8 00 	sts	0x00A8, r20

	// Enable this interrupt, but only do it after disabling
	// global interrupts (see above). This will cause push any possible
	// timer1a interrupt to the far side of the return, protecting the 
	// stack from recursively clobbering memory.
	TIMSK4 |= MASK(OCIE4A);
    56ea:	e2 e7       	ldi	r30, 0x72	; 114
    56ec:	f0 e0       	ldi	r31, 0x00	; 0
    56ee:	80 81       	ld	r24, Z
    56f0:	82 60       	ori	r24, 0x02	; 2
    56f2:	80 83       	st	Z, r24
}
    56f4:	1f 91       	pop	r17
    56f6:	0f 91       	pop	r16
    56f8:	08 95       	ret

000056fa <timer_stop>:

/// stop timers - emergency stop
void timer_stop() {
	// disable all interrupts
	TIMSK4 = 0;
    56fa:	10 92 72 00 	sts	0x0072, r1
    56fe:	08 95       	ret

00005700 <__cmpsf2>:
    5700:	40 d0       	rcall	.+128    	; 0x5782 <__fp_cmp>
    5702:	08 f4       	brcc	.+2      	; 0x5706 <__cmpsf2+0x6>
    5704:	81 e0       	ldi	r24, 0x01	; 1
    5706:	08 95       	ret

00005708 <__floatunsisf>:
    5708:	e8 94       	clt
    570a:	09 c0       	rjmp	.+18     	; 0x571e <__floatsisf+0x12>

0000570c <__floatsisf>:
    570c:	97 fb       	bst	r25, 7
    570e:	3e f4       	brtc	.+14     	; 0x571e <__floatsisf+0x12>
    5710:	90 95       	com	r25
    5712:	80 95       	com	r24
    5714:	70 95       	com	r23
    5716:	61 95       	neg	r22
    5718:	7f 4f       	sbci	r23, 0xFF	; 255
    571a:	8f 4f       	sbci	r24, 0xFF	; 255
    571c:	9f 4f       	sbci	r25, 0xFF	; 255
    571e:	99 23       	and	r25, r25
    5720:	a9 f0       	breq	.+42     	; 0x574c <__floatsisf+0x40>
    5722:	f9 2f       	mov	r31, r25
    5724:	96 e9       	ldi	r25, 0x96	; 150
    5726:	bb 27       	eor	r27, r27
    5728:	93 95       	inc	r25
    572a:	f6 95       	lsr	r31
    572c:	87 95       	ror	r24
    572e:	77 95       	ror	r23
    5730:	67 95       	ror	r22
    5732:	b7 95       	ror	r27
    5734:	f1 11       	cpse	r31, r1
    5736:	f8 cf       	rjmp	.-16     	; 0x5728 <__floatsisf+0x1c>
    5738:	fa f4       	brpl	.+62     	; 0x5778 <__floatsisf+0x6c>
    573a:	bb 0f       	add	r27, r27
    573c:	11 f4       	brne	.+4      	; 0x5742 <__floatsisf+0x36>
    573e:	60 ff       	sbrs	r22, 0
    5740:	1b c0       	rjmp	.+54     	; 0x5778 <__floatsisf+0x6c>
    5742:	6f 5f       	subi	r22, 0xFF	; 255
    5744:	7f 4f       	sbci	r23, 0xFF	; 255
    5746:	8f 4f       	sbci	r24, 0xFF	; 255
    5748:	9f 4f       	sbci	r25, 0xFF	; 255
    574a:	16 c0       	rjmp	.+44     	; 0x5778 <__floatsisf+0x6c>
    574c:	88 23       	and	r24, r24
    574e:	11 f0       	breq	.+4      	; 0x5754 <__floatsisf+0x48>
    5750:	96 e9       	ldi	r25, 0x96	; 150
    5752:	11 c0       	rjmp	.+34     	; 0x5776 <__floatsisf+0x6a>
    5754:	77 23       	and	r23, r23
    5756:	21 f0       	breq	.+8      	; 0x5760 <__floatsisf+0x54>
    5758:	9e e8       	ldi	r25, 0x8E	; 142
    575a:	87 2f       	mov	r24, r23
    575c:	76 2f       	mov	r23, r22
    575e:	05 c0       	rjmp	.+10     	; 0x576a <__floatsisf+0x5e>
    5760:	66 23       	and	r22, r22
    5762:	71 f0       	breq	.+28     	; 0x5780 <__floatsisf+0x74>
    5764:	96 e8       	ldi	r25, 0x86	; 134
    5766:	86 2f       	mov	r24, r22
    5768:	70 e0       	ldi	r23, 0x00	; 0
    576a:	60 e0       	ldi	r22, 0x00	; 0
    576c:	2a f0       	brmi	.+10     	; 0x5778 <__floatsisf+0x6c>
    576e:	9a 95       	dec	r25
    5770:	66 0f       	add	r22, r22
    5772:	77 1f       	adc	r23, r23
    5774:	88 1f       	adc	r24, r24
    5776:	da f7       	brpl	.-10     	; 0x576e <__floatsisf+0x62>
    5778:	88 0f       	add	r24, r24
    577a:	96 95       	lsr	r25
    577c:	87 95       	ror	r24
    577e:	97 f9       	bld	r25, 7
    5780:	08 95       	ret

00005782 <__fp_cmp>:
    5782:	99 0f       	add	r25, r25
    5784:	00 08       	sbc	r0, r0
    5786:	55 0f       	add	r21, r21
    5788:	aa 0b       	sbc	r26, r26
    578a:	e0 e8       	ldi	r30, 0x80	; 128
    578c:	fe ef       	ldi	r31, 0xFE	; 254
    578e:	16 16       	cp	r1, r22
    5790:	17 06       	cpc	r1, r23
    5792:	e8 07       	cpc	r30, r24
    5794:	f9 07       	cpc	r31, r25
    5796:	c0 f0       	brcs	.+48     	; 0x57c8 <__fp_cmp+0x46>
    5798:	12 16       	cp	r1, r18
    579a:	13 06       	cpc	r1, r19
    579c:	e4 07       	cpc	r30, r20
    579e:	f5 07       	cpc	r31, r21
    57a0:	98 f0       	brcs	.+38     	; 0x57c8 <__fp_cmp+0x46>
    57a2:	62 1b       	sub	r22, r18
    57a4:	73 0b       	sbc	r23, r19
    57a6:	84 0b       	sbc	r24, r20
    57a8:	95 0b       	sbc	r25, r21
    57aa:	39 f4       	brne	.+14     	; 0x57ba <__fp_cmp+0x38>
    57ac:	0a 26       	eor	r0, r26
    57ae:	61 f0       	breq	.+24     	; 0x57c8 <__fp_cmp+0x46>
    57b0:	23 2b       	or	r18, r19
    57b2:	24 2b       	or	r18, r20
    57b4:	25 2b       	or	r18, r21
    57b6:	21 f4       	brne	.+8      	; 0x57c0 <__fp_cmp+0x3e>
    57b8:	08 95       	ret
    57ba:	0a 26       	eor	r0, r26
    57bc:	09 f4       	brne	.+2      	; 0x57c0 <__fp_cmp+0x3e>
    57be:	a1 40       	sbci	r26, 0x01	; 1
    57c0:	a6 95       	lsr	r26
    57c2:	8f ef       	ldi	r24, 0xFF	; 255
    57c4:	81 1d       	adc	r24, r1
    57c6:	81 1d       	adc	r24, r1
    57c8:	08 95       	ret

000057ca <__gesf2>:
    57ca:	db df       	rcall	.-74     	; 0x5782 <__fp_cmp>
    57cc:	08 f4       	brcc	.+2      	; 0x57d0 <__gesf2+0x6>
    57ce:	8f ef       	ldi	r24, 0xFF	; 255
    57d0:	08 95       	ret

000057d2 <__mulsi3>:
    57d2:	db 01       	movw	r26, r22
    57d4:	8f 93       	push	r24
    57d6:	9f 93       	push	r25
    57d8:	5a d0       	rcall	.+180    	; 0x588e <__muluhisi3>
    57da:	bf 91       	pop	r27
    57dc:	af 91       	pop	r26
    57de:	a2 9f       	mul	r26, r18
    57e0:	80 0d       	add	r24, r0
    57e2:	91 1d       	adc	r25, r1
    57e4:	a3 9f       	mul	r26, r19
    57e6:	90 0d       	add	r25, r0
    57e8:	b2 9f       	mul	r27, r18
    57ea:	90 0d       	add	r25, r0
    57ec:	11 24       	eor	r1, r1
    57ee:	08 95       	ret

000057f0 <__udivmodsi4>:
    57f0:	a1 e2       	ldi	r26, 0x21	; 33
    57f2:	1a 2e       	mov	r1, r26
    57f4:	aa 1b       	sub	r26, r26
    57f6:	bb 1b       	sub	r27, r27
    57f8:	fd 01       	movw	r30, r26
    57fa:	0d c0       	rjmp	.+26     	; 0x5816 <__udivmodsi4_ep>

000057fc <__udivmodsi4_loop>:
    57fc:	aa 1f       	adc	r26, r26
    57fe:	bb 1f       	adc	r27, r27
    5800:	ee 1f       	adc	r30, r30
    5802:	ff 1f       	adc	r31, r31
    5804:	a2 17       	cp	r26, r18
    5806:	b3 07       	cpc	r27, r19
    5808:	e4 07       	cpc	r30, r20
    580a:	f5 07       	cpc	r31, r21
    580c:	20 f0       	brcs	.+8      	; 0x5816 <__udivmodsi4_ep>
    580e:	a2 1b       	sub	r26, r18
    5810:	b3 0b       	sbc	r27, r19
    5812:	e4 0b       	sbc	r30, r20
    5814:	f5 0b       	sbc	r31, r21

00005816 <__udivmodsi4_ep>:
    5816:	66 1f       	adc	r22, r22
    5818:	77 1f       	adc	r23, r23
    581a:	88 1f       	adc	r24, r24
    581c:	99 1f       	adc	r25, r25
    581e:	1a 94       	dec	r1
    5820:	69 f7       	brne	.-38     	; 0x57fc <__udivmodsi4_loop>
    5822:	60 95       	com	r22
    5824:	70 95       	com	r23
    5826:	80 95       	com	r24
    5828:	90 95       	com	r25
    582a:	9b 01       	movw	r18, r22
    582c:	ac 01       	movw	r20, r24
    582e:	bd 01       	movw	r22, r26
    5830:	cf 01       	movw	r24, r30
    5832:	08 95       	ret

00005834 <__divmodsi4>:
    5834:	05 2e       	mov	r0, r21
    5836:	97 fb       	bst	r25, 7
    5838:	16 f4       	brtc	.+4      	; 0x583e <__divmodsi4+0xa>
    583a:	00 94       	com	r0
    583c:	06 d0       	rcall	.+12     	; 0x584a <__divmodsi4_neg1>
    583e:	57 fd       	sbrc	r21, 7
    5840:	0c d0       	rcall	.+24     	; 0x585a <__divmodsi4_neg2>
    5842:	d6 df       	rcall	.-84     	; 0x57f0 <__udivmodsi4>
    5844:	07 fc       	sbrc	r0, 7
    5846:	09 d0       	rcall	.+18     	; 0x585a <__divmodsi4_neg2>
    5848:	7e f4       	brtc	.+30     	; 0x5868 <__divmodsi4_exit>

0000584a <__divmodsi4_neg1>:
    584a:	90 95       	com	r25
    584c:	80 95       	com	r24
    584e:	70 95       	com	r23
    5850:	61 95       	neg	r22
    5852:	7f 4f       	sbci	r23, 0xFF	; 255
    5854:	8f 4f       	sbci	r24, 0xFF	; 255
    5856:	9f 4f       	sbci	r25, 0xFF	; 255
    5858:	08 95       	ret

0000585a <__divmodsi4_neg2>:
    585a:	50 95       	com	r21
    585c:	40 95       	com	r20
    585e:	30 95       	com	r19
    5860:	21 95       	neg	r18
    5862:	3f 4f       	sbci	r19, 0xFF	; 255
    5864:	4f 4f       	sbci	r20, 0xFF	; 255
    5866:	5f 4f       	sbci	r21, 0xFF	; 255

00005868 <__divmodsi4_exit>:
    5868:	08 95       	ret

0000586a <__tablejump2__>:
    586a:	ee 0f       	add	r30, r30
    586c:	ff 1f       	adc	r31, r31

0000586e <__tablejump__>:
    586e:	05 90       	lpm	r0, Z+
    5870:	f4 91       	lpm	r31, Z
    5872:	e0 2d       	mov	r30, r0
    5874:	19 94       	eijmp

00005876 <__umulhisi3>:
    5876:	a2 9f       	mul	r26, r18
    5878:	b0 01       	movw	r22, r0
    587a:	b3 9f       	mul	r27, r19
    587c:	c0 01       	movw	r24, r0
    587e:	a3 9f       	mul	r26, r19
    5880:	01 d0       	rcall	.+2      	; 0x5884 <__umulhisi3+0xe>
    5882:	b2 9f       	mul	r27, r18
    5884:	70 0d       	add	r23, r0
    5886:	81 1d       	adc	r24, r1
    5888:	11 24       	eor	r1, r1
    588a:	91 1d       	adc	r25, r1
    588c:	08 95       	ret

0000588e <__muluhisi3>:
    588e:	f3 df       	rcall	.-26     	; 0x5876 <__umulhisi3>
    5890:	a5 9f       	mul	r26, r21
    5892:	90 0d       	add	r25, r0
    5894:	b4 9f       	mul	r27, r20
    5896:	90 0d       	add	r25, r0
    5898:	a4 9f       	mul	r26, r20
    589a:	80 0d       	add	r24, r0
    589c:	91 1d       	adc	r25, r1
    589e:	11 24       	eor	r1, r1
    58a0:	08 95       	ret

000058a2 <__mulshisi3>:
    58a2:	b7 ff       	sbrs	r27, 7
    58a4:	f4 cf       	rjmp	.-24     	; 0x588e <__muluhisi3>

000058a6 <__mulohisi3>:
    58a6:	f3 df       	rcall	.-26     	; 0x588e <__muluhisi3>
    58a8:	82 1b       	sub	r24, r18
    58aa:	93 0b       	sbc	r25, r19
    58ac:	08 95       	ret

000058ae <__eerd_dword_m2560>:
    58ae:	a6 e1       	ldi	r26, 0x16	; 22
    58b0:	b0 e0       	ldi	r27, 0x00	; 0
    58b2:	44 e0       	ldi	r20, 0x04	; 4
    58b4:	50 e0       	ldi	r21, 0x00	; 0
    58b6:	0f c0       	rjmp	.+30     	; 0x58d6 <__eerd_blraw_m2560>

000058b8 <__eerd_word_m2560>:
    58b8:	a8 e1       	ldi	r26, 0x18	; 24
    58ba:	b0 e0       	ldi	r27, 0x00	; 0
    58bc:	42 e0       	ldi	r20, 0x02	; 2
    58be:	50 e0       	ldi	r21, 0x00	; 0
    58c0:	0a c0       	rjmp	.+20     	; 0x58d6 <__eerd_blraw_m2560>

000058c2 <__eewr_dword_m2560>:
    58c2:	24 2f       	mov	r18, r20
    58c4:	17 d0       	rcall	.+46     	; 0x58f4 <__eewr_r18_m2560>
    58c6:	25 2f       	mov	r18, r21
    58c8:	15 d0       	rcall	.+42     	; 0x58f4 <__eewr_r18_m2560>
    58ca:	00 c0       	rjmp	.+0      	; 0x58cc <__eewr_word_m2560>

000058cc <__eewr_word_m2560>:
    58cc:	12 d0       	rcall	.+36     	; 0x58f2 <__eewr_byte_m2560>
    58ce:	27 2f       	mov	r18, r23
    58d0:	11 c0       	rjmp	.+34     	; 0x58f4 <__eewr_r18_m2560>

000058d2 <__eerd_block_m2560>:
    58d2:	dc 01       	movw	r26, r24
    58d4:	cb 01       	movw	r24, r22

000058d6 <__eerd_blraw_m2560>:
    58d6:	fc 01       	movw	r30, r24
    58d8:	f9 99       	sbic	0x1f, 1	; 31
    58da:	fe cf       	rjmp	.-4      	; 0x58d8 <__eerd_blraw_m2560+0x2>
    58dc:	06 c0       	rjmp	.+12     	; 0x58ea <__eerd_blraw_m2560+0x14>
    58de:	f2 bd       	out	0x22, r31	; 34
    58e0:	e1 bd       	out	0x21, r30	; 33
    58e2:	f8 9a       	sbi	0x1f, 0	; 31
    58e4:	31 96       	adiw	r30, 0x01	; 1
    58e6:	00 b4       	in	r0, 0x20	; 32
    58e8:	0d 92       	st	X+, r0
    58ea:	41 50       	subi	r20, 0x01	; 1
    58ec:	50 40       	sbci	r21, 0x00	; 0
    58ee:	b8 f7       	brcc	.-18     	; 0x58de <__eerd_blraw_m2560+0x8>
    58f0:	08 95       	ret

000058f2 <__eewr_byte_m2560>:
    58f2:	26 2f       	mov	r18, r22

000058f4 <__eewr_r18_m2560>:
    58f4:	f9 99       	sbic	0x1f, 1	; 31
    58f6:	fe cf       	rjmp	.-4      	; 0x58f4 <__eewr_r18_m2560>
    58f8:	1f ba       	out	0x1f, r1	; 31
    58fa:	92 bd       	out	0x22, r25	; 34
    58fc:	81 bd       	out	0x21, r24	; 33
    58fe:	20 bd       	out	0x20, r18	; 32
    5900:	0f b6       	in	r0, 0x3f	; 63
    5902:	f8 94       	cli
    5904:	fa 9a       	sbi	0x1f, 2	; 31
    5906:	f9 9a       	sbi	0x1f, 1	; 31
    5908:	0f be       	out	0x3f, r0	; 63
    590a:	01 96       	adiw	r24, 0x01	; 1
    590c:	08 95       	ret

0000590e <_exit>:
    590e:	f8 94       	cli

00005910 <__stop_program>:
    5910:	ff cf       	rjmp	.-2      	; 0x5910 <__stop_program>
